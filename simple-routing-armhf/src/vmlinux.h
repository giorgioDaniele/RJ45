#ifndef __VMLINUX_H__
#define __VMLINUX_H__

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute push (__attribute__((preserve_access_index)), apply_to = record)
#endif

typedef signed char __s8;

typedef unsigned char __u8;

typedef short unsigned int __u16;

typedef int __s32;

typedef unsigned int __u32;

typedef long long int __s64;

typedef long long unsigned int __u64;

typedef __s8 s8;

typedef __u8 u8;

typedef __u16 u16;

typedef __s32 s32;

typedef __u32 u32;

typedef __s64 s64;

typedef __u64 u64;

enum {
	false = 0,
	true = 1,
};

typedef long int __kernel_long_t;

typedef long unsigned int __kernel_ulong_t;

typedef int __kernel_pid_t;

typedef unsigned int __kernel_uid32_t;

typedef unsigned int __kernel_gid32_t;

typedef unsigned int __kernel_size_t;

typedef int __kernel_ssize_t;

typedef long long int __kernel_loff_t;

typedef long long int __kernel_time64_t;

typedef __kernel_long_t __kernel_clock_t;

typedef int __kernel_timer_t;

typedef int __kernel_clockid_t;

typedef __u16 __be16;

typedef __u32 __le32;

typedef __u32 __be32;

typedef __u32 __wsum;

typedef unsigned int __poll_t;

typedef u32 __kernel_dev_t;

typedef __kernel_dev_t dev_t;

typedef short unsigned int umode_t;

typedef __kernel_pid_t pid_t;

typedef __kernel_clockid_t clockid_t;

typedef _Bool bool;

typedef __kernel_uid32_t uid_t;

typedef __kernel_gid32_t gid_t;

typedef long unsigned int uintptr_t;

typedef __kernel_loff_t loff_t;

typedef __kernel_size_t size_t;

typedef __kernel_ssize_t ssize_t;

typedef s32 int32_t;

typedef u32 uint32_t;

typedef u64 uint64_t;

typedef u64 sector_t;

typedef u64 blkcnt_t;

typedef unsigned int gfp_t;

typedef unsigned int fmode_t;

typedef u32 phys_addr_t;

typedef long unsigned int irq_hw_number_t;

typedef struct {
	int counter;
} atomic_t;

struct list_head {
	struct list_head *next;
	struct list_head *prev;
};

struct hlist_node;

struct hlist_head {
	struct hlist_node *first;
};

struct hlist_node {
	struct hlist_node *next;
	struct hlist_node **pprev;
};

struct callback_head {
	struct callback_head *next;
	void (*func)(struct callback_head *);
};

struct cacheline_padding {
	char x[0];
};

struct pt_regs {
	long unsigned int uregs[18];
};

struct arch_hw_breakpoint_ctrl {
	u32 __reserved: 9;
	u32 mismatch: 1;
	short: 9;
	u32 len: 8;
	u32 type: 2;
	u32 privilege: 2;
	u32 enabled: 1;
};

struct arch_hw_breakpoint {
	u32 address;
	u32 trigger;
	struct arch_hw_breakpoint_ctrl step_ctrl;
	struct arch_hw_breakpoint_ctrl ctrl;
};

struct perf_event;

struct debug_info {
	struct perf_event *hbp[32];
};

struct rb_node {
	long unsigned int __rb_parent_color;
	struct rb_node *rb_right;
	struct rb_node *rb_left;
};

enum perf_event_state {
	PERF_EVENT_STATE_DEAD = 4294967292,
	PERF_EVENT_STATE_EXIT = 4294967293,
	PERF_EVENT_STATE_ERROR = 4294967294,
	PERF_EVENT_STATE_OFF = 4294967295,
	PERF_EVENT_STATE_INACTIVE = 0,
	PERF_EVENT_STATE_ACTIVE = 1,
};

typedef struct {
	s64 counter;
} atomic64_t;

typedef struct {
	atomic64_t a;
} local64_t;

struct perf_event_attr {
	__u32 type;
	__u32 size;
	__u64 config;
	union {
		__u64 sample_period;
		__u64 sample_freq;
	};
	__u64 sample_type;
	__u64 read_format;
	__u64 disabled: 1;
	__u64 inherit: 1;
	__u64 pinned: 1;
	__u64 exclusive: 1;
	__u64 exclude_user: 1;
	__u64 exclude_kernel: 1;
	__u64 exclude_hv: 1;
	__u64 exclude_idle: 1;
	__u64 mmap: 1;
	__u64 comm: 1;
	__u64 freq: 1;
	__u64 inherit_stat: 1;
	__u64 enable_on_exec: 1;
	__u64 task: 1;
	__u64 watermark: 1;
	__u64 precise_ip: 2;
	__u64 mmap_data: 1;
	__u64 sample_id_all: 1;
	__u64 exclude_host: 1;
	__u64 exclude_guest: 1;
	__u64 exclude_callchain_kernel: 1;
	__u64 exclude_callchain_user: 1;
	__u64 mmap2: 1;
	__u64 comm_exec: 1;
	__u64 use_clockid: 1;
	__u64 context_switch: 1;
	__u64 write_backward: 1;
	__u64 namespaces: 1;
	__u64 ksymbol: 1;
	__u64 bpf_event: 1;
	__u64 aux_output: 1;
	__u64 cgroup: 1;
	__u64 text_poke: 1;
	__u64 build_id: 1;
	__u64 inherit_thread: 1;
	__u64 remove_on_exec: 1;
	__u64 sigtrap: 1;
	__u64 __reserved_1: 26;
	union {
		__u32 wakeup_events;
		__u32 wakeup_watermark;
	};
	__u32 bp_type;
	union {
		__u64 bp_addr;
		__u64 kprobe_func;
		__u64 uprobe_path;
		__u64 config1;
	};
	union {
		__u64 bp_len;
		__u64 kprobe_addr;
		__u64 probe_offset;
		__u64 config2;
	};
	__u64 branch_sample_type;
	__u64 sample_regs_user;
	__u32 sample_stack_user;
	__s32 clockid;
	__u64 sample_regs_intr;
	__u32 aux_watermark;
	__u16 sample_max_stack;
	__u16 __reserved_2;
	__u32 aux_sample_size;
	__u32 __reserved_3;
	__u64 sig_data;
};

struct hw_perf_event_extra {
	u64 config;
	unsigned int reg;
	int alloc;
	int idx;
	int: 32;
};

typedef s64 ktime_t;

struct timerqueue_node {
	struct rb_node node;
	int: 32;
	ktime_t expires;
};

enum hrtimer_restart {
	HRTIMER_NORESTART = 0,
	HRTIMER_RESTART = 1,
};

struct hrtimer_clock_base;

struct hrtimer {
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *);
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
	int: 32;
};

struct rhash_head {
	struct rhash_head *next;
};

struct rhlist_head {
	struct rhash_head rhead;
	struct rhlist_head *next;
};

struct task_struct;

struct hw_perf_event {
	union {
		struct {
			u64 config;
			u64 last_tag;
			long unsigned int config_base;
			long unsigned int event_base;
			int event_base_rdpmc;
			int idx;
			int last_cpu;
			int flags;
			struct hw_perf_event_extra extra_reg;
			struct hw_perf_event_extra branch_reg;
		};
		struct {
			struct hrtimer hrtimer;
		};
		struct {
			struct list_head tp_list;
		};
		struct {
			u64 pwr_acc;
			u64 ptsc;
		};
		struct {
			struct arch_hw_breakpoint info;
			struct rhlist_head bp_list;
		};
		struct {
			u8 iommu_bank;
			u8 iommu_cntr;
			u16 padding;
			int: 32;
			u64 conf;
			u64 conf1;
		};
	};
	struct task_struct *target;
	void *addr_filters;
	long unsigned int addr_filters_gen;
	int state;
	local64_t prev_count;
	u64 sample_period;
	union {
		struct {
			u64 last_period;
			local64_t period_left;
		};
		struct {
			u64 saved_metric;
			u64 saved_slots;
		};
	};
	u64 interrupts_seq;
	u64 interrupts;
	u64 freq_time_stamp;
	u64 freq_count_stamp;
};

typedef atomic_t atomic_long_t;

struct __raw_tickets {
	u16 owner;
	u16 next;
};

typedef struct {
	union {
		u32 slock;
		struct __raw_tickets tickets;
	};
} arch_spinlock_t;

struct raw_spinlock {
	arch_spinlock_t raw_lock;
};

typedef struct raw_spinlock raw_spinlock_t;

struct optimistic_spin_queue {
	atomic_t tail;
};

struct mutex {
	atomic_long_t owner;
	raw_spinlock_t wait_lock;
	struct optimistic_spin_queue osq;
	struct list_head wait_list;
};

struct spinlock {
	union {
		struct raw_spinlock rlock;
	};
};

typedef struct spinlock spinlock_t;

struct wait_queue_head {
	spinlock_t lock;
	struct list_head head;
};

typedef struct wait_queue_head wait_queue_head_t;

struct llist_node {
	struct llist_node *next;
};

struct __call_single_node {
	struct llist_node llist;
	union {
		unsigned int u_flags;
		atomic_t a_flags;
	};
};

struct rcuwait {
	struct task_struct *task;
};

struct irq_work {
	struct __call_single_node node;
	void (*func)(struct irq_work *);
	struct rcuwait irqwait;
};

struct perf_addr_filters_head {
	struct list_head list;
	raw_spinlock_t lock;
	unsigned int nr_file_filters;
};

struct perf_sample_data;

typedef void (*perf_overflow_handler_t)(struct perf_event *, struct perf_sample_data *, struct pt_regs *);

struct pmu;

struct perf_event_context;

struct perf_buffer;

struct fasync_struct;

struct perf_addr_filter_range;

struct pid_namespace;

struct bpf_prog;

struct trace_event_call;

struct event_filter;

struct perf_event {
	struct list_head event_entry;
	struct list_head sibling_list;
	struct list_head active_list;
	struct rb_node group_node;
	int: 32;
	u64 group_index;
	struct list_head migrate_entry;
	struct hlist_node hlist_entry;
	struct list_head active_entry;
	int nr_siblings;
	int event_caps;
	int group_caps;
	struct perf_event *group_leader;
	struct pmu *pmu;
	void *pmu_private;
	enum perf_event_state state;
	unsigned int attach_state;
	local64_t count;
	atomic64_t child_count;
	u64 total_time_enabled;
	u64 total_time_running;
	u64 tstamp;
	struct perf_event_attr attr;
	u16 header_size;
	u16 id_header_size;
	u16 read_size;
	struct hw_perf_event hw;
	struct perf_event_context *ctx;
	atomic_long_t refcount;
	atomic64_t child_total_time_enabled;
	atomic64_t child_total_time_running;
	struct mutex child_mutex;
	struct list_head child_list;
	struct perf_event *parent;
	int oncpu;
	int cpu;
	struct list_head owner_entry;
	struct task_struct *owner;
	struct mutex mmap_mutex;
	atomic_t mmap_count;
	struct perf_buffer *rb;
	struct list_head rb_entry;
	long unsigned int rcu_batches;
	int rcu_pending;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
	unsigned int pending_wakeup;
	unsigned int pending_kill;
	unsigned int pending_disable;
	unsigned int pending_sigtrap;
	long unsigned int pending_addr;
	struct irq_work pending_irq;
	struct callback_head pending_task;
	unsigned int pending_work;
	atomic_t event_limit;
	struct perf_addr_filters_head addr_filters;
	struct perf_addr_filter_range *addr_filter_ranges;
	long unsigned int addr_filters_gen;
	struct perf_event *aux_event;
	void (*destroy)(struct perf_event *);
	struct callback_head callback_head;
	struct pid_namespace *ns;
	u64 id;
	atomic64_t lost_samples;
	u64 (*clock)();
	perf_overflow_handler_t overflow_handler;
	void *overflow_handler_context;
	perf_overflow_handler_t orig_overflow_handler;
	struct bpf_prog *prog;
	int: 32;
	u64 bpf_cookie;
	struct trace_event_call *tp_event;
	struct event_filter *filter;
	struct list_head sb_list;
};

struct thread_struct {
	long unsigned int address;
	long unsigned int trap_no;
	long unsigned int error_code;
	struct debug_info debug;
};

typedef __s64 time64_t;

struct __kernel_timespec {
	__kernel_time64_t tv_sec;
	long long int tv_nsec;
};

struct timespec64 {
	time64_t tv_sec;
	long int tv_nsec;
	int: 32;
};

typedef s32 old_time32_t;

struct old_timespec32 {
	old_time32_t tv_sec;
	s32 tv_nsec;
};

struct uid_gid_extent {
	u32 first;
	u32 lower_first;
	u32 count;
};

struct uid_gid_map {
	u32 nr_extents;
	union {
		struct uid_gid_extent extent[5];
		struct {
			struct uid_gid_extent *forward;
			struct uid_gid_extent *reverse;
		};
	};
};

typedef struct {
	uid_t val;
} kuid_t;

typedef struct {
	gid_t val;
} kgid_t;

struct refcount_struct {
	atomic_t refs;
};

typedef struct refcount_struct refcount_t;

struct proc_ns_operations;

struct ns_common {
	atomic_long_t stashed;
	const struct proc_ns_operations *ops;
	unsigned int inum;
	refcount_t count;
};

struct rw_semaphore {
	atomic_long_t count;
	atomic_long_t owner;
	struct optimistic_spin_queue osq;
	raw_spinlock_t wait_lock;
	struct list_head wait_list;
};

struct work_struct;

typedef void (*work_func_t)(struct work_struct *);

struct work_struct {
	atomic_long_t data;
	struct list_head entry;
	work_func_t func;
};

struct ctl_table;

struct completion;

struct ctl_table_root;

struct ctl_table_set;

struct ctl_dir;

struct ctl_node;

struct ctl_table_header {
	union {
		struct {
			struct ctl_table *ctl_table;
			int used;
			int count;
			int nreg;
		};
		struct callback_head rcu;
	};
	struct completion *unregistering;
	struct ctl_table *ctl_table_arg;
	struct ctl_table_root *root;
	struct ctl_table_set *set;
	struct ctl_dir *parent;
	struct ctl_node *node;
	struct hlist_head inodes;
};

struct rb_root {
	struct rb_node *rb_node;
};

struct ctl_dir {
	struct ctl_table_header header;
	struct rb_root root;
};

struct ctl_table_set {
	int (*is_seen)(struct ctl_table_set *);
	struct ctl_dir dir;
};

struct key;

struct ucounts;

struct user_namespace {
	struct uid_gid_map uid_map;
	struct uid_gid_map gid_map;
	struct uid_gid_map projid_map;
	struct user_namespace *parent;
	int level;
	kuid_t owner;
	kgid_t group;
	struct ns_common ns;
	long unsigned int flags;
	bool parent_could_setfcap;
	struct list_head keyring_name_list;
	struct key *user_keyring_register;
	struct rw_semaphore keyring_sem;
	struct work_struct work;
	struct ctl_table_set set;
	struct ctl_table_header *sysctls;
	struct ucounts *ucounts;
	long int ucount_max[10];
	long int rlimit_max[4];
};

struct kstat {
	u32 result_mask;
	umode_t mode;
	unsigned int nlink;
	uint32_t blksize;
	u64 attributes;
	u64 attributes_mask;
	u64 ino;
	dev_t dev;
	dev_t rdev;
	kuid_t uid;
	kgid_t gid;
	loff_t size;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	struct timespec64 btime;
	u64 blocks;
	u64 mnt_id;
	u32 dio_mem_align;
	u32 dio_offset_align;
};

struct kernel_symbol {
	long unsigned int value;
	const char *name;
	const char *namespace;
};

typedef int (*initcall_t)();

typedef initcall_t initcall_entry_t;

struct lock_class_key {};

struct fs_context;

struct fs_parameter_spec;

struct dentry;

struct super_block;

struct module;

struct file_system_type {
	const char *name;
	int fs_flags;
	int (*init_fs_context)(struct fs_context *);
	const struct fs_parameter_spec *parameters;
	struct dentry * (*mount)(struct file_system_type *, int, const char *, void *);
	void (*kill_sb)(struct super_block *);
	struct module *owner;
	struct file_system_type *next;
	struct hlist_head fs_supers;
	struct lock_class_key s_lock_key;
	struct lock_class_key s_umount_key;
	struct lock_class_key s_vfs_rename_key;
	struct lock_class_key s_writers_key[3];
	struct lock_class_key i_lock_key;
	struct lock_class_key i_mutex_key;
	struct lock_class_key invalidate_lock_key;
	struct lock_class_key i_mutex_dir_key;
};

struct obs_kernel_param {
	const char *str;
	int (*setup_func)(char *);
	int early;
};

typedef struct {
	u32 lock;
} arch_rwlock_t;

struct lockdep_map {};

struct ratelimit_state {
	raw_spinlock_t lock;
	int interval;
	int burst;
	int printed;
	int missed;
	long unsigned int begin;
	long unsigned int flags;
};

typedef void *fl_owner_t;

struct file;

struct kiocb;

struct iov_iter;

struct io_comp_batch;

struct dir_context;

struct poll_table_struct;

struct vm_area_struct;

struct inode;

struct file_lock;

struct page;

struct pipe_inode_info;

struct seq_file;

struct io_uring_cmd;

struct file_operations {
	struct module *owner;
	loff_t (*llseek)(struct file *, loff_t, int);
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	ssize_t (*read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*write_iter)(struct kiocb *, struct iov_iter *);
	int (*iopoll)(struct kiocb *, struct io_comp_batch *, unsigned int);
	int (*iterate)(struct file *, struct dir_context *);
	int (*iterate_shared)(struct file *, struct dir_context *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	long unsigned int mmap_supported_flags;
	int (*open)(struct inode *, struct file *);
	int (*flush)(struct file *, fl_owner_t);
	int (*release)(struct inode *, struct file *);
	int (*fsync)(struct file *, loff_t, loff_t, int);
	int (*fasync)(int, struct file *, int);
	int (*lock)(struct file *, int, struct file_lock *);
	ssize_t (*sendpage)(struct file *, struct page *, int, size_t, loff_t *, int);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*check_flags)(int);
	int (*flock)(struct file *, int, struct file_lock *);
	ssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);
	ssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*setlease)(struct file *, long int, struct file_lock **, void **);
	long int (*fallocate)(struct file *, int, loff_t, loff_t);
	void (*show_fdinfo)(struct seq_file *, struct file *);
	ssize_t (*copy_file_range)(struct file *, loff_t, struct file *, loff_t, size_t, unsigned int);
	loff_t (*remap_file_range)(struct file *, loff_t, struct file *, loff_t, loff_t, unsigned int);
	int (*fadvise)(struct file *, loff_t, loff_t, int);
	int (*uring_cmd)(struct io_uring_cmd *, unsigned int);
	int (*uring_cmd_iopoll)(struct io_uring_cmd *, struct io_comp_batch *, unsigned int);
};

struct static_call_key {
	void *func;
};

enum system_states {
	SYSTEM_BOOTING = 0,
	SYSTEM_SCHEDULING = 1,
	SYSTEM_FREEING_INITMEM = 2,
	SYSTEM_RUNNING = 3,
	SYSTEM_HALT = 4,
	SYSTEM_POWER_OFF = 5,
	SYSTEM_RESTART = 6,
	SYSTEM_SUSPEND = 7,
};

struct bug_entry {
	long unsigned int bug_addr;
	short unsigned int flags;
};

struct cpumask {
	long unsigned int bits[1];
};

typedef struct cpumask cpumask_t;

typedef struct cpumask cpumask_var_t[1];

typedef struct page *pgtable_t;

struct address_space;

struct page_pool;

struct mm_struct;

struct dev_pagemap;

struct page {
	long unsigned int flags;
	union {
		struct {
			union {
				struct list_head lru;
				struct {
					void *__filler;
					unsigned int mlock_count;
				};
				struct list_head buddy_list;
				struct list_head pcp_list;
			};
			struct address_space *mapping;
			long unsigned int index;
			long unsigned int private;
		};
		struct {
			long unsigned int pp_magic;
			struct page_pool *pp;
			long unsigned int _pp_mapping_pad;
			long unsigned int dma_addr;
			union {
				long unsigned int dma_addr_upper;
				atomic_long_t pp_frag_count;
			};
		};
		struct {
			long unsigned int compound_head;
			unsigned char compound_dtor;
			unsigned char compound_order;
			atomic_t compound_mapcount;
			atomic_t compound_pincount;
		};
		struct {
			long unsigned int _compound_pad_1;
			long unsigned int _compound_pad_2;
			struct list_head deferred_list;
		};
		struct {
			long unsigned int _pt_pad_1;
			pgtable_t pmd_huge_pte;
			long unsigned int _pt_pad_2;
			union {
				struct mm_struct *pt_mm;
				atomic_t pt_frag_refcount;
			};
			spinlock_t ptl;
		};
		struct {
			struct dev_pagemap *pgmap;
			void *zone_device_data;
		};
		struct callback_head callback_head;
	};
	union {
		atomic_t _mapcount;
		unsigned int page_type;
	};
	atomic_t _refcount;
	long unsigned int memcg_data;
};

typedef u32 pteval_t;

typedef pteval_t pgprot_t;

struct vm_userfaultfd_ctx {};

struct anon_vma_name;

struct anon_vma;

struct vm_operations_struct;

struct vm_area_struct {
	long unsigned int vm_start;
	long unsigned int vm_end;
	struct mm_struct *vm_mm;
	pgprot_t vm_page_prot;
	long unsigned int vm_flags;
	union {
		struct {
			struct rb_node rb;
			long unsigned int rb_subtree_last;
		} shared;
		struct anon_vma_name *anon_name;
	};
	struct list_head anon_vma_chain;
	struct anon_vma *anon_vma;
	const struct vm_operations_struct *vm_ops;
	long unsigned int vm_pgoff;
	struct file *vm_file;
	void *vm_private_data;
	atomic_long_t swap_readahead_info;
	struct vm_userfaultfd_ctx vm_userfaultfd_ctx;
};

typedef u32 pmdval_t;

typedef pteval_t pte_t;

typedef pmdval_t pmd_t;

typedef pmdval_t pgd_t[2];

struct task_rss_stat {
	int events;
	int count[4];
};

struct mm_rss_stat {
	atomic_long_t count[4];
};

struct page_frag {
	struct page *page;
	__u16 offset;
	__u16 size;
};

struct tlbflush_unmap_batch {};

enum timespec_type {
	TT_NONE = 0,
	TT_NATIVE = 1,
	TT_COMPAT = 2,
};

struct pollfd {
	int fd;
	short int events;
	short int revents;
};

struct restart_block {
	long unsigned int arch_data;
	long int (*fn)(struct restart_block *);
	union {
		struct {
			u32 *uaddr;
			u32 val;
			u32 flags;
			u32 bitset;
			u64 time;
			u32 *uaddr2;
			int: 32;
		} futex;
		struct {
			clockid_t clockid;
			enum timespec_type type;
			union {
				struct __kernel_timespec *rmtp;
				struct old_timespec32 *compat_rmtp;
			};
			int: 32;
			u64 expires;
		} nanosleep;
		struct {
			struct pollfd *ufds;
			int nfds;
			int has_timeout;
			long unsigned int tv_sec;
			long unsigned int tv_nsec;
		} poll;
	};
};

typedef long unsigned int mm_segment_t;

struct cpu_context_save {
	__u32 r4;
	__u32 r5;
	__u32 r6;
	__u32 r7;
	__u32 r8;
	__u32 r9;
	__u32 sl;
	__u32 fp;
	__u32 sp;
	__u32 pc;
	__u32 extra[2];
};

struct fp_hard_struct {
	unsigned int save[35];
};

struct fp_soft_struct {
	unsigned int save[35];
};

union fp_state {
	struct fp_hard_struct hard;
	struct fp_soft_struct soft;
};

struct vfp_hard_struct {
	__u64 fpregs[32];
	__u32 fpexc;
	__u32 fpscr;
	__u32 fpinst;
	__u32 fpinst2;
	__u32 cpu;
	int: 32;
};

union vfp_state {
	struct vfp_hard_struct hard;
};

struct thread_info {
	long unsigned int flags;
	int preempt_count;
	mm_segment_t addr_limit;
	__u32 cpu;
	__u32 cpu_domain;
	struct cpu_context_save cpu_context;
	__u32 abi_syscall;
	__u8 used_cp[16];
	long unsigned int tp_value[2];
	union fp_state fpstate;
	int: 32;
	union vfp_state vfpstate;
};

struct load_weight {
	long unsigned int weight;
	u32 inv_weight;
};

struct util_est {
	unsigned int enqueued;
	unsigned int ewma;
};

struct sched_avg {
	u64 last_update_time;
	u64 load_sum;
	u64 runnable_sum;
	u32 util_sum;
	u32 period_contrib;
	long unsigned int load_avg;
	long unsigned int runnable_avg;
	long unsigned int util_avg;
	int: 32;
	struct util_est util_est;
	int: 32;
	int: 32;
};

struct sched_entity {
	struct load_weight load;
	struct rb_node run_node;
	struct list_head group_node;
	unsigned int on_rq;
	u64 exec_start;
	u64 sum_exec_runtime;
	u64 vruntime;
	u64 prev_sum_exec_runtime;
	u64 nr_migrations;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sched_avg avg;
};

struct sched_rt_entity {
	struct list_head run_list;
	long unsigned int timeout;
	long unsigned int watchdog_stamp;
	unsigned int time_slice;
	short unsigned int on_rq;
	short unsigned int on_list;
	struct sched_rt_entity *back;
};

struct sched_dl_entity {
	struct rb_node rb_node;
	int: 32;
	u64 dl_runtime;
	u64 dl_deadline;
	u64 dl_period;
	u64 dl_bw;
	u64 dl_density;
	s64 runtime;
	u64 deadline;
	unsigned int flags;
	unsigned int dl_throttled: 1;
	unsigned int dl_yielded: 1;
	unsigned int dl_non_contending: 1;
	unsigned int dl_overrun: 1;
	struct hrtimer dl_timer;
	struct hrtimer inactive_timer;
	struct sched_dl_entity *pi_se;
	int: 32;
};

struct sched_statistics {};

union rcu_special {
	struct {
		u8 blocked;
		u8 need_qs;
		u8 exp_hint;
		u8 need_mb;
	} b;
	u32 s;
};

struct sched_info {};

struct plist_node {
	int prio;
	struct list_head prio_list;
	struct list_head node_list;
};

struct prev_cputime {
	u64 utime;
	u64 stime;
	raw_spinlock_t lock;
	int: 32;
};

struct rb_root_cached {
	struct rb_root rb_root;
	struct rb_node *rb_leftmost;
};

struct timerqueue_head {
	struct rb_root_cached rb_root;
};

struct posix_cputimer_base {
	u64 nextevt;
	struct timerqueue_head tqhead;
};

struct posix_cputimers {
	struct posix_cputimer_base bases[3];
	unsigned int timers_active;
	unsigned int expiry_active;
};

struct sem_undo_list;

struct sysv_sem {
	struct sem_undo_list *undo_list;
};

struct sysv_shm {
	struct list_head shm_clist;
};

typedef struct {
	long unsigned int sig[2];
} sigset_t;

struct sigpending {
	struct list_head list;
	sigset_t signal;
};

struct seccomp_filter;

struct seccomp {
	int mode;
	atomic_t filter_count;
	struct seccomp_filter *filter;
};

struct syscall_user_dispatch {};

struct wake_q_node {
	struct wake_q_node *next;
};

struct task_io_accounting {};

struct kmap_ctrl {
	int idx;
	pte_t pteval[16];
};

struct timer_list {
	struct hlist_node entry;
	long unsigned int expires;
	void (*function)(struct timer_list *);
	u32 flags;
};

struct llist_head {
	struct llist_node *first;
};

struct sched_class;

struct rcu_node;

struct pid;

struct cred;

struct nameidata;

struct fs_struct;

struct files_struct;

struct io_uring_task;

struct nsproxy;

struct signal_struct;

struct sighand_struct;

struct rt_mutex_waiter;

struct bio_list;

struct blk_plug;

struct reclaim_state;

struct backing_dev_info;

struct io_context;

struct capture_control;

struct kernel_siginfo;

typedef struct kernel_siginfo kernel_siginfo_t;

struct css_set;

struct robust_list_head;

struct futex_pi_state;

struct rseq;

struct mem_cgroup;

struct uprobe_task;

struct vm_struct;

struct bpf_local_storage;

struct bpf_run_ctx;

struct task_struct {
	struct thread_info thread_info;
	unsigned int __state;
	void *stack;
	refcount_t usage;
	unsigned int flags;
	unsigned int ptrace;
	int on_cpu;
	struct __call_single_node wake_entry;
	unsigned int wakee_flips;
	long unsigned int wakee_flip_decay_ts;
	struct task_struct *last_wakee;
	int recent_used_cpu;
	int wake_cpu;
	int on_rq;
	int prio;
	int static_prio;
	int normal_prio;
	unsigned int rt_priority;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sched_entity se;
	struct sched_rt_entity rt;
	int: 32;
	struct sched_dl_entity dl;
	const struct sched_class *sched_class;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sched_statistics stats;
	unsigned int policy;
	int nr_cpus_allowed;
	const cpumask_t *cpus_ptr;
	cpumask_t *user_cpus_ptr;
	cpumask_t cpus_mask;
	void *migration_pending;
	short unsigned int migration_disabled;
	short unsigned int migration_flags;
	int rcu_read_lock_nesting;
	union rcu_special rcu_read_unlock_special;
	struct list_head rcu_node_entry;
	struct rcu_node *rcu_blocked_node;
	long unsigned int rcu_tasks_nvcsw;
	u8 rcu_tasks_holdout;
	u8 rcu_tasks_idx;
	int rcu_tasks_idle_cpu;
	struct list_head rcu_tasks_holdout_list;
	int trc_reader_nesting;
	int trc_ipi_to_cpu;
	union rcu_special trc_reader_special;
	struct list_head trc_holdout_list;
	struct list_head trc_blkd_node;
	int trc_blkd_cpu;
	struct sched_info sched_info;
	struct list_head tasks;
	struct plist_node pushable_tasks;
	struct rb_node pushable_dl_tasks;
	struct mm_struct *mm;
	struct mm_struct *active_mm;
	struct task_rss_stat rss_stat;
	int exit_state;
	int exit_code;
	int exit_signal;
	int pdeath_signal;
	long unsigned int jobctl;
	unsigned int personality;
	unsigned int sched_reset_on_fork: 1;
	unsigned int sched_contributes_to_load: 1;
	unsigned int sched_migrated: 1;
	int: 29;
	unsigned int sched_remote_wakeup: 1;
	unsigned int in_execve: 1;
	unsigned int in_iowait: 1;
	unsigned int in_user_fault: 1;
	unsigned int no_cgroup_migration: 1;
	unsigned int frozen: 1;
	unsigned int in_eventfd: 1;
	long unsigned int atomic_flags;
	int: 32;
	struct restart_block restart_block;
	pid_t pid;
	pid_t tgid;
	long unsigned int stack_canary;
	struct task_struct *real_parent;
	struct task_struct *parent;
	struct list_head children;
	struct list_head sibling;
	struct task_struct *group_leader;
	struct list_head ptraced;
	struct list_head ptrace_entry;
	struct pid *thread_pid;
	struct hlist_node pid_links[4];
	struct list_head thread_group;
	struct list_head thread_node;
	struct completion *vfork_done;
	int *set_child_tid;
	int *clear_child_tid;
	void *worker_private;
	int: 32;
	u64 utime;
	u64 stime;
	u64 gtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	u64 start_time;
	u64 start_boottime;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	struct posix_cputimers posix_cputimers;
	const struct cred *ptracer_cred;
	const struct cred *real_cred;
	const struct cred *cred;
	struct key *cached_requested_key;
	char comm[16];
	struct nameidata *nameidata;
	struct sysv_sem sysvsem;
	struct sysv_shm sysvshm;
	struct fs_struct *fs;
	struct files_struct *files;
	struct io_uring_task *io_uring;
	struct nsproxy *nsproxy;
	struct signal_struct *signal;
	struct sighand_struct *sighand;
	sigset_t blocked;
	sigset_t real_blocked;
	sigset_t saved_sigmask;
	struct sigpending pending;
	long unsigned int sas_ss_sp;
	size_t sas_ss_size;
	unsigned int sas_ss_flags;
	struct callback_head *task_works;
	struct seccomp seccomp;
	struct syscall_user_dispatch syscall_dispatch;
	int: 32;
	u64 parent_exec_id;
	u64 self_exec_id;
	spinlock_t alloc_lock;
	raw_spinlock_t pi_lock;
	struct wake_q_node wake_q;
	struct rb_root_cached pi_waiters;
	struct task_struct *pi_top_task;
	struct rt_mutex_waiter *pi_blocked_on;
	void *journal_info;
	struct bio_list *bio_list;
	struct blk_plug *plug;
	struct reclaim_state *reclaim_state;
	struct backing_dev_info *backing_dev_info;
	struct io_context *io_context;
	struct capture_control *capture_control;
	long unsigned int ptrace_message;
	kernel_siginfo_t *last_siginfo;
	struct task_io_accounting ioac;
	struct css_set *cgroups;
	struct list_head cg_list;
	struct robust_list_head *robust_list;
	struct list_head pi_state_list;
	struct futex_pi_state *pi_state_cache;
	struct mutex futex_exit_mutex;
	unsigned int futex_state;
	struct perf_event_context *perf_event_ctxp[2];
	struct mutex perf_event_mutex;
	struct list_head perf_event_list;
	struct rseq *rseq;
	u32 rseq_sig;
	long unsigned int rseq_event_mask;
	struct tlbflush_unmap_batch tlb_ubc;
	union {
		refcount_t rcu_users;
		struct callback_head rcu;
	};
	struct pipe_inode_info *splice_pipe;
	struct page_frag task_frag;
	int nr_dirtied;
	int nr_dirtied_pause;
	long unsigned int dirty_paused_when;
	int: 32;
	u64 timer_slack_ns;
	u64 default_timer_slack_ns;
	long unsigned int trace_recursion;
	struct mem_cgroup *memcg_in_oom;
	gfp_t memcg_oom_gfp_mask;
	int memcg_oom_order;
	unsigned int memcg_nr_pages_over_high;
	struct mem_cgroup *active_memcg;
	struct uprobe_task *utask;
	struct kmap_ctrl kmap_ctrl;
	int pagefault_disabled;
	struct task_struct *oom_reaper_list;
	struct timer_list oom_reaper_timer;
	struct vm_struct *stack_vm_area;
	refcount_t stack_refcount;
	struct bpf_local_storage *bpf_storage;
	struct bpf_run_ctx *bpf_ctx;
	struct llist_head kretprobe_instances;
	struct thread_struct thread;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef struct {
	arch_rwlock_t raw_lock;
} rwlock_t;

enum refcount_saturation_type {
	REFCOUNT_ADD_NOT_ZERO_OVF = 0,
	REFCOUNT_ADD_OVF = 1,
	REFCOUNT_ADD_UAF = 2,
	REFCOUNT_SUB_UAF = 3,
	REFCOUNT_DEC_LEAK = 4,
};

struct kref {
	refcount_t refcount;
};

typedef struct {} lockdep_map_p;

struct maple_tree {
	union {
		spinlock_t ma_lock;
		lockdep_map_p ma_external_lock;
	};
	void *ma_root;
	unsigned int ma_flags;
};

struct wait_queue_entry;

typedef int (*wait_queue_func_t)(struct wait_queue_entry *, unsigned int, int, void *);

struct wait_queue_entry {
	unsigned int flags;
	void *private;
	wait_queue_func_t func;
	struct list_head entry;
};

typedef struct wait_queue_entry wait_queue_entry_t;

struct swait_queue_head {
	raw_spinlock_t lock;
	struct list_head task_list;
};

struct completion {
	unsigned int done;
	struct swait_queue_head wait;
};

struct seqcount {
	unsigned int sequence;
};

typedef struct seqcount seqcount_t;

typedef struct {
	atomic64_t id;
	atomic_t vmalloc_seq;
	long unsigned int sigpage;
	long unsigned int vdso;
	int: 32;
} mm_context_t;

struct xol_area;

struct uprobes_state {
	struct xol_area *xol_area;
};

struct linux_binfmt;

struct kioctx_table;

struct mm_struct {
	struct {
		struct maple_tree mm_mt;
		long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
		long unsigned int mmap_base;
		long unsigned int mmap_legacy_base;
		long unsigned int task_size;
		pgd_t *pgd;
		atomic_t membarrier_state;
		atomic_t mm_users;
		atomic_t mm_count;
		atomic_long_t pgtables_bytes;
		int map_count;
		spinlock_t page_table_lock;
		struct rw_semaphore mmap_lock;
		struct list_head mmlist;
		long unsigned int hiwater_rss;
		long unsigned int hiwater_vm;
		long unsigned int total_vm;
		long unsigned int locked_vm;
		atomic64_t pinned_vm;
		long unsigned int data_vm;
		long unsigned int exec_vm;
		long unsigned int stack_vm;
		long unsigned int def_flags;
		seqcount_t write_protect_seq;
		spinlock_t arg_lock;
		long unsigned int start_code;
		long unsigned int end_code;
		long unsigned int start_data;
		long unsigned int end_data;
		long unsigned int start_brk;
		long unsigned int brk;
		long unsigned int start_stack;
		long unsigned int arg_start;
		long unsigned int arg_end;
		long unsigned int env_start;
		long unsigned int env_end;
		long unsigned int saved_auxv[42];
		struct mm_rss_stat rss_stat;
		struct linux_binfmt *binfmt;
		mm_context_t context;
		long unsigned int flags;
		spinlock_t ioctx_lock;
		struct kioctx_table *ioctx_table;
		struct task_struct *owner;
		struct user_namespace *user_ns;
		struct file *exe_file;
		atomic_t tlb_flush_pending;
		struct uprobes_state uprobes_state;
		struct work_struct async_put_work;
	};
	long unsigned int cpu_bitmap[0];
};

struct arch_uprobe_task {
	u32 backup;
	long unsigned int saved_trap_no;
};

enum uprobe_task_state {
	UTASK_RUNNING = 0,
	UTASK_SSTEP = 1,
	UTASK_SSTEP_ACK = 2,
	UTASK_SSTEP_TRAPPED = 3,
};

struct uprobe;

struct return_instance;

struct uprobe_task {
	enum uprobe_task_state state;
	union {
		struct {
			struct arch_uprobe_task autask;
			long unsigned int vaddr;
		};
		struct {
			struct callback_head dup_xol_work;
			long unsigned int dup_xol_addr;
		};
	};
	struct uprobe *active_uprobe;
	long unsigned int xol_vaddr;
	struct return_instance *return_instances;
	unsigned int depth;
};

struct return_instance {
	struct uprobe *uprobe;
	long unsigned int func;
	long unsigned int stack;
	long unsigned int orig_ret_vaddr;
	bool chained;
	struct return_instance *next;
};

struct workqueue_struct;

struct delayed_work {
	struct work_struct work;
	struct timer_list timer;
	struct workqueue_struct *wq;
	int cpu;
};

struct rcu_work {
	struct work_struct work;
	struct callback_head rcu;
	struct workqueue_struct *wq;
};

struct seqcount_raw_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_raw_spinlock seqcount_raw_spinlock_t;

struct seqcount_spinlock {
	seqcount_t seqcount;
};

typedef struct seqcount_spinlock seqcount_spinlock_t;

typedef struct {
	seqcount_spinlock_t seqcount;
	spinlock_t lock;
} seqlock_t;

struct xarray {
	spinlock_t xa_lock;
	gfp_t xa_flags;
	void *xa_head;
};

typedef u32 errseq_t;

struct address_space_operations;

struct address_space {
	struct inode *host;
	struct xarray i_pages;
	struct rw_semaphore invalidate_lock;
	gfp_t gfp_mask;
	atomic_t i_mmap_writable;
	struct rb_root_cached i_mmap;
	struct rw_semaphore i_mmap_rwsem;
	long unsigned int nrpages;
	long unsigned int writeback_index;
	const struct address_space_operations *a_ops;
	long unsigned int flags;
	errseq_t wb_err;
	spinlock_t private_lock;
	struct list_head private_list;
	void *private_data;
};

enum dma_data_direction {
	DMA_BIDIRECTIONAL = 0,
	DMA_TO_DEVICE = 1,
	DMA_FROM_DEVICE = 2,
	DMA_NONE = 3,
};

struct device;

struct page_pool_params {
	unsigned int flags;
	unsigned int order;
	unsigned int pool_size;
	int nid;
	struct device *dev;
	enum dma_data_direction dma_dir;
	unsigned int max_len;
	unsigned int offset;
	void (*init_callback)(struct page *, void *);
	void *init_arg;
};

struct page_pool_alloc_stats {
	u64 fast;
	u64 slow;
	u64 slow_high_order;
	u64 empty;
	u64 refill;
	u64 waive;
};

struct pp_alloc_cache {
	u32 count;
	struct page *cache[128];
};

struct ptr_ring {
	int producer;
	spinlock_t producer_lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int consumer_head;
	int consumer_tail;
	spinlock_t consumer_lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int size;
	int batch;
	void **queue;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct page_pool_recycle_stats;

struct page_pool {
	struct page_pool_params p;
	struct delayed_work release_dw;
	void (*disconnect)(void *);
	long unsigned int defer_start;
	long unsigned int defer_warn;
	u32 pages_state_hold_cnt;
	unsigned int frag_offset;
	struct page *frag_page;
	long int frag_users;
	struct page_pool_alloc_stats alloc_stats;
	u32 xdp_mem_id;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct pp_alloc_cache alloc;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct ptr_ring ring;
	struct page_pool_recycle_stats *recycle_stats;
	atomic_t pages_state_release_cnt;
	refcount_t user_cnt;
	int: 32;
	u64 destroy_cnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct vmem_altmap {
	long unsigned int base_pfn;
	const long unsigned int end_pfn;
	const long unsigned int reserve;
	long unsigned int free;
	long unsigned int align;
	long unsigned int alloc;
};

struct percpu_ref_data;

struct percpu_ref {
	long unsigned int percpu_count_ptr;
	struct percpu_ref_data *data;
};

enum memory_type {
	MEMORY_DEVICE_PRIVATE = 1,
	MEMORY_DEVICE_COHERENT = 2,
	MEMORY_DEVICE_FS_DAX = 3,
	MEMORY_DEVICE_GENERIC = 4,
	MEMORY_DEVICE_PCI_P2PDMA = 5,
};

struct range {
	u64 start;
	u64 end;
};

struct dev_pagemap_ops;

struct dev_pagemap {
	struct vmem_altmap altmap;
	struct percpu_ref ref;
	struct completion done;
	enum memory_type type;
	unsigned int flags;
	long unsigned int vmemmap_shift;
	const struct dev_pagemap_ops *ops;
	void *owner;
	int nr_range;
	union {
		struct range range;
		struct range ranges[0];
	};
};

struct folio {
	union {
		struct {
			long unsigned int flags;
			union {
				struct list_head lru;
				struct {
					void *__filler;
					unsigned int mlock_count;
				};
			};
			struct address_space *mapping;
			long unsigned int index;
			void *private;
			atomic_t _mapcount;
			atomic_t _refcount;
			long unsigned int memcg_data;
		};
		struct page page;
	};
	long unsigned int _flags_1;
	long unsigned int __head;
	unsigned char _folio_dtor;
	unsigned char _folio_order;
	atomic_t _total_mapcount;
	atomic_t _pincount;
};

struct vfsmount;

struct path {
	struct vfsmount *mnt;
	struct dentry *dentry;
};

enum pid_type {
	PIDTYPE_PID = 0,
	PIDTYPE_TGID = 1,
	PIDTYPE_PGID = 2,
	PIDTYPE_SID = 3,
	PIDTYPE_MAX = 4,
};

struct fown_struct {
	rwlock_t lock;
	struct pid *pid;
	enum pid_type pid_type;
	kuid_t uid;
	kuid_t euid;
	int signum;
};

struct file_ra_state {
	long unsigned int start;
	unsigned int size;
	unsigned int async_size;
	unsigned int ra_pages;
	unsigned int mmap_miss;
	int: 32;
	loff_t prev_pos;
};

struct file {
	union {
		struct llist_node f_llist;
		struct callback_head f_rcuhead;
		unsigned int f_iocb_flags;
	};
	struct path f_path;
	struct inode *f_inode;
	const struct file_operations *f_op;
	spinlock_t f_lock;
	atomic_long_t f_count;
	unsigned int f_flags;
	fmode_t f_mode;
	struct mutex f_pos_lock;
	int: 32;
	loff_t f_pos;
	struct fown_struct f_owner;
	const struct cred *f_cred;
	int: 32;
	struct file_ra_state f_ra;
	u64 f_version;
	void *private_data;
	struct hlist_head *f_ep;
	struct address_space *f_mapping;
	errseq_t f_wb_err;
	errseq_t f_sb_err;
	int: 32;
};

struct anon_vma_name {
	struct kref kref;
	char name[0];
};

struct anon_vma {
	struct anon_vma *root;
	struct rw_semaphore rwsem;
	atomic_t refcount;
	long unsigned int num_children;
	long unsigned int num_active_vmas;
	struct anon_vma *parent;
	struct rb_root_cached rb_root;
};

typedef unsigned int vm_fault_t;

enum page_entry_size {
	PE_SIZE_PTE = 0,
	PE_SIZE_PMD = 1,
	PE_SIZE_PUD = 2,
};

struct vm_fault;

struct vm_operations_struct {
	void (*open)(struct vm_area_struct *);
	void (*close)(struct vm_area_struct *);
	int (*may_split)(struct vm_area_struct *, long unsigned int);
	int (*mremap)(struct vm_area_struct *);
	int (*mprotect)(struct vm_area_struct *, long unsigned int, long unsigned int, long unsigned int);
	vm_fault_t (*fault)(struct vm_fault *);
	vm_fault_t (*huge_fault)(struct vm_fault *, enum page_entry_size);
	vm_fault_t (*map_pages)(struct vm_fault *, long unsigned int, long unsigned int);
	long unsigned int (*pagesize)(struct vm_area_struct *);
	vm_fault_t (*page_mkwrite)(struct vm_fault *);
	vm_fault_t (*pfn_mkwrite)(struct vm_fault *);
	int (*access)(struct vm_area_struct *, long unsigned int, void *, int, int);
	const char * (*name)(struct vm_area_struct *);
	struct page * (*find_special_page)(struct vm_area_struct *, long unsigned int);
};

struct linux_binprm;

struct coredump_params;

struct linux_binfmt {
	struct list_head lh;
	struct module *module;
	int (*load_binary)(struct linux_binprm *);
	int (*load_shlib)(struct file *);
	int (*core_dump)(struct coredump_params *);
	long unsigned int min_coredump;
};

enum fault_flag {
	FAULT_FLAG_WRITE = 1,
	FAULT_FLAG_MKWRITE = 2,
	FAULT_FLAG_ALLOW_RETRY = 4,
	FAULT_FLAG_RETRY_NOWAIT = 8,
	FAULT_FLAG_KILLABLE = 16,
	FAULT_FLAG_TRIED = 32,
	FAULT_FLAG_USER = 64,
	FAULT_FLAG_REMOTE = 128,
	FAULT_FLAG_INSTRUCTION = 256,
	FAULT_FLAG_INTERRUPTIBLE = 512,
	FAULT_FLAG_UNSHARE = 1024,
	FAULT_FLAG_ORIG_PTE_VALID = 2048,
};

typedef struct {
	pgd_t pgd;
} p4d_t;

typedef struct {
	p4d_t p4d;
} pud_t;

struct vm_fault {
	const struct {
		struct vm_area_struct *vma;
		gfp_t gfp_mask;
		long unsigned int pgoff;
		long unsigned int address;
		long unsigned int real_address;
	};
	enum fault_flag flags;
	pmd_t *pmd;
	pud_t *pud;
	union {
		pte_t orig_pte;
		pmd_t orig_pmd;
	};
	struct page *cow_page;
	struct page *page;
	pte_t *pte;
	spinlock_t *ptl;
	pgtable_t prealloc_pte;
};

struct static_key {
	atomic_t enabled;
};

struct static_key_false {
	struct static_key key;
};

typedef struct {
	long unsigned int bits[1];
} nodemask_t;

enum node_states {
	N_POSSIBLE = 0,
	N_ONLINE = 1,
	N_NORMAL_MEMORY = 2,
	N_HIGH_MEMORY = 3,
	N_MEMORY = 4,
	N_CPU = 5,
	N_GENERIC_INITIATOR = 6,
	NR_NODE_STATES = 7,
};

struct free_area {
	struct list_head free_list[6];
	long unsigned int nr_free;
};

enum node_stat_item {
	NR_LRU_BASE = 0,
	NR_INACTIVE_ANON = 0,
	NR_ACTIVE_ANON = 1,
	NR_INACTIVE_FILE = 2,
	NR_ACTIVE_FILE = 3,
	NR_UNEVICTABLE = 4,
	NR_SLAB_RECLAIMABLE_B = 5,
	NR_SLAB_UNRECLAIMABLE_B = 6,
	NR_ISOLATED_ANON = 7,
	NR_ISOLATED_FILE = 8,
	WORKINGSET_NODES = 9,
	WORKINGSET_REFAULT_BASE = 10,
	WORKINGSET_REFAULT_ANON = 10,
	WORKINGSET_REFAULT_FILE = 11,
	WORKINGSET_ACTIVATE_BASE = 12,
	WORKINGSET_ACTIVATE_ANON = 12,
	WORKINGSET_ACTIVATE_FILE = 13,
	WORKINGSET_RESTORE_BASE = 14,
	WORKINGSET_RESTORE_ANON = 14,
	WORKINGSET_RESTORE_FILE = 15,
	WORKINGSET_NODERECLAIM = 16,
	NR_ANON_MAPPED = 17,
	NR_FILE_MAPPED = 18,
	NR_FILE_PAGES = 19,
	NR_FILE_DIRTY = 20,
	NR_WRITEBACK = 21,
	NR_WRITEBACK_TEMP = 22,
	NR_SHMEM = 23,
	NR_SHMEM_THPS = 24,
	NR_SHMEM_PMDMAPPED = 25,
	NR_FILE_THPS = 26,
	NR_FILE_PMDMAPPED = 27,
	NR_ANON_THPS = 28,
	NR_VMSCAN_WRITE = 29,
	NR_VMSCAN_IMMEDIATE = 30,
	NR_DIRTIED = 31,
	NR_WRITTEN = 32,
	NR_THROTTLED_WRITTEN = 33,
	NR_KERNEL_MISC_RECLAIMABLE = 34,
	NR_FOLL_PIN_ACQUIRED = 35,
	NR_FOLL_PIN_RELEASED = 36,
	NR_KERNEL_STACK_KB = 37,
	NR_PAGETABLE = 38,
	NR_SECONDARY_PAGETABLE = 39,
	NR_SWAPCACHE = 40,
	NR_VM_NODE_STAT_ITEMS = 41,
};

enum lru_list {
	LRU_INACTIVE_ANON = 0,
	LRU_ACTIVE_ANON = 1,
	LRU_INACTIVE_FILE = 2,
	LRU_ACTIVE_FILE = 3,
	LRU_UNEVICTABLE = 4,
	NR_LRU_LISTS = 5,
};

struct pglist_data;

struct lruvec {
	struct list_head lists[5];
	spinlock_t lru_lock;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	atomic_long_t nonresident_age;
	long unsigned int refaults[2];
	long unsigned int flags;
	struct pglist_data *pgdat;
};

struct per_cpu_pages;

struct per_cpu_zonestat;

struct zone {
	long unsigned int _watermark[4];
	long unsigned int watermark_boost;
	long unsigned int nr_reserved_highatomic;
	long int lowmem_reserve[3];
	struct pglist_data *zone_pgdat;
	struct per_cpu_pages *per_cpu_pageset;
	struct per_cpu_zonestat *per_cpu_zonestats;
	int pageset_high;
	int pageset_batch;
	long unsigned int *pageblock_flags;
	long unsigned int zone_start_pfn;
	atomic_long_t managed_pages;
	long unsigned int spanned_pages;
	long unsigned int present_pages;
	long unsigned int cma_pages;
	const char *name;
	long unsigned int nr_isolate_pageblock;
	int initialized;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct cacheline_padding _pad1_;
	struct free_area free_area[14];
	long unsigned int flags;
	spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct cacheline_padding _pad2_;
	long unsigned int percpu_drift_mark;
	long unsigned int compact_cached_free_pfn;
	long unsigned int compact_cached_migrate_pfn[2];
	long unsigned int compact_init_migrate_pfn;
	long unsigned int compact_init_free_pfn;
	unsigned int compact_considered;
	unsigned int compact_defer_shift;
	int compact_order_failed;
	bool compact_blockskip_flush;
	bool contiguous;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct cacheline_padding _pad3_;
	atomic_long_t vm_stat[10];
	atomic_long_t vm_numa_event[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct zoneref {
	struct zone *zone;
	int zone_idx;
};

struct zonelist {
	struct zoneref _zonerefs[4];
};

enum zone_type {
	ZONE_NORMAL = 0,
	ZONE_HIGHMEM = 1,
	ZONE_MOVABLE = 2,
	__MAX_NR_ZONES = 3,
};

struct per_cpu_nodestat;

struct pglist_data {
	struct zone node_zones[3];
	struct zonelist node_zonelists[1];
	int nr_zones;
	struct page *node_mem_map;
	long unsigned int node_start_pfn;
	long unsigned int node_present_pages;
	long unsigned int node_spanned_pages;
	int node_id;
	wait_queue_head_t kswapd_wait;
	wait_queue_head_t pfmemalloc_wait;
	wait_queue_head_t reclaim_wait[4];
	atomic_t nr_writeback_throttled;
	long unsigned int nr_reclaim_start;
	struct task_struct *kswapd;
	int kswapd_order;
	enum zone_type kswapd_highest_zoneidx;
	int kswapd_failures;
	int kcompactd_max_order;
	enum zone_type kcompactd_highest_zoneidx;
	wait_queue_head_t kcompactd_wait;
	struct task_struct *kcompactd;
	bool proactive_compact_trigger;
	long unsigned int totalreserve_pages;
	int: 32;
	int: 32;
	struct cacheline_padding _pad1_;
	struct lruvec __lruvec;
	long unsigned int flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct cacheline_padding _pad2_;
	struct per_cpu_nodestat *per_cpu_nodestats;
	atomic_long_t vm_stat[41];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct per_cpu_pages {
	spinlock_t lock;
	int count;
	int high;
	int batch;
	short int free_factor;
	struct list_head lists[12];
	int: 32;
	int: 32;
	int: 32;
};

struct per_cpu_zonestat {
	s8 vm_stat_diff[10];
	s8 stat_threshold;
};

struct per_cpu_nodestat {
	s8 stat_threshold;
	s8 vm_node_stat_diff[41];
};

struct rcu_segcblist {
	struct callback_head *head;
	struct callback_head **tails[4];
	long unsigned int gp_seq[4];
	long int len;
	long int seglen[4];
	u8 flags;
};

struct srcu_node;

struct srcu_struct;

struct srcu_data {
	long unsigned int srcu_lock_count[2];
	long unsigned int srcu_unlock_count[2];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t lock;
	struct rcu_segcblist srcu_cblist;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	bool srcu_cblist_invoking;
	struct timer_list delay_work;
	struct work_struct work;
	struct callback_head srcu_barrier_head;
	struct srcu_node *mynode;
	long unsigned int grpmask;
	int cpu;
	struct srcu_struct *ssp;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct srcu_node {
	spinlock_t lock;
	long unsigned int srcu_have_cbs[4];
	long unsigned int srcu_data_have_cbs[4];
	long unsigned int srcu_gp_seq_needed_exp;
	struct srcu_node *srcu_parent;
	int grplo;
	int grphi;
};

struct srcu_struct {
	struct srcu_node *node;
	struct srcu_node *level[2];
	int srcu_size_state;
	struct mutex srcu_cb_mutex;
	spinlock_t lock;
	struct mutex srcu_gp_mutex;
	unsigned int srcu_idx;
	long unsigned int srcu_gp_seq;
	long unsigned int srcu_gp_seq_needed;
	long unsigned int srcu_gp_seq_needed_exp;
	long unsigned int srcu_gp_start;
	long unsigned int srcu_last_gp_end;
	long unsigned int srcu_size_jiffies;
	long unsigned int srcu_n_lock_retries;
	long unsigned int srcu_n_exp_nodelay;
	struct srcu_data *sda;
	bool sda_is_static;
	long unsigned int srcu_barrier_seq;
	struct mutex srcu_barrier_mutex;
	struct completion srcu_barrier_completion;
	atomic_t srcu_barrier_cpu_cnt;
	long unsigned int reschedule_jiffies;
	long unsigned int reschedule_count;
	struct delayed_work work;
	struct lockdep_map dep_map;
};

struct notifier_block;

typedef int (*notifier_fn_t)(struct notifier_block *, long unsigned int, void *);

struct notifier_block {
	notifier_fn_t notifier_call;
	struct notifier_block *next;
	int priority;
};

struct blocking_notifier_head {
	struct rw_semaphore rwsem;
	struct notifier_block *head;
};

struct raw_notifier_head {
	struct notifier_block *head;
};

typedef int proc_handler(struct ctl_table *, int, void *, size_t *, loff_t *);

struct ctl_table_poll;

struct ctl_table {
	const char *procname;
	void *data;
	int maxlen;
	umode_t mode;
	struct ctl_table *child;
	proc_handler *proc_handler;
	struct ctl_table_poll *poll;
	void *extra1;
	void *extra2;
};

struct ctl_table_poll {
	atomic_t event;
	wait_queue_head_t wait;
};

struct ctl_node {
	struct rb_node node;
	struct ctl_table_header *header;
};

struct ctl_table_root {
	struct ctl_table_set default_set;
	struct ctl_table_set * (*lookup)(struct ctl_table_root *);
	void (*set_ownership)(struct ctl_table_header *, struct ctl_table *, kuid_t *, kgid_t *);
	int (*permissions)(struct ctl_table_header *, struct ctl_table *);
};

struct kernel_cap_struct {
	__u32 cap[2];
};

typedef struct kernel_cap_struct kernel_cap_t;

struct user_struct;

struct group_info;

struct cred {
	atomic_t usage;
	kuid_t uid;
	kgid_t gid;
	kuid_t suid;
	kgid_t sgid;
	kuid_t euid;
	kgid_t egid;
	kuid_t fsuid;
	kgid_t fsgid;
	unsigned int securebits;
	kernel_cap_t cap_inheritable;
	kernel_cap_t cap_permitted;
	kernel_cap_t cap_effective;
	kernel_cap_t cap_bset;
	kernel_cap_t cap_ambient;
	unsigned char jit_keyring;
	struct key *session_keyring;
	struct key *process_keyring;
	struct key *thread_keyring;
	struct key *request_key_auth;
	struct user_struct *user;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct group_info *group_info;
	union {
		int non_rcu;
		struct callback_head rcu;
	};
};

typedef __u32 Elf32_Addr;

typedef __u16 Elf32_Half;

typedef __u32 Elf32_Off;

typedef __u32 Elf32_Word;

struct elf32_sym {
	Elf32_Word st_name;
	Elf32_Addr st_value;
	Elf32_Word st_size;
	unsigned char st_info;
	unsigned char st_other;
	Elf32_Half st_shndx;
};

typedef struct elf32_sym Elf32_Sym;

struct elf32_shdr {
	Elf32_Word sh_name;
	Elf32_Word sh_type;
	Elf32_Word sh_flags;
	Elf32_Addr sh_addr;
	Elf32_Off sh_offset;
	Elf32_Word sh_size;
	Elf32_Word sh_link;
	Elf32_Word sh_info;
	Elf32_Word sh_addralign;
	Elf32_Word sh_entsize;
};

struct upid {
	int nr;
	struct pid_namespace *ns;
};

struct idr {
	struct xarray idr_rt;
	unsigned int idr_base;
	unsigned int idr_next;
};

struct kmem_cache;

struct pid_namespace {
	struct idr idr;
	struct callback_head rcu;
	unsigned int pid_allocated;
	struct task_struct *child_reaper;
	struct kmem_cache *pid_cachep;
	unsigned int level;
	struct pid_namespace *parent;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	int reboot;
	struct ns_common ns;
};

struct pid {
	refcount_t count;
	unsigned int level;
	spinlock_t lock;
	struct hlist_head tasks[4];
	struct hlist_head inodes;
	wait_queue_head_t wait_pidfd;
	struct callback_head rcu;
	struct upid numbers[1];
};

struct rhashtable;

struct rhashtable_compare_arg {
	struct rhashtable *ht;
	const void *key;
};

typedef u32 (*rht_hashfn_t)(const void *, u32, u32);

typedef u32 (*rht_obj_hashfn_t)(const void *, u32, u32);

typedef int (*rht_obj_cmpfn_t)(struct rhashtable_compare_arg *, const void *);

struct rhashtable_params {
	u16 nelem_hint;
	u16 key_len;
	u16 key_offset;
	u16 head_offset;
	unsigned int max_size;
	u16 min_size;
	bool automatic_shrinking;
	rht_hashfn_t hashfn;
	rht_obj_hashfn_t obj_hashfn;
	rht_obj_cmpfn_t obj_cmpfn;
};

struct bucket_table;

struct rhashtable {
	struct bucket_table *tbl;
	unsigned int key_len;
	unsigned int max_elems;
	struct rhashtable_params p;
	bool rhlist;
	struct work_struct run_work;
	struct mutex mutex;
	spinlock_t lock;
	atomic_t nelems;
};

struct hrtimer_cpu_base;

struct hrtimer_clock_base {
	struct hrtimer_cpu_base *cpu_base;
	unsigned int index;
	clockid_t clockid;
	seqcount_raw_spinlock_t seq;
	struct hrtimer *running;
	struct timerqueue_head active;
	ktime_t (*get_time)();
	ktime_t offset;
};

struct hrtimer_cpu_base {
	raw_spinlock_t lock;
	unsigned int cpu;
	unsigned int active_bases;
	unsigned int clock_was_set_seq;
	unsigned int hres_active: 1;
	unsigned int in_hrtirq: 1;
	unsigned int hang_detected: 1;
	unsigned int softirq_activated: 1;
	unsigned int nr_events;
	short unsigned int nr_retries;
	short unsigned int nr_hangs;
	unsigned int max_hang_time;
	ktime_t expires_next;
	struct hrtimer *next_timer;
	int: 32;
	ktime_t softirq_expires_next;
	struct hrtimer *softirq_next_timer;
	int: 32;
	struct hrtimer_clock_base clock_base[8];
};

struct rlimit {
	__kernel_ulong_t rlim_cur;
	__kernel_ulong_t rlim_max;
};

struct task_cputime {
	u64 stime;
	u64 utime;
	long long unsigned int sum_exec_runtime;
};

typedef void __signalfn_t(int);

typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t();

typedef __restorefn_t *__sigrestore_t;

union sigval {
	int sival_int;
	void *sival_ptr;
};

typedef union sigval sigval_t;

union __sifields {
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
	} _kill;
	struct {
		__kernel_timer_t _tid;
		int _overrun;
		sigval_t _sigval;
		int _sys_private;
	} _timer;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		sigval_t _sigval;
	} _rt;
	struct {
		__kernel_pid_t _pid;
		__kernel_uid32_t _uid;
		int _status;
		__kernel_clock_t _utime;
		__kernel_clock_t _stime;
	} _sigchld;
	struct {
		void *_addr;
		union {
			int _trapno;
			short int _addr_lsb;
			struct {
				char _dummy_bnd[4];
				void *_lower;
				void *_upper;
			} _addr_bnd;
			struct {
				char _dummy_pkey[4];
				__u32 _pkey;
			} _addr_pkey;
			struct {
				long unsigned int _data;
				__u32 _type;
				__u32 _flags;
			} _perf;
		};
	} _sigfault;
	struct {
		long int _band;
		int _fd;
	} _sigpoll;
	struct {
		void *_call_addr;
		int _syscall;
		unsigned int _arch;
	} _sigsys;
};

struct kernel_siginfo {
	struct {
		int si_signo;
		int si_errno;
		int si_code;
		union __sifields _sifields;
	};
};

struct ucounts {
	struct hlist_node node;
	struct user_namespace *ns;
	kuid_t uid;
	atomic_t count;
	atomic_long_t ucount[10];
	atomic_long_t rlimit[4];
};

struct sigaction {
	__sighandler_t sa_handler;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
	sigset_t sa_mask;
};

struct k_sigaction {
	struct sigaction sa;
};

struct cpu_itimer {
	u64 expires;
	u64 incr;
};

struct task_cputime_atomic {
	atomic64_t utime;
	atomic64_t stime;
	atomic64_t sum_exec_runtime;
};

struct thread_group_cputimer {
	struct task_cputime_atomic cputime_atomic;
};

struct core_state;

struct tty_struct;

struct signal_struct {
	refcount_t sigcnt;
	atomic_t live;
	int nr_threads;
	int quick_threads;
	struct list_head thread_head;
	wait_queue_head_t wait_chldexit;
	struct task_struct *curr_target;
	struct sigpending shared_pending;
	struct hlist_head multiprocess;
	int group_exit_code;
	int notify_count;
	struct task_struct *group_exec_task;
	int group_stop_count;
	unsigned int flags;
	struct core_state *core_state;
	unsigned int is_child_subreaper: 1;
	unsigned int has_child_subreaper: 1;
	int posix_timer_id;
	struct list_head posix_timers;
	int: 32;
	struct hrtimer real_timer;
	ktime_t it_real_incr;
	struct cpu_itimer it[2];
	struct thread_group_cputimer cputimer;
	struct posix_cputimers posix_cputimers;
	struct pid *pids[4];
	struct pid *tty_old_pgrp;
	int leader;
	struct tty_struct *tty;
	seqlock_t stats_lock;
	int: 32;
	u64 utime;
	u64 stime;
	u64 cutime;
	u64 cstime;
	u64 gtime;
	u64 cgtime;
	struct prev_cputime prev_cputime;
	long unsigned int nvcsw;
	long unsigned int nivcsw;
	long unsigned int cnvcsw;
	long unsigned int cnivcsw;
	long unsigned int min_flt;
	long unsigned int maj_flt;
	long unsigned int cmin_flt;
	long unsigned int cmaj_flt;
	long unsigned int inblock;
	long unsigned int oublock;
	long unsigned int cinblock;
	long unsigned int coublock;
	long unsigned int maxrss;
	long unsigned int cmaxrss;
	struct task_io_accounting ioac;
	long long unsigned int sum_sched_runtime;
	struct rlimit rlim[16];
	bool oom_flag_origin;
	short int oom_score_adj;
	short int oom_score_adj_min;
	struct mm_struct *oom_mm;
	struct mutex cred_guard_mutex;
	struct rw_semaphore exec_update_lock;
};

struct rseq {
	__u32 cpu_id_start;
	__u32 cpu_id;
	__u64 rseq_cs;
	__u32 flags;
	int: 32;
	int: 32;
	int: 32;
};

struct rq;

struct rq_flags;

struct sched_class {
	void (*enqueue_task)(struct rq *, struct task_struct *, int);
	void (*dequeue_task)(struct rq *, struct task_struct *, int);
	void (*yield_task)(struct rq *);
	bool (*yield_to_task)(struct rq *, struct task_struct *);
	void (*check_preempt_curr)(struct rq *, struct task_struct *, int);
	struct task_struct * (*pick_next_task)(struct rq *);
	void (*put_prev_task)(struct rq *, struct task_struct *);
	void (*set_next_task)(struct rq *, struct task_struct *, bool);
	int (*balance)(struct rq *, struct task_struct *, struct rq_flags *);
	int (*select_task_rq)(struct task_struct *, int, int);
	struct task_struct * (*pick_task)(struct rq *);
	void (*migrate_task_rq)(struct task_struct *, int);
	void (*task_woken)(struct rq *, struct task_struct *);
	void (*set_cpus_allowed)(struct task_struct *, const struct cpumask *, u32);
	void (*rq_online)(struct rq *);
	void (*rq_offline)(struct rq *);
	struct rq * (*find_lock_rq)(struct task_struct *, struct rq *);
	void (*task_tick)(struct rq *, struct task_struct *, int);
	void (*task_fork)(struct task_struct *);
	void (*task_dead)(struct task_struct *);
	void (*switched_from)(struct rq *, struct task_struct *);
	void (*switched_to)(struct rq *, struct task_struct *);
	void (*prio_changed)(struct rq *, struct task_struct *, int);
	unsigned int (*get_rr_interval)(struct rq *, struct task_struct *);
	void (*update_curr)(struct rq *);
};

typedef int32_t key_serial_t;

typedef uint32_t key_perm_t;

struct key_type;

struct key_tag;

struct keyring_index_key {
	long unsigned int hash;
	union {
		struct {
			u16 desc_len;
			char desc[2];
		};
		long unsigned int x;
	};
	struct key_type *type;
	struct key_tag *domain_tag;
	const char *description;
};

union key_payload {
	void *rcu_data0;
	void *data[4];
};

struct assoc_array_ptr;

struct assoc_array {
	struct assoc_array_ptr *root;
	long unsigned int nr_leaves_on_tree;
};

struct key_user;

struct key_restriction;

struct key {
	refcount_t usage;
	key_serial_t serial;
	union {
		struct list_head graveyard_link;
		struct rb_node serial_node;
	};
	struct rw_semaphore sem;
	struct key_user *user;
	void *security;
	int: 32;
	union {
		time64_t expiry;
		time64_t revoked_at;
	};
	time64_t last_used_at;
	kuid_t uid;
	kgid_t gid;
	key_perm_t perm;
	short unsigned int quotalen;
	short unsigned int datalen;
	short int state;
	long unsigned int flags;
	union {
		struct keyring_index_key index_key;
		struct {
			long unsigned int hash;
			long unsigned int len_desc;
			struct key_type *type;
			struct key_tag *domain_tag;
			char *description;
		};
	};
	union {
		union key_payload payload;
		struct {
			struct list_head name_link;
			struct assoc_array keys;
		};
	};
	struct key_restriction *restrict_link;
};

struct uts_namespace;

struct ipc_namespace;

struct mnt_namespace;

struct net;

struct time_namespace;

struct cgroup_namespace;

struct nsproxy {
	atomic_t count;
	struct uts_namespace *uts_ns;
	struct ipc_namespace *ipc_ns;
	struct mnt_namespace *mnt_ns;
	struct pid_namespace *pid_ns_for_children;
	struct net *net_ns;
	struct time_namespace *time_ns;
	struct time_namespace *time_ns_for_children;
	struct cgroup_namespace *cgroup_ns;
};

struct sighand_struct {
	spinlock_t siglock;
	refcount_t count;
	wait_queue_head_t signalfd_wqh;
	struct k_sigaction action[64];
};

struct bio;

struct bio_list {
	struct bio *head;
	struct bio *tail;
};

struct request;

struct blk_plug {
	struct request *mq_list;
	struct request *cached_rq;
	short unsigned int nr_ios;
	short unsigned int rq_count;
	bool multiple_queues;
	bool has_elevator;
	bool nowait;
	struct list_head cb_list;
};

struct reclaim_state {
	long unsigned int reclaimed_slab;
};

struct percpu_counter {
	raw_spinlock_t lock;
	int: 32;
	s64 count;
	struct list_head list;
	s32 *counters;
	int: 32;
};

struct fprop_local_percpu {
	struct percpu_counter events;
	unsigned int period;
	raw_spinlock_t lock;
};

enum wb_reason {
	WB_REASON_BACKGROUND = 0,
	WB_REASON_VMSCAN = 1,
	WB_REASON_SYNC = 2,
	WB_REASON_PERIODIC = 3,
	WB_REASON_LAPTOP_TIMER = 4,
	WB_REASON_FS_FREE_SPACE = 5,
	WB_REASON_FORKER_THREAD = 6,
	WB_REASON_FOREIGN_FLUSH = 7,
	WB_REASON_MAX = 8,
};

struct bdi_writeback {
	struct backing_dev_info *bdi;
	long unsigned int state;
	long unsigned int last_old_flush;
	struct list_head b_dirty;
	struct list_head b_io;
	struct list_head b_more_io;
	struct list_head b_dirty_time;
	spinlock_t list_lock;
	atomic_t writeback_inodes;
	int: 32;
	struct percpu_counter stat[4];
	long unsigned int bw_time_stamp;
	long unsigned int dirtied_stamp;
	long unsigned int written_stamp;
	long unsigned int write_bandwidth;
	long unsigned int avg_write_bandwidth;
	long unsigned int dirty_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	int: 32;
	struct fprop_local_percpu completions;
	int dirty_exceeded;
	enum wb_reason start_all_reason;
	spinlock_t work_lock;
	struct list_head work_list;
	struct delayed_work dwork;
	struct delayed_work bw_dwork;
	long unsigned int dirty_sleep;
	struct list_head bdi_node;
};

struct backing_dev_info {
	u64 id;
	struct rb_node rb_node;
	struct list_head bdi_list;
	long unsigned int ra_pages;
	long unsigned int io_pages;
	struct kref refcnt;
	unsigned int capabilities;
	unsigned int min_ratio;
	unsigned int max_ratio;
	unsigned int max_prop_frac;
	atomic_long_t tot_write_bandwidth;
	int: 32;
	struct bdi_writeback wb;
	struct list_head wb_list;
	wait_queue_head_t wb_waitq;
	struct device *dev;
	char dev_name[64];
	struct device *owner;
	struct timer_list laptop_mode_wb_timer;
	struct dentry *debug_dir;
	int: 32;
};

struct io_context {
	atomic_long_t refcount;
	atomic_t active_ref;
	short unsigned int ioprio;
};

struct cgroup_subsys_state;

struct cgroup;

struct css_set {
	struct cgroup_subsys_state *subsys[5];
	refcount_t refcount;
	struct css_set *dom_cset;
	struct cgroup *dfl_cgrp;
	int nr_tasks;
	struct list_head tasks;
	struct list_head mg_tasks;
	struct list_head dying_tasks;
	struct list_head task_iters;
	struct list_head e_cset_node[5];
	struct list_head threaded_csets;
	struct list_head threaded_csets_node;
	struct hlist_node hlist;
	struct list_head cgrp_links;
	struct list_head mg_src_preload_node;
	struct list_head mg_dst_preload_node;
	struct list_head mg_node;
	struct cgroup *mg_src_cgrp;
	struct cgroup *mg_dst_cgrp;
	struct css_set *mg_dst_cset;
	bool dead;
	struct callback_head callback_head;
};

struct perf_event_groups {
	struct rb_root tree;
	int: 32;
	u64 index;
};

typedef struct {
	atomic_long_t a;
} local_t;

struct perf_event_context {
	struct pmu *pmu;
	raw_spinlock_t lock;
	struct mutex mutex;
	struct list_head active_ctx_list;
	int: 32;
	struct perf_event_groups pinned_groups;
	struct perf_event_groups flexible_groups;
	struct list_head event_list;
	struct list_head pinned_active;
	struct list_head flexible_active;
	int nr_events;
	int nr_active;
	int nr_user;
	int is_active;
	int nr_stat;
	int nr_freq;
	int rotate_disable;
	int rotate_necessary;
	refcount_t refcount;
	struct task_struct *task;
	u64 time;
	u64 timestamp;
	u64 timeoffset;
	struct perf_event_context *parent_ctx;
	int: 32;
	u64 parent_gen;
	u64 generation;
	int pin_count;
	void *task_ctx_data;
	struct callback_head callback_head;
	local_t nr_pending;
	int: 32;
};

struct pipe_buffer;

struct pipe_inode_info {
	struct mutex mutex;
	wait_queue_head_t rd_wait;
	wait_queue_head_t wr_wait;
	unsigned int head;
	unsigned int tail;
	unsigned int max_usage;
	unsigned int ring_size;
	unsigned int nr_accounted;
	unsigned int readers;
	unsigned int writers;
	unsigned int files;
	unsigned int r_counter;
	unsigned int w_counter;
	bool poll_usage;
	struct page *tmp_page;
	struct fasync_struct *fasync_readers;
	struct fasync_struct *fasync_writers;
	struct pipe_buffer *bufs;
	struct user_struct *user;
};

struct cgroup_subsys;

struct cgroup_subsys_state {
	struct cgroup *cgroup;
	struct cgroup_subsys *ss;
	struct percpu_ref refcnt;
	struct list_head sibling;
	struct list_head children;
	struct list_head rstat_css_node;
	int id;
	unsigned int flags;
	u64 serial_nr;
	atomic_t online_cnt;
	struct work_struct destroy_work;
	struct rcu_work destroy_rwork;
	struct cgroup_subsys_state *parent;
	int: 32;
};

struct mem_cgroup_id {
	int id;
	refcount_t ref;
};

struct page_counter {
	atomic_long_t usage;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct cacheline_padding _pad1_;
	long unsigned int emin;
	atomic_long_t min_usage;
	atomic_long_t children_min_usage;
	long unsigned int elow;
	atomic_long_t low_usage;
	atomic_long_t children_low_usage;
	long unsigned int watermark;
	long unsigned int failcnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct cacheline_padding _pad2_;
	long unsigned int min;
	long unsigned int low;
	long unsigned int high;
	long unsigned int max;
	struct page_counter *parent;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct vmpressure {
	long unsigned int scanned;
	long unsigned int reclaimed;
	long unsigned int tree_scanned;
	long unsigned int tree_reclaimed;
	spinlock_t sr_lock;
	struct list_head events;
	struct mutex events_lock;
	struct work_struct work;
};

struct kernfs_node;

struct cgroup_file {
	struct kernfs_node *kn;
	long unsigned int notified_at;
	struct timer_list notify_timer;
};

struct mem_cgroup_threshold_ary;

struct mem_cgroup_thresholds {
	struct mem_cgroup_threshold_ary *primary;
	struct mem_cgroup_threshold_ary *spare;
};

struct memcg_vmstats;

struct obj_cgroup;

struct memcg_vmstats_percpu;

struct mem_cgroup_per_node;

struct mem_cgroup {
	struct cgroup_subsys_state css;
	struct mem_cgroup_id id;
	int: 32;
	int: 32;
	struct page_counter memory;
	union {
		struct page_counter swap;
		struct page_counter memsw;
	};
	struct page_counter kmem;
	struct page_counter tcpmem;
	struct work_struct high_work;
	long unsigned int soft_limit;
	struct vmpressure vmpressure;
	bool oom_group;
	bool oom_lock;
	int under_oom;
	int swappiness;
	int oom_kill_disable;
	struct cgroup_file events_file;
	struct cgroup_file events_local_file;
	struct cgroup_file swap_events_file;
	struct mutex thresholds_lock;
	struct mem_cgroup_thresholds thresholds;
	struct mem_cgroup_thresholds memsw_thresholds;
	struct list_head oom_notify;
	long unsigned int move_charge_at_immigrate;
	spinlock_t move_lock;
	long unsigned int move_lock_flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct cacheline_padding _pad1_;
	struct memcg_vmstats *vmstats;
	atomic_long_t memory_events[9];
	atomic_long_t memory_events_local[9];
	long unsigned int socket_pressure;
	bool tcpmem_active;
	int tcpmem_pressure;
	int kmemcg_id;
	struct obj_cgroup *objcg;
	struct list_head objcg_list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct cacheline_padding _pad2_;
	atomic_t moving_account;
	struct task_struct *move_lock_task;
	struct memcg_vmstats_percpu *vmstats_percpu;
	struct list_head event_list;
	spinlock_t event_list_lock;
	struct mem_cgroup_per_node *nodeinfo[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct vm_struct {
	struct vm_struct *next;
	void *addr;
	long unsigned int size;
	long unsigned int flags;
	struct page **pages;
	unsigned int nr_pages;
	phys_addr_t phys_addr;
	const void *caller;
};

struct list_lru_node;

struct list_lru {
	struct list_lru_node *node;
	struct list_head list;
	int shrinker_id;
	bool memcg_aware;
	struct xarray xa;
};

struct kernfs_root;

struct kernfs_elem_dir {
	long unsigned int subdirs;
	struct rb_root children;
	struct kernfs_root *root;
	long unsigned int rev;
};

struct kernfs_elem_symlink {
	struct kernfs_node *target_kn;
};

struct kernfs_ops;

struct kernfs_open_node;

struct kernfs_elem_attr {
	const struct kernfs_ops *ops;
	struct kernfs_open_node *open;
	loff_t size;
	struct kernfs_node *notify_next;
	int: 32;
};

struct kernfs_iattrs;

struct kernfs_node {
	atomic_t count;
	atomic_t active;
	struct kernfs_node *parent;
	const char *name;
	struct rb_node rb;
	const void *ns;
	unsigned int hash;
	int: 32;
	union {
		struct kernfs_elem_dir dir;
		struct kernfs_elem_symlink symlink;
		struct kernfs_elem_attr attr;
	};
	void *priv;
	int: 32;
	u64 id;
	short unsigned int flags;
	umode_t mode;
	struct kernfs_iattrs *iattr;
};

struct kernfs_open_file;

struct kernfs_ops {
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	ssize_t (*read)(struct kernfs_open_file *, char *, size_t, loff_t);
	size_t atomic_write_len;
	bool prealloc;
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
	int (*mmap)(struct kernfs_open_file *, struct vm_area_struct *);
};

struct seq_operations;

struct seq_file {
	char *buf;
	size_t size;
	size_t from;
	size_t count;
	size_t pad_until;
	int: 32;
	loff_t index;
	loff_t read_pos;
	struct mutex lock;
	const struct seq_operations *op;
	int poll_event;
	const struct file *file;
	void *private;
	int: 32;
};

struct kernfs_open_file {
	struct kernfs_node *kn;
	struct file *file;
	struct seq_file *seq_file;
	void *priv;
	struct mutex mutex;
	struct mutex prealloc_mutex;
	int event;
	struct list_head list;
	char *prealloc_buf;
	size_t atomic_write_len;
	bool mmapped: 1;
	bool released: 1;
	const struct vm_operations_struct *vm_ops;
};

typedef void (*poll_queue_proc)(struct file *, wait_queue_head_t *, struct poll_table_struct *);

struct poll_table_struct {
	poll_queue_proc _qproc;
	__poll_t _key;
};

enum kobj_ns_type {
	KOBJ_NS_TYPE_NONE = 0,
	KOBJ_NS_TYPE_NET = 1,
	KOBJ_NS_TYPES = 2,
};

struct sock;

struct kobj_ns_type_operations {
	enum kobj_ns_type type;
	bool (*current_may_mount)();
	void * (*grab_current_ns)();
	const void * (*netlink_ns)(struct sock *);
	const void * (*initial_ns)();
	void (*drop_ns)(void *);
};

struct attribute {
	const char *name;
	umode_t mode;
};

struct kobject;

struct bin_attribute;

struct attribute_group {
	const char *name;
	umode_t (*is_visible)(struct kobject *, struct attribute *, int);
	umode_t (*is_bin_visible)(struct kobject *, struct bin_attribute *, int);
	struct attribute **attrs;
	struct bin_attribute **bin_attrs;
};

struct kset;

struct kobj_type;

struct kobject {
	const char *name;
	struct list_head entry;
	struct kobject *parent;
	struct kset *kset;
	const struct kobj_type *ktype;
	struct kernfs_node *sd;
	struct kref kref;
	unsigned int state_initialized: 1;
	unsigned int state_in_sysfs: 1;
	unsigned int state_add_uevent_sent: 1;
	unsigned int state_remove_uevent_sent: 1;
	unsigned int uevent_suppress: 1;
};

struct bin_attribute {
	struct attribute attr;
	size_t size;
	void *private;
	struct address_space * (*f_mapping)();
	ssize_t (*read)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	ssize_t (*write)(struct file *, struct kobject *, struct bin_attribute *, char *, loff_t, size_t);
	int (*mmap)(struct file *, struct kobject *, struct bin_attribute *, struct vm_area_struct *);
};

struct sysfs_ops {
	ssize_t (*show)(struct kobject *, struct attribute *, char *);
	ssize_t (*store)(struct kobject *, struct attribute *, const char *, size_t);
};

struct kset_uevent_ops;

struct kset {
	struct list_head list;
	spinlock_t list_lock;
	struct kobject kobj;
	const struct kset_uevent_ops *uevent_ops;
};

struct kobj_type {
	void (*release)(struct kobject *);
	const struct sysfs_ops *sysfs_ops;
	const struct attribute_group **default_groups;
	const struct kobj_ns_type_operations * (*child_ns_type)(struct kobject *);
	const void * (*namespace)(struct kobject *);
	void (*get_ownership)(struct kobject *, kuid_t *, kgid_t *);
};

struct kobj_uevent_env {
	char *argv[3];
	char *envp[64];
	int envp_idx;
	char buf[2048];
	int buflen;
};

struct kset_uevent_ops {
	int (* const filter)(struct kobject *);
	const char * (* const name)(struct kobject *);
	int (* const uevent)(struct kobject *, struct kobj_uevent_env *);
};

struct kernel_param;

struct kernel_param_ops {
	unsigned int flags;
	int (*set)(const char *, const struct kernel_param *);
	int (*get)(char *, const struct kernel_param *);
	void (*free)(void *);
};

struct kparam_string;

struct kparam_array;

struct kernel_param {
	const char *name;
	struct module *mod;
	const struct kernel_param_ops *ops;
	const u16 perm;
	s8 level;
	u8 flags;
	union {
		void *arg;
		const struct kparam_string *str;
		const struct kparam_array *arr;
	};
};

struct kparam_string {
	unsigned int maxlen;
	char *string;
};

struct kparam_array {
	unsigned int max;
	unsigned int elemsize;
	unsigned int *num;
	const struct kernel_param_ops *ops;
	void *elem;
};

enum module_state {
	MODULE_STATE_LIVE = 0,
	MODULE_STATE_COMING = 1,
	MODULE_STATE_GOING = 2,
	MODULE_STATE_UNFORMED = 3,
};

struct module_param_attrs;

struct module_kobject {
	struct kobject kobj;
	struct module *mod;
	struct kobject *drivers_dir;
	struct module_param_attrs *mp;
	struct completion *kobj_completion;
};

struct latch_tree_node {
	struct rb_node node[2];
};

struct mod_tree_node {
	struct module *mod;
	struct latch_tree_node node;
};

struct module_layout {
	void *base;
	unsigned int size;
	unsigned int text_size;
	unsigned int ro_size;
	unsigned int ro_after_init_size;
	struct mod_tree_node mtn;
};

struct plt_entries;

struct mod_plt_sec {
	struct elf32_shdr *plt;
	struct plt_entries *plt_ent;
	int plt_count;
};

struct unwind_table;

struct mod_arch_specific {
	struct list_head unwind_list;
	struct unwind_table *init_table;
	struct mod_plt_sec core;
	struct mod_plt_sec init;
};

struct mod_kallsyms {
	Elf32_Sym *symtab;
	unsigned int num_symtab;
	char *strtab;
	char *typetab;
};

struct module_attribute;

struct exception_table_entry;

struct module_sect_attrs;

struct module_notes_attrs;

struct tracepoint;

typedef struct tracepoint * const tracepoint_ptr_t;

struct bpf_raw_event_map;

struct trace_eval_map;

struct module {
	enum module_state state;
	struct list_head list;
	char name[60];
	struct module_kobject mkobj;
	struct module_attribute *modinfo_attrs;
	const char *version;
	const char *srcversion;
	struct kobject *holders_dir;
	const struct kernel_symbol *syms;
	const s32 *crcs;
	unsigned int num_syms;
	struct mutex param_lock;
	struct kernel_param *kp;
	unsigned int num_kp;
	unsigned int num_gpl_syms;
	const struct kernel_symbol *gpl_syms;
	const s32 *gpl_crcs;
	bool using_gplonly_symbols;
	bool async_probe_requested;
	unsigned int num_exentries;
	struct exception_table_entry *extable;
	int (*init)();
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct module_layout core_layout;
	struct module_layout init_layout;
	struct mod_arch_specific arch;
	long unsigned int taints;
	unsigned int num_bugs;
	struct list_head bug_list;
	struct bug_entry *bug_table;
	struct mod_kallsyms *kallsyms;
	struct mod_kallsyms core_kallsyms;
	struct module_sect_attrs *sect_attrs;
	struct module_notes_attrs *notes_attrs;
	char *args;
	void *percpu;
	unsigned int percpu_size;
	void *noinstr_text_start;
	unsigned int noinstr_text_size;
	unsigned int num_tracepoints;
	tracepoint_ptr_t *tracepoints_ptrs;
	unsigned int num_srcu_structs;
	struct srcu_struct **srcu_struct_ptrs;
	unsigned int num_bpf_raw_events;
	struct bpf_raw_event_map *bpf_raw_events;
	unsigned int btf_data_size;
	void *btf_data;
	unsigned int num_trace_bprintk_fmt;
	const char **trace_bprintk_fmt_start;
	struct trace_event_call **trace_events;
	unsigned int num_trace_events;
	struct trace_eval_map **trace_evals;
	unsigned int num_trace_evals;
	void *kprobes_text_start;
	unsigned int kprobes_text_size;
	long unsigned int *kprobe_blacklist;
	unsigned int num_kprobe_blacklist;
	struct list_head source_list;
	struct list_head target_list;
	void (*exit)();
	atomic_t refcnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct tracepoint_func {
	void *func;
	void *data;
	int prio;
};

struct tracepoint {
	const char *name;
	struct static_key key;
	struct static_call_key *static_call_key;
	void *static_call_tramp;
	void *iterator;
	int (*regfunc)();
	void (*unregfunc)();
	struct tracepoint_func *funcs;
};

struct bpf_raw_event_map {
	struct tracepoint *tp;
	void *bpf_func;
	u32 num_args;
	u32 writable_size;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct unwind_idx {
	long unsigned int addr_offset;
	long unsigned int insn;
};

struct unwind_table {
	struct list_head list;
	struct list_head mod_list;
	const struct unwind_idx *start;
	const struct unwind_idx *origin;
	const struct unwind_idx *stop;
	long unsigned int begin_addr;
	long unsigned int end_addr;
};

struct plt_entries {
	u32 ldr[16];
	u32 lit[16];
};

struct module_attribute {
	struct attribute attr;
	ssize_t (*show)(struct module_attribute *, struct module_kobject *, char *);
	ssize_t (*store)(struct module_attribute *, struct module_kobject *, const char *, size_t);
	void (*setup)(struct module *, const char *);
	int (*test)(struct module *);
	void (*free)(struct module *);
};

struct exception_table_entry {
	long unsigned int insn;
	long unsigned int fixup;
};

struct trace_event_functions;

struct trace_event {
	struct hlist_node node;
	struct list_head list;
	int type;
	struct trace_event_functions *funcs;
};

struct trace_event_class;

struct bpf_prog_array;

struct trace_event_call {
	struct list_head list;
	struct trace_event_class *class;
	union {
		char *name;
		struct tracepoint *tp;
	};
	struct trace_event event;
	char *print_fmt;
	struct event_filter *filter;
	union {
		void *module;
		atomic_t refcnt;
	};
	void *data;
	int flags;
	int perf_refcount;
	struct hlist_head *perf_events;
	struct bpf_prog_array *prog_array;
	int (*perf_perm)(struct trace_event_call *, struct perf_event *);
};

struct trace_eval_map {
	const char *system;
	const char *eval_string;
	long unsigned int eval_value;
};

struct hlist_bl_node;

struct hlist_bl_head {
	struct hlist_bl_node *first;
};

struct hlist_bl_node {
	struct hlist_bl_node *next;
	struct hlist_bl_node **pprev;
};

struct lockref {
	union {
		__u64 lock_count;
		struct {
			spinlock_t lock;
			int count;
		};
	};
};

struct qstr {
	union {
		struct {
			u32 hash;
			u32 len;
		};
		u64 hash_len;
	};
	const unsigned char *name;
	int: 32;
};

struct dentry_operations;

struct dentry {
	unsigned int d_flags;
	seqcount_spinlock_t d_seq;
	struct hlist_bl_node d_hash;
	struct dentry *d_parent;
	int: 32;
	struct qstr d_name;
	struct inode *d_inode;
	unsigned char d_iname[36];
	struct lockref d_lockref;
	const struct dentry_operations *d_op;
	struct super_block *d_sb;
	long unsigned int d_time;
	void *d_fsdata;
	union {
		struct list_head d_lru;
		wait_queue_head_t *d_wait;
	};
	struct list_head d_child;
	struct list_head d_subdirs;
	union {
		struct hlist_node d_alias;
		struct hlist_bl_node d_in_lookup_hash;
		struct callback_head d_rcu;
	} d_u;
};

struct posix_acl;

struct inode_operations;

struct file_lock_context;

struct cdev;

struct fsnotify_mark_connector;

struct inode {
	umode_t i_mode;
	short unsigned int i_opflags;
	kuid_t i_uid;
	kgid_t i_gid;
	unsigned int i_flags;
	struct posix_acl *i_acl;
	struct posix_acl *i_default_acl;
	const struct inode_operations *i_op;
	struct super_block *i_sb;
	struct address_space *i_mapping;
	long unsigned int i_ino;
	union {
		const unsigned int i_nlink;
		unsigned int __i_nlink;
	};
	dev_t i_rdev;
	loff_t i_size;
	struct timespec64 i_atime;
	struct timespec64 i_mtime;
	struct timespec64 i_ctime;
	spinlock_t i_lock;
	short unsigned int i_bytes;
	u8 i_blkbits;
	u8 i_write_hint;
	blkcnt_t i_blocks;
	seqcount_t i_size_seqcount;
	long unsigned int i_state;
	struct rw_semaphore i_rwsem;
	long unsigned int dirtied_when;
	long unsigned int dirtied_time_when;
	struct hlist_node i_hash;
	struct list_head i_io_list;
	struct list_head i_lru;
	struct list_head i_sb_list;
	struct list_head i_wb_list;
	union {
		struct hlist_head i_dentry;
		struct callback_head i_rcu;
	};
	atomic64_t i_version;
	atomic64_t i_sequence;
	atomic_t i_count;
	atomic_t i_dio_count;
	atomic_t i_writecount;
	atomic_t i_readcount;
	union {
		const struct file_operations *i_fop;
		void (*free_inode)(struct inode *);
	};
	struct file_lock_context *i_flctx;
	struct address_space i_data;
	struct list_head i_devices;
	union {
		struct pipe_inode_info *i_pipe;
		struct cdev *i_cdev;
		char *i_link;
		unsigned int i_dir_seq;
	};
	__u32 i_generation;
	__u32 i_fsnotify_mask;
	struct fsnotify_mark_connector *i_fsnotify_marks;
	void *i_private;
};

struct dentry_operations {
	int (*d_revalidate)(struct dentry *, unsigned int);
	int (*d_weak_revalidate)(struct dentry *, unsigned int);
	int (*d_hash)(const struct dentry *, struct qstr *);
	int (*d_compare)(const struct dentry *, unsigned int, const char *, const struct qstr *);
	int (*d_delete)(const struct dentry *);
	int (*d_init)(struct dentry *);
	void (*d_release)(struct dentry *);
	void (*d_prune)(struct dentry *);
	void (*d_iput)(struct dentry *, struct inode *);
	char * (*d_dname)(struct dentry *, char *, int);
	struct vfsmount * (*d_automount)(struct path *);
	int (*d_manage)(const struct path *, bool);
	struct dentry * (*d_real)(struct dentry *, const struct inode *);
	int: 32;
	int: 32;
	int: 32;
};

typedef long long int qsize_t;

struct quota_format_type;

struct mem_dqinfo {
	struct quota_format_type *dqi_format;
	int dqi_fmt_id;
	struct list_head dqi_dirty_list;
	long unsigned int dqi_flags;
	unsigned int dqi_bgrace;
	unsigned int dqi_igrace;
	int: 32;
	qsize_t dqi_max_spc_limit;
	qsize_t dqi_max_ino_limit;
	void *dqi_priv;
	int: 32;
};

struct quota_format_ops;

struct quota_info {
	unsigned int flags;
	struct rw_semaphore dqio_sem;
	struct inode *files[3];
	struct mem_dqinfo info[3];
	const struct quota_format_ops *ops[3];
	int: 32;
};

struct rcu_sync {
	int gp_state;
	int gp_count;
	wait_queue_head_t gp_wait;
	struct callback_head cb_head;
};

struct percpu_rw_semaphore {
	struct rcu_sync rss;
	unsigned int *read_count;
	struct rcuwait writer;
	wait_queue_head_t waiters;
	atomic_t block;
};

struct sb_writers {
	int frozen;
	wait_queue_head_t wait_unfrozen;
	struct percpu_rw_semaphore rw_sem[3];
};

typedef struct {
	__u8 b[16];
} uuid_t;

struct shrink_control;

struct shrinker {
	long unsigned int (*count_objects)(struct shrinker *, struct shrink_control *);
	long unsigned int (*scan_objects)(struct shrinker *, struct shrink_control *);
	long int batch;
	int seeks;
	unsigned int flags;
	struct list_head list;
	int id;
	atomic_long_t *nr_deferred;
};

struct super_operations;

struct dquot_operations;

struct quotactl_ops;

struct export_operations;

struct xattr_handler;

struct block_device;

struct mtd_info;

struct super_block {
	struct list_head s_list;
	dev_t s_dev;
	unsigned char s_blocksize_bits;
	long unsigned int s_blocksize;
	int: 32;
	loff_t s_maxbytes;
	struct file_system_type *s_type;
	const struct super_operations *s_op;
	const struct dquot_operations *dq_op;
	const struct quotactl_ops *s_qcop;
	const struct export_operations *s_export_op;
	long unsigned int s_flags;
	long unsigned int s_iflags;
	long unsigned int s_magic;
	struct dentry *s_root;
	struct rw_semaphore s_umount;
	int s_count;
	atomic_t s_active;
	const struct xattr_handler **s_xattr;
	struct hlist_bl_head s_roots;
	struct list_head s_mounts;
	struct block_device *s_bdev;
	struct backing_dev_info *s_bdi;
	struct mtd_info *s_mtd;
	struct hlist_node s_instances;
	unsigned int s_quota_types;
	int: 32;
	struct quota_info s_dquot;
	struct sb_writers s_writers;
	void *s_fs_info;
	u32 s_time_gran;
	int: 32;
	time64_t s_time_min;
	time64_t s_time_max;
	__u32 s_fsnotify_mask;
	struct fsnotify_mark_connector *s_fsnotify_marks;
	char s_id[32];
	uuid_t s_uuid;
	unsigned int s_max_links;
	fmode_t s_mode;
	struct mutex s_vfs_rename_mutex;
	const char *s_subtype;
	const struct dentry_operations *s_d_op;
	struct shrinker s_shrink;
	atomic_long_t s_remove_count;
	atomic_long_t s_fsnotify_connectors;
	int s_readonly_remount;
	errseq_t s_wb_err;
	struct workqueue_struct *s_dio_done_wq;
	struct hlist_head s_pins;
	struct user_namespace *s_user_ns;
	struct list_lru s_dentry_lru;
	struct list_lru s_inode_lru;
	struct callback_head rcu;
	struct work_struct destroy_work;
	struct mutex s_sync_lock;
	int s_stack_depth;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t s_inode_list_lock;
	struct list_head s_inodes;
	spinlock_t s_inode_wblist_lock;
	struct list_head s_inodes_wb;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct vfsmount {
	struct dentry *mnt_root;
	struct super_block *mnt_sb;
	int mnt_flags;
	struct user_namespace *mnt_userns;
};

struct shrink_control {
	gfp_t gfp_mask;
	int nid;
	long unsigned int nr_to_scan;
	long unsigned int nr_scanned;
	struct mem_cgroup *memcg;
};

struct list_lru_one {
	struct list_head list;
	long int nr_items;
};

struct list_lru_node {
	spinlock_t lock;
	struct list_lru_one lru;
	long int nr_items;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum migrate_mode {
	MIGRATE_ASYNC = 0,
	MIGRATE_SYNC_LIGHT = 1,
	MIGRATE_SYNC = 2,
	MIGRATE_SYNC_NO_COPY = 3,
};

struct cgroup_base_stat {
	struct task_cputime cputime;
};

struct cgroup_bpf {
	struct bpf_prog_array *effective[23];
	struct hlist_head progs[23];
	u8 flags[23];
	struct list_head storages;
	struct bpf_prog_array *inactive;
	struct percpu_ref refcnt;
	struct work_struct release_work;
};

struct cgroup_freezer_state {
	bool freeze;
	int e_freeze;
	int nr_frozen_descendants;
	int nr_frozen_tasks;
};

struct cgroup_root;

struct cgroup_rstat_cpu;

struct psi_group;

struct cgroup {
	struct cgroup_subsys_state self;
	long unsigned int flags;
	int level;
	int max_depth;
	int nr_descendants;
	int nr_dying_descendants;
	int max_descendants;
	int nr_populated_csets;
	int nr_populated_domain_children;
	int nr_populated_threaded_children;
	int nr_threaded_children;
	struct kernfs_node *kn;
	struct cgroup_file procs_file;
	struct cgroup_file events_file;
	struct cgroup_file psi_files[0];
	u16 subtree_control;
	u16 subtree_ss_mask;
	u16 old_subtree_control;
	u16 old_subtree_ss_mask;
	struct cgroup_subsys_state *subsys[5];
	struct cgroup_root *root;
	struct list_head cset_links;
	struct list_head e_csets[5];
	struct cgroup *dom_cgrp;
	struct cgroup *old_dom_cgrp;
	struct cgroup_rstat_cpu *rstat_cpu;
	struct list_head rstat_css_list;
	struct cgroup_base_stat last_bstat;
	struct cgroup_base_stat bstat;
	struct prev_cputime prev_cputime;
	struct list_head pidlists;
	struct mutex pidlist_mutex;
	wait_queue_head_t offline_waitq;
	struct work_struct release_agent_work;
	struct psi_group *psi;
	struct cgroup_bpf bpf;
	atomic_t congestion_count;
	struct cgroup_freezer_state freezer;
	struct cgroup *ancestors[0];
	int: 32;
};

struct key_tag {
	struct callback_head rcu;
	refcount_t usage;
	bool removed;
};

typedef int (*request_key_actor_t)(struct key *, void *);

struct key_preparsed_payload;

struct key_match_data;

struct kernel_pkey_params;

struct kernel_pkey_query;

struct key_type {
	const char *name;
	size_t def_datalen;
	unsigned int flags;
	int (*vet_description)(const char *);
	int (*preparse)(struct key_preparsed_payload *);
	void (*free_preparse)(struct key_preparsed_payload *);
	int (*instantiate)(struct key *, struct key_preparsed_payload *);
	int (*update)(struct key *, struct key_preparsed_payload *);
	int (*match_preparse)(struct key_match_data *);
	void (*match_free)(struct key_match_data *);
	void (*revoke)(struct key *);
	void (*destroy)(struct key *);
	void (*describe)(const struct key *, struct seq_file *);
	long int (*read)(const struct key *, char *, size_t);
	request_key_actor_t request_key;
	struct key_restriction * (*lookup_restriction)(const char *);
	int (*asym_query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*asym_eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*asym_verify_signature)(struct kernel_pkey_params *, const void *, const void *);
	struct list_head link;
	struct lock_class_key lock_class;
};

typedef int (*key_restrict_link_func_t)(struct key *, const struct key_type *, const union key_payload *, struct key *);

struct key_restriction {
	key_restrict_link_func_t check;
	struct key *key;
	struct key_type *keytype;
};

struct user_struct {
	refcount_t __count;
	int: 32;
	struct percpu_counter epoll_watches;
	long unsigned int unix_inflight;
	atomic_long_t pipe_bufs;
	struct hlist_node uidhash_node;
	kuid_t uid;
	atomic_long_t locked_vm;
	struct ratelimit_state ratelimit;
	int: 32;
};

struct group_info {
	atomic_t usage;
	int ngroups;
	kgid_t gid[0];
};

struct core_thread {
	struct task_struct *task;
	struct core_thread *next;
};

struct core_state {
	atomic_t nr_threads;
	struct core_thread dumper;
	struct completion startup;
};

struct delayed_call {
	void (*fn)(void *);
	void *arg;
};

enum rpm_status {
	RPM_INVALID = 4294967295,
	RPM_ACTIVE = 0,
	RPM_RESUMING = 1,
	RPM_SUSPENDED = 2,
	RPM_SUSPENDING = 3,
};

enum blk_bounce {
	BLK_BOUNCE_NONE = 0,
	BLK_BOUNCE_HIGH = 1,
};

enum blk_zoned_model {
	BLK_ZONED_NONE = 0,
	BLK_ZONED_HA = 1,
	BLK_ZONED_HM = 2,
};

struct queue_limits {
	enum blk_bounce bounce;
	long unsigned int seg_boundary_mask;
	long unsigned int virt_boundary_mask;
	unsigned int max_hw_sectors;
	unsigned int max_dev_sectors;
	unsigned int chunk_sectors;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	unsigned int physical_block_size;
	unsigned int logical_block_size;
	unsigned int alignment_offset;
	unsigned int io_min;
	unsigned int io_opt;
	unsigned int max_discard_sectors;
	unsigned int max_hw_discard_sectors;
	unsigned int max_secure_erase_sectors;
	unsigned int max_write_zeroes_sectors;
	unsigned int max_zone_append_sectors;
	unsigned int discard_granularity;
	unsigned int discard_alignment;
	unsigned int zone_write_granularity;
	short unsigned int max_segments;
	short unsigned int max_integrity_segments;
	short unsigned int max_discard_segments;
	unsigned char misaligned;
	unsigned char discard_misaligned;
	unsigned char raid_partial_stripes_expensive;
	enum blk_zoned_model zoned;
	unsigned int dma_alignment;
};

struct elevator_queue;

struct blk_queue_stats;

struct rq_qos;

struct blk_mq_ops;

struct blk_mq_ctx;

struct gendisk;

struct blk_stat_callback;

struct blk_rq_stat;

struct blk_mq_tags;

struct blk_flush_queue;

struct blk_mq_tag_set;

struct request_queue {
	struct request *last_merge;
	struct elevator_queue *elevator;
	struct percpu_ref q_usage_counter;
	struct blk_queue_stats *stats;
	struct rq_qos *rq_qos;
	const struct blk_mq_ops *mq_ops;
	struct blk_mq_ctx *queue_ctx;
	unsigned int queue_depth;
	struct xarray hctx_table;
	unsigned int nr_hw_queues;
	void *queuedata;
	long unsigned int queue_flags;
	atomic_t pm_only;
	int id;
	spinlock_t queue_lock;
	struct gendisk *disk;
	struct kobject kobj;
	struct kobject *mq_kobj;
	struct device *dev;
	enum rpm_status rpm_status;
	long unsigned int nr_requests;
	unsigned int dma_pad_mask;
	unsigned int rq_timeout;
	int poll_nsec;
	struct blk_stat_callback *poll_cb;
	struct blk_rq_stat *poll_stat;
	struct timer_list timeout;
	struct work_struct timeout_work;
	atomic_t nr_active_requests_shared_tags;
	struct blk_mq_tags *sched_shared_tags;
	struct list_head icq_list;
	struct queue_limits limits;
	unsigned int required_elevator_features;
	int node;
	struct blk_flush_queue *fq;
	struct list_head requeue_list;
	spinlock_t requeue_lock;
	struct delayed_work requeue_work;
	struct mutex sysfs_lock;
	struct mutex sysfs_dir_lock;
	struct list_head unused_hctx_list;
	spinlock_t unused_hctx_lock;
	int mq_freeze_depth;
	struct callback_head callback_head;
	wait_queue_head_t mq_freeze_wq;
	struct mutex mq_freeze_lock;
	int quiesce_depth;
	struct blk_mq_tag_set *tag_set;
	struct list_head tag_set_list;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct dentry *rqos_debugfs_dir;
	struct mutex debugfs_mutex;
	bool mq_sysfs_init_done;
	struct srcu_struct srcu[0];
};

typedef struct {
	uid_t val;
} vfsuid_t;

typedef struct {
	gid_t val;
} vfsgid_t;

typedef void percpu_ref_func_t(struct percpu_ref *);

struct percpu_ref_data {
	atomic_long_t count;
	percpu_ref_func_t *release;
	percpu_ref_func_t *confirm_switch;
	bool force_atomic: 1;
	bool allow_reinit: 1;
	struct callback_head rcu;
	struct percpu_ref *ref;
};

enum kmalloc_cache_type {
	KMALLOC_NORMAL = 0,
	KMALLOC_DMA = 0,
	KMALLOC_CGROUP = 1,
	KMALLOC_RECLAIM = 2,
	NR_KMALLOC_TYPES = 3,
};

struct wait_page_queue;

struct kiocb {
	struct file *ki_filp;
	int: 32;
	loff_t ki_pos;
	void (*ki_complete)(struct kiocb *, long int);
	void *private;
	int ki_flags;
	u16 ki_ioprio;
	struct wait_page_queue *ki_waitq;
	int: 32;
};

struct iattr {
	unsigned int ia_valid;
	umode_t ia_mode;
	union {
		kuid_t ia_uid;
		vfsuid_t ia_vfsuid;
	};
	union {
		kgid_t ia_gid;
		vfsgid_t ia_vfsgid;
	};
	loff_t ia_size;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct file *ia_file;
	int: 32;
};

typedef __kernel_uid32_t projid_t;

typedef struct {
	projid_t val;
} kprojid_t;

enum quota_type {
	USRQUOTA = 0,
	GRPQUOTA = 1,
	PRJQUOTA = 2,
};

struct kqid {
	union {
		kuid_t uid;
		kgid_t gid;
		kprojid_t projid;
	};
	enum quota_type type;
};

struct mem_dqblk {
	qsize_t dqb_bhardlimit;
	qsize_t dqb_bsoftlimit;
	qsize_t dqb_curspace;
	qsize_t dqb_rsvspace;
	qsize_t dqb_ihardlimit;
	qsize_t dqb_isoftlimit;
	qsize_t dqb_curinodes;
	time64_t dqb_btime;
	time64_t dqb_itime;
};

struct dquot {
	struct hlist_node dq_hash;
	struct list_head dq_inuse;
	struct list_head dq_free;
	struct list_head dq_dirty;
	struct mutex dq_lock;
	spinlock_t dq_dqb_lock;
	atomic_t dq_count;
	struct super_block *dq_sb;
	struct kqid dq_id;
	loff_t dq_off;
	long unsigned int dq_flags;
	int: 32;
	struct mem_dqblk dq_dqb;
};

struct quota_format_type {
	int qf_fmt_id;
	const struct quota_format_ops *qf_ops;
	struct module *qf_owner;
	struct quota_format_type *qf_next;
};

struct quota_format_ops {
	int (*check_quota_file)(struct super_block *, int);
	int (*read_file_info)(struct super_block *, int);
	int (*write_file_info)(struct super_block *, int);
	int (*free_file_info)(struct super_block *, int);
	int (*read_dqblk)(struct dquot *);
	int (*commit_dqblk)(struct dquot *);
	int (*release_dqblk)(struct dquot *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct dquot_operations {
	int (*write_dquot)(struct dquot *);
	struct dquot * (*alloc_dquot)(struct super_block *, int);
	void (*destroy_dquot)(struct dquot *);
	int (*acquire_dquot)(struct dquot *);
	int (*release_dquot)(struct dquot *);
	int (*mark_dirty)(struct dquot *);
	int (*write_info)(struct super_block *, int);
	qsize_t * (*get_reserved_space)(struct inode *);
	int (*get_projid)(struct inode *, kprojid_t *);
	int (*get_inode_usage)(struct inode *, qsize_t *);
	int (*get_next_id)(struct super_block *, struct kqid *);
};

struct qc_dqblk {
	int d_fieldmask;
	int: 32;
	u64 d_spc_hardlimit;
	u64 d_spc_softlimit;
	u64 d_ino_hardlimit;
	u64 d_ino_softlimit;
	u64 d_space;
	u64 d_ino_count;
	s64 d_ino_timer;
	s64 d_spc_timer;
	int d_ino_warns;
	int d_spc_warns;
	u64 d_rt_spc_hardlimit;
	u64 d_rt_spc_softlimit;
	u64 d_rt_space;
	s64 d_rt_spc_timer;
	int d_rt_spc_warns;
	int: 32;
};

struct qc_type_state {
	unsigned int flags;
	unsigned int spc_timelimit;
	unsigned int ino_timelimit;
	unsigned int rt_spc_timelimit;
	unsigned int spc_warnlimit;
	unsigned int ino_warnlimit;
	unsigned int rt_spc_warnlimit;
	int: 32;
	long long unsigned int ino;
	blkcnt_t blocks;
	blkcnt_t nextents;
};

struct qc_state {
	unsigned int s_incoredqs;
	int: 32;
	struct qc_type_state s_state[3];
};

struct qc_info {
	int i_fieldmask;
	unsigned int i_flags;
	unsigned int i_spc_timelimit;
	unsigned int i_ino_timelimit;
	unsigned int i_rt_spc_timelimit;
	unsigned int i_spc_warnlimit;
	unsigned int i_ino_warnlimit;
	unsigned int i_rt_spc_warnlimit;
};

struct quotactl_ops {
	int (*quota_on)(struct super_block *, int, int, const struct path *);
	int (*quota_off)(struct super_block *, int);
	int (*quota_enable)(struct super_block *, unsigned int);
	int (*quota_disable)(struct super_block *, unsigned int);
	int (*quota_sync)(struct super_block *, int);
	int (*set_info)(struct super_block *, int, struct qc_info *);
	int (*get_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_nextdqblk)(struct super_block *, struct kqid *, struct qc_dqblk *);
	int (*set_dqblk)(struct super_block *, struct kqid, struct qc_dqblk *);
	int (*get_state)(struct super_block *, struct qc_state *);
	int (*rm_xquota)(struct super_block *, unsigned int);
};

struct wait_page_queue {
	struct folio *folio;
	int bit_nr;
	wait_queue_entry_t wait;
};

struct writeback_control;

struct readahead_control;

struct swap_info_struct;

struct address_space_operations {
	int (*writepage)(struct page *, struct writeback_control *);
	int (*read_folio)(struct file *, struct folio *);
	int (*writepages)(struct address_space *, struct writeback_control *);
	bool (*dirty_folio)(struct address_space *, struct folio *);
	void (*readahead)(struct readahead_control *);
	int (*write_begin)(struct file *, struct address_space *, loff_t, unsigned int, struct page **, void **);
	int (*write_end)(struct file *, struct address_space *, loff_t, unsigned int, unsigned int, struct page *, void *);
	sector_t (*bmap)(struct address_space *, sector_t);
	void (*invalidate_folio)(struct folio *, size_t, size_t);
	bool (*release_folio)(struct folio *, gfp_t);
	void (*free_folio)(struct folio *);
	ssize_t (*direct_IO)(struct kiocb *, struct iov_iter *);
	int (*migrate_folio)(struct address_space *, struct folio *, struct folio *, enum migrate_mode);
	int (*launder_folio)(struct folio *);
	bool (*is_partially_uptodate)(struct folio *, size_t, size_t);
	void (*is_dirty_writeback)(struct folio *, bool *, bool *);
	int (*error_remove_page)(struct address_space *, struct page *);
	int (*swap_activate)(struct swap_info_struct *, struct file *, sector_t *);
	void (*swap_deactivate)(struct file *);
	int (*swap_rw)(struct kiocb *, struct iov_iter *);
};

enum writeback_sync_modes {
	WB_SYNC_NONE = 0,
	WB_SYNC_ALL = 1,
};

struct swap_iocb;

struct writeback_control {
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	enum writeback_sync_modes sync_mode;
	unsigned int for_kupdate: 1;
	unsigned int for_background: 1;
	unsigned int tagged_writepages: 1;
	unsigned int for_reclaim: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_sync: 1;
	unsigned int unpinned_fscache_wb: 1;
	unsigned int no_cgroup_owner: 1;
	unsigned int punt_to_cgroup: 1;
	struct swap_iocb **swap_plug;
	int: 32;
};

struct readahead_control {
	struct file *file;
	struct address_space *mapping;
	struct file_ra_state *ra;
	long unsigned int _index;
	unsigned int _nr_pages;
	unsigned int _batch_count;
	bool _workingset;
	long unsigned int _pflags;
};

struct iovec;

struct kvec;

struct bio_vec;

struct iov_iter {
	u8 iter_type;
	bool nofault;
	bool data_source;
	bool user_backed;
	union {
		size_t iov_offset;
		int last_offset;
	};
	size_t count;
	union {
		const struct iovec *iov;
		const struct kvec *kvec;
		const struct bio_vec *bvec;
		struct xarray *xarray;
		struct pipe_inode_info *pipe;
		void *ubuf;
	};
	union {
		long unsigned int nr_segs;
		struct {
			unsigned int head;
			unsigned int start_head;
		};
		loff_t xarray_start;
	};
};

struct swap_cluster_info {
	spinlock_t lock;
	unsigned int data: 24;
	unsigned int flags: 8;
};

struct swap_cluster_list {
	struct swap_cluster_info head;
	struct swap_cluster_info tail;
};

struct percpu_cluster;

struct swap_info_struct {
	struct percpu_ref users;
	long unsigned int flags;
	short int prio;
	struct plist_node list;
	signed char type;
	unsigned int max;
	unsigned char *swap_map;
	struct swap_cluster_info *cluster_info;
	struct swap_cluster_list free_clusters;
	unsigned int lowest_bit;
	unsigned int highest_bit;
	unsigned int pages;
	unsigned int inuse_pages;
	unsigned int cluster_next;
	unsigned int cluster_nr;
	unsigned int *cluster_next_cpu;
	struct percpu_cluster *percpu_cluster;
	struct rb_root swap_extent_root;
	struct block_device *bdev;
	struct file *swap_file;
	unsigned int old_block_size;
	struct completion comp;
	spinlock_t lock;
	spinlock_t cont_lock;
	struct work_struct discard_work;
	struct swap_cluster_list discard_clusters;
	struct plist_node avail_lists[0];
};

struct cdev {
	struct kobject kobj;
	struct module *owner;
	const struct file_operations *ops;
	struct list_head list;
	dev_t dev;
	unsigned int count;
};

struct fiemap_extent_info;

struct fileattr;

struct inode_operations {
	struct dentry * (*lookup)(struct inode *, struct dentry *, unsigned int);
	const char * (*get_link)(struct dentry *, struct inode *, struct delayed_call *);
	int (*permission)(struct user_namespace *, struct inode *, int);
	struct posix_acl * (*get_acl)(struct inode *, int, bool);
	int (*readlink)(struct dentry *, char *, int);
	int (*create)(struct user_namespace *, struct inode *, struct dentry *, umode_t, bool);
	int (*link)(struct dentry *, struct inode *, struct dentry *);
	int (*unlink)(struct inode *, struct dentry *);
	int (*symlink)(struct user_namespace *, struct inode *, struct dentry *, const char *);
	int (*mkdir)(struct user_namespace *, struct inode *, struct dentry *, umode_t);
	int (*rmdir)(struct inode *, struct dentry *);
	int (*mknod)(struct user_namespace *, struct inode *, struct dentry *, umode_t, dev_t);
	int (*rename)(struct user_namespace *, struct inode *, struct dentry *, struct inode *, struct dentry *, unsigned int);
	int (*setattr)(struct user_namespace *, struct dentry *, struct iattr *);
	int (*getattr)(struct user_namespace *, const struct path *, struct kstat *, u32, unsigned int);
	ssize_t (*listxattr)(struct dentry *, char *, size_t);
	int (*fiemap)(struct inode *, struct fiemap_extent_info *, u64, u64);
	int (*update_time)(struct inode *, struct timespec64 *, int);
	int (*atomic_open)(struct inode *, struct dentry *, struct file *, unsigned int, umode_t);
	int (*tmpfile)(struct user_namespace *, struct inode *, struct file *, umode_t);
	int (*set_acl)(struct user_namespace *, struct inode *, struct posix_acl *, int);
	int (*fileattr_set)(struct user_namespace *, struct dentry *, struct fileattr *);
	int (*fileattr_get)(struct dentry *, struct fileattr *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct file_lock_context {
	spinlock_t flc_lock;
	struct list_head flc_flock;
	struct list_head flc_posix;
	struct list_head flc_lease;
};

struct file_lock_operations {
	void (*fl_copy_lock)(struct file_lock *, struct file_lock *);
	void (*fl_release_private)(struct file_lock *);
};

struct nlm_lockowner;

struct nfs_lock_info {
	u32 state;
	struct nlm_lockowner *owner;
	struct list_head list;
};

struct nfs4_lock_state;

struct nfs4_lock_info {
	struct nfs4_lock_state *owner;
};

struct lock_manager_operations;

struct file_lock {
	struct file_lock *fl_blocker;
	struct list_head fl_list;
	struct hlist_node fl_link;
	struct list_head fl_blocked_requests;
	struct list_head fl_blocked_member;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	unsigned int fl_pid;
	int fl_link_cpu;
	wait_queue_head_t fl_wait;
	struct file *fl_file;
	loff_t fl_start;
	loff_t fl_end;
	struct fasync_struct *fl_fasync;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	const struct file_lock_operations *fl_ops;
	const struct lock_manager_operations *fl_lmops;
	union {
		struct nfs_lock_info nfs_fl;
		struct nfs4_lock_info nfs4_fl;
		struct {
			struct list_head link;
			int state;
			unsigned int debug_id;
		} afs;
	} fl_u;
	int: 32;
};

struct lock_manager_operations {
	void *lm_mod_owner;
	fl_owner_t (*lm_get_owner)(fl_owner_t);
	void (*lm_put_owner)(fl_owner_t);
	void (*lm_notify)(struct file_lock *);
	int (*lm_grant)(struct file_lock *, int);
	bool (*lm_break)(struct file_lock *);
	int (*lm_change)(struct file_lock *, int, struct list_head *);
	void (*lm_setup)(struct file_lock *, void **);
	bool (*lm_breaker_owns_lease)(struct file_lock *);
	bool (*lm_lock_expirable)(struct file_lock *);
	void (*lm_expire_lock)();
};

struct fasync_struct {
	rwlock_t fa_lock;
	int magic;
	int fa_fd;
	struct fasync_struct *fa_next;
	struct file *fa_file;
	struct callback_head fa_rcu;
};

struct kstatfs;

struct super_operations {
	struct inode * (*alloc_inode)(struct super_block *);
	void (*destroy_inode)(struct inode *);
	void (*free_inode)(struct inode *);
	void (*dirty_inode)(struct inode *, int);
	int (*write_inode)(struct inode *, struct writeback_control *);
	int (*drop_inode)(struct inode *);
	void (*evict_inode)(struct inode *);
	void (*put_super)(struct super_block *);
	int (*sync_fs)(struct super_block *, int);
	int (*freeze_super)(struct super_block *);
	int (*freeze_fs)(struct super_block *);
	int (*thaw_super)(struct super_block *);
	int (*unfreeze_fs)(struct super_block *);
	int (*statfs)(struct dentry *, struct kstatfs *);
	int (*remount_fs)(struct super_block *, int *, char *);
	void (*umount_begin)(struct super_block *);
	int (*show_options)(struct seq_file *, struct dentry *);
	int (*show_devname)(struct seq_file *, struct dentry *);
	int (*show_path)(struct seq_file *, struct dentry *);
	int (*show_stats)(struct seq_file *, struct dentry *);
	ssize_t (*quota_read)(struct super_block *, int, char *, size_t, loff_t);
	ssize_t (*quota_write)(struct super_block *, int, const char *, size_t, loff_t);
	struct dquot ** (*get_dquots)(struct inode *);
	long int (*nr_cached_objects)(struct super_block *, struct shrink_control *);
	long int (*free_cached_objects)(struct super_block *, struct shrink_control *);
};

struct iomap;

struct fid;

struct export_operations {
	int (*encode_fh)(struct inode *, __u32 *, int *, struct inode *);
	struct dentry * (*fh_to_dentry)(struct super_block *, struct fid *, int, int);
	struct dentry * (*fh_to_parent)(struct super_block *, struct fid *, int, int);
	int (*get_name)(struct dentry *, char *, struct dentry *);
	struct dentry * (*get_parent)(struct dentry *);
	int (*commit_metadata)(struct inode *);
	int (*get_uuid)(struct super_block *, u8 *, u32 *, u64 *);
	int (*map_blocks)(struct inode *, loff_t, u64, struct iomap *, bool, u32 *);
	int (*commit_blocks)(struct inode *, struct iomap *, int, struct iattr *);
	u64 (*fetch_iversion)(struct inode *);
	long unsigned int flags;
};

struct xattr_handler {
	const char *name;
	const char *prefix;
	int flags;
	bool (*list)(struct dentry *);
	int (*get)(const struct xattr_handler *, struct dentry *, struct inode *, const char *, void *, size_t);
	int (*set)(const struct xattr_handler *, struct user_namespace *, struct dentry *, struct inode *, const char *, const void *, size_t, int);
};

enum dl_dev_state {
	DL_DEV_NO_DRIVER = 0,
	DL_DEV_PROBING = 1,
	DL_DEV_DRIVER_BOUND = 2,
	DL_DEV_UNBINDING = 3,
};

struct dev_links_info {
	struct list_head suppliers;
	struct list_head consumers;
	struct list_head defer_sync;
	enum dl_dev_state status;
};

struct pm_message {
	int event;
};

typedef struct pm_message pm_message_t;

enum rpm_request {
	RPM_REQ_NONE = 0,
	RPM_REQ_IDLE = 1,
	RPM_REQ_SUSPEND = 2,
	RPM_REQ_AUTOSUSPEND = 3,
	RPM_REQ_RESUME = 4,
};

struct wakeup_source;

struct wake_irq;

struct pm_subsys_data;

struct dev_pm_qos;

struct dev_pm_info {
	pm_message_t power_state;
	unsigned int can_wakeup: 1;
	unsigned int async_suspend: 1;
	bool in_dpm_list: 1;
	bool is_prepared: 1;
	bool is_suspended: 1;
	bool is_noirq_suspended: 1;
	bool is_late_suspended: 1;
	bool no_pm: 1;
	bool early_init: 1;
	bool direct_complete: 1;
	u32 driver_flags;
	spinlock_t lock;
	struct list_head entry;
	struct completion completion;
	struct wakeup_source *wakeup;
	bool wakeup_path: 1;
	bool syscore: 1;
	bool no_pm_callbacks: 1;
	unsigned int must_resume: 1;
	unsigned int may_skip_resume: 1;
	struct hrtimer suspend_timer;
	u64 timer_expires;
	struct work_struct work;
	wait_queue_head_t wait_queue;
	struct wake_irq *wakeirq;
	atomic_t usage_count;
	atomic_t child_count;
	unsigned int disable_depth: 3;
	unsigned int idle_notification: 1;
	unsigned int request_pending: 1;
	unsigned int deferred_resume: 1;
	unsigned int needs_force_resume: 1;
	unsigned int runtime_auto: 1;
	bool ignore_children: 1;
	unsigned int no_callbacks: 1;
	unsigned int irq_safe: 1;
	unsigned int use_autosuspend: 1;
	unsigned int timer_autosuspends: 1;
	unsigned int memalloc_noio: 1;
	unsigned int links_count;
	enum rpm_request request;
	enum rpm_status runtime_status;
	enum rpm_status last_status;
	int runtime_error;
	int autosuspend_delay;
	int: 32;
	u64 last_busy;
	u64 active_time;
	u64 suspended_time;
	u64 accounting_timestamp;
	struct pm_subsys_data *subsys_data;
	void (*set_latency_tolerance)(struct device *, s32);
	struct dev_pm_qos *qos;
	int: 32;
};

struct irq_domain;

struct msi_device_data;

struct dev_msi_info {
	struct irq_domain *domain;
	struct msi_device_data *data;
};

struct dev_archdata {
	unsigned int dma_ops_setup: 1;
};

struct dev_iommu;

enum device_removable {
	DEVICE_REMOVABLE_NOT_SUPPORTED = 0,
	DEVICE_REMOVABLE_UNKNOWN = 1,
	DEVICE_FIXED = 2,
	DEVICE_REMOVABLE = 3,
};

struct device_private;

struct device_type;

struct bus_type;

struct device_driver;

struct dev_pm_domain;

struct dev_pin_info;

struct dma_map_ops;

struct bus_dma_region;

struct device_dma_parameters;

struct dma_coherent_mem;

struct cma;

struct device_node;

struct fwnode_handle;

struct class;

struct iommu_group;

struct device_physical_location;

struct device {
	struct kobject kobj;
	struct device *parent;
	struct device_private *p;
	const char *init_name;
	const struct device_type *type;
	struct bus_type *bus;
	struct device_driver *driver;
	void *platform_data;
	void *driver_data;
	struct mutex mutex;
	struct dev_links_info links;
	int: 32;
	struct dev_pm_info power;
	struct dev_pm_domain *pm_domain;
	struct dev_pin_info *pins;
	struct dev_msi_info msi;
	const struct dma_map_ops *dma_ops;
	u64 *dma_mask;
	u64 coherent_dma_mask;
	u64 bus_dma_limit;
	const struct bus_dma_region *dma_range_map;
	struct device_dma_parameters *dma_parms;
	struct list_head dma_pools;
	struct dma_coherent_mem *dma_mem;
	struct cma *cma_area;
	struct dev_archdata archdata;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	dev_t devt;
	u32 id;
	spinlock_t devres_lock;
	struct list_head devres_head;
	struct class *class;
	const struct attribute_group **groups;
	void (*release)(struct device *);
	struct iommu_group *iommu_group;
	struct dev_iommu *iommu;
	struct device_physical_location *physical_location;
	enum device_removable removable;
	bool offline_disabled: 1;
	bool offline: 1;
	bool of_node_reused: 1;
	bool state_synced: 1;
	bool can_match: 1;
	bool dma_coherent: 1;
};

struct disk_stats;

struct partition_meta_info;

struct block_device {
	sector_t bd_start_sect;
	sector_t bd_nr_sectors;
	struct disk_stats *bd_stats;
	long unsigned int bd_stamp;
	bool bd_read_only;
	dev_t bd_dev;
	atomic_t bd_openers;
	struct inode *bd_inode;
	struct super_block *bd_super;
	void *bd_claiming;
	struct device bd_device;
	void *bd_holder;
	int bd_holders;
	bool bd_write_holder;
	struct kobject *bd_holder_dir;
	u8 bd_partno;
	spinlock_t bd_size_lock;
	struct gendisk *bd_disk;
	struct request_queue *bd_queue;
	int bd_fsfreeze_count;
	struct mutex bd_fsfreeze_mutex;
	struct super_block *bd_fsfreeze_sb;
	struct partition_meta_info *bd_meta_info;
};

typedef bool (*filldir_t)(struct dir_context *, const char *, int, loff_t, u64, unsigned int);

struct dir_context {
	filldir_t actor;
	int: 32;
	loff_t pos;
};

struct io_comp_batch {
	struct request *req_list;
	bool need_ts;
	void (*complete)(struct io_comp_batch *);
};

struct fc_log;

struct p_log {
	const char *prefix;
	struct fc_log *log;
};

enum fs_context_purpose {
	FS_CONTEXT_FOR_MOUNT = 0,
	FS_CONTEXT_FOR_SUBMOUNT = 1,
	FS_CONTEXT_FOR_RECONFIGURE = 2,
};

enum fs_context_phase {
	FS_CONTEXT_CREATE_PARAMS = 0,
	FS_CONTEXT_CREATING = 1,
	FS_CONTEXT_AWAITING_MOUNT = 2,
	FS_CONTEXT_AWAITING_RECONF = 3,
	FS_CONTEXT_RECONF_PARAMS = 4,
	FS_CONTEXT_RECONFIGURING = 5,
	FS_CONTEXT_FAILED = 6,
};

struct fs_context_operations;

struct fs_context {
	const struct fs_context_operations *ops;
	struct mutex uapi_mutex;
	struct file_system_type *fs_type;
	void *fs_private;
	void *sget_key;
	struct dentry *root;
	struct user_namespace *user_ns;
	struct net *net_ns;
	const struct cred *cred;
	struct p_log log;
	const char *source;
	void *security;
	void *s_fs_info;
	unsigned int sb_flags;
	unsigned int sb_flags_mask;
	unsigned int s_iflags;
	unsigned int lsm_flags;
	enum fs_context_purpose purpose: 8;
	enum fs_context_phase phase: 8;
	bool need_free: 1;
	bool global: 1;
	bool oldapi: 1;
};

struct fs_parameter;

struct fs_parse_result;

typedef int fs_param_type(struct p_log *, const struct fs_parameter_spec *, struct fs_parameter *, struct fs_parse_result *);

struct fs_parameter_spec {
	const char *name;
	fs_param_type *type;
	u8 opt;
	short unsigned int flags;
	const void *data;
};

struct audit_names;

struct filename {
	const char *name;
	const char *uptr;
	int refcnt;
	struct audit_names *aname;
	const char iname[0];
};

typedef __u32 blk_opf_t;

typedef u8 blk_status_t;

struct bvec_iter {
	sector_t bi_sector;
	unsigned int bi_size;
	unsigned int bi_idx;
	unsigned int bi_bvec_done;
};

typedef unsigned int blk_qc_t;

typedef void bio_end_io_t(struct bio *);

struct bio_vec {
	struct page *bv_page;
	unsigned int bv_len;
	unsigned int bv_offset;
};

struct bio_set;

struct bio {
	struct bio *bi_next;
	struct block_device *bi_bdev;
	blk_opf_t bi_opf;
	short unsigned int bi_flags;
	short unsigned int bi_ioprio;
	blk_status_t bi_status;
	atomic_t __bi_remaining;
	struct bvec_iter bi_iter;
	blk_qc_t bi_cookie;
	bio_end_io_t *bi_end_io;
	void *bi_private;
	union {	};
	short unsigned int bi_vcnt;
	short unsigned int bi_max_vecs;
	atomic_t __bi_cnt;
	struct bio_vec *bi_io_vec;
	struct bio_set *bi_pool;
	struct bio_vec bi_inline_vecs[0];
};

struct linux_binprm {
	struct vm_area_struct *vma;
	long unsigned int vma_pages;
	struct mm_struct *mm;
	long unsigned int p;
	long unsigned int argmin;
	unsigned int have_execfd: 1;
	unsigned int execfd_creds: 1;
	unsigned int secureexec: 1;
	unsigned int point_of_no_return: 1;
	struct file *executable;
	struct file *interpreter;
	struct file *file;
	struct cred *cred;
	int unsafe;
	unsigned int per_clear;
	int argc;
	int envc;
	const char *filename;
	const char *interp;
	const char *fdpath;
	unsigned int interp_flags;
	int execfd;
	long unsigned int loader;
	long unsigned int exec;
	struct rlimit rlim_stack;
	char buf[256];
};

struct dev_pm_ops {
	int (*prepare)(struct device *);
	void (*complete)(struct device *);
	int (*suspend)(struct device *);
	int (*resume)(struct device *);
	int (*freeze)(struct device *);
	int (*thaw)(struct device *);
	int (*poweroff)(struct device *);
	int (*restore)(struct device *);
	int (*suspend_late)(struct device *);
	int (*resume_early)(struct device *);
	int (*freeze_late)(struct device *);
	int (*thaw_early)(struct device *);
	int (*poweroff_late)(struct device *);
	int (*restore_early)(struct device *);
	int (*suspend_noirq)(struct device *);
	int (*resume_noirq)(struct device *);
	int (*freeze_noirq)(struct device *);
	int (*thaw_noirq)(struct device *);
	int (*poweroff_noirq)(struct device *);
	int (*restore_noirq)(struct device *);
	int (*runtime_suspend)(struct device *);
	int (*runtime_resume)(struct device *);
	int (*runtime_idle)(struct device *);
};

struct pm_domain_data;

struct pm_subsys_data {
	spinlock_t lock;
	unsigned int refcount;
	unsigned int clock_op_might_sleep;
	struct mutex clock_mutex;
	struct list_head clock_list;
	struct pm_domain_data *domain_data;
};

struct wakeup_source {
	const char *name;
	int id;
	struct list_head entry;
	spinlock_t lock;
	struct wake_irq *wakeirq;
	struct timer_list timer;
	long unsigned int timer_expires;
	ktime_t total_time;
	ktime_t max_time;
	ktime_t last_time;
	ktime_t start_prevent_time;
	ktime_t prevent_sleep_time;
	long unsigned int event_count;
	long unsigned int active_count;
	long unsigned int relax_count;
	long unsigned int expire_count;
	long unsigned int wakeup_count;
	struct device *dev;
	bool active: 1;
	bool autosleep_enabled: 1;
	int: 30;
	int: 32;
};

struct dev_pm_domain {
	struct dev_pm_ops ops;
	int (*start)(struct device *);
	void (*detach)(struct device *, bool);
	int (*activate)(struct device *);
	void (*sync)(struct device *);
	void (*dismiss)(struct device *);
};

struct iommu_ops;

struct subsys_private;

struct bus_type {
	const char *name;
	const char *dev_name;
	struct device *dev_root;
	const struct attribute_group **bus_groups;
	const struct attribute_group **dev_groups;
	const struct attribute_group **drv_groups;
	int (*match)(struct device *, struct device_driver *);
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	void (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*online)(struct device *);
	int (*offline)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	int (*num_vf)(struct device *);
	int (*dma_configure)(struct device *);
	void (*dma_cleanup)(struct device *);
	const struct dev_pm_ops *pm;
	const struct iommu_ops *iommu_ops;
	struct subsys_private *p;
	struct lock_class_key lock_key;
	bool need_parent_lock;
};

enum probe_type {
	PROBE_DEFAULT_STRATEGY = 0,
	PROBE_PREFER_ASYNCHRONOUS = 1,
	PROBE_FORCE_SYNCHRONOUS = 2,
};

struct of_device_id;

struct acpi_device_id;

struct driver_private;

struct device_driver {
	const char *name;
	struct bus_type *bus;
	struct module *owner;
	const char *mod_name;
	bool suppress_bind_attrs;
	enum probe_type probe_type;
	const struct of_device_id *of_match_table;
	const struct acpi_device_id *acpi_match_table;
	int (*probe)(struct device *);
	void (*sync_state)(struct device *);
	int (*remove)(struct device *);
	void (*shutdown)(struct device *);
	int (*suspend)(struct device *, pm_message_t);
	int (*resume)(struct device *);
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	const struct dev_pm_ops *pm;
	void (*coredump)(struct device *);
	struct driver_private *p;
};

struct iommu_ops {};

struct device_type {
	const char *name;
	const struct attribute_group **groups;
	int (*uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *, kuid_t *, kgid_t *);
	void (*release)(struct device *);
	const struct dev_pm_ops *pm;
};

struct class {
	const char *name;
	struct module *owner;
	const struct attribute_group **class_groups;
	const struct attribute_group **dev_groups;
	struct kobject *dev_kobj;
	int (*dev_uevent)(struct device *, struct kobj_uevent_env *);
	char * (*devnode)(struct device *, umode_t *);
	void (*class_release)(struct class *);
	void (*dev_release)(struct device *);
	int (*shutdown_pre)(struct device *);
	const struct kobj_ns_type_operations *ns_type;
	const void * (*namespace)(struct device *);
	void (*get_ownership)(struct device *, kuid_t *, kgid_t *);
	const struct dev_pm_ops *pm;
	struct subsys_private *p;
};

struct of_device_id {
	char name[32];
	char type[32];
	char compatible[128];
	const void *data;
};

typedef long unsigned int kernel_ulong_t;

struct acpi_device_id {
	__u8 id[16];
	kernel_ulong_t driver_data;
	__u32 cls;
	__u32 cls_msk;
};

struct device_dma_parameters {
	unsigned int max_segment_size;
	unsigned int min_align_mask;
	long unsigned int segment_boundary_mask;
};

enum irq_domain_bus_token {
	DOMAIN_BUS_ANY = 0,
	DOMAIN_BUS_WIRED = 1,
	DOMAIN_BUS_GENERIC_MSI = 2,
	DOMAIN_BUS_PCI_MSI = 3,
	DOMAIN_BUS_PLATFORM_MSI = 4,
	DOMAIN_BUS_NEXUS = 5,
	DOMAIN_BUS_IPI = 6,
	DOMAIN_BUS_FSL_MC_MSI = 7,
	DOMAIN_BUS_TI_SCI_INTA_MSI = 8,
	DOMAIN_BUS_WAKEUP = 9,
	DOMAIN_BUS_VMD_MSI = 10,
};

struct irq_domain_ops;

struct irq_domain_chip_generic;

struct irq_data;

struct irq_domain {
	struct list_head link;
	const char *name;
	const struct irq_domain_ops *ops;
	void *host_data;
	unsigned int flags;
	unsigned int mapcount;
	struct fwnode_handle *fwnode;
	enum irq_domain_bus_token bus_token;
	struct irq_domain_chip_generic *gc;
	struct device *dev;
	struct irq_domain *parent;
	irq_hw_number_t hwirq_max;
	unsigned int revmap_size;
	struct xarray revmap_tree;
	struct mutex revmap_mutex;
	struct irq_data *revmap[0];
};

enum device_physical_location_panel {
	DEVICE_PANEL_TOP = 0,
	DEVICE_PANEL_BOTTOM = 1,
	DEVICE_PANEL_LEFT = 2,
	DEVICE_PANEL_RIGHT = 3,
	DEVICE_PANEL_FRONT = 4,
	DEVICE_PANEL_BACK = 5,
	DEVICE_PANEL_UNKNOWN = 6,
};

enum device_physical_location_vertical_position {
	DEVICE_VERT_POS_UPPER = 0,
	DEVICE_VERT_POS_CENTER = 1,
	DEVICE_VERT_POS_LOWER = 2,
};

enum device_physical_location_horizontal_position {
	DEVICE_HORI_POS_LEFT = 0,
	DEVICE_HORI_POS_CENTER = 1,
	DEVICE_HORI_POS_RIGHT = 2,
};

struct device_physical_location {
	enum device_physical_location_panel panel;
	enum device_physical_location_vertical_position vertical_position;
	enum device_physical_location_horizontal_position horizontal_position;
	bool dock;
	bool lid;
};

typedef u32 dma_addr_t;

struct sg_table;

struct scatterlist;

struct dma_map_ops {
	unsigned int flags;
	void * (*alloc)(struct device *, size_t, dma_addr_t *, gfp_t, long unsigned int);
	void (*free)(struct device *, size_t, void *, dma_addr_t, long unsigned int);
	struct page * (*alloc_pages)(struct device *, size_t, dma_addr_t *, enum dma_data_direction, gfp_t);
	void (*free_pages)(struct device *, size_t, struct page *, dma_addr_t, enum dma_data_direction);
	struct sg_table * (*alloc_noncontiguous)(struct device *, size_t, enum dma_data_direction, gfp_t, long unsigned int);
	void (*free_noncontiguous)(struct device *, size_t, struct sg_table *, enum dma_data_direction);
	int (*mmap)(struct device *, struct vm_area_struct *, void *, dma_addr_t, size_t, long unsigned int);
	int (*get_sgtable)(struct device *, struct sg_table *, void *, dma_addr_t, size_t, long unsigned int);
	dma_addr_t (*map_page)(struct device *, struct page *, long unsigned int, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_page)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	int (*map_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	void (*unmap_sg)(struct device *, struct scatterlist *, int, enum dma_data_direction, long unsigned int);
	dma_addr_t (*map_resource)(struct device *, phys_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*unmap_resource)(struct device *, dma_addr_t, size_t, enum dma_data_direction, long unsigned int);
	void (*sync_single_for_cpu)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_single_for_device)(struct device *, dma_addr_t, size_t, enum dma_data_direction);
	void (*sync_sg_for_cpu)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*sync_sg_for_device)(struct device *, struct scatterlist *, int, enum dma_data_direction);
	void (*cache_sync)(struct device *, void *, size_t, enum dma_data_direction);
	int (*dma_supported)(struct device *, u64);
	u64 (*get_required_mask)(struct device *);
	size_t (*max_mapping_size)(struct device *);
	size_t (*opt_mapping_size)();
	long unsigned int (*get_merge_boundary)(struct device *);
};

struct bus_dma_region {
	phys_addr_t cpu_start;
	dma_addr_t dma_start;
	u64 size;
	u64 offset;
};

typedef u32 phandle;

struct fwnode_operations;

struct fwnode_handle {
	struct fwnode_handle *secondary;
	const struct fwnode_operations *ops;
	struct device *dev;
	struct list_head suppliers;
	struct list_head consumers;
	u8 flags;
};

struct property;

struct device_node {
	const char *name;
	phandle phandle;
	const char *full_name;
	struct fwnode_handle fwnode;
	struct property *properties;
	struct property *deadprops;
	struct device_node *parent;
	struct device_node *child;
	struct device_node *sibling;
	struct kobject kobj;
	long unsigned int _flags;
	void *data;
};

enum cpuhp_state {
	CPUHP_INVALID = 4294967295,
	CPUHP_OFFLINE = 0,
	CPUHP_CREATE_THREADS = 1,
	CPUHP_PERF_PREPARE = 2,
	CPUHP_PERF_X86_PREPARE = 3,
	CPUHP_PERF_X86_AMD_UNCORE_PREP = 4,
	CPUHP_PERF_POWER = 5,
	CPUHP_PERF_SUPERH = 6,
	CPUHP_X86_HPET_DEAD = 7,
	CPUHP_X86_APB_DEAD = 8,
	CPUHP_X86_MCE_DEAD = 9,
	CPUHP_VIRT_NET_DEAD = 10,
	CPUHP_SLUB_DEAD = 11,
	CPUHP_DEBUG_OBJ_DEAD = 12,
	CPUHP_MM_WRITEBACK_DEAD = 13,
	CPUHP_MM_DEMOTION_DEAD = 14,
	CPUHP_MM_VMSTAT_DEAD = 15,
	CPUHP_SOFTIRQ_DEAD = 16,
	CPUHP_NET_MVNETA_DEAD = 17,
	CPUHP_CPUIDLE_DEAD = 18,
	CPUHP_ARM64_FPSIMD_DEAD = 19,
	CPUHP_ARM_OMAP_WAKE_DEAD = 20,
	CPUHP_IRQ_POLL_DEAD = 21,
	CPUHP_BLOCK_SOFTIRQ_DEAD = 22,
	CPUHP_BIO_DEAD = 23,
	CPUHP_ACPI_CPUDRV_DEAD = 24,
	CPUHP_S390_PFAULT_DEAD = 25,
	CPUHP_BLK_MQ_DEAD = 26,
	CPUHP_FS_BUFF_DEAD = 27,
	CPUHP_PRINTK_DEAD = 28,
	CPUHP_MM_MEMCQ_DEAD = 29,
	CPUHP_XFS_DEAD = 30,
	CPUHP_PERCPU_CNT_DEAD = 31,
	CPUHP_RADIX_DEAD = 32,
	CPUHP_PAGE_ALLOC = 33,
	CPUHP_NET_DEV_DEAD = 34,
	CPUHP_PCI_XGENE_DEAD = 35,
	CPUHP_IOMMU_IOVA_DEAD = 36,
	CPUHP_LUSTRE_CFS_DEAD = 37,
	CPUHP_AP_ARM_CACHE_B15_RAC_DEAD = 38,
	CPUHP_PADATA_DEAD = 39,
	CPUHP_AP_DTPM_CPU_DEAD = 40,
	CPUHP_RANDOM_PREPARE = 41,
	CPUHP_WORKQUEUE_PREP = 42,
	CPUHP_POWER_NUMA_PREPARE = 43,
	CPUHP_HRTIMERS_PREPARE = 44,
	CPUHP_PROFILE_PREPARE = 45,
	CPUHP_X2APIC_PREPARE = 46,
	CPUHP_SMPCFD_PREPARE = 47,
	CPUHP_RELAY_PREPARE = 48,
	CPUHP_SLAB_PREPARE = 49,
	CPUHP_MD_RAID5_PREPARE = 50,
	CPUHP_RCUTREE_PREP = 51,
	CPUHP_CPUIDLE_COUPLED_PREPARE = 52,
	CPUHP_POWERPC_PMAC_PREPARE = 53,
	CPUHP_POWERPC_MMU_CTX_PREPARE = 54,
	CPUHP_XEN_PREPARE = 55,
	CPUHP_XEN_EVTCHN_PREPARE = 56,
	CPUHP_ARM_SHMOBILE_SCU_PREPARE = 57,
	CPUHP_SH_SH3X_PREPARE = 58,
	CPUHP_NET_FLOW_PREPARE = 59,
	CPUHP_TOPOLOGY_PREPARE = 60,
	CPUHP_NET_IUCV_PREPARE = 61,
	CPUHP_ARM_BL_PREPARE = 62,
	CPUHP_TRACE_RB_PREPARE = 63,
	CPUHP_MM_ZS_PREPARE = 64,
	CPUHP_MM_ZSWP_MEM_PREPARE = 65,
	CPUHP_MM_ZSWP_POOL_PREPARE = 66,
	CPUHP_KVM_PPC_BOOK3S_PREPARE = 67,
	CPUHP_ZCOMP_PREPARE = 68,
	CPUHP_TIMERS_PREPARE = 69,
	CPUHP_MIPS_SOC_PREPARE = 70,
	CPUHP_BP_PREPARE_DYN = 71,
	CPUHP_BP_PREPARE_DYN_END = 91,
	CPUHP_BRINGUP_CPU = 92,
	CPUHP_AP_IDLE_DEAD = 93,
	CPUHP_AP_OFFLINE = 94,
	CPUHP_AP_SCHED_STARTING = 95,
	CPUHP_AP_RCUTREE_DYING = 96,
	CPUHP_AP_CPU_PM_STARTING = 97,
	CPUHP_AP_IRQ_GIC_STARTING = 98,
	CPUHP_AP_IRQ_HIP04_STARTING = 99,
	CPUHP_AP_IRQ_APPLE_AIC_STARTING = 100,
	CPUHP_AP_IRQ_ARMADA_XP_STARTING = 101,
	CPUHP_AP_IRQ_BCM2836_STARTING = 102,
	CPUHP_AP_IRQ_MIPS_GIC_STARTING = 103,
	CPUHP_AP_IRQ_RISCV_STARTING = 104,
	CPUHP_AP_IRQ_LOONGARCH_STARTING = 105,
	CPUHP_AP_IRQ_SIFIVE_PLIC_STARTING = 106,
	CPUHP_AP_ARM_MVEBU_COHERENCY = 107,
	CPUHP_AP_MICROCODE_LOADER = 108,
	CPUHP_AP_PERF_X86_AMD_UNCORE_STARTING = 109,
	CPUHP_AP_PERF_X86_STARTING = 110,
	CPUHP_AP_PERF_X86_AMD_IBS_STARTING = 111,
	CPUHP_AP_PERF_X86_CQM_STARTING = 112,
	CPUHP_AP_PERF_X86_CSTATE_STARTING = 113,
	CPUHP_AP_PERF_XTENSA_STARTING = 114,
	CPUHP_AP_MIPS_OP_LOONGSON3_STARTING = 115,
	CPUHP_AP_ARM_SDEI_STARTING = 116,
	CPUHP_AP_ARM_VFP_STARTING = 117,
	CPUHP_AP_ARM64_DEBUG_MONITORS_STARTING = 118,
	CPUHP_AP_PERF_ARM_HW_BREAKPOINT_STARTING = 119,
	CPUHP_AP_PERF_ARM_ACPI_STARTING = 120,
	CPUHP_AP_PERF_ARM_STARTING = 121,
	CPUHP_AP_PERF_RISCV_STARTING = 122,
	CPUHP_AP_ARM_L2X0_STARTING = 123,
	CPUHP_AP_EXYNOS4_MCT_TIMER_STARTING = 124,
	CPUHP_AP_ARM_ARCH_TIMER_STARTING = 125,
	CPUHP_AP_ARM_GLOBAL_TIMER_STARTING = 126,
	CPUHP_AP_JCORE_TIMER_STARTING = 127,
	CPUHP_AP_ARM_TWD_STARTING = 128,
	CPUHP_AP_QCOM_TIMER_STARTING = 129,
	CPUHP_AP_TEGRA_TIMER_STARTING = 130,
	CPUHP_AP_ARMADA_TIMER_STARTING = 131,
	CPUHP_AP_MARCO_TIMER_STARTING = 132,
	CPUHP_AP_MIPS_GIC_TIMER_STARTING = 133,
	CPUHP_AP_ARC_TIMER_STARTING = 134,
	CPUHP_AP_RISCV_TIMER_STARTING = 135,
	CPUHP_AP_CLINT_TIMER_STARTING = 136,
	CPUHP_AP_CSKY_TIMER_STARTING = 137,
	CPUHP_AP_TI_GP_TIMER_STARTING = 138,
	CPUHP_AP_HYPERV_TIMER_STARTING = 139,
	CPUHP_AP_KVM_STARTING = 140,
	CPUHP_AP_KVM_ARM_VGIC_INIT_STARTING = 141,
	CPUHP_AP_KVM_ARM_VGIC_STARTING = 142,
	CPUHP_AP_KVM_ARM_TIMER_STARTING = 143,
	CPUHP_AP_DUMMY_TIMER_STARTING = 144,
	CPUHP_AP_ARM_XEN_STARTING = 145,
	CPUHP_AP_ARM_CORESIGHT_STARTING = 146,
	CPUHP_AP_ARM_CORESIGHT_CTI_STARTING = 147,
	CPUHP_AP_ARM64_ISNDEP_STARTING = 148,
	CPUHP_AP_SMPCFD_DYING = 149,
	CPUHP_AP_X86_TBOOT_DYING = 150,
	CPUHP_AP_ARM_CACHE_B15_RAC_DYING = 151,
	CPUHP_AP_ONLINE = 152,
	CPUHP_TEARDOWN_CPU = 153,
	CPUHP_AP_ONLINE_IDLE = 154,
	CPUHP_AP_SCHED_WAIT_EMPTY = 155,
	CPUHP_AP_SMPBOOT_THREADS = 156,
	CPUHP_AP_X86_VDSO_VMA_ONLINE = 157,
	CPUHP_AP_IRQ_AFFINITY_ONLINE = 158,
	CPUHP_AP_BLK_MQ_ONLINE = 159,
	CPUHP_AP_ARM_MVEBU_SYNC_CLOCKS = 160,
	CPUHP_AP_X86_INTEL_EPB_ONLINE = 161,
	CPUHP_AP_PERF_ONLINE = 162,
	CPUHP_AP_PERF_X86_ONLINE = 163,
	CPUHP_AP_PERF_X86_UNCORE_ONLINE = 164,
	CPUHP_AP_PERF_X86_AMD_UNCORE_ONLINE = 165,
	CPUHP_AP_PERF_X86_AMD_POWER_ONLINE = 166,
	CPUHP_AP_PERF_X86_RAPL_ONLINE = 167,
	CPUHP_AP_PERF_X86_CQM_ONLINE = 168,
	CPUHP_AP_PERF_X86_CSTATE_ONLINE = 169,
	CPUHP_AP_PERF_X86_IDXD_ONLINE = 170,
	CPUHP_AP_PERF_S390_CF_ONLINE = 171,
	CPUHP_AP_PERF_S390_SF_ONLINE = 172,
	CPUHP_AP_PERF_ARM_CCI_ONLINE = 173,
	CPUHP_AP_PERF_ARM_CCN_ONLINE = 174,
	CPUHP_AP_PERF_ARM_HISI_CPA_ONLINE = 175,
	CPUHP_AP_PERF_ARM_HISI_DDRC_ONLINE = 176,
	CPUHP_AP_PERF_ARM_HISI_HHA_ONLINE = 177,
	CPUHP_AP_PERF_ARM_HISI_L3_ONLINE = 178,
	CPUHP_AP_PERF_ARM_HISI_PA_ONLINE = 179,
	CPUHP_AP_PERF_ARM_HISI_SLLC_ONLINE = 180,
	CPUHP_AP_PERF_ARM_HISI_PCIE_PMU_ONLINE = 181,
	CPUHP_AP_PERF_ARM_HNS3_PMU_ONLINE = 182,
	CPUHP_AP_PERF_ARM_L2X0_ONLINE = 183,
	CPUHP_AP_PERF_ARM_QCOM_L2_ONLINE = 184,
	CPUHP_AP_PERF_ARM_QCOM_L3_ONLINE = 185,
	CPUHP_AP_PERF_ARM_APM_XGENE_ONLINE = 186,
	CPUHP_AP_PERF_ARM_CAVIUM_TX2_UNCORE_ONLINE = 187,
	CPUHP_AP_PERF_ARM_MARVELL_CN10K_DDR_ONLINE = 188,
	CPUHP_AP_PERF_POWERPC_NEST_IMC_ONLINE = 189,
	CPUHP_AP_PERF_POWERPC_CORE_IMC_ONLINE = 190,
	CPUHP_AP_PERF_POWERPC_THREAD_IMC_ONLINE = 191,
	CPUHP_AP_PERF_POWERPC_TRACE_IMC_ONLINE = 192,
	CPUHP_AP_PERF_POWERPC_HV_24x7_ONLINE = 193,
	CPUHP_AP_PERF_POWERPC_HV_GPCI_ONLINE = 194,
	CPUHP_AP_PERF_CSKY_ONLINE = 195,
	CPUHP_AP_WATCHDOG_ONLINE = 196,
	CPUHP_AP_WORKQUEUE_ONLINE = 197,
	CPUHP_AP_RANDOM_ONLINE = 198,
	CPUHP_AP_RCUTREE_ONLINE = 199,
	CPUHP_AP_BASE_CACHEINFO_ONLINE = 200,
	CPUHP_AP_ONLINE_DYN = 201,
	CPUHP_AP_ONLINE_DYN_END = 231,
	CPUHP_AP_MM_DEMOTION_ONLINE = 232,
	CPUHP_AP_X86_HPET_ONLINE = 233,
	CPUHP_AP_X86_KVM_CLK_ONLINE = 234,
	CPUHP_AP_ACTIVE = 235,
	CPUHP_ONLINE = 236,
};

struct dev_pagemap_ops {
	void (*page_free)(struct page *);
	vm_fault_t (*migrate_to_ram)(struct vm_fault *);
	int (*memory_failure)(struct dev_pagemap *, long unsigned int, long unsigned int, int);
};

struct seq_operations {
	void * (*start)(struct seq_file *, loff_t *);
	void (*stop)(struct seq_file *, void *);
	void * (*next)(struct seq_file *, void *, loff_t *);
	int (*show)(struct seq_file *, void *);
};

struct ring_buffer_event {
	u32 type_len: 5;
	u32 time_delta: 27;
	u32 array[0];
};

struct seq_buf {
	char *buffer;
	size_t size;
	size_t len;
	int: 32;
	loff_t readpos;
};

struct trace_seq {
	char buffer[4096];
	struct seq_buf seq;
	int full;
	int: 32;
};

struct irq_desc;

typedef void (*irq_flow_handler_t)(struct irq_desc *);

struct msi_desc;

struct irq_common_data {
	unsigned int state_use_accessors;
	void *handler_data;
	struct msi_desc *msi_desc;
	cpumask_var_t affinity;
	cpumask_var_t effective_affinity;
	unsigned int ipi_offset;
};

struct irq_chip;

struct irq_data {
	u32 mask;
	unsigned int irq;
	long unsigned int hwirq;
	struct irq_common_data *common;
	struct irq_chip *chip;
	struct irq_domain *domain;
	struct irq_data *parent_data;
	void *chip_data;
};

struct irqaction;

struct irq_affinity_notify;

struct proc_dir_entry;

struct irq_desc {
	struct irq_common_data irq_common_data;
	struct irq_data irq_data;
	unsigned int *kstat_irqs;
	irq_flow_handler_t handle_irq;
	struct irqaction *action;
	unsigned int status_use_accessors;
	unsigned int core_internal_state__do_not_mess_with_it;
	unsigned int depth;
	unsigned int wake_depth;
	unsigned int tot_count;
	unsigned int irq_count;
	long unsigned int last_unhandled;
	unsigned int irqs_unhandled;
	atomic_t threads_handled;
	int threads_handled_last;
	raw_spinlock_t lock;
	struct cpumask *percpu_enabled;
	const struct cpumask *percpu_affinity;
	const struct cpumask *affinity_hint;
	struct irq_affinity_notify *affinity_notify;
	long unsigned int threads_oneshot;
	atomic_t threads_active;
	wait_queue_head_t wait_for_threads;
	unsigned int nr_actions;
	unsigned int no_suspend_depth;
	unsigned int cond_suspend_depth;
	unsigned int force_resume_depth;
	struct proc_dir_entry *dir;
	struct callback_head rcu;
	struct kobject kobj;
	struct mutex request_mutex;
	int parent_irq;
	struct module *owner;
	const char *name;
	int: 32;
	int: 32;
	int: 32;
};

enum irqreturn {
	IRQ_NONE = 0,
	IRQ_HANDLED = 1,
	IRQ_WAKE_THREAD = 2,
};

typedef enum irqreturn irqreturn_t;

enum dev_dma_attr {
	DEV_DMA_NOT_SUPPORTED = 0,
	DEV_DMA_NON_COHERENT = 1,
	DEV_DMA_COHERENT = 2,
};

struct fwnode_reference_args;

struct fwnode_endpoint;

struct fwnode_operations {
	struct fwnode_handle * (*get)(struct fwnode_handle *);
	void (*put)(struct fwnode_handle *);
	bool (*device_is_available)(const struct fwnode_handle *);
	const void * (*device_get_match_data)(const struct fwnode_handle *, const struct device *);
	bool (*device_dma_supported)(const struct fwnode_handle *);
	enum dev_dma_attr (*device_get_dma_attr)(const struct fwnode_handle *);
	bool (*property_present)(const struct fwnode_handle *, const char *);
	int (*property_read_int_array)(const struct fwnode_handle *, const char *, unsigned int, void *, size_t);
	int (*property_read_string_array)(const struct fwnode_handle *, const char *, const char **, size_t);
	const char * (*get_name)(const struct fwnode_handle *);
	const char * (*get_name_prefix)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_parent)(const struct fwnode_handle *);
	struct fwnode_handle * (*get_next_child_node)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*get_named_child_node)(const struct fwnode_handle *, const char *);
	int (*get_reference_args)(const struct fwnode_handle *, const char *, const char *, unsigned int, unsigned int, struct fwnode_reference_args *);
	struct fwnode_handle * (*graph_get_next_endpoint)(const struct fwnode_handle *, struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_remote_endpoint)(const struct fwnode_handle *);
	struct fwnode_handle * (*graph_get_port_parent)(struct fwnode_handle *);
	int (*graph_parse_endpoint)(const struct fwnode_handle *, struct fwnode_endpoint *);
	void * (*iomap)(struct fwnode_handle *, int);
	int (*irq_get)(const struct fwnode_handle *, unsigned int);
	int (*add_links)(struct fwnode_handle *);
};

struct fwnode_endpoint {
	unsigned int port;
	unsigned int id;
	const struct fwnode_handle *local_fwnode;
};

struct fwnode_reference_args {
	struct fwnode_handle *fwnode;
	unsigned int nargs;
	u64 args[8];
};

enum irqchip_irq_state {
	IRQCHIP_STATE_PENDING = 0,
	IRQCHIP_STATE_ACTIVE = 1,
	IRQCHIP_STATE_MASKED = 2,
	IRQCHIP_STATE_LINE_LEVEL = 3,
};

struct msi_msg;

struct irq_chip {
	const char *name;
	unsigned int (*irq_startup)(struct irq_data *);
	void (*irq_shutdown)(struct irq_data *);
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_ack)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
	void (*irq_mask_ack)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_eoi)(struct irq_data *);
	int (*irq_set_affinity)(struct irq_data *, const struct cpumask *, bool);
	int (*irq_retrigger)(struct irq_data *);
	int (*irq_set_type)(struct irq_data *, unsigned int);
	int (*irq_set_wake)(struct irq_data *, unsigned int);
	void (*irq_bus_lock)(struct irq_data *);
	void (*irq_bus_sync_unlock)(struct irq_data *);
	void (*irq_suspend)(struct irq_data *);
	void (*irq_resume)(struct irq_data *);
	void (*irq_pm_shutdown)(struct irq_data *);
	void (*irq_calc_mask)(struct irq_data *);
	void (*irq_print_chip)(struct irq_data *, struct seq_file *);
	int (*irq_request_resources)(struct irq_data *);
	void (*irq_release_resources)(struct irq_data *);
	void (*irq_compose_msi_msg)(struct irq_data *, struct msi_msg *);
	void (*irq_write_msi_msg)(struct irq_data *, struct msi_msg *);
	int (*irq_get_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool *);
	int (*irq_set_irqchip_state)(struct irq_data *, enum irqchip_irq_state, bool);
	int (*irq_set_vcpu_affinity)(struct irq_data *, void *);
	void (*ipi_send_single)(struct irq_data *, unsigned int);
	void (*ipi_send_mask)(struct irq_data *, const struct cpumask *);
	int (*irq_nmi_setup)(struct irq_data *);
	void (*irq_nmi_teardown)(struct irq_data *);
	long unsigned int flags;
};

typedef irqreturn_t (*irq_handler_t)(int, void *);

struct irqaction {
	irq_handler_t handler;
	void *dev_id;
	void *percpu_dev_id;
	struct irqaction *next;
	irq_handler_t thread_fn;
	struct task_struct *thread;
	struct irqaction *secondary;
	unsigned int irq;
	unsigned int flags;
	long unsigned int thread_flags;
	long unsigned int thread_mask;
	const char *name;
	struct proc_dir_entry *dir;
	int: 32;
	int: 32;
	int: 32;
};

struct irq_affinity_notify {
	unsigned int irq;
	struct kref kref;
	struct work_struct work;
	void (*notify)(struct irq_affinity_notify *, const cpumask_t *);
	void (*release)(struct kref *);
};

struct irq_chip_regs {
	long unsigned int enable;
	long unsigned int disable;
	long unsigned int mask;
	long unsigned int ack;
	long unsigned int eoi;
	long unsigned int type;
	long unsigned int polarity;
};

struct irq_chip_type {
	struct irq_chip chip;
	struct irq_chip_regs regs;
	irq_flow_handler_t handler;
	u32 type;
	u32 mask_cache_priv;
	u32 *mask_cache;
};

struct irq_chip_generic {
	raw_spinlock_t lock;
	void *reg_base;
	u32 (*reg_readl)(void *);
	void (*reg_writel)(u32, void *);
	void (*suspend)(struct irq_chip_generic *);
	void (*resume)(struct irq_chip_generic *);
	unsigned int irq_base;
	unsigned int irq_cnt;
	u32 mask_cache;
	u32 type_cache;
	u32 polarity_cache;
	u32 wake_enabled;
	u32 wake_active;
	unsigned int num_ct;
	void *private;
	long unsigned int installed;
	long unsigned int unused;
	struct irq_domain *domain;
	struct list_head list;
	struct irq_chip_type chip_types[0];
};

enum irq_gc_flags {
	IRQ_GC_INIT_MASK_CACHE = 1,
	IRQ_GC_INIT_NESTED_LOCK = 2,
	IRQ_GC_MASK_CACHE_PER_TYPE = 4,
	IRQ_GC_NO_MASK = 8,
	IRQ_GC_BE_IO = 16,
};

struct irq_domain_chip_generic {
	unsigned int irqs_per_chip;
	unsigned int num_chips;
	unsigned int irq_flags_to_clear;
	unsigned int irq_flags_to_set;
	enum irq_gc_flags gc_flags;
	struct irq_chip_generic *gc[0];
};

union perf_mem_data_src {
	__u64 val;
	struct {
		__u64 mem_op: 5;
		__u64 mem_lvl: 14;
		__u64 mem_snoop: 5;
		__u64 mem_lock: 2;
		__u64 mem_dtlb: 7;
		__u64 mem_lvl_num: 4;
		__u64 mem_remote: 1;
		__u64 mem_snoopx: 2;
		__u64 mem_blk: 3;
		__u64 mem_hops: 3;
		__u64 mem_rsvd: 18;
	};
};

struct perf_branch_entry {
	__u64 from;
	__u64 to;
	__u64 mispred: 1;
	__u64 predicted: 1;
	__u64 in_tx: 1;
	__u64 abort: 1;
	__u64 cycles: 16;
	__u64 type: 4;
	__u64 spec: 2;
	__u64 new_type: 4;
	__u64 priv: 3;
	__u64 reserved: 31;
};

union perf_sample_weight {
	__u64 full;
	struct {
		__u32 var1_dw;
		__u16 var2_w;
		__u16 var3_w;
	};
};

struct new_utsname {
	char sysname[65];
	char nodename[65];
	char release[65];
	char version[65];
	char machine[65];
	char domainname[65];
};

struct uts_namespace {
	struct new_utsname name;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
};

struct ref_tracker_dir {};

struct prot_inuse;

struct netns_core {
	struct ctl_table_header *sysctl_hdr;
	int sysctl_somaxconn;
	u8 sysctl_txrehash;
	struct prot_inuse *prot_inuse;
};

struct ipstats_mib;

struct tcp_mib;

struct linux_mib;

struct udp_mib;

struct linux_tls_mib;

struct icmp_mib;

struct icmpmsg_mib;

struct icmpv6_mib;

struct icmpv6msg_mib;

struct netns_mib {
	struct ipstats_mib *ip_statistics;
	struct ipstats_mib *ipv6_statistics;
	struct tcp_mib *tcp_statistics;
	struct linux_mib *net_statistics;
	struct udp_mib *udp_statistics;
	struct udp_mib *udp_stats_in6;
	struct linux_tls_mib *tls_statistics;
	struct udp_mib *udplite_statistics;
	struct udp_mib *udplite_stats_in6;
	struct icmp_mib *icmp_statistics;
	struct icmpmsg_mib *icmpmsg_statistics;
	struct icmpv6_mib *icmpv6_statistics;
	struct icmpv6msg_mib *icmpv6msg_statistics;
	struct proc_dir_entry *proc_net_devsnmp6;
};

struct netns_packet {
	struct mutex sklist_lock;
	struct hlist_head sklist;
};

struct unix_table {
	spinlock_t *locks;
	struct hlist_head *buckets;
};

struct netns_unix {
	struct unix_table table;
	int sysctl_max_dgram_qlen;
	struct ctl_table_header *ctl;
};

struct netns_nexthop {
	struct rb_root rb_root;
	struct hlist_head *devhash;
	unsigned int seq;
	u32 last_id_allocated;
	struct blocking_notifier_head notifier_chain;
};

struct inet_hashinfo;

struct inet_timewait_death_row {
	refcount_t tw_refcount;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct inet_hashinfo *hashinfo;
	int sysctl_max_tw_buckets;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct local_ports {
	seqlock_t lock;
	int range[2];
	bool warned;
};

struct ping_group_range {
	seqlock_t lock;
	kgid_t range[2];
};

typedef struct {
	u64 key[2];
} siphash_key_t;

struct ipv4_devconf;

struct ip_ra_chain;

struct inet_peer_base;

struct fqdir;

struct tcp_congestion_ops;

struct tcp_fastopen_context;

struct fib_notifier_ops;

struct netns_ipv4 {
	struct inet_timewait_death_row tcp_death_row;
	struct ctl_table_header *forw_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *ipv4_hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *xfrm4_hdr;
	struct ipv4_devconf *devconf_all;
	struct ipv4_devconf *devconf_dflt;
	struct ip_ra_chain *ra_chain;
	struct mutex ra_mutex;
	bool fib_has_custom_local_routes;
	bool fib_offload_disabled;
	atomic_t fib_num_tclassid_users;
	struct hlist_head *fib_table_hash;
	struct sock *fibnl;
	struct sock *mc_autojoin_sk;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	u8 sysctl_icmp_echo_ignore_all;
	u8 sysctl_icmp_echo_enable_probe;
	u8 sysctl_icmp_echo_ignore_broadcasts;
	u8 sysctl_icmp_ignore_bogus_error_responses;
	u8 sysctl_icmp_errors_use_inbound_ifaddr;
	int sysctl_icmp_ratelimit;
	int sysctl_icmp_ratemask;
	u32 ip_rt_min_pmtu;
	int ip_rt_mtu_expires;
	int ip_rt_min_advmss;
	struct local_ports ip_local_ports;
	u8 sysctl_tcp_ecn;
	u8 sysctl_tcp_ecn_fallback;
	u8 sysctl_ip_default_ttl;
	u8 sysctl_ip_no_pmtu_disc;
	u8 sysctl_ip_fwd_use_pmtu;
	u8 sysctl_ip_fwd_update_priority;
	u8 sysctl_ip_nonlocal_bind;
	u8 sysctl_ip_autobind_reuse;
	u8 sysctl_ip_dynaddr;
	u8 sysctl_ip_early_demux;
	u8 sysctl_tcp_early_demux;
	u8 sysctl_udp_early_demux;
	u8 sysctl_nexthop_compat_mode;
	u8 sysctl_fwmark_reflect;
	u8 sysctl_tcp_fwmark_accept;
	u8 sysctl_tcp_mtu_probing;
	int sysctl_tcp_mtu_probe_floor;
	int sysctl_tcp_base_mss;
	int sysctl_tcp_min_snd_mss;
	int sysctl_tcp_probe_threshold;
	u32 sysctl_tcp_probe_interval;
	int sysctl_tcp_keepalive_time;
	int sysctl_tcp_keepalive_intvl;
	u8 sysctl_tcp_keepalive_probes;
	u8 sysctl_tcp_syn_retries;
	u8 sysctl_tcp_synack_retries;
	u8 sysctl_tcp_syncookies;
	u8 sysctl_tcp_migrate_req;
	u8 sysctl_tcp_comp_sack_nr;
	int sysctl_tcp_reordering;
	u8 sysctl_tcp_retries1;
	u8 sysctl_tcp_retries2;
	u8 sysctl_tcp_orphan_retries;
	u8 sysctl_tcp_tw_reuse;
	int sysctl_tcp_fin_timeout;
	unsigned int sysctl_tcp_notsent_lowat;
	u8 sysctl_tcp_sack;
	u8 sysctl_tcp_window_scaling;
	u8 sysctl_tcp_timestamps;
	u8 sysctl_tcp_early_retrans;
	u8 sysctl_tcp_recovery;
	u8 sysctl_tcp_thin_linear_timeouts;
	u8 sysctl_tcp_slow_start_after_idle;
	u8 sysctl_tcp_retrans_collapse;
	u8 sysctl_tcp_stdurg;
	u8 sysctl_tcp_rfc1337;
	u8 sysctl_tcp_abort_on_overflow;
	u8 sysctl_tcp_fack;
	int sysctl_tcp_max_reordering;
	int sysctl_tcp_adv_win_scale;
	u8 sysctl_tcp_dsack;
	u8 sysctl_tcp_app_win;
	u8 sysctl_tcp_frto;
	u8 sysctl_tcp_nometrics_save;
	u8 sysctl_tcp_no_ssthresh_metrics_save;
	u8 sysctl_tcp_moderate_rcvbuf;
	u8 sysctl_tcp_tso_win_divisor;
	u8 sysctl_tcp_workaround_signed_windows;
	int sysctl_tcp_limit_output_bytes;
	int sysctl_tcp_challenge_ack_limit;
	int sysctl_tcp_min_rtt_wlen;
	u8 sysctl_tcp_min_tso_segs;
	u8 sysctl_tcp_tso_rtt_log;
	u8 sysctl_tcp_autocorking;
	u8 sysctl_tcp_reflect_tos;
	int sysctl_tcp_invalid_ratelimit;
	int sysctl_tcp_pacing_ss_ratio;
	int sysctl_tcp_pacing_ca_ratio;
	int sysctl_tcp_wmem[3];
	int sysctl_tcp_rmem[3];
	unsigned int sysctl_tcp_child_ehash_entries;
	long unsigned int sysctl_tcp_comp_sack_delay_ns;
	long unsigned int sysctl_tcp_comp_sack_slack_ns;
	int sysctl_max_syn_backlog;
	int sysctl_tcp_fastopen;
	const struct tcp_congestion_ops *tcp_congestion_control;
	struct tcp_fastopen_context *tcp_fastopen_ctx;
	unsigned int sysctl_tcp_fastopen_blackhole_timeout;
	atomic_t tfo_active_disable_times;
	long unsigned int tfo_active_disable_stamp;
	u32 tcp_challenge_timestamp;
	u32 tcp_challenge_count;
	int sysctl_udp_wmem_min;
	int sysctl_udp_rmem_min;
	u8 sysctl_fib_notify_on_flag_change;
	u8 sysctl_igmp_llm_reports;
	int sysctl_igmp_max_memberships;
	int sysctl_igmp_max_msf;
	int sysctl_igmp_qrv;
	struct ping_group_range ping_group_range;
	atomic_t dev_addr_genid;
	long unsigned int *sysctl_local_reserved_ports;
	int sysctl_ip_prot_sock;
	struct fib_notifier_ops *notifier_ops;
	unsigned int fib_seq;
	struct fib_notifier_ops *ipmr_notifier_ops;
	unsigned int ipmr_seq;
	atomic_t rt_genid;
	int: 32;
	siphash_key_t ip_id_key;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct dst_entry;

struct net_device;

struct sk_buff;

struct neighbour;

struct dst_ops {
	short unsigned int family;
	unsigned int gc_thresh;
	int (*gc)(struct dst_ops *);
	struct dst_entry * (*check)(struct dst_entry *, __u32);
	unsigned int (*default_advmss)(const struct dst_entry *);
	unsigned int (*mtu)(const struct dst_entry *);
	u32 * (*cow_metrics)(struct dst_entry *, long unsigned int);
	void (*destroy)(struct dst_entry *);
	void (*ifdown)(struct dst_entry *, struct net_device *, int);
	struct dst_entry * (*negative_advice)(struct dst_entry *);
	void (*link_failure)(struct sk_buff *);
	void (*update_pmtu)(struct dst_entry *, struct sock *, struct sk_buff *, u32, bool);
	void (*redirect)(struct dst_entry *, struct sock *, struct sk_buff *);
	int (*local_out)(struct net *, struct sock *, struct sk_buff *);
	struct neighbour * (*neigh_lookup)(const struct dst_entry *, struct sk_buff *, const void *);
	void (*confirm_neigh)(const struct dst_entry *, const void *);
	struct kmem_cache *kmem_cachep;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct percpu_counter pcpuc_entries;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct netns_sysctl_ipv6 {
	struct ctl_table_header *hdr;
	struct ctl_table_header *route_hdr;
	struct ctl_table_header *icmp_hdr;
	struct ctl_table_header *frags_hdr;
	struct ctl_table_header *xfrm6_hdr;
	int flush_delay;
	int ip6_rt_max_size;
	int ip6_rt_gc_min_interval;
	int ip6_rt_gc_timeout;
	int ip6_rt_gc_interval;
	int ip6_rt_gc_elasticity;
	int ip6_rt_mtu_expires;
	int ip6_rt_min_advmss;
	u32 multipath_hash_fields;
	u8 multipath_hash_policy;
	u8 bindv6only;
	u8 flowlabel_consistency;
	u8 auto_flowlabels;
	int icmpv6_time;
	u8 icmpv6_echo_ignore_all;
	u8 icmpv6_echo_ignore_multicast;
	u8 icmpv6_echo_ignore_anycast;
	long unsigned int icmpv6_ratemask[8];
	long unsigned int *icmpv6_ratemask_ptr;
	u8 anycast_src_echo_reply;
	u8 ip_nonlocal_bind;
	u8 fwmark_reflect;
	u8 flowlabel_state_ranges;
	int idgen_retries;
	int idgen_delay;
	int flowlabel_reflect;
	int max_dst_opts_cnt;
	int max_hbh_opts_cnt;
	int max_dst_opts_len;
	int max_hbh_opts_len;
	int seg6_flowlabel;
	u32 ioam6_id;
	u64 ioam6_id_wide;
	bool skip_notify_on_dev_down;
	u8 fib_notify_on_flag_change;
	int: 16;
	int: 32;
};

struct ipv6_devconf;

struct fib6_info;

struct rt6_info;

struct rt6_statistics;

struct fib6_table;

struct seg6_pernet_data;

struct ioam6_pernet_data;

struct netns_ipv6 {
	struct dst_ops ip6_dst_ops;
	struct netns_sysctl_ipv6 sysctl;
	struct ipv6_devconf *devconf_all;
	struct ipv6_devconf *devconf_dflt;
	struct inet_peer_base *peers;
	struct fqdir *fqdir;
	struct fib6_info *fib6_null_entry;
	struct rt6_info *ip6_null_entry;
	struct rt6_statistics *rt6_stats;
	struct timer_list ip6_fib_timer;
	struct hlist_head *fib_table_hash;
	struct fib6_table *fib6_main_tbl;
	struct list_head fib6_walkers;
	rwlock_t fib6_walker_lock;
	spinlock_t fib6_gc_lock;
	atomic_t ip6_rt_gc_expire;
	long unsigned int ip6_rt_last_gc;
	unsigned char flowlabel_has_excl;
	struct sock *ndisc_sk;
	struct sock *tcp_sk;
	struct sock *igmp_sk;
	struct sock *mc_autojoin_sk;
	struct hlist_head *inet6_addr_lst;
	spinlock_t addrconf_hash_lock;
	struct delayed_work addr_chk_work;
	atomic_t dev_addr_genid;
	atomic_t fib6_sernum;
	struct seg6_pernet_data *seg6_data;
	struct fib_notifier_ops *notifier_ops;
	struct fib_notifier_ops *ip6mr_notifier_ops;
	unsigned int ipmr_seq;
	struct {
		struct hlist_head head;
		spinlock_t lock;
		u32 seq;
	} ip6addrlbl_table;
	struct ioam6_pernet_data *ioam6_data;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct nf_logger;

struct nf_hook_entries;

struct netns_nf {
	struct proc_dir_entry *proc_netfilter;
	const struct nf_logger *nf_loggers[11];
	struct ctl_table_header *nf_log_dir_header;
	struct nf_hook_entries *hooks_ipv4[5];
	struct nf_hook_entries *hooks_ipv6[5];
	struct nf_hook_entries *hooks_arp[3];
	struct nf_hook_entries *hooks_bridge[5];
	unsigned int defrag_ipv4_users;
	unsigned int defrag_ipv6_users;
};

struct nf_generic_net {
	unsigned int timeout;
};

struct nf_tcp_net {
	unsigned int timeouts[14];
	u8 tcp_loose;
	u8 tcp_be_liberal;
	u8 tcp_max_retrans;
	u8 tcp_ignore_invalid_rst;
	unsigned int offload_timeout;
};

struct nf_udp_net {
	unsigned int timeouts[2];
	unsigned int offload_timeout;
};

struct nf_icmp_net {
	unsigned int timeout;
};

struct nf_dccp_net {
	u8 dccp_loose;
	unsigned int dccp_timeout[10];
};

struct nf_sctp_net {
	unsigned int timeouts[10];
};

struct nf_gre_net {
	struct list_head keymap_list;
	unsigned int timeouts[2];
};

struct nf_ip_net {
	struct nf_generic_net generic;
	struct nf_tcp_net tcp;
	struct nf_udp_net udp;
	struct nf_icmp_net icmp;
	struct nf_icmp_net icmpv6;
	struct nf_dccp_net dccp;
	struct nf_sctp_net sctp;
	struct nf_gre_net gre;
};

struct ip_conntrack_stat;

struct nf_ct_event_notifier;

struct netns_ct {
	u8 ctnetlink_has_listener;
	bool ecache_dwork_pending;
	u8 sysctl_log_invalid;
	u8 sysctl_events;
	u8 sysctl_acct;
	u8 sysctl_tstamp;
	u8 sysctl_checksum;
	struct ip_conntrack_stat *stat;
	struct nf_ct_event_notifier *nf_conntrack_event_cb;
	struct nf_ip_net nf_ct_proto;
	unsigned int labels_used;
};

struct netns_nftables {
	u8 gencursor;
};

struct nf_flow_table_stat;

struct netns_ft {
	struct nf_flow_table_stat *stat;
};

struct sk_buff_list {
	struct sk_buff *next;
	struct sk_buff *prev;
};

struct sk_buff_head {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
		};
		struct sk_buff_list list;
	};
	__u32 qlen;
	spinlock_t lock;
};

struct netns_bpf {
	struct bpf_prog_array *run_array[2];
	struct bpf_prog *progs[2];
	struct list_head links[2];
};

struct can_dev_rcv_lists;

struct can_pkg_stats;

struct can_rcv_lists_stats;

struct netns_can {
	struct proc_dir_entry *proc_dir;
	struct proc_dir_entry *pde_stats;
	struct proc_dir_entry *pde_reset_stats;
	struct proc_dir_entry *pde_rcvlist_all;
	struct proc_dir_entry *pde_rcvlist_fil;
	struct proc_dir_entry *pde_rcvlist_inv;
	struct proc_dir_entry *pde_rcvlist_sff;
	struct proc_dir_entry *pde_rcvlist_eff;
	struct proc_dir_entry *pde_rcvlist_err;
	struct proc_dir_entry *bcmproc_dir;
	struct can_dev_rcv_lists *rx_alldev_list;
	spinlock_t rcvlists_lock;
	struct timer_list stattimer;
	struct can_pkg_stats *pkg_stats;
	struct can_rcv_lists_stats *rcv_lists_stats;
	struct hlist_head cgw_list;
};

struct uevent_sock;

struct net_generic;

struct net {
	refcount_t passive;
	spinlock_t rules_mod_lock;
	atomic_t dev_unreg_count;
	unsigned int dev_base_seq;
	int ifindex;
	spinlock_t nsid_lock;
	atomic_t fnhe_genid;
	struct list_head list;
	struct list_head exit_list;
	struct llist_node cleanup_list;
	struct key_tag *key_domain;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct idr netns_ids;
	struct ns_common ns;
	struct ref_tracker_dir refcnt_tracker;
	struct list_head dev_base_head;
	struct proc_dir_entry *proc_net;
	struct proc_dir_entry *proc_net_stat;
	struct ctl_table_set sysctls;
	struct sock *rtnl;
	struct sock *genl_sock;
	struct uevent_sock *uevent_sock;
	struct hlist_head *dev_name_head;
	struct hlist_head *dev_index_head;
	struct raw_notifier_head netdev_chain;
	u32 hash_mix;
	struct net_device *loopback_dev;
	struct list_head rules_ops;
	struct netns_core core;
	struct netns_mib mib;
	struct netns_packet packet;
	struct netns_unix unx;
	struct netns_nexthop nexthop;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct netns_ipv4 ipv4;
	struct netns_ipv6 ipv6;
	struct netns_nf nf;
	struct netns_ct ct;
	struct netns_nftables nft;
	struct netns_ft ft;
	struct sk_buff_head wext_nlevents;
	struct net_generic *gen;
	struct netns_bpf bpf;
	u64 net_cookie;
	struct netns_can can;
	struct sock *crypto_nlsk;
	struct sock *diag_nlsk;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct cgroup_namespace {
	struct ns_common ns;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct css_set *root_cset;
};

struct nsset {
	unsigned int flags;
	struct nsproxy *nsproxy;
	struct fs_struct *fs;
	const struct cred *cred;
};

struct proc_ns_operations {
	const char *name;
	const char *real_ns_name;
	int type;
	struct ns_common * (*get)(struct task_struct *);
	void (*put)(struct ns_common *);
	int (*install)(struct nsset *, struct ns_common *);
	struct user_namespace * (*owner)(struct ns_common *);
	struct ns_common * (*get_parent)(struct ns_common *);
};

struct perf_regs {
	__u64 abi;
	struct pt_regs *regs;
	int: 32;
};

struct u64_stats_sync {
	seqcount_t seq;
};

struct psi_group {};

struct cgroup_taskset;

struct cftype;

struct cgroup_subsys {
	struct cgroup_subsys_state * (*css_alloc)(struct cgroup_subsys_state *);
	int (*css_online)(struct cgroup_subsys_state *);
	void (*css_offline)(struct cgroup_subsys_state *);
	void (*css_released)(struct cgroup_subsys_state *);
	void (*css_free)(struct cgroup_subsys_state *);
	void (*css_reset)(struct cgroup_subsys_state *);
	void (*css_rstat_flush)(struct cgroup_subsys_state *, int);
	int (*css_extra_stat_show)(struct seq_file *, struct cgroup_subsys_state *);
	int (*can_attach)(struct cgroup_taskset *);
	void (*cancel_attach)(struct cgroup_taskset *);
	void (*attach)(struct cgroup_taskset *);
	void (*post_attach)();
	int (*can_fork)(struct task_struct *, struct css_set *);
	void (*cancel_fork)(struct task_struct *, struct css_set *);
	void (*fork)(struct task_struct *);
	void (*exit)(struct task_struct *);
	void (*release)(struct task_struct *);
	void (*bind)(struct cgroup_subsys_state *);
	bool early_init: 1;
	bool implicit_on_dfl: 1;
	bool threaded: 1;
	int id;
	const char *name;
	const char *legacy_name;
	struct cgroup_root *root;
	struct idr css_idr;
	struct list_head cfts;
	struct cftype *dfl_cftypes;
	struct cftype *legacy_cftypes;
	unsigned int depends_on;
};

struct cgroup_rstat_cpu {
	struct u64_stats_sync bsync;
	int: 32;
	struct cgroup_base_stat bstat;
	struct cgroup_base_stat last_bstat;
	struct cgroup *updated_children;
	struct cgroup *updated_next;
};

struct cgroup_root {
	struct kernfs_root *kf_root;
	unsigned int subsys_mask;
	int hierarchy_id;
	int: 32;
	struct cgroup cgrp;
	struct cgroup *cgrp_ancestor_storage;
	atomic_t nr_cgrps;
	struct list_head root_list;
	unsigned int flags;
	char release_agent_path[4096];
	char name[64];
	int: 32;
};

struct cftype {
	char name[64];
	long unsigned int private;
	size_t max_write_len;
	unsigned int flags;
	unsigned int file_offset;
	struct cgroup_subsys *ss;
	struct list_head node;
	struct kernfs_ops *kf_ops;
	int (*open)(struct kernfs_open_file *);
	void (*release)(struct kernfs_open_file *);
	u64 (*read_u64)(struct cgroup_subsys_state *, struct cftype *);
	s64 (*read_s64)(struct cgroup_subsys_state *, struct cftype *);
	int (*seq_show)(struct seq_file *, void *);
	void * (*seq_start)(struct seq_file *, loff_t *);
	void * (*seq_next)(struct seq_file *, void *, loff_t *);
	void (*seq_stop)(struct seq_file *, void *);
	int (*write_u64)(struct cgroup_subsys_state *, struct cftype *, u64);
	int (*write_s64)(struct cgroup_subsys_state *, struct cftype *, s64);
	ssize_t (*write)(struct kernfs_open_file *, char *, size_t, loff_t);
	__poll_t (*poll)(struct kernfs_open_file *, struct poll_table_struct *);
};

struct perf_callchain_entry {
	__u64 nr;
	__u64 ip[0];
};

typedef long unsigned int (*perf_copy_f)(void *, const void *, long unsigned int, long unsigned int);

struct perf_raw_frag {
	union {
		struct perf_raw_frag *next;
		long unsigned int pad;
	};
	perf_copy_f copy;
	void *data;
	u32 size;
};

struct perf_raw_record {
	struct perf_raw_frag frag;
	u32 size;
};

struct perf_branch_stack {
	__u64 nr;
	__u64 hw_idx;
	struct perf_branch_entry entries[0];
};

struct perf_cpu_context;

struct perf_output_handle;

struct pmu {
	struct list_head entry;
	struct module *module;
	struct device *dev;
	const struct attribute_group **attr_groups;
	const struct attribute_group **attr_update;
	const char *name;
	int type;
	int capabilities;
	int *pmu_disable_count;
	struct perf_cpu_context *pmu_cpu_context;
	atomic_t exclusive_cnt;
	int task_ctx_nr;
	int hrtimer_interval_ms;
	unsigned int nr_addr_filters;
	void (*pmu_enable)(struct pmu *);
	void (*pmu_disable)(struct pmu *);
	int (*event_init)(struct perf_event *);
	void (*event_mapped)(struct perf_event *, struct mm_struct *);
	void (*event_unmapped)(struct perf_event *, struct mm_struct *);
	int (*add)(struct perf_event *, int);
	void (*del)(struct perf_event *, int);
	void (*start)(struct perf_event *, int);
	void (*stop)(struct perf_event *, int);
	void (*read)(struct perf_event *);
	void (*start_txn)(struct pmu *, unsigned int);
	int (*commit_txn)(struct pmu *);
	void (*cancel_txn)(struct pmu *);
	int (*event_idx)(struct perf_event *);
	void (*sched_task)(struct perf_event_context *, bool);
	struct kmem_cache *task_ctx_cache;
	void (*swap_task_ctx)(struct perf_event_context *, struct perf_event_context *);
	void * (*setup_aux)(struct perf_event *, void **, int, bool);
	void (*free_aux)(void *);
	long int (*snapshot_aux)(struct perf_event *, struct perf_output_handle *, long unsigned int);
	int (*addr_filters_validate)(struct list_head *);
	void (*addr_filters_sync)(struct perf_event *);
	int (*aux_output_match)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int (*check_period)(struct perf_event *, u64);
};

struct perf_cpu_context {
	struct perf_event_context ctx;
	struct perf_event_context *task_ctx;
	int active_oncpu;
	int exclusive;
	raw_spinlock_t hrtimer_lock;
	struct hrtimer hrtimer;
	ktime_t hrtimer_interval;
	unsigned int hrtimer_active;
	struct list_head sched_cb_entry;
	int sched_cb_usage;
	int online;
	int heap_size;
	struct perf_event **heap;
	struct perf_event *heap_default[2];
	int: 32;
};

struct perf_output_handle {
	struct perf_event *event;
	struct perf_buffer *rb;
	long unsigned int wakeup;
	long unsigned int size;
	u64 aux_flags;
	union {
		void *addr;
		long unsigned int head;
	};
	int page;
};

struct perf_addr_filter_range {
	long unsigned int start;
	long unsigned int size;
};

struct perf_sample_data {
	u64 sample_flags;
	u64 period;
	struct perf_branch_stack *br_stack;
	int: 32;
	union perf_sample_weight weight;
	union perf_mem_data_src data_src;
	u64 txn;
	u64 addr;
	struct perf_raw_record *raw;
	int: 32;
	u64 type;
	u64 ip;
	struct {
		u32 pid;
		u32 tid;
	} tid_entry;
	u64 time;
	u64 id;
	u64 stream_id;
	struct {
		u32 cpu;
		u32 reserved;
	} cpu_entry;
	struct perf_callchain_entry *callchain;
	int: 32;
	u64 aux_size;
	struct perf_regs regs_user;
	struct perf_regs regs_intr;
	u64 stack_user_size;
	u64 phys_addr;
	u64 cgroup;
	u64 data_page_size;
	u64 code_page_size;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct trace_entry {
	short unsigned int type;
	unsigned char flags;
	unsigned char preempt_count;
	int pid;
};

struct trace_array;

struct tracer;

struct array_buffer;

struct ring_buffer_iter;

struct trace_iterator {
	struct trace_array *tr;
	struct tracer *trace;
	struct array_buffer *array_buffer;
	void *private;
	int cpu_file;
	struct mutex mutex;
	struct ring_buffer_iter **buffer_iter;
	long unsigned int iter_flags;
	void *temp;
	unsigned int temp_size;
	char *fmt;
	unsigned int fmt_size;
	long int wait_index;
	int: 32;
	struct trace_seq tmp_seq;
	cpumask_var_t started;
	bool snapshot;
	struct trace_seq seq;
	struct trace_entry *ent;
	long unsigned int lost_events;
	int leftover;
	int ent_size;
	int cpu;
	int: 32;
	u64 ts;
	loff_t pos;
	long int idx;
	int: 32;
};

enum print_line_t {
	TRACE_TYPE_PARTIAL_LINE = 0,
	TRACE_TYPE_HANDLED = 1,
	TRACE_TYPE_UNHANDLED = 2,
	TRACE_TYPE_NO_CONSUME = 3,
};

typedef enum print_line_t (*trace_print_func)(struct trace_iterator *, int, struct trace_event *);

struct trace_event_functions {
	trace_print_func trace;
	trace_print_func raw;
	trace_print_func hex;
	trace_print_func binary;
};

enum trace_reg {
	TRACE_REG_REGISTER = 0,
	TRACE_REG_UNREGISTER = 1,
	TRACE_REG_PERF_REGISTER = 2,
	TRACE_REG_PERF_UNREGISTER = 3,
	TRACE_REG_PERF_OPEN = 4,
	TRACE_REG_PERF_CLOSE = 5,
	TRACE_REG_PERF_ADD = 6,
	TRACE_REG_PERF_DEL = 7,
};

struct trace_event_fields {
	const char *type;
	union {
		struct {
			const char *name;
			const int size;
			const int align;
			const int is_signed;
			const int filter_type;
		};
		int (*define_fields)(struct trace_event_call *);
	};
};

struct trace_event_class {
	const char *system;
	void *probe;
	void *perf_probe;
	int (*reg)(struct trace_event_call *, enum trace_reg, void *);
	struct trace_event_fields *fields_array;
	struct list_head * (*get_fields)(struct trace_event_call *);
	struct list_head fields;
	int (*raw_init)(struct trace_event_call *);
};

struct trace_buffer;

struct trace_event_file;

struct trace_event_buffer {
	struct trace_buffer *buffer;
	struct ring_buffer_event *event;
	struct trace_event_file *trace_file;
	void *entry;
	unsigned int trace_ctx;
	struct pt_regs *regs;
};

struct trace_subsystem_dir;

struct trace_event_file {
	struct list_head list;
	struct trace_event_call *event_call;
	struct event_filter *filter;
	struct dentry *dir;
	struct trace_array *tr;
	struct trace_subsystem_dir *system;
	struct list_head triggers;
	long unsigned int flags;
	atomic_t sm_ref;
	atomic_t tm_ref;
};

enum {
	TRACE_EVENT_FL_FILTERED = 1,
	TRACE_EVENT_FL_CAP_ANY = 2,
	TRACE_EVENT_FL_NO_SET_FILTER = 4,
	TRACE_EVENT_FL_IGNORE_ENABLE = 8,
	TRACE_EVENT_FL_TRACEPOINT = 16,
	TRACE_EVENT_FL_DYNAMIC = 32,
	TRACE_EVENT_FL_KPROBE = 64,
	TRACE_EVENT_FL_UPROBE = 128,
	TRACE_EVENT_FL_EPROBE = 256,
	TRACE_EVENT_FL_CUSTOM = 512,
};

enum {
	EVENT_FILE_FL_ENABLED = 1,
	EVENT_FILE_FL_RECORDED_CMD = 2,
	EVENT_FILE_FL_RECORDED_TGID = 4,
	EVENT_FILE_FL_FILTERED = 8,
	EVENT_FILE_FL_NO_SET_FILTER = 16,
	EVENT_FILE_FL_SOFT_MODE = 32,
	EVENT_FILE_FL_SOFT_DISABLED = 64,
	EVENT_FILE_FL_TRIGGER_MODE = 128,
	EVENT_FILE_FL_TRIGGER_COND = 256,
	EVENT_FILE_FL_PID_FILTER = 512,
	EVENT_FILE_FL_WAS_ENABLED = 1024,
};

enum {
	FILTER_OTHER = 0,
	FILTER_STATIC_STRING = 1,
	FILTER_DYN_STRING = 2,
	FILTER_RDYN_STRING = 3,
	FILTER_PTR_STRING = 4,
	FILTER_TRACE_FN = 5,
	FILTER_COMM = 6,
	FILTER_CPU = 7,
};

struct property {
	char *name;
	int length;
	void *value;
	struct property *next;
	long unsigned int _flags;
	struct bin_attribute attr;
};

struct irq_fwspec {
	struct fwnode_handle *fwnode;
	int param_count;
	u32 param[16];
};

struct irq_domain_ops {
	int (*match)(struct irq_domain *, struct device_node *, enum irq_domain_bus_token);
	int (*select)(struct irq_domain *, struct irq_fwspec *, enum irq_domain_bus_token);
	int (*map)(struct irq_domain *, unsigned int, irq_hw_number_t);
	void (*unmap)(struct irq_domain *, unsigned int);
	int (*xlate)(struct irq_domain *, struct device_node *, const u32 *, unsigned int, long unsigned int *, unsigned int *);
	int (*alloc)(struct irq_domain *, unsigned int, unsigned int, void *);
	void (*free)(struct irq_domain *, unsigned int, unsigned int);
	int (*activate)(struct irq_domain *, struct irq_data *, bool);
	void (*deactivate)(struct irq_domain *, struct irq_data *);
	int (*translate)(struct irq_domain *, struct irq_fwspec *, long unsigned int *, unsigned int *);
};

enum fixed_addresses {
	FIX_EARLYCON_MEM_BASE = 0,
	__end_of_permanent_fixed_addresses = 1,
	FIX_KMAP_BEGIN = 1,
	FIX_KMAP_END = 64,
	FIX_TEXT_POKE0 = 65,
	FIX_TEXT_POKE1 = 66,
	__end_of_fixmap_region = 67,
	FIX_BTMAP_END = 1,
	FIX_BTMAP_BEGIN = 224,
	__end_of_early_ioremap_region = 225,
};

typedef void *mempool_alloc_t(gfp_t, void *);

typedef void mempool_free_t(void *, void *);

struct mempool_s {
	spinlock_t lock;
	int min_nr;
	int curr_nr;
	void **elements;
	void *pool_data;
	mempool_alloc_t *alloc;
	mempool_free_t *free;
	wait_queue_head_t wait;
};

typedef struct mempool_s mempool_t;

struct bio_alloc_cache;

struct bio_set {
	struct kmem_cache *bio_slab;
	unsigned int front_pad;
	struct bio_alloc_cache *cache;
	mempool_t bio_pool;
	mempool_t bvec_pool;
	unsigned int back_pad;
	spinlock_t rescue_lock;
	struct bio_list rescue_list;
	struct work_struct rescue_work;
	struct workqueue_struct *rescue_workqueue;
	struct hlist_node cpuhp_dead;
};

struct block_device_operations;

struct timer_rand_state;

struct disk_events;

struct badblocks;

struct blk_independent_access_ranges;

struct gendisk {
	int major;
	int first_minor;
	int minors;
	char disk_name[32];
	short unsigned int events;
	short unsigned int event_flags;
	struct xarray part_tbl;
	struct block_device *part0;
	const struct block_device_operations *fops;
	struct request_queue *queue;
	void *private_data;
	struct bio_set bio_split;
	int flags;
	long unsigned int state;
	struct mutex open_mutex;
	unsigned int open_partitions;
	struct backing_dev_info *bdi;
	struct kobject *slave_dir;
	struct list_head slave_bdevs;
	struct timer_rand_state *random;
	atomic_t sync_io;
	struct disk_events *ev;
	int node_id;
	struct badblocks *bb;
	struct lockdep_map lockdep_map;
	u64 diskseq;
	struct blk_independent_access_ranges *ia_ranges;
	int: 32;
};

struct partition_meta_info {
	char uuid[37];
	u8 volname[64];
};

enum req_op {
	REQ_OP_READ = 0,
	REQ_OP_WRITE = 1,
	REQ_OP_FLUSH = 2,
	REQ_OP_DISCARD = 3,
	REQ_OP_SECURE_ERASE = 5,
	REQ_OP_WRITE_ZEROES = 9,
	REQ_OP_ZONE_OPEN = 10,
	REQ_OP_ZONE_CLOSE = 11,
	REQ_OP_ZONE_FINISH = 12,
	REQ_OP_ZONE_APPEND = 13,
	REQ_OP_ZONE_RESET = 15,
	REQ_OP_ZONE_RESET_ALL = 17,
	REQ_OP_DRV_IN = 34,
	REQ_OP_DRV_OUT = 35,
	REQ_OP_LAST = 36,
};

struct blk_rq_stat {
	u64 mean;
	u64 min;
	u64 max;
	u32 nr_samples;
	int: 32;
	u64 batch;
};

enum memcg_memory_event {
	MEMCG_LOW = 0,
	MEMCG_HIGH = 1,
	MEMCG_MAX = 2,
	MEMCG_OOM = 3,
	MEMCG_OOM_KILL = 4,
	MEMCG_OOM_GROUP_KILL = 5,
	MEMCG_SWAP_HIGH = 6,
	MEMCG_SWAP_MAX = 7,
	MEMCG_SWAP_FAIL = 8,
	MEMCG_NR_MEMORY_EVENTS = 9,
};

struct mem_cgroup_reclaim_iter {
	struct mem_cgroup *position;
	unsigned int generation;
};

struct shrinker_info {
	struct callback_head rcu;
	atomic_long_t *nr_deferred;
	long unsigned int *map;
};

struct lruvec_stats_percpu {
	long int state[41];
	long int state_prev[41];
};

struct lruvec_stats {
	long int state[41];
	long int state_pending[41];
};

struct mem_cgroup_per_node {
	struct lruvec lruvec;
	struct lruvec_stats_percpu *lruvec_stats_percpu;
	struct lruvec_stats lruvec_stats;
	long unsigned int lru_zone_size[15];
	struct mem_cgroup_reclaim_iter iter;
	struct shrinker_info *shrinker_info;
	struct rb_node tree_node;
	long unsigned int usage_in_excess;
	bool on_tree;
	struct mem_cgroup *memcg;
};

struct eventfd_ctx;

struct mem_cgroup_threshold {
	struct eventfd_ctx *eventfd;
	long unsigned int threshold;
};

struct mem_cgroup_threshold_ary {
	int current_threshold;
	unsigned int size;
	struct mem_cgroup_threshold entries[0];
};

struct obj_cgroup {
	struct percpu_ref refcnt;
	struct mem_cgroup *memcg;
	atomic_t nr_charged_bytes;
	union {
		struct list_head list;
		struct callback_head rcu;
	};
};

struct percpu_cluster {
	struct swap_cluster_info index;
	unsigned int next;
};

enum fs_value_type {
	fs_value_is_undefined = 0,
	fs_value_is_flag = 1,
	fs_value_is_string = 2,
	fs_value_is_blob = 3,
	fs_value_is_filename = 4,
	fs_value_is_file = 5,
};

struct fs_parameter {
	const char *key;
	enum fs_value_type type: 8;
	union {
		char *string;
		void *blob;
		struct filename *name;
		struct file *file;
	};
	size_t size;
	int dirfd;
};

struct fc_log {
	refcount_t usage;
	u8 head;
	u8 tail;
	u8 need_free;
	struct module *owner;
	char *buffer[8];
};

struct fs_context_operations {
	void (*free)(struct fs_context *);
	int (*dup)(struct fs_context *, struct fs_context *);
	int (*parse_param)(struct fs_context *, struct fs_parameter *);
	int (*parse_monolithic)(struct fs_context *, void *);
	int (*get_tree)(struct fs_context *);
	int (*reconfigure)(struct fs_context *);
};

struct fs_parse_result {
	bool negated;
	int: 24;
	int: 32;
	union {
		bool boolean;
		int int_32;
		unsigned int uint_32;
		u64 uint_64;
	};
};

struct iovec {
	void *iov_base;
	__kernel_size_t iov_len;
};

struct kvec {
	void *iov_base;
	size_t iov_len;
};

struct blk_zone {
	__u64 start;
	__u64 len;
	__u64 wp;
	__u8 type;
	__u8 cond;
	__u8 non_seq;
	__u8 reset;
	__u8 resv[4];
	__u64 capacity;
	__u8 reserved[24];
};

typedef int (*report_zones_cb)(struct blk_zone *, unsigned int, void *);

enum blk_unique_id {
	BLK_UID_T10 = 1,
	BLK_UID_EUI64 = 2,
	BLK_UID_NAA = 3,
};

struct hd_geometry;

struct pr_ops;

struct block_device_operations {
	void (*submit_bio)(struct bio *);
	int (*poll_bio)(struct bio *, struct io_comp_batch *, unsigned int);
	int (*open)(struct block_device *, fmode_t);
	void (*release)(struct gendisk *, fmode_t);
	int (*rw_page)(struct block_device *, sector_t, struct page *, enum req_op);
	int (*ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct block_device *, fmode_t, unsigned int, long unsigned int);
	unsigned int (*check_events)(struct gendisk *, unsigned int);
	void (*unlock_native_capacity)(struct gendisk *);
	int (*getgeo)(struct block_device *, struct hd_geometry *);
	int (*set_read_only)(struct block_device *, bool);
	void (*free_disk)(struct gendisk *);
	void (*swap_slot_free_notify)(struct block_device *, long unsigned int);
	int (*report_zones)(struct gendisk *, sector_t, unsigned int, report_zones_cb, void *);
	char * (*devnode)(struct gendisk *, umode_t *);
	int (*get_unique_id)(struct gendisk *, u8 *, enum blk_unique_id);
	struct module *owner;
	const struct pr_ops *pr_ops;
	int (*alternative_gpt_sector)(struct gendisk *, sector_t *);
};

struct blk_independent_access_range {
	struct kobject kobj;
	int: 32;
	sector_t sector;
	sector_t nr_sectors;
};

struct blk_independent_access_ranges {
	struct kobject kobj;
	bool sysfs_registered;
	unsigned int nr_ia_ranges;
	int: 32;
	struct blk_independent_access_range ia_range[0];
};

enum blk_eh_timer_return {
	BLK_EH_DONE = 0,
	BLK_EH_RESET_TIMER = 1,
};

struct blk_mq_hw_ctx;

struct blk_mq_queue_data;

struct blk_mq_ops {
	blk_status_t (*queue_rq)(struct blk_mq_hw_ctx *, const struct blk_mq_queue_data *);
	void (*commit_rqs)(struct blk_mq_hw_ctx *);
	void (*queue_rqs)(struct request **);
	int (*get_budget)(struct request_queue *);
	void (*put_budget)(struct request_queue *, int);
	void (*set_rq_budget_token)(struct request *, int);
	int (*get_rq_budget_token)(struct request *);
	enum blk_eh_timer_return (*timeout)(struct request *);
	int (*poll)(struct blk_mq_hw_ctx *, struct io_comp_batch *);
	void (*complete)(struct request *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, void *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	int (*init_request)(struct blk_mq_tag_set *, struct request *, unsigned int, unsigned int);
	void (*exit_request)(struct blk_mq_tag_set *, struct request *, unsigned int);
	void (*cleanup_rq)(struct request *);
	bool (*busy)(struct request_queue *);
	void (*map_queues)(struct blk_mq_tag_set *);
	void (*show_rq)(struct seq_file *, struct request *);
};

enum pr_type {
	PR_WRITE_EXCLUSIVE = 1,
	PR_EXCLUSIVE_ACCESS = 2,
	PR_WRITE_EXCLUSIVE_REG_ONLY = 3,
	PR_EXCLUSIVE_ACCESS_REG_ONLY = 4,
	PR_WRITE_EXCLUSIVE_ALL_REGS = 5,
	PR_EXCLUSIVE_ACCESS_ALL_REGS = 6,
};

struct pr_ops {
	int (*pr_register)(struct block_device *, u64, u64, u32);
	int (*pr_reserve)(struct block_device *, u64, enum pr_type, u32);
	int (*pr_release)(struct block_device *, u64, enum pr_type);
	int (*pr_preempt)(struct block_device *, u64, u64, enum pr_type, bool);
	int (*pr_clear)(struct block_device *, u64);
};

typedef unsigned char *sk_buff_data_t;

struct sk_buff {
	union {
		struct {
			struct sk_buff *next;
			struct sk_buff *prev;
			union {
				struct net_device *dev;
				long unsigned int dev_scratch;
			};
		};
		struct rb_node rbnode;
		struct list_head list;
		struct llist_node ll_node;
	};
	union {
		struct sock *sk;
		int ip_defrag_offset;
	};
	union {
		ktime_t tstamp;
		u64 skb_mstamp_ns;
	};
	char cb[48];
	union {
		struct {
			long unsigned int _skb_refdst;
			void (*destructor)(struct sk_buff *);
		};
		struct list_head tcp_tsorted_anchor;
		long unsigned int _sk_redir;
	};
	long unsigned int _nfct;
	unsigned int len;
	unsigned int data_len;
	__u16 mac_len;
	__u16 hdr_len;
	__u16 queue_mapping;
	__u8 __cloned_offset[0];
	__u8 cloned: 1;
	__u8 nohdr: 1;
	__u8 fclone: 2;
	__u8 peeked: 1;
	__u8 head_frag: 1;
	__u8 pfmemalloc: 1;
	__u8 pp_recycle: 1;
	union {
		struct {
			__u8 __pkt_type_offset[0];
			__u8 pkt_type: 3;
			__u8 ignore_df: 1;
			__u8 nf_trace: 1;
			__u8 ip_summed: 2;
			__u8 ooo_okay: 1;
			__u8 l4_hash: 1;
			__u8 sw_hash: 1;
			__u8 wifi_acked_valid: 1;
			__u8 wifi_acked: 1;
			__u8 no_fcs: 1;
			__u8 encapsulation: 1;
			__u8 encap_hdr_csum: 1;
			__u8 csum_valid: 1;
			__u8 __pkt_vlan_present_offset[0];
			__u8 vlan_present: 1;
			__u8 csum_complete_sw: 1;
			__u8 csum_level: 2;
			__u8 dst_pending_confirm: 1;
			__u8 mono_delivery_time: 1;
			__u8 tc_skip_classify: 1;
			__u8 tc_at_ingress: 1;
			__u8 ndisc_nodetype: 2;
			__u8 ipvs_property: 1;
			__u8 inner_protocol_type: 1;
			__u8 remcsum_offload: 1;
			__u8 offload_fwd_mark: 1;
			__u8 offload_l3_fwd_mark: 1;
			__u8 redirected: 1;
			__u8 nf_skip_egress: 1;
			__u8 decrypted: 1;
			__u8 slow_gro: 1;
			__u8 csum_not_inet: 1;
			__u8 scm_io_uring: 1;
			__u16 tc_index;
			union {
				__wsum csum;
				struct {
					__u16 csum_start;
					__u16 csum_offset;
				};
			};
			__u32 priority;
			int skb_iif;
			__u32 hash;
			__be16 vlan_proto;
			__u16 vlan_tci;
			union {
				unsigned int napi_id;
				unsigned int sender_cpu;
			};
			u16 alloc_cpu;
			union {
				__u32 mark;
				__u32 reserved_tailroom;
			};
			union {
				__be16 inner_protocol;
				__u8 inner_ipproto;
			};
			__u16 inner_transport_header;
			__u16 inner_network_header;
			__u16 inner_mac_header;
			__be16 protocol;
			__u16 transport_header;
			__u16 network_header;
			__u16 mac_header;
		};
		struct {
			__u8 __pkt_type_offset[0];
			__u8 pkt_type: 3;
			__u8 ignore_df: 1;
			__u8 nf_trace: 1;
			__u8 ip_summed: 2;
			__u8 ooo_okay: 1;
			__u8 l4_hash: 1;
			__u8 sw_hash: 1;
			__u8 wifi_acked_valid: 1;
			__u8 wifi_acked: 1;
			__u8 no_fcs: 1;
			__u8 encapsulation: 1;
			__u8 encap_hdr_csum: 1;
			__u8 csum_valid: 1;
			__u8 __pkt_vlan_present_offset[0];
			__u8 vlan_present: 1;
			__u8 csum_complete_sw: 1;
			__u8 csum_level: 2;
			__u8 dst_pending_confirm: 1;
			__u8 mono_delivery_time: 1;
			__u8 tc_skip_classify: 1;
			__u8 tc_at_ingress: 1;
			__u8 ndisc_nodetype: 2;
			__u8 ipvs_property: 1;
			__u8 inner_protocol_type: 1;
			__u8 remcsum_offload: 1;
			__u8 offload_fwd_mark: 1;
			__u8 offload_l3_fwd_mark: 1;
			__u8 redirected: 1;
			__u8 nf_skip_egress: 1;
			__u8 decrypted: 1;
			__u8 slow_gro: 1;
			__u8 csum_not_inet: 1;
			__u8 scm_io_uring: 1;
			__u16 tc_index;
			union {
				__wsum csum;
				struct {
					__u16 csum_start;
					__u16 csum_offset;
				};
			};
			__u32 priority;
			int skb_iif;
			__u32 hash;
			__be16 vlan_proto;
			__u16 vlan_tci;
			union {
				unsigned int napi_id;
				unsigned int sender_cpu;
			};
			u16 alloc_cpu;
			union {
				__u32 mark;
				__u32 reserved_tailroom;
			};
			union {
				__be16 inner_protocol;
				__u8 inner_ipproto;
			};
			__u16 inner_transport_header;
			__u16 inner_network_header;
			__u16 inner_mac_header;
			__be16 protocol;
			__u16 transport_header;
			__u16 network_header;
			__u16 mac_header;
		} headers;
	};
	sk_buff_data_t tail;
	sk_buff_data_t end;
	unsigned char *head;
	unsigned char *data;
	unsigned int truesize;
	refcount_t users;
	int: 32;
};

struct in6_addr {
	union {
		__u8 u6_addr8[16];
		__be16 u6_addr16[8];
		__be32 u6_addr32[4];
	} in6_u;
};

enum flow_dissector_key_id {
	FLOW_DISSECTOR_KEY_CONTROL = 0,
	FLOW_DISSECTOR_KEY_BASIC = 1,
	FLOW_DISSECTOR_KEY_IPV4_ADDRS = 2,
	FLOW_DISSECTOR_KEY_IPV6_ADDRS = 3,
	FLOW_DISSECTOR_KEY_PORTS = 4,
	FLOW_DISSECTOR_KEY_PORTS_RANGE = 5,
	FLOW_DISSECTOR_KEY_ICMP = 6,
	FLOW_DISSECTOR_KEY_ETH_ADDRS = 7,
	FLOW_DISSECTOR_KEY_TIPC = 8,
	FLOW_DISSECTOR_KEY_ARP = 9,
	FLOW_DISSECTOR_KEY_VLAN = 10,
	FLOW_DISSECTOR_KEY_FLOW_LABEL = 11,
	FLOW_DISSECTOR_KEY_GRE_KEYID = 12,
	FLOW_DISSECTOR_KEY_MPLS_ENTROPY = 13,
	FLOW_DISSECTOR_KEY_ENC_KEYID = 14,
	FLOW_DISSECTOR_KEY_ENC_IPV4_ADDRS = 15,
	FLOW_DISSECTOR_KEY_ENC_IPV6_ADDRS = 16,
	FLOW_DISSECTOR_KEY_ENC_CONTROL = 17,
	FLOW_DISSECTOR_KEY_ENC_PORTS = 18,
	FLOW_DISSECTOR_KEY_MPLS = 19,
	FLOW_DISSECTOR_KEY_TCP = 20,
	FLOW_DISSECTOR_KEY_IP = 21,
	FLOW_DISSECTOR_KEY_CVLAN = 22,
	FLOW_DISSECTOR_KEY_ENC_IP = 23,
	FLOW_DISSECTOR_KEY_ENC_OPTS = 24,
	FLOW_DISSECTOR_KEY_META = 25,
	FLOW_DISSECTOR_KEY_CT = 26,
	FLOW_DISSECTOR_KEY_HASH = 27,
	FLOW_DISSECTOR_KEY_NUM_OF_VLANS = 28,
	FLOW_DISSECTOR_KEY_PPPOE = 29,
	FLOW_DISSECTOR_KEY_L2TPV3 = 30,
	FLOW_DISSECTOR_KEY_MAX = 31,
};

enum {
	IPSTATS_MIB_NUM = 0,
	IPSTATS_MIB_INPKTS = 1,
	IPSTATS_MIB_INOCTETS = 2,
	IPSTATS_MIB_INDELIVERS = 3,
	IPSTATS_MIB_OUTFORWDATAGRAMS = 4,
	IPSTATS_MIB_OUTPKTS = 5,
	IPSTATS_MIB_OUTOCTETS = 6,
	IPSTATS_MIB_INHDRERRORS = 7,
	IPSTATS_MIB_INTOOBIGERRORS = 8,
	IPSTATS_MIB_INNOROUTES = 9,
	IPSTATS_MIB_INADDRERRORS = 10,
	IPSTATS_MIB_INUNKNOWNPROTOS = 11,
	IPSTATS_MIB_INTRUNCATEDPKTS = 12,
	IPSTATS_MIB_INDISCARDS = 13,
	IPSTATS_MIB_OUTDISCARDS = 14,
	IPSTATS_MIB_OUTNOROUTES = 15,
	IPSTATS_MIB_REASMTIMEOUT = 16,
	IPSTATS_MIB_REASMREQDS = 17,
	IPSTATS_MIB_REASMOKS = 18,
	IPSTATS_MIB_REASMFAILS = 19,
	IPSTATS_MIB_FRAGOKS = 20,
	IPSTATS_MIB_FRAGFAILS = 21,
	IPSTATS_MIB_FRAGCREATES = 22,
	IPSTATS_MIB_INMCASTPKTS = 23,
	IPSTATS_MIB_OUTMCASTPKTS = 24,
	IPSTATS_MIB_INBCASTPKTS = 25,
	IPSTATS_MIB_OUTBCASTPKTS = 26,
	IPSTATS_MIB_INMCASTOCTETS = 27,
	IPSTATS_MIB_OUTMCASTOCTETS = 28,
	IPSTATS_MIB_INBCASTOCTETS = 29,
	IPSTATS_MIB_OUTBCASTOCTETS = 30,
	IPSTATS_MIB_CSUMERRORS = 31,
	IPSTATS_MIB_NOECTPKTS = 32,
	IPSTATS_MIB_ECT1PKTS = 33,
	IPSTATS_MIB_ECT0PKTS = 34,
	IPSTATS_MIB_CEPKTS = 35,
	IPSTATS_MIB_REASM_OVERLAPS = 36,
	__IPSTATS_MIB_MAX = 37,
};

enum {
	ICMP_MIB_NUM = 0,
	ICMP_MIB_INMSGS = 1,
	ICMP_MIB_INERRORS = 2,
	ICMP_MIB_INDESTUNREACHS = 3,
	ICMP_MIB_INTIMEEXCDS = 4,
	ICMP_MIB_INPARMPROBS = 5,
	ICMP_MIB_INSRCQUENCHS = 6,
	ICMP_MIB_INREDIRECTS = 7,
	ICMP_MIB_INECHOS = 8,
	ICMP_MIB_INECHOREPS = 9,
	ICMP_MIB_INTIMESTAMPS = 10,
	ICMP_MIB_INTIMESTAMPREPS = 11,
	ICMP_MIB_INADDRMASKS = 12,
	ICMP_MIB_INADDRMASKREPS = 13,
	ICMP_MIB_OUTMSGS = 14,
	ICMP_MIB_OUTERRORS = 15,
	ICMP_MIB_OUTDESTUNREACHS = 16,
	ICMP_MIB_OUTTIMEEXCDS = 17,
	ICMP_MIB_OUTPARMPROBS = 18,
	ICMP_MIB_OUTSRCQUENCHS = 19,
	ICMP_MIB_OUTREDIRECTS = 20,
	ICMP_MIB_OUTECHOS = 21,
	ICMP_MIB_OUTECHOREPS = 22,
	ICMP_MIB_OUTTIMESTAMPS = 23,
	ICMP_MIB_OUTTIMESTAMPREPS = 24,
	ICMP_MIB_OUTADDRMASKS = 25,
	ICMP_MIB_OUTADDRMASKREPS = 26,
	ICMP_MIB_CSUMERRORS = 27,
	__ICMP_MIB_MAX = 28,
};

enum {
	ICMP6_MIB_NUM = 0,
	ICMP6_MIB_INMSGS = 1,
	ICMP6_MIB_INERRORS = 2,
	ICMP6_MIB_OUTMSGS = 3,
	ICMP6_MIB_OUTERRORS = 4,
	ICMP6_MIB_CSUMERRORS = 5,
	__ICMP6_MIB_MAX = 6,
};

enum {
	TCP_MIB_NUM = 0,
	TCP_MIB_RTOALGORITHM = 1,
	TCP_MIB_RTOMIN = 2,
	TCP_MIB_RTOMAX = 3,
	TCP_MIB_MAXCONN = 4,
	TCP_MIB_ACTIVEOPENS = 5,
	TCP_MIB_PASSIVEOPENS = 6,
	TCP_MIB_ATTEMPTFAILS = 7,
	TCP_MIB_ESTABRESETS = 8,
	TCP_MIB_CURRESTAB = 9,
	TCP_MIB_INSEGS = 10,
	TCP_MIB_OUTSEGS = 11,
	TCP_MIB_RETRANSSEGS = 12,
	TCP_MIB_INERRS = 13,
	TCP_MIB_OUTRSTS = 14,
	TCP_MIB_CSUMERRORS = 15,
	__TCP_MIB_MAX = 16,
};

enum {
	UDP_MIB_NUM = 0,
	UDP_MIB_INDATAGRAMS = 1,
	UDP_MIB_NOPORTS = 2,
	UDP_MIB_INERRORS = 3,
	UDP_MIB_OUTDATAGRAMS = 4,
	UDP_MIB_RCVBUFERRORS = 5,
	UDP_MIB_SNDBUFERRORS = 6,
	UDP_MIB_CSUMERRORS = 7,
	UDP_MIB_IGNOREDMULTI = 8,
	UDP_MIB_MEMERRORS = 9,
	__UDP_MIB_MAX = 10,
};

enum {
	LINUX_MIB_NUM = 0,
	LINUX_MIB_SYNCOOKIESSENT = 1,
	LINUX_MIB_SYNCOOKIESRECV = 2,
	LINUX_MIB_SYNCOOKIESFAILED = 3,
	LINUX_MIB_EMBRYONICRSTS = 4,
	LINUX_MIB_PRUNECALLED = 5,
	LINUX_MIB_RCVPRUNED = 6,
	LINUX_MIB_OFOPRUNED = 7,
	LINUX_MIB_OUTOFWINDOWICMPS = 8,
	LINUX_MIB_LOCKDROPPEDICMPS = 9,
	LINUX_MIB_ARPFILTER = 10,
	LINUX_MIB_TIMEWAITED = 11,
	LINUX_MIB_TIMEWAITRECYCLED = 12,
	LINUX_MIB_TIMEWAITKILLED = 13,
	LINUX_MIB_PAWSACTIVEREJECTED = 14,
	LINUX_MIB_PAWSESTABREJECTED = 15,
	LINUX_MIB_DELAYEDACKS = 16,
	LINUX_MIB_DELAYEDACKLOCKED = 17,
	LINUX_MIB_DELAYEDACKLOST = 18,
	LINUX_MIB_LISTENOVERFLOWS = 19,
	LINUX_MIB_LISTENDROPS = 20,
	LINUX_MIB_TCPHPHITS = 21,
	LINUX_MIB_TCPPUREACKS = 22,
	LINUX_MIB_TCPHPACKS = 23,
	LINUX_MIB_TCPRENORECOVERY = 24,
	LINUX_MIB_TCPSACKRECOVERY = 25,
	LINUX_MIB_TCPSACKRENEGING = 26,
	LINUX_MIB_TCPSACKREORDER = 27,
	LINUX_MIB_TCPRENOREORDER = 28,
	LINUX_MIB_TCPTSREORDER = 29,
	LINUX_MIB_TCPFULLUNDO = 30,
	LINUX_MIB_TCPPARTIALUNDO = 31,
	LINUX_MIB_TCPDSACKUNDO = 32,
	LINUX_MIB_TCPLOSSUNDO = 33,
	LINUX_MIB_TCPLOSTRETRANSMIT = 34,
	LINUX_MIB_TCPRENOFAILURES = 35,
	LINUX_MIB_TCPSACKFAILURES = 36,
	LINUX_MIB_TCPLOSSFAILURES = 37,
	LINUX_MIB_TCPFASTRETRANS = 38,
	LINUX_MIB_TCPSLOWSTARTRETRANS = 39,
	LINUX_MIB_TCPTIMEOUTS = 40,
	LINUX_MIB_TCPLOSSPROBES = 41,
	LINUX_MIB_TCPLOSSPROBERECOVERY = 42,
	LINUX_MIB_TCPRENORECOVERYFAIL = 43,
	LINUX_MIB_TCPSACKRECOVERYFAIL = 44,
	LINUX_MIB_TCPRCVCOLLAPSED = 45,
	LINUX_MIB_TCPDSACKOLDSENT = 46,
	LINUX_MIB_TCPDSACKOFOSENT = 47,
	LINUX_MIB_TCPDSACKRECV = 48,
	LINUX_MIB_TCPDSACKOFORECV = 49,
	LINUX_MIB_TCPABORTONDATA = 50,
	LINUX_MIB_TCPABORTONCLOSE = 51,
	LINUX_MIB_TCPABORTONMEMORY = 52,
	LINUX_MIB_TCPABORTONTIMEOUT = 53,
	LINUX_MIB_TCPABORTONLINGER = 54,
	LINUX_MIB_TCPABORTFAILED = 55,
	LINUX_MIB_TCPMEMORYPRESSURES = 56,
	LINUX_MIB_TCPMEMORYPRESSURESCHRONO = 57,
	LINUX_MIB_TCPSACKDISCARD = 58,
	LINUX_MIB_TCPDSACKIGNOREDOLD = 59,
	LINUX_MIB_TCPDSACKIGNOREDNOUNDO = 60,
	LINUX_MIB_TCPSPURIOUSRTOS = 61,
	LINUX_MIB_TCPMD5NOTFOUND = 62,
	LINUX_MIB_TCPMD5UNEXPECTED = 63,
	LINUX_MIB_TCPMD5FAILURE = 64,
	LINUX_MIB_SACKSHIFTED = 65,
	LINUX_MIB_SACKMERGED = 66,
	LINUX_MIB_SACKSHIFTFALLBACK = 67,
	LINUX_MIB_TCPBACKLOGDROP = 68,
	LINUX_MIB_PFMEMALLOCDROP = 69,
	LINUX_MIB_TCPMINTTLDROP = 70,
	LINUX_MIB_TCPDEFERACCEPTDROP = 71,
	LINUX_MIB_IPRPFILTER = 72,
	LINUX_MIB_TCPTIMEWAITOVERFLOW = 73,
	LINUX_MIB_TCPREQQFULLDOCOOKIES = 74,
	LINUX_MIB_TCPREQQFULLDROP = 75,
	LINUX_MIB_TCPRETRANSFAIL = 76,
	LINUX_MIB_TCPRCVCOALESCE = 77,
	LINUX_MIB_TCPBACKLOGCOALESCE = 78,
	LINUX_MIB_TCPOFOQUEUE = 79,
	LINUX_MIB_TCPOFODROP = 80,
	LINUX_MIB_TCPOFOMERGE = 81,
	LINUX_MIB_TCPCHALLENGEACK = 82,
	LINUX_MIB_TCPSYNCHALLENGE = 83,
	LINUX_MIB_TCPFASTOPENACTIVE = 84,
	LINUX_MIB_TCPFASTOPENACTIVEFAIL = 85,
	LINUX_MIB_TCPFASTOPENPASSIVE = 86,
	LINUX_MIB_TCPFASTOPENPASSIVEFAIL = 87,
	LINUX_MIB_TCPFASTOPENLISTENOVERFLOW = 88,
	LINUX_MIB_TCPFASTOPENCOOKIEREQD = 89,
	LINUX_MIB_TCPFASTOPENBLACKHOLE = 90,
	LINUX_MIB_TCPSPURIOUS_RTX_HOSTQUEUES = 91,
	LINUX_MIB_BUSYPOLLRXPACKETS = 92,
	LINUX_MIB_TCPAUTOCORKING = 93,
	LINUX_MIB_TCPFROMZEROWINDOWADV = 94,
	LINUX_MIB_TCPTOZEROWINDOWADV = 95,
	LINUX_MIB_TCPWANTZEROWINDOWADV = 96,
	LINUX_MIB_TCPSYNRETRANS = 97,
	LINUX_MIB_TCPORIGDATASENT = 98,
	LINUX_MIB_TCPHYSTARTTRAINDETECT = 99,
	LINUX_MIB_TCPHYSTARTTRAINCWND = 100,
	LINUX_MIB_TCPHYSTARTDELAYDETECT = 101,
	LINUX_MIB_TCPHYSTARTDELAYCWND = 102,
	LINUX_MIB_TCPACKSKIPPEDSYNRECV = 103,
	LINUX_MIB_TCPACKSKIPPEDPAWS = 104,
	LINUX_MIB_TCPACKSKIPPEDSEQ = 105,
	LINUX_MIB_TCPACKSKIPPEDFINWAIT2 = 106,
	LINUX_MIB_TCPACKSKIPPEDTIMEWAIT = 107,
	LINUX_MIB_TCPACKSKIPPEDCHALLENGE = 108,
	LINUX_MIB_TCPWINPROBE = 109,
	LINUX_MIB_TCPKEEPALIVE = 110,
	LINUX_MIB_TCPMTUPFAIL = 111,
	LINUX_MIB_TCPMTUPSUCCESS = 112,
	LINUX_MIB_TCPDELIVERED = 113,
	LINUX_MIB_TCPDELIVEREDCE = 114,
	LINUX_MIB_TCPACKCOMPRESSED = 115,
	LINUX_MIB_TCPZEROWINDOWDROP = 116,
	LINUX_MIB_TCPRCVQDROP = 117,
	LINUX_MIB_TCPWQUEUETOOBIG = 118,
	LINUX_MIB_TCPFASTOPENPASSIVEALTKEY = 119,
	LINUX_MIB_TCPTIMEOUTREHASH = 120,
	LINUX_MIB_TCPDUPLICATEDATAREHASH = 121,
	LINUX_MIB_TCPDSACKRECVSEGS = 122,
	LINUX_MIB_TCPDSACKIGNOREDDUBIOUS = 123,
	LINUX_MIB_TCPMIGRATEREQSUCCESS = 124,
	LINUX_MIB_TCPMIGRATEREQFAILURE = 125,
	__LINUX_MIB_MAX = 126,
};

enum {
	LINUX_MIB_XFRMNUM = 0,
	LINUX_MIB_XFRMINERROR = 1,
	LINUX_MIB_XFRMINBUFFERERROR = 2,
	LINUX_MIB_XFRMINHDRERROR = 3,
	LINUX_MIB_XFRMINNOSTATES = 4,
	LINUX_MIB_XFRMINSTATEPROTOERROR = 5,
	LINUX_MIB_XFRMINSTATEMODEERROR = 6,
	LINUX_MIB_XFRMINSTATESEQERROR = 7,
	LINUX_MIB_XFRMINSTATEEXPIRED = 8,
	LINUX_MIB_XFRMINSTATEMISMATCH = 9,
	LINUX_MIB_XFRMINSTATEINVALID = 10,
	LINUX_MIB_XFRMINTMPLMISMATCH = 11,
	LINUX_MIB_XFRMINNOPOLS = 12,
	LINUX_MIB_XFRMINPOLBLOCK = 13,
	LINUX_MIB_XFRMINPOLERROR = 14,
	LINUX_MIB_XFRMOUTERROR = 15,
	LINUX_MIB_XFRMOUTBUNDLEGENERROR = 16,
	LINUX_MIB_XFRMOUTBUNDLECHECKERROR = 17,
	LINUX_MIB_XFRMOUTNOSTATES = 18,
	LINUX_MIB_XFRMOUTSTATEPROTOERROR = 19,
	LINUX_MIB_XFRMOUTSTATEMODEERROR = 20,
	LINUX_MIB_XFRMOUTSTATESEQERROR = 21,
	LINUX_MIB_XFRMOUTSTATEEXPIRED = 22,
	LINUX_MIB_XFRMOUTPOLBLOCK = 23,
	LINUX_MIB_XFRMOUTPOLDEAD = 24,
	LINUX_MIB_XFRMOUTPOLERROR = 25,
	LINUX_MIB_XFRMFWDHDRERROR = 26,
	LINUX_MIB_XFRMOUTSTATEINVALID = 27,
	LINUX_MIB_XFRMACQUIREERROR = 28,
	__LINUX_MIB_XFRMMAX = 29,
};

enum {
	LINUX_MIB_TLSNUM = 0,
	LINUX_MIB_TLSCURRTXSW = 1,
	LINUX_MIB_TLSCURRRXSW = 2,
	LINUX_MIB_TLSCURRTXDEVICE = 3,
	LINUX_MIB_TLSCURRRXDEVICE = 4,
	LINUX_MIB_TLSTXSW = 5,
	LINUX_MIB_TLSRXSW = 6,
	LINUX_MIB_TLSTXDEVICE = 7,
	LINUX_MIB_TLSRXDEVICE = 8,
	LINUX_MIB_TLSDECRYPTERROR = 9,
	LINUX_MIB_TLSRXDEVICERESYNC = 10,
	LINUX_MIB_TLSDECRYPTRETRY = 11,
	LINUX_MIB_TLSRXNOPADVIOL = 12,
	__LINUX_MIB_TLSMAX = 13,
};

struct ipstats_mib {
	u64 mibs[37];
	struct u64_stats_sync syncp;
	int: 32;
};

struct icmp_mib {
	long unsigned int mibs[28];
};

struct icmpmsg_mib {
	atomic_long_t mibs[512];
};

struct icmpv6_mib {
	long unsigned int mibs[6];
};

struct icmpv6msg_mib {
	atomic_long_t mibs[512];
};

struct tcp_mib {
	long unsigned int mibs[16];
};

struct udp_mib {
	long unsigned int mibs[10];
};

struct linux_mib {
	long unsigned int mibs[126];
};

struct linux_tls_mib {
	long unsigned int mibs[13];
};

struct inet_frags;

struct fqdir {
	long int high_thresh;
	long int low_thresh;
	int timeout;
	int max_dist;
	struct inet_frags *f;
	struct net *net;
	bool dead;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct rhashtable rhashtable;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic_long_t mem;
	struct work_struct destroy_work;
	struct llist_node free_list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct inet_frag_queue;

struct inet_frags {
	unsigned int qsize;
	void (*constructor)(struct inet_frag_queue *, const void *);
	void (*destructor)(struct inet_frag_queue *);
	void (*frag_expire)(struct timer_list *);
	struct kmem_cache *frags_cachep;
	const char *frags_cache_name;
	struct rhashtable_params rhash_params;
	refcount_t refcnt;
	struct completion completion;
};

struct frag_v4_compare_key {
	__be32 saddr;
	__be32 daddr;
	u32 user;
	u32 vif;
	__be16 id;
	u16 protocol;
};

struct frag_v6_compare_key {
	struct in6_addr saddr;
	struct in6_addr daddr;
	u32 user;
	__be32 id;
	u32 iif;
};

struct inet_frag_queue {
	struct rhash_head node;
	union {
		struct frag_v4_compare_key v4;
		struct frag_v6_compare_key v6;
	} key;
	struct timer_list timer;
	spinlock_t lock;
	refcount_t refcnt;
	struct rb_root rb_fragments;
	struct sk_buff *fragments_tail;
	struct sk_buff *last_run_head;
	ktime_t stamp;
	int len;
	int meat;
	u8 mono_delivery_time;
	__u8 flags;
	u16 max_size;
	struct fqdir *fqdir;
	struct callback_head rcu;
};

enum tcp_ca_event {
	CA_EVENT_TX_START = 0,
	CA_EVENT_CWND_RESTART = 1,
	CA_EVENT_COMPLETE_CWR = 2,
	CA_EVENT_LOSS = 3,
	CA_EVENT_ECN_NO_CE = 4,
	CA_EVENT_ECN_IS_CE = 5,
};

struct ack_sample;

struct rate_sample;

union tcp_cc_info;

struct tcp_congestion_ops {
	u32 (*ssthresh)(struct sock *);
	void (*cong_avoid)(struct sock *, u32, u32);
	void (*set_state)(struct sock *, u8);
	void (*cwnd_event)(struct sock *, enum tcp_ca_event);
	void (*in_ack_event)(struct sock *, u32);
	void (*pkts_acked)(struct sock *, const struct ack_sample *);
	u32 (*min_tso_segs)(struct sock *);
	void (*cong_control)(struct sock *, const struct rate_sample *);
	u32 (*undo_cwnd)(struct sock *);
	u32 (*sndbuf_expand)(struct sock *);
	size_t (*get_info)(struct sock *, u32, int *, union tcp_cc_info *);
	char name[16];
	struct module *owner;
	struct list_head list;
	u32 key;
	u32 flags;
	void (*init)(struct sock *);
	void (*release)(struct sock *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef struct {} netdevice_tracker;

struct lwtunnel_state;

struct dst_entry {
	struct net_device *dev;
	struct dst_ops *ops;
	long unsigned int _metrics;
	long unsigned int expires;
	void *__pad1;
	int (*input)(struct sk_buff *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	short unsigned int flags;
	short int obsolete;
	short unsigned int header_len;
	short unsigned int trailer_len;
	int __use;
	long unsigned int lastuse;
	struct lwtunnel_state *lwtstate;
	struct callback_head callback_head;
	short int error;
	short int __pad;
	__u32 tclassid;
	atomic_t __refcnt;
	netdevice_tracker dev_tracker;
};

enum nf_inet_hooks {
	NF_INET_PRE_ROUTING = 0,
	NF_INET_LOCAL_IN = 1,
	NF_INET_FORWARD = 2,
	NF_INET_LOCAL_OUT = 3,
	NF_INET_POST_ROUTING = 4,
	NF_INET_NUMHOOKS = 5,
	NF_INET_INGRESS = 5,
};

enum {
	NFPROTO_UNSPEC = 0,
	NFPROTO_INET = 1,
	NFPROTO_IPV4 = 2,
	NFPROTO_ARP = 3,
	NFPROTO_NETDEV = 5,
	NFPROTO_BRIDGE = 7,
	NFPROTO_IPV6 = 10,
	NFPROTO_NUMPROTO = 11,
};

enum nf_log_type {
	NF_LOG_TYPE_LOG = 0,
	NF_LOG_TYPE_ULOG = 1,
	NF_LOG_TYPE_MAX = 2,
};

typedef u8 u_int8_t;

struct nf_loginfo;

typedef void nf_logfn(struct net *, u_int8_t, unsigned int, const struct sk_buff *, const struct net_device *, const struct net_device *, const struct nf_loginfo *, const char *);

struct nf_logger {
	char *name;
	enum nf_log_type type;
	nf_logfn *logfn;
	struct module *me;
};

enum tcp_conntrack {
	TCP_CONNTRACK_NONE = 0,
	TCP_CONNTRACK_SYN_SENT = 1,
	TCP_CONNTRACK_SYN_RECV = 2,
	TCP_CONNTRACK_ESTABLISHED = 3,
	TCP_CONNTRACK_FIN_WAIT = 4,
	TCP_CONNTRACK_CLOSE_WAIT = 5,
	TCP_CONNTRACK_LAST_ACK = 6,
	TCP_CONNTRACK_TIME_WAIT = 7,
	TCP_CONNTRACK_CLOSE = 8,
	TCP_CONNTRACK_LISTEN = 9,
	TCP_CONNTRACK_MAX = 10,
	TCP_CONNTRACK_IGNORE = 11,
	TCP_CONNTRACK_RETRANS = 12,
	TCP_CONNTRACK_UNACK = 13,
	TCP_CONNTRACK_TIMEOUT_MAX = 14,
};

enum ct_dccp_states {
	CT_DCCP_NONE = 0,
	CT_DCCP_REQUEST = 1,
	CT_DCCP_RESPOND = 2,
	CT_DCCP_PARTOPEN = 3,
	CT_DCCP_OPEN = 4,
	CT_DCCP_CLOSEREQ = 5,
	CT_DCCP_CLOSING = 6,
	CT_DCCP_TIMEWAIT = 7,
	CT_DCCP_IGNORE = 8,
	CT_DCCP_INVALID = 9,
	__CT_DCCP_MAX = 10,
};

struct ip_conntrack_stat {
	unsigned int found;
	unsigned int invalid;
	unsigned int insert;
	unsigned int insert_failed;
	unsigned int clash_resolve;
	unsigned int drop;
	unsigned int early_drop;
	unsigned int error;
	unsigned int expect_new;
	unsigned int expect_create;
	unsigned int expect_delete;
	unsigned int search_restart;
	unsigned int chaintoolong;
};

enum ip_conntrack_dir {
	IP_CT_DIR_ORIGINAL = 0,
	IP_CT_DIR_REPLY = 1,
	IP_CT_DIR_MAX = 2,
};

enum sctp_conntrack {
	SCTP_CONNTRACK_NONE = 0,
	SCTP_CONNTRACK_CLOSED = 1,
	SCTP_CONNTRACK_COOKIE_WAIT = 2,
	SCTP_CONNTRACK_COOKIE_ECHOED = 3,
	SCTP_CONNTRACK_ESTABLISHED = 4,
	SCTP_CONNTRACK_SHUTDOWN_SENT = 5,
	SCTP_CONNTRACK_SHUTDOWN_RECD = 6,
	SCTP_CONNTRACK_SHUTDOWN_ACK_SENT = 7,
	SCTP_CONNTRACK_HEARTBEAT_SENT = 8,
	SCTP_CONNTRACK_HEARTBEAT_ACKED = 9,
	SCTP_CONNTRACK_MAX = 10,
};

enum udp_conntrack {
	UDP_CT_UNREPLIED = 0,
	UDP_CT_REPLIED = 1,
	UDP_CT_MAX = 2,
};

enum gre_conntrack {
	GRE_CT_UNREPLIED = 0,
	GRE_CT_REPLIED = 1,
	GRE_CT_MAX = 2,
};

struct nf_flow_table_stat {
	unsigned int count_wq_add;
	unsigned int count_wq_del;
	unsigned int count_wq_stats;
};

enum {
	XFRM_POLICY_IN = 0,
	XFRM_POLICY_OUT = 1,
	XFRM_POLICY_FWD = 2,
	XFRM_POLICY_MASK = 3,
	XFRM_POLICY_MAX = 3,
};

enum netns_bpf_attach_type {
	NETNS_BPF_INVALID = 4294967295,
	NETNS_BPF_FLOW_DISSECTOR = 0,
	NETNS_BPF_SK_LOOKUP = 1,
	MAX_NETNS_BPF_ATTACH_TYPE = 2,
};

struct pipe_buf_operations;

struct pipe_buffer {
	struct page *page;
	unsigned int offset;
	unsigned int len;
	const struct pipe_buf_operations *ops;
	unsigned int flags;
	long unsigned int private;
};

struct pipe_buf_operations {
	int (*confirm)(struct pipe_inode_info *, struct pipe_buffer *);
	void (*release)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*try_steal)(struct pipe_inode_info *, struct pipe_buffer *);
	bool (*get)(struct pipe_inode_info *, struct pipe_buffer *);
};

struct page_pool_recycle_stats {
	u64 cached;
	u64 cache_full;
	u64 ring;
	u64 ring_full;
	u64 released_refcnt;
};

struct trace_event_raw_initcall_level {
	struct trace_entry ent;
	u32 __data_loc_level;
	char __data[0];
};

struct trace_event_raw_initcall_start {
	struct trace_entry ent;
	initcall_t func;
	char __data[0];
};

struct trace_event_raw_initcall_finish {
	struct trace_entry ent;
	initcall_t func;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_initcall_level {
	u32 level;
};

struct trace_event_data_offsets_initcall_start {};

struct trace_event_data_offsets_initcall_finish {};

typedef void (*btf_trace_initcall_level)(void *, const char *);

typedef void (*btf_trace_initcall_start)(void *, initcall_t);

typedef void (*btf_trace_initcall_finish)(void *, initcall_t, int);

struct blacklist_entry {
	struct list_head next;
	char *buf;
};

struct elf32_note {
	Elf32_Word n_namesz;
	Elf32_Word n_descsz;
	Elf32_Word n_type;
};

enum pcpu_fc {
	PCPU_FC_AUTO = 0,
	PCPU_FC_EMBED = 1,
	PCPU_FC_PAGE = 2,
	PCPU_FC_NR = 3,
};

enum hrtimer_base_type {
	HRTIMER_BASE_MONOTONIC = 0,
	HRTIMER_BASE_REALTIME = 1,
	HRTIMER_BASE_BOOTTIME = 2,
	HRTIMER_BASE_TAI = 3,
	HRTIMER_BASE_MONOTONIC_SOFT = 4,
	HRTIMER_BASE_REALTIME_SOFT = 5,
	HRTIMER_BASE_BOOTTIME_SOFT = 6,
	HRTIMER_BASE_TAI_SOFT = 7,
	HRTIMER_MAX_CLOCK_BASES = 8,
};

enum {
	MM_FILEPAGES = 0,
	MM_ANONPAGES = 1,
	MM_SWAPENTS = 2,
	MM_SHMEMPAGES = 3,
	NR_MM_COUNTERS = 4,
};

enum rseq_cs_flags_bit {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT_BIT = 0,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL_BIT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE_BIT = 2,
};

enum {
	TASK_COMM_LEN = 16,
};

enum perf_event_task_context {
	perf_invalid_context = 4294967295,
	perf_hw_context = 0,
	perf_sw_context = 1,
	perf_nr_task_contexts = 2,
};

enum rseq_event_mask_bits {
	RSEQ_EVENT_PREEMPT_BIT = 0,
	RSEQ_EVENT_SIGNAL_BIT = 1,
	RSEQ_EVENT_MIGRATE_BIT = 2,
};

enum {
	PROC_ROOT_INO = 1,
	PROC_IPC_INIT_INO = 4026531839,
	PROC_UTS_INIT_INO = 4026531838,
	PROC_USER_INIT_INO = 4026531837,
	PROC_PID_INIT_INO = 4026531836,
	PROC_CGROUP_INIT_INO = 4026531835,
	PROC_TIME_INIT_INO = 4026531834,
};

typedef short int __s16;

typedef __s16 s16;

typedef unsigned int slab_flags_t;

struct fs_struct {
	int users;
	spinlock_t lock;
	seqcount_spinlock_t seq;
	int umask;
	int in_exec;
	struct path root;
	struct path pwd;
};

typedef __u64 __addrpair;

typedef __u32 __portpair;

typedef struct {
	struct net *net;
} possible_net_t;

struct hlist_nulls_node {
	struct hlist_nulls_node *next;
	struct hlist_nulls_node **pprev;
};

struct proto;

struct sock_common {
	union {
		__addrpair skc_addrpair;
		struct {
			__be32 skc_daddr;
			__be32 skc_rcv_saddr;
		};
	};
	union {
		unsigned int skc_hash;
		__u16 skc_u16hashes[2];
	};
	union {
		__portpair skc_portpair;
		struct {
			__be16 skc_dport;
			__u16 skc_num;
		};
	};
	short unsigned int skc_family;
	volatile unsigned char skc_state;
	unsigned char skc_reuse: 4;
	unsigned char skc_reuseport: 1;
	unsigned char skc_ipv6only: 1;
	unsigned char skc_net_refcnt: 1;
	int skc_bound_dev_if;
	union {
		struct hlist_node skc_bind_node;
		struct hlist_node skc_portaddr_node;
	};
	struct proto *skc_prot;
	possible_net_t skc_net;
	struct in6_addr skc_v6_daddr;
	struct in6_addr skc_v6_rcv_saddr;
	atomic64_t skc_cookie;
	union {
		long unsigned int skc_flags;
		struct sock *skc_listener;
		struct inet_timewait_death_row *skc_tw_dr;
	};
	int skc_dontcopy_begin[0];
	union {
		struct hlist_node skc_node;
		struct hlist_nulls_node skc_nulls_node;
	};
	short unsigned int skc_tx_queue_mapping;
	short unsigned int skc_rx_queue_mapping;
	union {
		int skc_incoming_cpu;
		u32 skc_rcv_wnd;
		u32 skc_tw_rcv_nxt;
	};
	refcount_t skc_refcnt;
	int skc_dontcopy_end[0];
	union {
		u32 skc_rxhash;
		u32 skc_window_clamp;
		u32 skc_tw_snd_nxt;
	};
	int: 32;
};

typedef struct {
	spinlock_t slock;
	int owned;
	wait_queue_head_t wq;
} socket_lock_t;

typedef u64 netdev_features_t;

struct sock_cgroup_data {
	struct cgroup *cgroup;
	u32 classid;
};

typedef struct {} netns_tracker;

struct sk_filter;

struct socket_wq;

struct socket;

struct sock_reuseport;

struct sock {
	struct sock_common __sk_common;
	struct dst_entry *sk_rx_dst;
	int sk_rx_dst_ifindex;
	u32 sk_rx_dst_cookie;
	socket_lock_t sk_lock;
	atomic_t sk_drops;
	int sk_rcvlowat;
	struct sk_buff_head sk_error_queue;
	struct sk_buff_head sk_receive_queue;
	struct {
		atomic_t rmem_alloc;
		int len;
		struct sk_buff *head;
		struct sk_buff *tail;
	} sk_backlog;
	int sk_forward_alloc;
	u32 sk_reserved_mem;
	unsigned int sk_ll_usec;
	unsigned int sk_napi_id;
	int sk_rcvbuf;
	struct sk_filter *sk_filter;
	union {
		struct socket_wq *sk_wq;
		struct socket_wq *sk_wq_raw;
	};
	struct dst_entry *sk_dst_cache;
	atomic_t sk_omem_alloc;
	int sk_sndbuf;
	int sk_wmem_queued;
	refcount_t sk_wmem_alloc;
	long unsigned int sk_tsq_flags;
	union {
		struct sk_buff *sk_send_head;
		struct rb_root tcp_rtx_queue;
	};
	struct sk_buff_head sk_write_queue;
	__s32 sk_peek_off;
	int sk_write_pending;
	__u32 sk_dst_pending_confirm;
	u32 sk_pacing_status;
	long int sk_sndtimeo;
	struct timer_list sk_timer;
	__u32 sk_priority;
	__u32 sk_mark;
	long unsigned int sk_pacing_rate;
	long unsigned int sk_max_pacing_rate;
	struct page_frag sk_frag;
	netdev_features_t sk_route_caps;
	int sk_gso_type;
	unsigned int sk_gso_max_size;
	gfp_t sk_allocation;
	__u32 sk_txhash;
	u8 sk_gso_disabled: 1;
	u8 sk_kern_sock: 1;
	u8 sk_no_check_tx: 1;
	u8 sk_no_check_rx: 1;
	u8 sk_userlocks: 4;
	u8 sk_pacing_shift;
	u16 sk_type;
	u16 sk_protocol;
	u16 sk_gso_max_segs;
	long unsigned int sk_lingertime;
	struct proto *sk_prot_creator;
	rwlock_t sk_callback_lock;
	int sk_err;
	int sk_err_soft;
	u32 sk_ack_backlog;
	u32 sk_max_ack_backlog;
	kuid_t sk_uid;
	u8 sk_txrehash;
	u8 sk_prefer_busy_poll;
	u16 sk_busy_poll_budget;
	spinlock_t sk_peer_lock;
	int sk_bind_phc;
	struct pid *sk_peer_pid;
	const struct cred *sk_peer_cred;
	long int sk_rcvtimeo;
	ktime_t sk_stamp;
	seqlock_t sk_stamp_seq;
	u16 sk_tsflags;
	u8 sk_shutdown;
	atomic_t sk_tskey;
	atomic_t sk_zckey;
	u8 sk_clockid;
	u8 sk_txtime_deadline_mode: 1;
	u8 sk_txtime_report_errors: 1;
	u8 sk_txtime_unused: 6;
	struct socket *sk_socket;
	void *sk_user_data;
	struct sock_cgroup_data sk_cgrp_data;
	struct mem_cgroup *sk_memcg;
	void (*sk_state_change)(struct sock *);
	void (*sk_data_ready)(struct sock *);
	void (*sk_write_space)(struct sock *);
	void (*sk_error_report)(struct sock *);
	int (*sk_backlog_rcv)(struct sock *, struct sk_buff *);
	struct sk_buff * (*sk_validate_xmit_skb)(struct sock *, struct net_device *, struct sk_buff *);
	void (*sk_destruct)(struct sock *);
	struct sock_reuseport *sk_reuseport_cb;
	struct bpf_local_storage *sk_bpf_storage;
	struct callback_head sk_rcu;
	netns_tracker ns_tracker;
	struct hlist_node sk_bind2_node;
};

struct ld_semaphore {
	atomic_long_t count;
	raw_spinlock_t wait_lock;
	unsigned int wait_readers;
	struct list_head read_wait;
	struct list_head write_wait;
};

typedef unsigned int tcflag_t;

typedef unsigned char cc_t;

typedef unsigned int speed_t;

struct ktermios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct winsize {
	short unsigned int ws_row;
	short unsigned int ws_col;
	short unsigned int ws_xpixel;
	short unsigned int ws_ypixel;
};

struct tty_driver;

struct tty_operations;

struct tty_ldisc;

struct tty_port;

struct tty_struct {
	struct kref kref;
	struct device *dev;
	struct tty_driver *driver;
	const struct tty_operations *ops;
	int index;
	struct ld_semaphore ldisc_sem;
	struct tty_ldisc *ldisc;
	struct mutex atomic_write_lock;
	struct mutex legacy_mutex;
	struct mutex throttle_mutex;
	struct rw_semaphore termios_rwsem;
	struct mutex winsize_mutex;
	struct ktermios termios;
	struct ktermios termios_locked;
	char name[64];
	long unsigned int flags;
	int count;
	struct winsize winsize;
	struct {
		spinlock_t lock;
		bool stopped;
		bool tco_stopped;
		long unsigned int unused[0];
	} flow;
	struct {
		spinlock_t lock;
		struct pid *pgrp;
		struct pid *session;
		unsigned char pktstatus;
		bool packet;
		long unsigned int unused[0];
	} ctrl;
	int hw_stopped;
	unsigned int receive_room;
	int flow_change;
	struct tty_struct *link;
	struct fasync_struct *fasync;
	wait_queue_head_t write_wait;
	wait_queue_head_t read_wait;
	struct work_struct hangup_work;
	void *disc_data;
	void *driver_data;
	spinlock_t files_lock;
	struct list_head tty_files;
	int closing;
	unsigned char *write_buf;
	int write_cnt;
	struct work_struct SAK_work;
	struct tty_port *port;
};

struct posix_acl_entry {
	short int e_tag;
	short unsigned int e_perm;
	union {
		kuid_t e_uid;
		kgid_t e_gid;
	};
};

struct posix_acl {
	refcount_t a_refcount;
	struct callback_head a_rcu;
	unsigned int a_count;
	struct posix_acl_entry a_entries[0];
};

struct tty_buffer {
	union {
		struct tty_buffer *next;
		struct llist_node free;
	};
	int used;
	int size;
	int commit;
	int lookahead;
	int read;
	int flags;
	long unsigned int data[0];
};

struct tty_bufhead {
	struct tty_buffer *head;
	struct work_struct work;
	struct mutex lock;
	atomic_t priority;
	struct tty_buffer sentinel;
	struct llist_head free;
	atomic_t mem_used;
	int mem_limit;
	struct tty_buffer *tail;
};

struct serial_icounter_struct;

struct serial_struct;

struct tty_operations {
	struct tty_struct * (*lookup)(struct tty_driver *, struct file *, int);
	int (*install)(struct tty_driver *, struct tty_struct *);
	void (*remove)(struct tty_driver *, struct tty_struct *);
	int (*open)(struct tty_struct *, struct file *);
	void (*close)(struct tty_struct *, struct file *);
	void (*shutdown)(struct tty_struct *);
	void (*cleanup)(struct tty_struct *);
	int (*write)(struct tty_struct *, const unsigned char *, int);
	int (*put_char)(struct tty_struct *, unsigned char);
	void (*flush_chars)(struct tty_struct *);
	unsigned int (*write_room)(struct tty_struct *);
	unsigned int (*chars_in_buffer)(struct tty_struct *);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, const struct ktermios *);
	void (*throttle)(struct tty_struct *);
	void (*unthrottle)(struct tty_struct *);
	void (*stop)(struct tty_struct *);
	void (*start)(struct tty_struct *);
	void (*hangup)(struct tty_struct *);
	int (*break_ctl)(struct tty_struct *, int);
	void (*flush_buffer)(struct tty_struct *);
	void (*set_ldisc)(struct tty_struct *);
	void (*wait_until_sent)(struct tty_struct *, int);
	void (*send_xchar)(struct tty_struct *, char);
	int (*tiocmget)(struct tty_struct *);
	int (*tiocmset)(struct tty_struct *, unsigned int, unsigned int);
	int (*resize)(struct tty_struct *, struct winsize *);
	int (*get_icount)(struct tty_struct *, struct serial_icounter_struct *);
	int (*get_serial)(struct tty_struct *, struct serial_struct *);
	int (*set_serial)(struct tty_struct *, struct serial_struct *);
	void (*show_fdinfo)(struct tty_struct *, struct seq_file *);
	int (*proc_show)(struct seq_file *, void *);
};

struct tty_driver {
	struct kref kref;
	struct cdev **cdevs;
	struct module *owner;
	const char *driver_name;
	const char *name;
	int name_base;
	int major;
	int minor_start;
	unsigned int num;
	short int type;
	short int subtype;
	struct ktermios init_termios;
	long unsigned int flags;
	struct proc_dir_entry *proc_entry;
	struct tty_driver *other;
	struct tty_struct **ttys;
	struct tty_port **ports;
	struct ktermios **termios;
	void *driver_state;
	const struct tty_operations *ops;
	struct list_head tty_drivers;
};

struct __kfifo {
	unsigned int in;
	unsigned int out;
	unsigned int mask;
	unsigned int esize;
	void *data;
};

struct tty_port_operations;

struct tty_port_client_operations;

struct tty_port {
	struct tty_bufhead buf;
	struct tty_struct *tty;
	struct tty_struct *itty;
	const struct tty_port_operations *ops;
	const struct tty_port_client_operations *client_ops;
	spinlock_t lock;
	int blocked_open;
	int count;
	wait_queue_head_t open_wait;
	wait_queue_head_t delta_msr_wait;
	long unsigned int flags;
	long unsigned int iflags;
	unsigned char console: 1;
	struct mutex mutex;
	struct mutex buf_mutex;
	unsigned char *xmit_buf;
	struct {
		union {
			struct __kfifo kfifo;
			unsigned char *type;
			const unsigned char *const_type;
			char (*rectype)[0];
			unsigned char *ptr;
			const unsigned char *ptr_const;
		};
		unsigned char buf[0];
	} xmit_fifo;
	unsigned int close_delay;
	unsigned int closing_wait;
	int drain_delay;
	struct kref kref;
	void *client_data;
};

struct tty_ldisc_ops {
	char *name;
	int num;
	int (*open)(struct tty_struct *);
	void (*close)(struct tty_struct *);
	void (*flush_buffer)(struct tty_struct *);
	ssize_t (*read)(struct tty_struct *, struct file *, unsigned char *, size_t, void **, long unsigned int);
	ssize_t (*write)(struct tty_struct *, struct file *, const unsigned char *, size_t);
	int (*ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	int (*compat_ioctl)(struct tty_struct *, unsigned int, long unsigned int);
	void (*set_termios)(struct tty_struct *, const struct ktermios *);
	__poll_t (*poll)(struct tty_struct *, struct file *, struct poll_table_struct *);
	void (*hangup)(struct tty_struct *);
	void (*receive_buf)(struct tty_struct *, const unsigned char *, const char *, int);
	void (*write_wakeup)(struct tty_struct *);
	void (*dcd_change)(struct tty_struct *, unsigned int);
	int (*receive_buf2)(struct tty_struct *, const unsigned char *, const char *, int);
	void (*lookahead_buf)(struct tty_struct *, const unsigned char *, const unsigned char *, unsigned int);
	struct module *owner;
};

struct tty_ldisc {
	struct tty_ldisc_ops *ops;
	struct tty_struct *tty;
};

struct tty_port_operations {
	int (*carrier_raised)(struct tty_port *);
	void (*dtr_rts)(struct tty_port *, int);
	void (*shutdown)(struct tty_port *);
	int (*activate)(struct tty_port *, struct tty_struct *);
	void (*destruct)(struct tty_port *);
};

struct tty_port_client_operations {
	int (*receive_buf)(struct tty_port *, const unsigned char *, const unsigned char *, size_t);
	void (*lookahead_buf)(struct tty_port *, const unsigned char *, const unsigned char *, unsigned int);
	void (*write_wakeup)(struct tty_port *);
};

typedef struct {
	u64 v;
} u64_stats_t;

enum {
	Root_NFS = 255,
	Root_CIFS = 254,
	Root_RAM0 = 1048576,
	Root_RAM1 = 1048577,
	Root_FD0 = 2097152,
	Root_HDA1 = 3145729,
	Root_HDA2 = 3145730,
	Root_SDA1 = 8388609,
	Root_SDA2 = 8388610,
	Root_HDC1 = 23068673,
	Root_SR0 = 11534336,
};

typedef short unsigned int __kernel_sa_family_t;

typedef __kernel_sa_family_t sa_family_t;

struct sockaddr {
	sa_family_t sa_family;
	char sa_data[14];
};

struct ubuf_info;

struct msghdr {
	void *msg_name;
	int msg_namelen;
	int msg_inq;
	int: 32;
	struct iov_iter msg_iter;
	union {
		void *msg_control;
		void *msg_control_user;
	};
	bool msg_control_is_user: 1;
	bool msg_get_inq: 1;
	unsigned int msg_flags;
	__kernel_size_t msg_controllen;
	struct kiocb *msg_iocb;
	struct ubuf_info *msg_ubuf;
	int (*sg_from_iter)(struct sock *, struct sk_buff *, struct iov_iter *, size_t);
	int: 32;
};

struct ubuf_info {
	void (*callback)(struct sk_buff *, struct ubuf_info *, bool);
	refcount_t refcnt;
	u8 flags;
};

enum {
	IPPROTO_IP = 0,
	IPPROTO_ICMP = 1,
	IPPROTO_IGMP = 2,
	IPPROTO_IPIP = 4,
	IPPROTO_TCP = 6,
	IPPROTO_EGP = 8,
	IPPROTO_PUP = 12,
	IPPROTO_UDP = 17,
	IPPROTO_IDP = 22,
	IPPROTO_TP = 29,
	IPPROTO_DCCP = 33,
	IPPROTO_IPV6 = 41,
	IPPROTO_RSVP = 46,
	IPPROTO_GRE = 47,
	IPPROTO_ESP = 50,
	IPPROTO_AH = 51,
	IPPROTO_MTP = 92,
	IPPROTO_BEETPH = 94,
	IPPROTO_ENCAP = 98,
	IPPROTO_PIM = 103,
	IPPROTO_COMP = 108,
	IPPROTO_L2TP = 115,
	IPPROTO_SCTP = 132,
	IPPROTO_UDPLITE = 136,
	IPPROTO_MPLS = 137,
	IPPROTO_ETHERNET = 143,
	IPPROTO_RAW = 255,
	IPPROTO_MPTCP = 262,
	IPPROTO_MAX = 263,
};

struct prot_inuse {
	int all;
	int val[64];
};

struct icmpv6_mib_device {
	atomic_long_t mibs[6];
};

struct icmpv6msg_mib_device {
	atomic_long_t mibs[512];
};

struct netlink_ext_ack;

struct fib_notifier_ops {
	int family;
	struct list_head list;
	unsigned int (*fib_seq_read)(struct net *);
	int (*fib_dump)(struct net *, struct notifier_block *, struct netlink_ext_ack *);
	struct module *owner;
	struct callback_head rcu;
};

struct net_device_stats {
	long unsigned int rx_packets;
	long unsigned int tx_packets;
	long unsigned int rx_bytes;
	long unsigned int tx_bytes;
	long unsigned int rx_errors;
	long unsigned int tx_errors;
	long unsigned int rx_dropped;
	long unsigned int tx_dropped;
	long unsigned int multicast;
	long unsigned int collisions;
	long unsigned int rx_length_errors;
	long unsigned int rx_over_errors;
	long unsigned int rx_crc_errors;
	long unsigned int rx_frame_errors;
	long unsigned int rx_fifo_errors;
	long unsigned int rx_missed_errors;
	long unsigned int tx_aborted_errors;
	long unsigned int tx_carrier_errors;
	long unsigned int tx_fifo_errors;
	long unsigned int tx_heartbeat_errors;
	long unsigned int tx_window_errors;
	long unsigned int rx_compressed;
	long unsigned int tx_compressed;
};

struct netdev_hw_addr_list {
	struct list_head list;
	int count;
	struct rb_root tree;
};

enum rx_handler_result {
	RX_HANDLER_CONSUMED = 0,
	RX_HANDLER_ANOTHER = 1,
	RX_HANDLER_EXACT = 2,
	RX_HANDLER_PASS = 3,
};

typedef enum rx_handler_result rx_handler_result_t;

typedef rx_handler_result_t rx_handler_func_t(struct sk_buff **);

enum netdev_ml_priv_type {
	ML_PRIV_NONE = 0,
	ML_PRIV_CAN = 1,
};

struct pcpu_dstats;

struct netdev_tc_txq {
	u16 count;
	u16 offset;
};

struct sfp_bus;

struct udp_tunnel_nic;

struct bpf_xdp_link;

struct bpf_xdp_entity {
	struct bpf_prog *prog;
	struct bpf_xdp_link *link;
};

struct netdev_name_node;

struct dev_ifalias;

struct net_device_ops;

struct net_device_core_stats;

struct iw_handler_def;

struct iw_public_data;

struct ethtool_ops;

struct ndisc_ops;

struct tlsdev_ops;

struct header_ops;

struct in_device;

struct inet6_dev;

struct vlan_info;

struct dsa_port;

struct netdev_rx_queue;

struct mini_Qdisc;

struct netdev_queue;

struct cpu_rmap;

struct Qdisc;

struct xdp_dev_bulk_queue;

struct xps_dev_maps;

struct pcpu_lstats;

struct pcpu_sw_netstats;

struct rtnl_link_ops;

struct phy_device;

struct udp_tunnel_nic_info;

struct rtnl_hw_stats64;

struct net_device {
	char name[16];
	struct netdev_name_node *name_node;
	struct dev_ifalias *ifalias;
	long unsigned int mem_end;
	long unsigned int mem_start;
	long unsigned int base_addr;
	long unsigned int state;
	struct list_head dev_list;
	struct list_head napi_list;
	struct list_head unreg_list;
	struct list_head close_list;
	struct list_head ptype_all;
	struct list_head ptype_specific;
	struct {
		struct list_head upper;
		struct list_head lower;
	} adj_list;
	unsigned int flags;
	int: 32;
	long long unsigned int priv_flags;
	const struct net_device_ops *netdev_ops;
	int ifindex;
	short unsigned int gflags;
	short unsigned int hard_header_len;
	unsigned int mtu;
	short unsigned int needed_headroom;
	short unsigned int needed_tailroom;
	int: 32;
	netdev_features_t features;
	netdev_features_t hw_features;
	netdev_features_t wanted_features;
	netdev_features_t vlan_features;
	netdev_features_t hw_enc_features;
	netdev_features_t mpls_features;
	netdev_features_t gso_partial_features;
	unsigned int min_mtu;
	unsigned int max_mtu;
	short unsigned int type;
	unsigned char min_header_len;
	unsigned char name_assign_type;
	int group;
	struct net_device_stats stats;
	struct net_device_core_stats *core_stats;
	atomic_t carrier_up_count;
	atomic_t carrier_down_count;
	const struct iw_handler_def *wireless_handlers;
	struct iw_public_data *wireless_data;
	const struct ethtool_ops *ethtool_ops;
	const struct ndisc_ops *ndisc_ops;
	const struct tlsdev_ops *tlsdev_ops;
	const struct header_ops *header_ops;
	unsigned char operstate;
	unsigned char link_mode;
	unsigned char if_port;
	unsigned char dma;
	unsigned char perm_addr[32];
	unsigned char addr_assign_type;
	unsigned char addr_len;
	unsigned char upper_level;
	unsigned char lower_level;
	short unsigned int neigh_priv_len;
	short unsigned int dev_id;
	short unsigned int dev_port;
	short unsigned int padded;
	spinlock_t addr_list_lock;
	int irq;
	struct netdev_hw_addr_list uc;
	struct netdev_hw_addr_list mc;
	struct netdev_hw_addr_list dev_addrs;
	struct kset *queues_kset;
	unsigned int promiscuity;
	unsigned int allmulti;
	bool uc_promisc;
	struct in_device *ip_ptr;
	struct inet6_dev *ip6_ptr;
	struct vlan_info *vlan_info;
	struct dsa_port *dsa_ptr;
	const unsigned char *dev_addr;
	struct netdev_rx_queue *_rx;
	unsigned int num_rx_queues;
	unsigned int real_num_rx_queues;
	struct bpf_prog *xdp_prog;
	long unsigned int gro_flush_timeout;
	int napi_defer_hard_irqs;
	unsigned int gro_max_size;
	rx_handler_func_t *rx_handler;
	void *rx_handler_data;
	struct mini_Qdisc *miniq_ingress;
	struct netdev_queue *ingress_queue;
	struct nf_hook_entries *nf_hooks_ingress;
	unsigned char broadcast[32];
	struct cpu_rmap *rx_cpu_rmap;
	struct hlist_node index_hlist;
	struct netdev_queue *_tx;
	unsigned int num_tx_queues;
	unsigned int real_num_tx_queues;
	struct Qdisc *qdisc;
	unsigned int tx_queue_len;
	spinlock_t tx_global_lock;
	struct xdp_dev_bulk_queue *xdp_bulkq;
	struct xps_dev_maps *xps_maps[2];
	struct mini_Qdisc *miniq_egress;
	struct nf_hook_entries *nf_hooks_egress;
	struct hlist_head qdisc_hash[16];
	struct timer_list watchdog_timer;
	int watchdog_timeo;
	u32 proto_down_reason;
	struct list_head todo_list;
	int *pcpu_refcnt;
	struct ref_tracker_dir refcnt_tracker;
	struct list_head link_watch_list;
	enum {
		NETREG_UNINITIALIZED = 0,
		NETREG_REGISTERED = 1,
		NETREG_UNREGISTERING = 2,
		NETREG_UNREGISTERED = 3,
		NETREG_RELEASED = 4,
		NETREG_DUMMY = 5,
	} reg_state: 8;
	bool dismantle;
	enum {
		RTNL_LINK_INITIALIZED = 0,
		RTNL_LINK_INITIALIZING = 1,
	} rtnl_link_state: 16;
	bool needs_free_netdev;
	void (*priv_destructor)(struct net_device *);
	possible_net_t nd_net;
	void *ml_priv;
	enum netdev_ml_priv_type ml_priv_type;
	union {
		struct pcpu_lstats *lstats;
		struct pcpu_sw_netstats *tstats;
		struct pcpu_dstats *dstats;
	};
	struct device dev;
	const struct attribute_group *sysfs_groups[4];
	const struct attribute_group *sysfs_rx_queue_group;
	const struct rtnl_link_ops *rtnl_link_ops;
	unsigned int gso_max_size;
	unsigned int tso_max_size;
	u16 gso_max_segs;
	u16 tso_max_segs;
	s16 num_tc;
	struct netdev_tc_txq tc_to_txq[16];
	u8 prio_tc_map[16];
	struct phy_device *phydev;
	struct sfp_bus *sfp_bus;
	struct lock_class_key *qdisc_tx_busylock;
	bool proto_down;
	unsigned int wol_enabled: 1;
	unsigned int threaded: 1;
	struct list_head net_notifier_list;
	const struct udp_tunnel_nic_info *udp_tunnel_nic_info;
	struct udp_tunnel_nic *udp_tunnel_nic;
	struct bpf_xdp_entity xdp_state[3];
	u8 dev_addr_shadow[32];
	netdevice_tracker linkwatch_dev_tracker;
	netdevice_tracker watchdog_dev_tracker;
	netdevice_tracker dev_registered_tracker;
	struct rtnl_hw_stats64 *offload_xstats_l3;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct hh_cache {
	unsigned int hh_len;
	seqlock_t hh_lock;
	long unsigned int hh_data[24];
};

struct neigh_table;

struct neigh_parms;

struct neigh_ops;

struct neighbour {
	struct neighbour *next;
	struct neigh_table *tbl;
	struct neigh_parms *parms;
	long unsigned int confirmed;
	long unsigned int updated;
	rwlock_t lock;
	refcount_t refcnt;
	unsigned int arp_queue_len_bytes;
	struct sk_buff_head arp_queue;
	struct timer_list timer;
	long unsigned int used;
	atomic_t probes;
	u8 nud_state;
	u8 type;
	u8 dead;
	u8 protocol;
	u32 flags;
	seqlock_t ha_lock;
	int: 32;
	unsigned char ha[32];
	struct hh_cache hh;
	int (*output)(struct neighbour *, struct sk_buff *);
	const struct neigh_ops *ops;
	struct list_head gc_list;
	struct list_head managed_list;
	struct callback_head rcu;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u8 primary_key[0];
};

struct ipv6_stable_secret {
	bool initialized;
	struct in6_addr secret;
};

struct ipv6_devconf {
	__s32 forwarding;
	__s32 hop_limit;
	__s32 mtu6;
	__s32 accept_ra;
	__s32 accept_redirects;
	__s32 autoconf;
	__s32 dad_transmits;
	__s32 rtr_solicits;
	__s32 rtr_solicit_interval;
	__s32 rtr_solicit_max_interval;
	__s32 rtr_solicit_delay;
	__s32 force_mld_version;
	__s32 mldv1_unsolicited_report_interval;
	__s32 mldv2_unsolicited_report_interval;
	__s32 use_tempaddr;
	__s32 temp_valid_lft;
	__s32 temp_prefered_lft;
	__s32 regen_max_retry;
	__s32 max_desync_factor;
	__s32 max_addresses;
	__s32 accept_ra_defrtr;
	__u32 ra_defrtr_metric;
	__s32 accept_ra_min_hop_limit;
	__s32 accept_ra_pinfo;
	__s32 ignore_routes_with_linkdown;
	__s32 proxy_ndp;
	__s32 accept_source_route;
	__s32 accept_ra_from_local;
	__s32 disable_ipv6;
	__s32 drop_unicast_in_l2_multicast;
	__s32 accept_dad;
	__s32 force_tllao;
	__s32 ndisc_notify;
	__s32 suppress_frag_ndisc;
	__s32 accept_ra_mtu;
	__s32 drop_unsolicited_na;
	__s32 accept_untracked_na;
	struct ipv6_stable_secret stable_secret;
	__s32 use_oif_addrs_only;
	__s32 keep_addr_on_down;
	__s32 seg6_enabled;
	__u32 enhanced_dad;
	__u32 addr_gen_mode;
	__s32 disable_policy;
	__s32 ndisc_tclass;
	__s32 rpl_seg_enabled;
	__u32 ioam6_id;
	__u32 ioam6_id_wide;
	__u8 ioam6_enabled;
	__u8 ndisc_evict_nocarrier;
	struct ctl_table_header *sysctl_header;
};

typedef struct {
	union {
		void *kernel;
		void *user;
	};
	bool is_kernel: 1;
} sockptr_t;

typedef enum {
	SS_FREE = 0,
	SS_UNCONNECTED = 1,
	SS_CONNECTING = 2,
	SS_CONNECTED = 3,
	SS_DISCONNECTING = 4,
} socket_state;

struct socket_wq {
	wait_queue_head_t wait;
	struct fasync_struct *fasync_list;
	long unsigned int flags;
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct proto_ops;

struct socket {
	socket_state state;
	short int type;
	long unsigned int flags;
	struct file *file;
	struct sock *sk;
	const struct proto_ops *ops;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct socket_wq wq;
};

typedef struct {
	size_t written;
	size_t count;
	union {
		char *buf;
		void *data;
	} arg;
	int error;
} read_descriptor_t;

typedef int (*sk_read_actor_t)(read_descriptor_t *, struct sk_buff *, unsigned int, size_t);

typedef int (*skb_read_actor_t)(struct sock *, struct sk_buff *);

struct proto_ops {
	int family;
	struct module *owner;
	int (*release)(struct socket *);
	int (*bind)(struct socket *, struct sockaddr *, int);
	int (*connect)(struct socket *, struct sockaddr *, int, int);
	int (*socketpair)(struct socket *, struct socket *);
	int (*accept)(struct socket *, struct socket *, int, bool);
	int (*getname)(struct socket *, struct sockaddr *, int);
	__poll_t (*poll)(struct file *, struct socket *, struct poll_table_struct *);
	int (*ioctl)(struct socket *, unsigned int, long unsigned int);
	int (*gettstamp)(struct socket *, void *, bool, bool);
	int (*listen)(struct socket *, int);
	int (*shutdown)(struct socket *, int);
	int (*setsockopt)(struct socket *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct socket *, int, int, char *, int *);
	void (*show_fdinfo)(struct seq_file *, struct socket *);
	int (*sendmsg)(struct socket *, struct msghdr *, size_t);
	int (*recvmsg)(struct socket *, struct msghdr *, size_t, int);
	int (*mmap)(struct file *, struct socket *, struct vm_area_struct *);
	ssize_t (*sendpage)(struct socket *, struct page *, int, size_t, int);
	ssize_t (*splice_read)(struct socket *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	int (*set_peek_off)(struct sock *, int);
	int (*peek_len)(struct socket *);
	int (*read_sock)(struct sock *, read_descriptor_t *, sk_read_actor_t);
	int (*read_skb)(struct sock *, skb_read_actor_t);
	int (*sendpage_locked)(struct sock *, struct page *, int, size_t, int);
	int (*sendmsg_locked)(struct sock *, struct msghdr *, size_t);
	int (*set_rcvlowat)(struct sock *, int);
};

struct skb_shared_hwtstamps {
	union {
		ktime_t hwtstamp;
		void *netdev_data;
	};
};

enum rpc_display_format_t {
	RPC_DISPLAY_ADDR = 0,
	RPC_DISPLAY_PORT = 1,
	RPC_DISPLAY_PROTO = 2,
	RPC_DISPLAY_HEX_ADDR = 3,
	RPC_DISPLAY_HEX_PORT = 4,
	RPC_DISPLAY_NETID = 5,
	RPC_DISPLAY_MAX = 6,
};

struct dql {
	unsigned int num_queued;
	unsigned int adj_limit;
	unsigned int last_obj_cnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	unsigned int limit;
	unsigned int num_completed;
	unsigned int prev_ovlimit;
	unsigned int prev_num_queued;
	unsigned int prev_last_obj_cnt;
	unsigned int lowest_slack;
	long unsigned int slack_start_time;
	unsigned int max_limit;
	unsigned int min_limit;
	unsigned int slack_hold_time;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xdp_mem_info {
	u32 type;
	u32 id;
};

struct xdp_rxq_info {
	struct net_device *dev;
	u32 queue_index;
	u32 reg_state;
	struct xdp_mem_info mem;
	unsigned int napi_id;
	u32 frag_size;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xdp_txq_info {
	struct net_device *dev;
};

struct xdp_buff {
	void *data;
	void *data_end;
	void *data_meta;
	void *data_hard_start;
	struct xdp_rxq_info *rxq;
	struct xdp_txq_info *txq;
	u32 frame_sz;
	u32 flags;
};

struct xdp_frame {
	void *data;
	u16 len;
	u16 headroom;
	u32 metasize;
	struct xdp_mem_info mem;
	struct net_device *dev_rx;
	u32 frame_sz;
	u32 flags;
};

struct nlmsghdr {
	__u32 nlmsg_len;
	__u16 nlmsg_type;
	__u16 nlmsg_flags;
	__u32 nlmsg_seq;
	__u32 nlmsg_pid;
};

struct nlattr {
	__u16 nla_len;
	__u16 nla_type;
};

struct nla_policy;

struct netlink_ext_ack {
	const char *_msg;
	const struct nlattr *bad_attr;
	const struct nla_policy *policy;
	const struct nlattr *miss_nest;
	u16 miss_type;
	u8 cookie[20];
	u8 cookie_len;
};

struct netlink_range_validation;

struct netlink_range_validation_signed;

struct nla_policy {
	u8 type;
	u8 validation_type;
	u16 len;
	union {
		u16 strict_start_type;
		const u32 bitfield32_valid;
		const u32 mask;
		const char *reject_message;
		const struct nla_policy *nested_policy;
		struct netlink_range_validation *range;
		struct netlink_range_validation_signed *range_signed;
		struct {
			s16 min;
			s16 max;
		};
		int (*validate)(const struct nlattr *, struct netlink_ext_ack *);
	};
};

struct netlink_callback {
	struct sk_buff *skb;
	const struct nlmsghdr *nlh;
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	struct netlink_ext_ack *extack;
	u16 family;
	u16 answer_flags;
	u32 min_dump_alloc;
	unsigned int prev_seq;
	unsigned int seq;
	bool strict_check;
	union {
		u8 ctx[48];
		long int args[6];
	};
};

struct ndmsg {
	__u8 ndm_family;
	__u8 ndm_pad1;
	__u16 ndm_pad2;
	__s32 ndm_ifindex;
	__u16 ndm_state;
	__u8 ndm_flags;
	__u8 ndm_type;
};

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
} sync_serial_settings;

typedef struct {
	unsigned int clock_rate;
	unsigned int clock_type;
	short unsigned int loopback;
	unsigned int slot_map;
} te1_settings;

typedef struct {
	short unsigned int encoding;
	short unsigned int parity;
} raw_hdlc_proto;

typedef struct {
	unsigned int t391;
	unsigned int t392;
	unsigned int n391;
	unsigned int n392;
	unsigned int n393;
	short unsigned int lmi;
	short unsigned int dce;
} fr_proto;

typedef struct {
	unsigned int dlci;
} fr_proto_pvc;

typedef struct {
	unsigned int dlci;
	char master[16];
} fr_proto_pvc_info;

typedef struct {
	unsigned int interval;
	unsigned int timeout;
} cisco_proto;

typedef struct {
	short unsigned int dce;
	unsigned int modulo;
	unsigned int window;
	unsigned int t1;
	unsigned int t2;
	unsigned int n2;
} x25_hdlc_proto;

struct ifmap {
	long unsigned int mem_start;
	long unsigned int mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct if_settings {
	unsigned int type;
	unsigned int size;
	union {
		raw_hdlc_proto *raw_hdlc;
		cisco_proto *cisco;
		fr_proto *fr;
		fr_proto_pvc *fr_pvc;
		fr_proto_pvc_info *fr_pvc_info;
		x25_hdlc_proto *x25;
		sync_serial_settings *sync;
		te1_settings *te1;
	} ifs_ifsu;
};

struct ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		int ifru_ivalue;
		int ifru_mtu;
		struct ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		void *ifru_data;
		struct if_settings ifru_settings;
	} ifr_ifru;
};

struct rtnl_link_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
	__u64 collisions;
	__u64 rx_length_errors;
	__u64 rx_over_errors;
	__u64 rx_crc_errors;
	__u64 rx_frame_errors;
	__u64 rx_fifo_errors;
	__u64 rx_missed_errors;
	__u64 tx_aborted_errors;
	__u64 tx_carrier_errors;
	__u64 tx_fifo_errors;
	__u64 tx_heartbeat_errors;
	__u64 tx_window_errors;
	__u64 rx_compressed;
	__u64 tx_compressed;
	__u64 rx_nohandler;
	__u64 rx_otherhost_dropped;
};

struct rtnl_hw_stats64 {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 rx_errors;
	__u64 tx_errors;
	__u64 rx_dropped;
	__u64 tx_dropped;
	__u64 multicast;
};

struct ifla_vf_guid {
	__u32 vf;
	int: 32;
	__u64 guid;
};

struct ifla_vf_stats {
	__u64 rx_packets;
	__u64 tx_packets;
	__u64 rx_bytes;
	__u64 tx_bytes;
	__u64 broadcast;
	__u64 multicast;
	__u64 rx_dropped;
	__u64 tx_dropped;
};

struct ifla_vf_info {
	__u32 vf;
	__u8 mac[32];
	__u32 vlan;
	__u32 qos;
	__u32 spoofchk;
	__u32 linkstate;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
	__u32 rss_query_en;
	__u32 trusted;
	__be16 vlan_proto;
};

enum netdev_tx {
	__NETDEV_TX_MIN = 2147483648,
	NETDEV_TX_OK = 0,
	NETDEV_TX_BUSY = 16,
};

typedef enum netdev_tx netdev_tx_t;

struct net_device_core_stats {
	long unsigned int rx_dropped;
	long unsigned int tx_dropped;
	long unsigned int rx_nohandler;
	long unsigned int rx_otherhost_dropped;
};

struct header_ops {
	int (*create)(struct sk_buff *, struct net_device *, short unsigned int, const void *, const void *, unsigned int);
	int (*parse)(const struct sk_buff *, unsigned char *);
	int (*cache)(const struct neighbour *, struct hh_cache *, __be16);
	void (*cache_update)(struct hh_cache *, const struct net_device *, const unsigned char *);
	bool (*validate)(const char *, unsigned int);
	__be16 (*parse_protocol)(const struct sk_buff *);
};

enum {
	NAPI_STATE_SCHED = 0,
	NAPI_STATE_MISSED = 1,
	NAPI_STATE_DISABLE = 2,
	NAPI_STATE_NPSVC = 3,
	NAPI_STATE_LISTED = 4,
	NAPI_STATE_NO_BUSY_POLL = 5,
	NAPI_STATE_IN_BUSY_POLL = 6,
	NAPI_STATE_PREFER_BUSY_POLL = 7,
	NAPI_STATE_THREADED = 8,
	NAPI_STATE_SCHED_THREADED = 9,
};

struct netdev_queue {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct Qdisc *qdisc;
	struct Qdisc *qdisc_sleeping;
	struct kobject kobj;
	long unsigned int tx_maxrate;
	atomic_long_t trans_timeout;
	struct net_device *sb_dev;
	int: 32;
	spinlock_t _xmit_lock;
	int xmit_lock_owner;
	long unsigned int trans_start;
	long unsigned int state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct dql dql;
};

struct rps_map {
	unsigned int len;
	struct callback_head rcu;
	u16 cpus[0];
};

struct rps_dev_flow {
	u16 cpu;
	u16 filter;
	unsigned int last_qtail;
};

struct rps_dev_flow_table {
	unsigned int mask;
	struct callback_head rcu;
	struct rps_dev_flow flows[0];
};

struct netdev_rx_queue {
	struct xdp_rxq_info xdp_rxq;
	struct rps_map *rps_map;
	struct rps_dev_flow_table *rps_flow_table;
	struct kobject kobj;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum xps_map_type {
	XPS_CPUS = 0,
	XPS_RXQS = 1,
	XPS_MAPS_MAX = 2,
};

struct xps_map {
	unsigned int len;
	unsigned int alloc_len;
	struct callback_head rcu;
	u16 queues[0];
};

struct xps_dev_maps {
	struct callback_head rcu;
	unsigned int nr_ids;
	s16 num_tc;
	struct xps_map *attr_map[0];
};

struct netdev_phys_item_id {
	unsigned char id[32];
	unsigned char id_len;
};

enum net_device_path_type {
	DEV_PATH_ETHERNET = 0,
	DEV_PATH_VLAN = 1,
	DEV_PATH_BRIDGE = 2,
	DEV_PATH_PPPOE = 3,
	DEV_PATH_DSA = 4,
	DEV_PATH_MTK_WDMA = 5,
};

struct net_device_path {
	enum net_device_path_type type;
	const struct net_device *dev;
	union {
		struct {
			u16 id;
			__be16 proto;
			u8 h_dest[6];
		} encap;
		struct {
			enum {
				DEV_PATH_BR_VLAN_KEEP = 0,
				DEV_PATH_BR_VLAN_TAG = 1,
				DEV_PATH_BR_VLAN_UNTAG = 2,
				DEV_PATH_BR_VLAN_UNTAG_HW = 3,
			} vlan_mode;
			u16 vlan_id;
			__be16 vlan_proto;
		} bridge;
		struct {
			int port;
			u16 proto;
		} dsa;
		struct {
			u8 wdma_idx;
			u8 queue;
			u16 wcid;
			u8 bss;
		} mtk_wdma;
	};
};

struct net_device_path_ctx {
	const struct net_device *dev;
	u8 daddr[6];
	int num_vlans;
	struct {
		u16 id;
		__be16 proto;
	} vlan[2];
};

enum tc_setup_type {
	TC_QUERY_CAPS = 0,
	TC_SETUP_QDISC_MQPRIO = 1,
	TC_SETUP_CLSU32 = 2,
	TC_SETUP_CLSFLOWER = 3,
	TC_SETUP_CLSMATCHALL = 4,
	TC_SETUP_CLSBPF = 5,
	TC_SETUP_BLOCK = 6,
	TC_SETUP_QDISC_CBS = 7,
	TC_SETUP_QDISC_RED = 8,
	TC_SETUP_QDISC_PRIO = 9,
	TC_SETUP_QDISC_MQ = 10,
	TC_SETUP_QDISC_ETF = 11,
	TC_SETUP_ROOT_QDISC = 12,
	TC_SETUP_QDISC_GRED = 13,
	TC_SETUP_QDISC_TAPRIO = 14,
	TC_SETUP_FT = 15,
	TC_SETUP_QDISC_ETS = 16,
	TC_SETUP_QDISC_TBF = 17,
	TC_SETUP_QDISC_FIFO = 18,
	TC_SETUP_QDISC_HTB = 19,
	TC_SETUP_ACT = 20,
};

enum bpf_netdev_command {
	XDP_SETUP_PROG = 0,
	XDP_SETUP_PROG_HW = 1,
	BPF_OFFLOAD_MAP_ALLOC = 2,
	BPF_OFFLOAD_MAP_FREE = 3,
	XDP_SETUP_XSK_POOL = 4,
};

enum bpf_xdp_mode {
	XDP_MODE_SKB = 0,
	XDP_MODE_DRV = 1,
	XDP_MODE_HW = 2,
	__MAX_XDP_MODE = 3,
};

struct bpf_offloaded_map;

struct xsk_buff_pool;

struct netdev_bpf {
	enum bpf_netdev_command command;
	union {
		struct {
			u32 flags;
			struct bpf_prog *prog;
			struct netlink_ext_ack *extack;
		};
		struct {
			struct bpf_offloaded_map *offmap;
		};
		struct {
			struct xsk_buff_pool *pool;
			u16 queue_id;
		} xsk;
	};
};

struct dev_ifalias {
	struct callback_head rcuhead;
	char ifalias[0];
};

struct devlink_port;

struct ip_tunnel_parm;

struct net_device_ops {
	int (*ndo_init)(struct net_device *);
	void (*ndo_uninit)(struct net_device *);
	int (*ndo_open)(struct net_device *);
	int (*ndo_stop)(struct net_device *);
	netdev_tx_t (*ndo_start_xmit)(struct sk_buff *, struct net_device *);
	netdev_features_t (*ndo_features_check)(struct sk_buff *, struct net_device *, netdev_features_t);
	u16 (*ndo_select_queue)(struct net_device *, struct sk_buff *, struct net_device *);
	void (*ndo_change_rx_flags)(struct net_device *, int);
	void (*ndo_set_rx_mode)(struct net_device *);
	int (*ndo_set_mac_address)(struct net_device *, void *);
	int (*ndo_validate_addr)(struct net_device *);
	int (*ndo_do_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_eth_ioctl)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocbond)(struct net_device *, struct ifreq *, int);
	int (*ndo_siocwandev)(struct net_device *, struct if_settings *);
	int (*ndo_siocdevprivate)(struct net_device *, struct ifreq *, void *, int);
	int (*ndo_set_config)(struct net_device *, struct ifmap *);
	int (*ndo_change_mtu)(struct net_device *, int);
	int (*ndo_neigh_setup)(struct net_device *, struct neigh_parms *);
	void (*ndo_tx_timeout)(struct net_device *, unsigned int);
	void (*ndo_get_stats64)(struct net_device *, struct rtnl_link_stats64 *);
	bool (*ndo_has_offload_stats)(const struct net_device *, int);
	int (*ndo_get_offload_stats)(int, const struct net_device *, void *);
	struct net_device_stats * (*ndo_get_stats)(struct net_device *);
	int (*ndo_vlan_rx_add_vid)(struct net_device *, __be16, u16);
	int (*ndo_vlan_rx_kill_vid)(struct net_device *, __be16, u16);
	int (*ndo_set_vf_mac)(struct net_device *, int, u8 *);
	int (*ndo_set_vf_vlan)(struct net_device *, int, u16, u8, __be16);
	int (*ndo_set_vf_rate)(struct net_device *, int, int, int);
	int (*ndo_set_vf_spoofchk)(struct net_device *, int, bool);
	int (*ndo_set_vf_trust)(struct net_device *, int, bool);
	int (*ndo_get_vf_config)(struct net_device *, int, struct ifla_vf_info *);
	int (*ndo_set_vf_link_state)(struct net_device *, int, int);
	int (*ndo_get_vf_stats)(struct net_device *, int, struct ifla_vf_stats *);
	int (*ndo_set_vf_port)(struct net_device *, int, struct nlattr **);
	int (*ndo_get_vf_port)(struct net_device *, int, struct sk_buff *);
	int (*ndo_get_vf_guid)(struct net_device *, int, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*ndo_set_vf_guid)(struct net_device *, int, u64, int);
	int (*ndo_set_vf_rss_query_en)(struct net_device *, int, bool);
	int (*ndo_setup_tc)(struct net_device *, enum tc_setup_type, void *);
	int (*ndo_rx_flow_steer)(struct net_device *, const struct sk_buff *, u16, u32);
	int (*ndo_add_slave)(struct net_device *, struct net_device *, struct netlink_ext_ack *);
	int (*ndo_del_slave)(struct net_device *, struct net_device *);
	struct net_device * (*ndo_get_xmit_slave)(struct net_device *, struct sk_buff *, bool);
	struct net_device * (*ndo_sk_get_lower_dev)(struct net_device *, struct sock *);
	netdev_features_t (*ndo_fix_features)(struct net_device *, netdev_features_t);
	int (*ndo_set_features)(struct net_device *, netdev_features_t);
	int (*ndo_neigh_construct)(struct net_device *, struct neighbour *);
	void (*ndo_neigh_destroy)(struct net_device *, struct neighbour *);
	int (*ndo_fdb_add)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del)(struct ndmsg *, struct nlattr **, struct net_device *, const unsigned char *, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_del_bulk)(struct ndmsg *, struct nlattr **, struct net_device *, u16, struct netlink_ext_ack *);
	int (*ndo_fdb_dump)(struct sk_buff *, struct netlink_callback *, struct net_device *, struct net_device *, int *);
	int (*ndo_fdb_get)(struct sk_buff *, struct nlattr **, struct net_device *, const unsigned char *, u16, u32, u32, struct netlink_ext_ack *);
	int (*ndo_bridge_setlink)(struct net_device *, struct nlmsghdr *, u16, struct netlink_ext_ack *);
	int (*ndo_bridge_getlink)(struct sk_buff *, u32, u32, struct net_device *, u32, int);
	int (*ndo_bridge_dellink)(struct net_device *, struct nlmsghdr *, u16);
	int (*ndo_change_carrier)(struct net_device *, bool);
	int (*ndo_get_phys_port_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_port_parent_id)(struct net_device *, struct netdev_phys_item_id *);
	int (*ndo_get_phys_port_name)(struct net_device *, char *, size_t);
	void * (*ndo_dfwd_add_station)(struct net_device *, struct net_device *);
	void (*ndo_dfwd_del_station)(struct net_device *, void *);
	int (*ndo_set_tx_maxrate)(struct net_device *, int, u32);
	int (*ndo_get_iflink)(const struct net_device *);
	int (*ndo_fill_metadata_dst)(struct net_device *, struct sk_buff *);
	void (*ndo_set_rx_headroom)(struct net_device *, int);
	int (*ndo_bpf)(struct net_device *, struct netdev_bpf *);
	int (*ndo_xdp_xmit)(struct net_device *, int, struct xdp_frame **, u32);
	struct net_device * (*ndo_xdp_get_xmit_slave)(struct net_device *, struct xdp_buff *);
	int (*ndo_xsk_wakeup)(struct net_device *, u32, u32);
	struct devlink_port * (*ndo_get_devlink_port)(struct net_device *);
	int (*ndo_tunnel_ctl)(struct net_device *, struct ip_tunnel_parm *, int);
	struct net_device * (*ndo_get_peer_dev)(struct net_device *);
	int (*ndo_fill_forward_path)(struct net_device_path_ctx *, struct net_device_path *);
	ktime_t (*ndo_get_tstamp)(struct net_device *, const struct skb_shared_hwtstamps *, bool);
};

struct neigh_parms {
	possible_net_t net;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head list;
	int (*neigh_setup)(struct neighbour *);
	struct neigh_table *tbl;
	void *sysctl_table;
	int dead;
	refcount_t refcnt;
	struct callback_head callback_head;
	int reachable_time;
	u32 qlen;
	int data[14];
	long unsigned int data_state[1];
};

struct pcpu_lstats {
	u64_stats_t packets;
	u64_stats_t bytes;
	struct u64_stats_sync syncp;
	int: 32;
	int: 32;
	int: 32;
};

struct pcpu_sw_netstats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct iw_request_info;

union iwreq_data;

typedef int (*iw_handler)(struct net_device *, struct iw_request_info *, union iwreq_data *, char *);

struct iw_priv_args;

struct iw_statistics;

struct iw_handler_def {
	const iw_handler *standard;
	__u16 num_standard;
	__u16 num_private;
	__u16 num_private_args;
	const iw_handler *private;
	const struct iw_priv_args *private_args;
	struct iw_statistics * (*get_wireless_stats)(struct net_device *);
};

enum ethtool_phys_id_state {
	ETHTOOL_ID_INACTIVE = 0,
	ETHTOOL_ID_ACTIVE = 1,
	ETHTOOL_ID_ON = 2,
	ETHTOOL_ID_OFF = 3,
};

struct ethtool_drvinfo;

struct ethtool_regs;

struct ethtool_wolinfo;

struct ethtool_link_ext_state_info;

struct ethtool_eeprom;

struct ethtool_coalesce;

struct kernel_ethtool_coalesce;

struct ethtool_ringparam;

struct kernel_ethtool_ringparam;

struct ethtool_pause_stats;

struct ethtool_pauseparam;

struct ethtool_test;

struct ethtool_stats;

struct ethtool_rxnfc;

struct ethtool_flash;

struct ethtool_channels;

struct ethtool_dump;

struct ethtool_ts_info;

struct ethtool_modinfo;

struct ethtool_eee;

struct ethtool_tunable;

struct ethtool_link_ksettings;

struct ethtool_fec_stats;

struct ethtool_fecparam;

struct ethtool_module_eeprom;

struct ethtool_eth_phy_stats;

struct ethtool_eth_mac_stats;

struct ethtool_eth_ctrl_stats;

struct ethtool_rmon_stats;

struct ethtool_rmon_hist_range;

struct ethtool_module_power_mode_params;

struct ethtool_ops {
	u32 cap_link_lanes_supported: 1;
	u32 supported_coalesce_params;
	u32 supported_ring_params;
	void (*get_drvinfo)(struct net_device *, struct ethtool_drvinfo *);
	int (*get_regs_len)(struct net_device *);
	void (*get_regs)(struct net_device *, struct ethtool_regs *, void *);
	void (*get_wol)(struct net_device *, struct ethtool_wolinfo *);
	int (*set_wol)(struct net_device *, struct ethtool_wolinfo *);
	u32 (*get_msglevel)(struct net_device *);
	void (*set_msglevel)(struct net_device *, u32);
	int (*nway_reset)(struct net_device *);
	u32 (*get_link)(struct net_device *);
	int (*get_link_ext_state)(struct net_device *, struct ethtool_link_ext_state_info *);
	int (*get_eeprom_len)(struct net_device *);
	int (*get_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	int (*set_coalesce)(struct net_device *, struct ethtool_coalesce *, struct kernel_ethtool_coalesce *, struct netlink_ext_ack *);
	void (*get_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
	int (*set_ringparam)(struct net_device *, struct ethtool_ringparam *, struct kernel_ethtool_ringparam *, struct netlink_ext_ack *);
	void (*get_pause_stats)(struct net_device *, struct ethtool_pause_stats *);
	void (*get_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	int (*set_pauseparam)(struct net_device *, struct ethtool_pauseparam *);
	void (*self_test)(struct net_device *, struct ethtool_test *, u64 *);
	void (*get_strings)(struct net_device *, u32, u8 *);
	int (*set_phys_id)(struct net_device *, enum ethtool_phys_id_state);
	void (*get_ethtool_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*begin)(struct net_device *);
	void (*complete)(struct net_device *);
	u32 (*get_priv_flags)(struct net_device *);
	int (*set_priv_flags)(struct net_device *, u32);
	int (*get_sset_count)(struct net_device *, int);
	int (*get_rxnfc)(struct net_device *, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct net_device *, struct ethtool_rxnfc *);
	int (*flash_device)(struct net_device *, struct ethtool_flash *);
	int (*reset)(struct net_device *, u32 *);
	u32 (*get_rxfh_key_size)(struct net_device *);
	u32 (*get_rxfh_indir_size)(struct net_device *);
	int (*get_rxfh)(struct net_device *, u32 *, u8 *, u8 *);
	int (*set_rxfh)(struct net_device *, const u32 *, const u8 *, const u8);
	int (*get_rxfh_context)(struct net_device *, u32 *, u8 *, u8 *, u32);
	int (*set_rxfh_context)(struct net_device *, const u32 *, const u8 *, const u8, u32 *, bool);
	void (*get_channels)(struct net_device *, struct ethtool_channels *);
	int (*set_channels)(struct net_device *, struct ethtool_channels *);
	int (*get_dump_flag)(struct net_device *, struct ethtool_dump *);
	int (*get_dump_data)(struct net_device *, struct ethtool_dump *, void *);
	int (*set_dump)(struct net_device *, struct ethtool_dump *);
	int (*get_ts_info)(struct net_device *, struct ethtool_ts_info *);
	int (*get_module_info)(struct net_device *, struct ethtool_modinfo *);
	int (*get_module_eeprom)(struct net_device *, struct ethtool_eeprom *, u8 *);
	int (*get_eee)(struct net_device *, struct ethtool_eee *);
	int (*set_eee)(struct net_device *, struct ethtool_eee *);
	int (*get_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*set_per_queue_coalesce)(struct net_device *, u32, struct ethtool_coalesce *);
	int (*get_link_ksettings)(struct net_device *, struct ethtool_link_ksettings *);
	int (*set_link_ksettings)(struct net_device *, const struct ethtool_link_ksettings *);
	void (*get_fec_stats)(struct net_device *, struct ethtool_fec_stats *);
	int (*get_fecparam)(struct net_device *, struct ethtool_fecparam *);
	int (*set_fecparam)(struct net_device *, struct ethtool_fecparam *);
	void (*get_ethtool_phy_stats)(struct net_device *, struct ethtool_stats *, u64 *);
	int (*get_phy_tunable)(struct net_device *, const struct ethtool_tunable *, void *);
	int (*set_phy_tunable)(struct net_device *, const struct ethtool_tunable *, const void *);
	int (*get_module_eeprom_by_page)(struct net_device *, const struct ethtool_module_eeprom *, struct netlink_ext_ack *);
	void (*get_eth_phy_stats)(struct net_device *, struct ethtool_eth_phy_stats *);
	void (*get_eth_mac_stats)(struct net_device *, struct ethtool_eth_mac_stats *);
	void (*get_eth_ctrl_stats)(struct net_device *, struct ethtool_eth_ctrl_stats *);
	void (*get_rmon_stats)(struct net_device *, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
	int (*get_module_power_mode)(struct net_device *, struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
	int (*set_module_power_mode)(struct net_device *, const struct ethtool_module_power_mode_params *, struct netlink_ext_ack *);
};

struct nd_opt_hdr;

struct ndisc_options;

struct prefix_info;

struct ndisc_ops {
	int (*is_useropt)(u8);
	int (*parse_options)(const struct net_device *, struct nd_opt_hdr *, struct ndisc_options *);
	void (*update)(const struct net_device *, struct neighbour *, u32, u8, const struct ndisc_options *);
	int (*opt_addr_space)(const struct net_device *, u8, struct neighbour *, u8 *, u8 **);
	void (*fill_addr_option)(const struct net_device *, struct sk_buff *, u8, const u8 *);
	void (*prefix_rcv_add_addr)(struct net *, struct net_device *, const struct prefix_info *, struct inet6_dev *, struct in6_addr *, int, u32, bool, bool, __u32, u32, bool);
};

enum tls_offload_ctx_dir {
	TLS_OFFLOAD_CTX_DIR_RX = 0,
	TLS_OFFLOAD_CTX_DIR_TX = 1,
};

struct tls_crypto_info;

struct tls_context;

struct tlsdev_ops {
	int (*tls_dev_add)(struct net_device *, struct sock *, enum tls_offload_ctx_dir, struct tls_crypto_info *, u32);
	void (*tls_dev_del)(struct net_device *, struct tls_context *, enum tls_offload_ctx_dir);
	int (*tls_dev_resync)(struct net_device *, struct sock *, u32, u8 *, enum tls_offload_ctx_dir);
};

struct ipv6_devstat {
	struct proc_dir_entry *proc_dir_entry;
	struct ipstats_mib *ipv6;
	struct icmpv6_mib_device *icmpv6dev;
	struct icmpv6msg_mib_device *icmpv6msgdev;
};

struct ifmcaddr6;

struct ifacaddr6;

struct inet6_dev {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head addr_list;
	struct ifmcaddr6 *mc_list;
	struct ifmcaddr6 *mc_tomb;
	unsigned char mc_qrv;
	unsigned char mc_gq_running;
	unsigned char mc_ifc_count;
	unsigned char mc_dad_count;
	long unsigned int mc_v1_seen;
	long unsigned int mc_qi;
	long unsigned int mc_qri;
	long unsigned int mc_maxdelay;
	struct delayed_work mc_gq_work;
	struct delayed_work mc_ifc_work;
	struct delayed_work mc_dad_work;
	struct delayed_work mc_query_work;
	struct delayed_work mc_report_work;
	struct sk_buff_head mc_query_queue;
	struct sk_buff_head mc_report_queue;
	spinlock_t mc_query_lock;
	spinlock_t mc_report_lock;
	struct mutex mc_lock;
	struct ifacaddr6 *ac_list;
	rwlock_t lock;
	refcount_t refcnt;
	__u32 if_flags;
	int dead;
	u32 desync_factor;
	struct list_head tempaddr_list;
	struct in6_addr token;
	struct neigh_parms *nd_parms;
	struct ipv6_devconf cnf;
	struct ipv6_devstat stats;
	struct timer_list rs_timer;
	__s32 rs_interval;
	__u8 rs_probes;
	long unsigned int tstamp;
	struct callback_head rcu;
	unsigned int ra_mtu;
};

struct rtnl_link_ops {
	struct list_head list;
	const char *kind;
	size_t priv_size;
	struct net_device * (*alloc)(struct nlattr **, const char *, unsigned char, unsigned int, unsigned int);
	void (*setup)(struct net_device *);
	bool netns_refund;
	unsigned int maxtype;
	const struct nla_policy *policy;
	int (*validate)(struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*newlink)(struct net *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	int (*changelink)(struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	void (*dellink)(struct net_device *, struct list_head *);
	size_t (*get_size)(const struct net_device *);
	int (*fill_info)(struct sk_buff *, const struct net_device *);
	size_t (*get_xstats_size)(const struct net_device *);
	int (*fill_xstats)(struct sk_buff *, const struct net_device *);
	unsigned int (*get_num_tx_queues)();
	unsigned int (*get_num_rx_queues)();
	unsigned int slave_maxtype;
	const struct nla_policy *slave_policy;
	int (*slave_changelink)(struct net_device *, struct net_device *, struct nlattr **, struct nlattr **, struct netlink_ext_ack *);
	size_t (*get_slave_size)(const struct net_device *, const struct net_device *);
	int (*fill_slave_info)(struct sk_buff *, const struct net_device *, const struct net_device *);
	struct net * (*get_link_net)(const struct net_device *);
	size_t (*get_linkxstats_size)(const struct net_device *, int);
	int (*fill_linkxstats)(struct sk_buff *, const struct net_device *, int *, int);
};

struct udp_tunnel_nic_table_info {
	unsigned int n_entries;
	unsigned int tunnel_types;
};

struct udp_tunnel_info;

struct udp_tunnel_nic_shared;

struct udp_tunnel_nic_info {
	int (*set_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*unset_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	int (*sync_table)(struct net_device *, unsigned int);
	struct udp_tunnel_nic_shared *shared;
	unsigned int flags;
	struct udp_tunnel_nic_table_info tables[4];
};

enum {
	NETIF_MSG_DRV_BIT = 0,
	NETIF_MSG_PROBE_BIT = 1,
	NETIF_MSG_LINK_BIT = 2,
	NETIF_MSG_TIMER_BIT = 3,
	NETIF_MSG_IFDOWN_BIT = 4,
	NETIF_MSG_IFUP_BIT = 5,
	NETIF_MSG_RX_ERR_BIT = 6,
	NETIF_MSG_TX_ERR_BIT = 7,
	NETIF_MSG_TX_QUEUED_BIT = 8,
	NETIF_MSG_INTR_BIT = 9,
	NETIF_MSG_TX_DONE_BIT = 10,
	NETIF_MSG_RX_STATUS_BIT = 11,
	NETIF_MSG_PKTDATA_BIT = 12,
	NETIF_MSG_HW_BIT = 13,
	NETIF_MSG_WOL_BIT = 14,
	NETIF_MSG_CLASS_COUNT = 15,
};

enum {
	RTAX_UNSPEC = 0,
	RTAX_LOCK = 1,
	RTAX_MTU = 2,
	RTAX_WINDOW = 3,
	RTAX_RTT = 4,
	RTAX_RTTVAR = 5,
	RTAX_SSTHRESH = 6,
	RTAX_CWND = 7,
	RTAX_ADVMSS = 8,
	RTAX_REORDERING = 9,
	RTAX_HOPLIMIT = 10,
	RTAX_INITCWND = 11,
	RTAX_FEATURES = 12,
	RTAX_RTO_MIN = 13,
	RTAX_INITRWND = 14,
	RTAX_QUICKACK = 15,
	RTAX_CC_ALGO = 16,
	RTAX_FASTOPEN_NO_COOKIE = 17,
	__RTAX_MAX = 18,
};

struct netlink_range_validation {
	u64 min;
	u64 max;
};

struct netlink_range_validation_signed {
	s64 min;
	s64 max;
};

enum {
	NEIGH_VAR_MCAST_PROBES = 0,
	NEIGH_VAR_UCAST_PROBES = 1,
	NEIGH_VAR_APP_PROBES = 2,
	NEIGH_VAR_MCAST_REPROBES = 3,
	NEIGH_VAR_RETRANS_TIME = 4,
	NEIGH_VAR_BASE_REACHABLE_TIME = 5,
	NEIGH_VAR_DELAY_PROBE_TIME = 6,
	NEIGH_VAR_INTERVAL_PROBE_TIME_MS = 7,
	NEIGH_VAR_GC_STALETIME = 8,
	NEIGH_VAR_QUEUE_LEN_BYTES = 9,
	NEIGH_VAR_PROXY_QLEN = 10,
	NEIGH_VAR_ANYCAST_DELAY = 11,
	NEIGH_VAR_PROXY_DELAY = 12,
	NEIGH_VAR_LOCKTIME = 13,
	NEIGH_VAR_QUEUE_LEN = 14,
	NEIGH_VAR_RETRANS_TIME_MS = 15,
	NEIGH_VAR_BASE_REACHABLE_TIME_MS = 16,
	NEIGH_VAR_GC_INTERVAL = 17,
	NEIGH_VAR_GC_THRESH1 = 18,
	NEIGH_VAR_GC_THRESH2 = 19,
	NEIGH_VAR_GC_THRESH3 = 20,
	NEIGH_VAR_MAX = 21,
};

struct pneigh_entry;

struct neigh_statistics;

struct neigh_hash_table;

struct neigh_table {
	int family;
	unsigned int entry_size;
	unsigned int key_len;
	__be16 protocol;
	__u32 (*hash)(const void *, const struct net_device *, __u32 *);
	bool (*key_eq)(const struct neighbour *, const void *);
	int (*constructor)(struct neighbour *);
	int (*pconstructor)(struct pneigh_entry *);
	void (*pdestructor)(struct pneigh_entry *);
	void (*proxy_redo)(struct sk_buff *);
	int (*is_multicast)(const void *);
	bool (*allow_add)(const struct net_device *, struct netlink_ext_ack *);
	char *id;
	struct neigh_parms parms;
	struct list_head parms_list;
	int gc_interval;
	int gc_thresh1;
	int gc_thresh2;
	int gc_thresh3;
	long unsigned int last_flush;
	struct delayed_work gc_work;
	struct delayed_work managed_work;
	struct timer_list proxy_timer;
	struct sk_buff_head proxy_queue;
	atomic_t entries;
	atomic_t gc_entries;
	struct list_head gc_list;
	struct list_head managed_list;
	rwlock_t lock;
	long unsigned int last_rand;
	struct neigh_statistics *stats;
	struct neigh_hash_table *nht;
	struct pneigh_entry **phash_buckets;
};

struct neigh_statistics {
	long unsigned int allocs;
	long unsigned int destroys;
	long unsigned int hash_grows;
	long unsigned int res_failed;
	long unsigned int lookups;
	long unsigned int hits;
	long unsigned int rcv_probes_mcast;
	long unsigned int rcv_probes_ucast;
	long unsigned int periodic_gc_runs;
	long unsigned int forced_gc_runs;
	long unsigned int unres_discards;
	long unsigned int table_fulls;
};

struct neigh_ops {
	int family;
	void (*solicit)(struct neighbour *, struct sk_buff *);
	void (*error_report)(struct neighbour *, struct sk_buff *);
	int (*output)(struct neighbour *, struct sk_buff *);
	int (*connected_output)(struct neighbour *, struct sk_buff *);
};

struct pneigh_entry {
	struct pneigh_entry *next;
	possible_net_t net;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 flags;
	u8 protocol;
	u8 key[0];
};

struct neigh_hash_table {
	struct neighbour **hash_buckets;
	unsigned int hash_shift;
	__u32 hash_rnd[4];
	struct callback_head rcu;
};

enum {
	TCP_ESTABLISHED = 1,
	TCP_SYN_SENT = 2,
	TCP_SYN_RECV = 3,
	TCP_FIN_WAIT1 = 4,
	TCP_FIN_WAIT2 = 5,
	TCP_TIME_WAIT = 6,
	TCP_CLOSE = 7,
	TCP_CLOSE_WAIT = 8,
	TCP_LAST_ACK = 9,
	TCP_LISTEN = 10,
	TCP_CLOSING = 11,
	TCP_NEW_SYN_RECV = 12,
	TCP_MAX_STATES = 13,
};

struct smc_hashinfo;

struct sk_psock;

struct request_sock_ops;

struct timewait_sock_ops;

struct udp_table;

struct raw_hashinfo;

struct proto {
	void (*close)(struct sock *, long int);
	int (*pre_connect)(struct sock *, struct sockaddr *, int);
	int (*connect)(struct sock *, struct sockaddr *, int);
	int (*disconnect)(struct sock *, int);
	struct sock * (*accept)(struct sock *, int, int *, bool);
	int (*ioctl)(struct sock *, int, long unsigned int);
	int (*init)(struct sock *);
	void (*destroy)(struct sock *);
	void (*shutdown)(struct sock *, int);
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*keepalive)(struct sock *, int);
	int (*sendmsg)(struct sock *, struct msghdr *, size_t);
	int (*recvmsg)(struct sock *, struct msghdr *, size_t, int, int *);
	int (*sendpage)(struct sock *, struct page *, int, size_t, int);
	int (*bind)(struct sock *, struct sockaddr *, int);
	int (*bind_add)(struct sock *, struct sockaddr *, int);
	int (*backlog_rcv)(struct sock *, struct sk_buff *);
	bool (*bpf_bypass_getsockopt)(int, int);
	void (*release_cb)(struct sock *);
	int (*hash)(struct sock *);
	void (*unhash)(struct sock *);
	void (*rehash)(struct sock *);
	int (*get_port)(struct sock *, short unsigned int);
	void (*put_port)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	unsigned int inuse_idx;
	bool (*stream_memory_free)(const struct sock *, int);
	bool (*sock_is_readable)(struct sock *);
	void (*enter_memory_pressure)(struct sock *);
	void (*leave_memory_pressure)(struct sock *);
	atomic_long_t *memory_allocated;
	int *per_cpu_fw_alloc;
	struct percpu_counter *sockets_allocated;
	long unsigned int *memory_pressure;
	long int *sysctl_mem;
	int *sysctl_wmem;
	int *sysctl_rmem;
	u32 sysctl_wmem_offset;
	u32 sysctl_rmem_offset;
	int max_header;
	bool no_autobind;
	struct kmem_cache *slab;
	unsigned int obj_size;
	slab_flags_t slab_flags;
	unsigned int useroffset;
	unsigned int usersize;
	unsigned int *orphan_count;
	struct request_sock_ops *rsk_prot;
	struct timewait_sock_ops *twsk_prot;
	union {
		struct inet_hashinfo *hashinfo;
		struct udp_table *udp_table;
		struct raw_hashinfo *raw_hash;
		struct smc_hashinfo *smc_hash;
	} h;
	struct module *owner;
	char name[32];
	struct list_head node;
	int (*diag_destroy)(struct sock *, int);
};

struct request_sock;

struct request_sock_ops {
	int family;
	unsigned int obj_size;
	struct kmem_cache *slab;
	char *slab_name;
	int (*rtx_syn_ack)(const struct sock *, struct request_sock *);
	void (*send_ack)(const struct sock *, struct sk_buff *, struct request_sock *);
	void (*send_reset)(const struct sock *, struct sk_buff *);
	void (*destructor)(struct request_sock *);
	void (*syn_ack_timeout)(const struct request_sock *);
};

struct timewait_sock_ops {
	struct kmem_cache *twsk_slab;
	char *twsk_slab_name;
	unsigned int twsk_obj_size;
	int (*twsk_unique)(struct sock *, struct sock *, void *);
	void (*twsk_destructor)(struct sock *);
};

struct saved_syn;

struct request_sock {
	struct sock_common __req_common;
	struct request_sock *dl_next;
	u16 mss;
	u8 num_retrans;
	u8 syncookie: 1;
	u8 num_timeout: 7;
	u32 ts_recent;
	struct timer_list rsk_timer;
	const struct request_sock_ops *rsk_ops;
	struct sock *sk;
	struct saved_syn *saved_syn;
	u32 secid;
	u32 peer_secid;
	u32 timeout;
};

struct saved_syn {
	u32 mac_hdrlen;
	u32 network_hdrlen;
	u32 tcp_hdrlen;
	u8 data[0];
};

enum tsq_enum {
	TSQ_THROTTLED = 0,
	TSQ_QUEUED = 1,
	TCP_TSQ_DEFERRED = 2,
	TCP_WRITE_TIMER_DEFERRED = 3,
	TCP_DELACK_TIMER_DEFERRED = 4,
	TCP_MTU_REDUCED_DEFERRED = 5,
};

struct ip6_sf_list {
	struct ip6_sf_list *sf_next;
	struct in6_addr sf_addr;
	long unsigned int sf_count[2];
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
	struct callback_head rcu;
};

struct ifmcaddr6 {
	struct in6_addr mca_addr;
	struct inet6_dev *idev;
	struct ifmcaddr6 *next;
	struct ip6_sf_list *mca_sources;
	struct ip6_sf_list *mca_tomb;
	unsigned int mca_sfmode;
	unsigned char mca_crcount;
	long unsigned int mca_sfcount[2];
	struct delayed_work mca_work;
	unsigned int mca_flags;
	int mca_users;
	refcount_t mca_refcnt;
	long unsigned int mca_cstamp;
	long unsigned int mca_tstamp;
	struct callback_head rcu;
};

struct ifacaddr6 {
	struct in6_addr aca_addr;
	struct fib6_info *aca_rt;
	struct ifacaddr6 *aca_next;
	struct hlist_node aca_addr_lst;
	int aca_users;
	refcount_t aca_refcnt;
	long unsigned int aca_cstamp;
	long unsigned int aca_tstamp;
	struct callback_head rcu;
};

enum nfs_opnum4 {
	OP_ACCESS = 3,
	OP_CLOSE = 4,
	OP_COMMIT = 5,
	OP_CREATE = 6,
	OP_DELEGPURGE = 7,
	OP_DELEGRETURN = 8,
	OP_GETATTR = 9,
	OP_GETFH = 10,
	OP_LINK = 11,
	OP_LOCK = 12,
	OP_LOCKT = 13,
	OP_LOCKU = 14,
	OP_LOOKUP = 15,
	OP_LOOKUPP = 16,
	OP_NVERIFY = 17,
	OP_OPEN = 18,
	OP_OPENATTR = 19,
	OP_OPEN_CONFIRM = 20,
	OP_OPEN_DOWNGRADE = 21,
	OP_PUTFH = 22,
	OP_PUTPUBFH = 23,
	OP_PUTROOTFH = 24,
	OP_READ = 25,
	OP_READDIR = 26,
	OP_READLINK = 27,
	OP_REMOVE = 28,
	OP_RENAME = 29,
	OP_RENEW = 30,
	OP_RESTOREFH = 31,
	OP_SAVEFH = 32,
	OP_SECINFO = 33,
	OP_SETATTR = 34,
	OP_SETCLIENTID = 35,
	OP_SETCLIENTID_CONFIRM = 36,
	OP_VERIFY = 37,
	OP_WRITE = 38,
	OP_RELEASE_LOCKOWNER = 39,
	OP_BACKCHANNEL_CTL = 40,
	OP_BIND_CONN_TO_SESSION = 41,
	OP_EXCHANGE_ID = 42,
	OP_CREATE_SESSION = 43,
	OP_DESTROY_SESSION = 44,
	OP_FREE_STATEID = 45,
	OP_GET_DIR_DELEGATION = 46,
	OP_GETDEVICEINFO = 47,
	OP_GETDEVICELIST = 48,
	OP_LAYOUTCOMMIT = 49,
	OP_LAYOUTGET = 50,
	OP_LAYOUTRETURN = 51,
	OP_SECINFO_NO_NAME = 52,
	OP_SEQUENCE = 53,
	OP_SET_SSV = 54,
	OP_TEST_STATEID = 55,
	OP_WANT_DELEGATION = 56,
	OP_DESTROY_CLIENTID = 57,
	OP_RECLAIM_COMPLETE = 58,
	OP_ALLOCATE = 59,
	OP_COPY = 60,
	OP_COPY_NOTIFY = 61,
	OP_DEALLOCATE = 62,
	OP_IO_ADVISE = 63,
	OP_LAYOUTERROR = 64,
	OP_LAYOUTSTATS = 65,
	OP_OFFLOAD_CANCEL = 66,
	OP_OFFLOAD_STATUS = 67,
	OP_READ_PLUS = 68,
	OP_SEEK = 69,
	OP_WRITE_SAME = 70,
	OP_CLONE = 71,
	OP_GETXATTR = 72,
	OP_SETXATTR = 73,
	OP_LISTXATTRS = 74,
	OP_REMOVEXATTR = 75,
	OP_ILLEGAL = 10044,
};

enum {
	UNAME26 = 131072,
	ADDR_NO_RANDOMIZE = 262144,
	FDPIC_FUNCPTRS = 524288,
	MMAP_PAGE_ZERO = 1048576,
	ADDR_COMPAT_LAYOUT = 2097152,
	READ_IMPLIES_EXEC = 4194304,
	ADDR_LIMIT_32BIT = 8388608,
	SHORT_INODE = 16777216,
	WHOLE_SECONDS = 33554432,
	STICKY_TIMEOUTS = 67108864,
	ADDR_LIMIT_3GB = 134217728,
};

enum perf_sw_ids {
	PERF_COUNT_SW_CPU_CLOCK = 0,
	PERF_COUNT_SW_TASK_CLOCK = 1,
	PERF_COUNT_SW_PAGE_FAULTS = 2,
	PERF_COUNT_SW_CONTEXT_SWITCHES = 3,
	PERF_COUNT_SW_CPU_MIGRATIONS = 4,
	PERF_COUNT_SW_PAGE_FAULTS_MIN = 5,
	PERF_COUNT_SW_PAGE_FAULTS_MAJ = 6,
	PERF_COUNT_SW_ALIGNMENT_FAULTS = 7,
	PERF_COUNT_SW_EMULATION_FAULTS = 8,
	PERF_COUNT_SW_DUMMY = 9,
	PERF_COUNT_SW_BPF_OUTPUT = 10,
	PERF_COUNT_SW_CGROUP_SWITCHES = 11,
	PERF_COUNT_SW_MAX = 12,
};

enum perf_branch_sample_type_shift {
	PERF_SAMPLE_BRANCH_USER_SHIFT = 0,
	PERF_SAMPLE_BRANCH_KERNEL_SHIFT = 1,
	PERF_SAMPLE_BRANCH_HV_SHIFT = 2,
	PERF_SAMPLE_BRANCH_ANY_SHIFT = 3,
	PERF_SAMPLE_BRANCH_ANY_CALL_SHIFT = 4,
	PERF_SAMPLE_BRANCH_ANY_RETURN_SHIFT = 5,
	PERF_SAMPLE_BRANCH_IND_CALL_SHIFT = 6,
	PERF_SAMPLE_BRANCH_ABORT_TX_SHIFT = 7,
	PERF_SAMPLE_BRANCH_IN_TX_SHIFT = 8,
	PERF_SAMPLE_BRANCH_NO_TX_SHIFT = 9,
	PERF_SAMPLE_BRANCH_COND_SHIFT = 10,
	PERF_SAMPLE_BRANCH_CALL_STACK_SHIFT = 11,
	PERF_SAMPLE_BRANCH_IND_JUMP_SHIFT = 12,
	PERF_SAMPLE_BRANCH_CALL_SHIFT = 13,
	PERF_SAMPLE_BRANCH_NO_FLAGS_SHIFT = 14,
	PERF_SAMPLE_BRANCH_NO_CYCLES_SHIFT = 15,
	PERF_SAMPLE_BRANCH_TYPE_SAVE_SHIFT = 16,
	PERF_SAMPLE_BRANCH_HW_INDEX_SHIFT = 17,
	PERF_SAMPLE_BRANCH_PRIV_SAVE_SHIFT = 18,
	PERF_SAMPLE_BRANCH_MAX_SHIFT = 19,
};

enum {
	TRACE_EVENT_FL_FILTERED_BIT = 0,
	TRACE_EVENT_FL_CAP_ANY_BIT = 1,
	TRACE_EVENT_FL_NO_SET_FILTER_BIT = 2,
	TRACE_EVENT_FL_IGNORE_ENABLE_BIT = 3,
	TRACE_EVENT_FL_TRACEPOINT_BIT = 4,
	TRACE_EVENT_FL_DYNAMIC_BIT = 5,
	TRACE_EVENT_FL_KPROBE_BIT = 6,
	TRACE_EVENT_FL_UPROBE_BIT = 7,
	TRACE_EVENT_FL_EPROBE_BIT = 8,
	TRACE_EVENT_FL_CUSTOM_BIT = 9,
};

enum {
	EVENT_FILE_FL_ENABLED_BIT = 0,
	EVENT_FILE_FL_RECORDED_CMD_BIT = 1,
	EVENT_FILE_FL_RECORDED_TGID_BIT = 2,
	EVENT_FILE_FL_FILTERED_BIT = 3,
	EVENT_FILE_FL_NO_SET_FILTER_BIT = 4,
	EVENT_FILE_FL_SOFT_MODE_BIT = 5,
	EVENT_FILE_FL_SOFT_DISABLED_BIT = 6,
	EVENT_FILE_FL_TRIGGER_MODE_BIT = 7,
	EVENT_FILE_FL_TRIGGER_COND_BIT = 8,
	EVENT_FILE_FL_PID_FILTER_BIT = 9,
	EVENT_FILE_FL_WAS_ENABLED_BIT = 10,
};

struct uuidcmp {
	const char *uuid;
	int len;
};

typedef __u16 __le16;

typedef __u64 __le64;

struct minix_super_block {
	__u16 s_ninodes;
	__u16 s_nzones;
	__u16 s_imap_blocks;
	__u16 s_zmap_blocks;
	__u16 s_firstdatazone;
	__u16 s_log_zone_size;
	__u32 s_max_size;
	__u16 s_magic;
	__u16 s_state;
	__u32 s_zones;
};

struct romfs_super_block {
	__be32 word0;
	__be32 word1;
	__be32 size;
	__be32 checksum;
	char name[0];
};

struct cramfs_inode {
	__u32 mode: 16;
	__u32 uid: 16;
	__u32 size: 24;
	__u32 gid: 8;
	__u32 namelen: 6;
	__u32 offset: 26;
};

struct cramfs_info {
	__u32 crc;
	__u32 edition;
	__u32 blocks;
	__u32 files;
};

struct cramfs_super {
	__u32 magic;
	__u32 size;
	__u32 flags;
	__u32 future;
	__u8 signature[16];
	struct cramfs_info fsid;
	__u8 name[16];
	struct cramfs_inode root;
};

struct squashfs_super_block {
	__le32 s_magic;
	__le32 inodes;
	__le32 mkfs_time;
	__le32 block_size;
	__le32 fragments;
	__le16 compression;
	__le16 block_log;
	__le16 flags;
	__le16 no_ids;
	__le16 s_major;
	__le16 s_minor;
	__le64 root_inode;
	__le64 bytes_used;
	__le64 id_table_start;
	__le64 xattr_id_table_start;
	__le64 inode_table_start;
	__le64 directory_table_start;
	__le64 fragment_table_start;
	__le64 lookup_table_start;
};

typedef int (*decompress_fn)(unsigned char *, long int, long int (*)(void *, long unsigned int), long int (*)(void *, long unsigned int), unsigned char *, long int *, void (*)(char *));

struct subprocess_info {
	struct work_struct work;
	struct completion *complete;
	const char *path;
	char **argv;
	char **envp;
	int wait;
	int retval;
	int (*init)(struct subprocess_info *, struct cred *);
	void (*cleanup)(struct subprocess_info *);
	void *data;
};

typedef phys_addr_t resource_size_t;

struct __va_list {
	void *__ap;
};

typedef struct __va_list va_list;

struct resource {
	resource_size_t start;
	resource_size_t end;
	const char *name;
	long unsigned int flags;
	long unsigned int desc;
	struct resource *parent;
	struct resource *sibling;
	struct resource *child;
};

enum umh_disable_depth {
	UMH_ENABLED = 0,
	UMH_FREEZING = 1,
	UMH_DISABLED = 2,
};

typedef u64 async_cookie_t;

typedef void (*async_func_t)(void *, async_cookie_t);

struct async_domain {
	struct list_head pending;
	unsigned int registered: 1;
};

struct hash {
	int ino;
	int minor;
	int major;
	umode_t mode;
	struct hash *next;
	char name[4098];
};

struct dir_entry {
	struct list_head list;
	time64_t mtime;
	char name[0];
};

enum state {
	Start = 0,
	Collect = 1,
	GotHeader = 2,
	SkipIt = 3,
	GotName = 4,
	CopyFile = 5,
	GotSymlink = 6,
	Reset = 7,
};

enum key_being_used_for {
	VERIFYING_MODULE_SIGNATURE = 0,
	VERIFYING_FIRMWARE_SIGNATURE = 1,
	VERIFYING_KEXEC_PE_SIGNATURE = 2,
	VERIFYING_KEY_SIGNATURE = 3,
	VERIFYING_KEY_SELF_SIGNATURE = 4,
	VERIFYING_UNSPECIFIED_SIGNATURE = 5,
	NR__KEY_BEING_USED_FOR = 6,
};

struct arm_delay_ops {
	void (*delay)(long unsigned int);
	void (*const_udelay)(long unsigned int);
	void (*udelay)(long unsigned int);
	long unsigned int ticks_per_jiffy;
};

enum {
	__SD_BALANCE_NEWIDLE = 0,
	__SD_BALANCE_EXEC = 1,
	__SD_BALANCE_FORK = 2,
	__SD_BALANCE_WAKE = 3,
	__SD_WAKE_AFFINE = 4,
	__SD_ASYM_CPUCAPACITY = 5,
	__SD_ASYM_CPUCAPACITY_FULL = 6,
	__SD_SHARE_CPUCAPACITY = 7,
	__SD_SHARE_PKG_RESOURCES = 8,
	__SD_SERIALIZE = 9,
	__SD_ASYM_PACKING = 10,
	__SD_PREFER_SIBLING = 11,
	__SD_OVERLAP = 12,
	__SD_NUMA = 13,
	__SD_FLAG_CNT = 14,
};

typedef void (*smp_call_func_t)(void *);

enum migratetype {
	MIGRATE_UNMOVABLE = 0,
	MIGRATE_MOVABLE = 1,
	MIGRATE_RECLAIMABLE = 2,
	MIGRATE_PCPTYPES = 3,
	MIGRATE_HIGHATOMIC = 3,
	MIGRATE_CMA = 4,
	MIGRATE_ISOLATE = 5,
	MIGRATE_TYPES = 6,
};

enum zone_stat_item {
	NR_FREE_PAGES = 0,
	NR_ZONE_LRU_BASE = 1,
	NR_ZONE_INACTIVE_ANON = 1,
	NR_ZONE_ACTIVE_ANON = 2,
	NR_ZONE_INACTIVE_FILE = 3,
	NR_ZONE_ACTIVE_FILE = 4,
	NR_ZONE_UNEVICTABLE = 5,
	NR_ZONE_WRITE_PENDING = 6,
	NR_MLOCK = 7,
	NR_BOUNCE = 8,
	NR_FREE_CMA_PAGES = 9,
	NR_VM_ZONE_STAT_ITEMS = 10,
};

enum vmscan_throttle_state {
	VMSCAN_THROTTLE_WRITEBACK = 0,
	VMSCAN_THROTTLE_ISOLATED = 1,
	VMSCAN_THROTTLE_NOPROGRESS = 2,
	VMSCAN_THROTTLE_CONGESTED = 3,
	NR_VMSCAN_THROTTLE = 4,
};

enum zone_watermarks {
	WMARK_MIN = 0,
	WMARK_LOW = 1,
	WMARK_HIGH = 2,
	WMARK_PROMO = 3,
	NR_WMARK = 4,
};

enum {
	ZONELIST_FALLBACK = 0,
	MAX_ZONELISTS = 1,
};

struct atomic_notifier_head {
	spinlock_t lock;
	struct notifier_block *head;
};

struct user_vfp {
	long long unsigned int fpregs[32];
	long unsigned int fpscr;
	int: 32;
};

struct user_vfp_exc {
	long unsigned int fpexc;
	long unsigned int fpinst;
	long unsigned int fpinst2;
};

enum cpu_pm_event {
	CPU_PM_ENTER = 0,
	CPU_PM_ENTER_FAILED = 1,
	CPU_PM_EXIT = 2,
	CPU_CLUSTER_PM_ENTER = 3,
	CPU_CLUSTER_PM_ENTER_FAILED = 4,
	CPU_CLUSTER_PM_EXIT = 5,
};

struct undef_hook {
	struct list_head node;
	u32 instr_mask;
	u32 instr_val;
	u32 cpsr_mask;
	u32 cpsr_val;
	int (*fn)(struct pt_regs *, unsigned int);
};

struct vfp_single {
	s16 exponent;
	u16 sign;
	u32 significand;
};

struct vfp_double {
	s16 exponent;
	u16 sign;
	int: 32;
	u64 significand;
};

struct op {
	u32 (* const fn)(int, int, int, u32);
	u32 flags;
};

enum {
	PER_LINUX = 0,
	PER_LINUX_32BIT = 8388608,
	PER_LINUX_FDPIC = 524288,
	PER_SVR4 = 68157441,
	PER_SVR3 = 83886082,
	PER_SCOSVR3 = 117440515,
	PER_OSR5 = 100663299,
	PER_WYSEV386 = 83886084,
	PER_ISCR4 = 67108869,
	PER_BSD = 6,
	PER_SUNOS = 67108870,
	PER_XENIX = 83886087,
	PER_LINUX32 = 8,
	PER_LINUX32_3GB = 134217736,
	PER_IRIX32 = 67108873,
	PER_IRIXN32 = 67108874,
	PER_IRIX64 = 67108875,
	PER_RISCOS = 12,
	PER_SOLARIS = 67108877,
	PER_UW7 = 68157454,
	PER_OSF4 = 15,
	PER_HPUX = 16,
	PER_MASK = 255,
};

struct elf32_hdr {
	unsigned char e_ident[16];
	Elf32_Half e_type;
	Elf32_Half e_machine;
	Elf32_Word e_version;
	Elf32_Addr e_entry;
	Elf32_Off e_phoff;
	Elf32_Off e_shoff;
	Elf32_Word e_flags;
	Elf32_Half e_ehsize;
	Elf32_Half e_phentsize;
	Elf32_Half e_phnum;
	Elf32_Half e_shentsize;
	Elf32_Half e_shnum;
	Elf32_Half e_shstrndx;
};

struct smp_operations {
	void (*smp_init_cpus)();
	void (*smp_prepare_cpus)(unsigned int);
	void (*smp_secondary_init)(unsigned int);
	int (*smp_boot_secondary)(unsigned int, struct task_struct *);
	int (*cpu_kill)(unsigned int);
	void (*cpu_die)(unsigned int);
	bool (*cpu_can_disable)(unsigned int);
	int (*cpu_disable)(unsigned int);
};

enum {
	HI_SOFTIRQ = 0,
	TIMER_SOFTIRQ = 1,
	NET_TX_SOFTIRQ = 2,
	NET_RX_SOFTIRQ = 3,
	BLOCK_SOFTIRQ = 4,
	IRQ_POLL_SOFTIRQ = 5,
	TASKLET_SOFTIRQ = 6,
	SCHED_SOFTIRQ = 7,
	HRTIMER_SOFTIRQ = 8,
	RCU_SOFTIRQ = 9,
	NR_SOFTIRQS = 10,
};

enum {
	DQF_ROOT_SQUASH_B = 0,
	DQF_SYS_FILE_B = 16,
	DQF_PRIVATE = 17,
};

enum {
	DQST_LOOKUPS = 0,
	DQST_DROPS = 1,
	DQST_READS = 2,
	DQST_WRITES = 3,
	DQST_CACHE_HITS = 4,
	DQST_ALLOC_DQUOTS = 5,
	DQST_FREE_DQUOTS = 6,
	DQST_SYNCS = 7,
	_DQST_DQSTAT_LAST = 8,
};

enum {
	SB_UNFROZEN = 0,
	SB_FREEZE_WRITE = 1,
	SB_FREEZE_PAGEFAULT = 2,
	SB_FREEZE_FS = 3,
	SB_FREEZE_COMPLETE = 4,
};

enum compound_dtor_id {
	NULL_COMPOUND_DTOR = 0,
	COMPOUND_PAGE_DTOR = 1,
	NR_COMPOUND_DTORS = 2,
};

enum vm_event_item {
	PGPGIN = 0,
	PGPGOUT = 1,
	PSWPIN = 2,
	PSWPOUT = 3,
	PGALLOC_NORMAL = 4,
	PGALLOC_HIGH = 5,
	PGALLOC_MOVABLE = 6,
	ALLOCSTALL_NORMAL = 7,
	ALLOCSTALL_HIGH = 8,
	ALLOCSTALL_MOVABLE = 9,
	PGSCAN_SKIP_NORMAL = 10,
	PGSCAN_SKIP_HIGH = 11,
	PGSCAN_SKIP_MOVABLE = 12,
	PGFREE = 13,
	PGACTIVATE = 14,
	PGDEACTIVATE = 15,
	PGLAZYFREE = 16,
	PGFAULT = 17,
	PGMAJFAULT = 18,
	PGLAZYFREED = 19,
	PGREFILL = 20,
	PGREUSE = 21,
	PGSTEAL_KSWAPD = 22,
	PGSTEAL_DIRECT = 23,
	PGDEMOTE_KSWAPD = 24,
	PGDEMOTE_DIRECT = 25,
	PGSCAN_KSWAPD = 26,
	PGSCAN_DIRECT = 27,
	PGSCAN_DIRECT_THROTTLE = 28,
	PGSCAN_ANON = 29,
	PGSCAN_FILE = 30,
	PGSTEAL_ANON = 31,
	PGSTEAL_FILE = 32,
	PGINODESTEAL = 33,
	SLABS_SCANNED = 34,
	KSWAPD_INODESTEAL = 35,
	KSWAPD_LOW_WMARK_HIT_QUICKLY = 36,
	KSWAPD_HIGH_WMARK_HIT_QUICKLY = 37,
	PAGEOUTRUN = 38,
	PGROTATED = 39,
	DROP_PAGECACHE = 40,
	DROP_SLAB = 41,
	OOM_KILL = 42,
	PGMIGRATE_SUCCESS = 43,
	PGMIGRATE_FAIL = 44,
	THP_MIGRATION_SUCCESS = 45,
	THP_MIGRATION_FAIL = 46,
	THP_MIGRATION_SPLIT = 47,
	COMPACTMIGRATE_SCANNED = 48,
	COMPACTFREE_SCANNED = 49,
	COMPACTISOLATED = 50,
	COMPACTSTALL = 51,
	COMPACTFAIL = 52,
	COMPACTSUCCESS = 53,
	KCOMPACTD_WAKE = 54,
	KCOMPACTD_MIGRATE_SCANNED = 55,
	KCOMPACTD_FREE_SCANNED = 56,
	CMA_ALLOC_SUCCESS = 57,
	CMA_ALLOC_FAIL = 58,
	UNEVICTABLE_PGCULLED = 59,
	UNEVICTABLE_PGSCANNED = 60,
	UNEVICTABLE_PGRESCUED = 61,
	UNEVICTABLE_PGMLOCKED = 62,
	UNEVICTABLE_PGMUNLOCKED = 63,
	UNEVICTABLE_PGCLEARED = 64,
	UNEVICTABLE_PGSTRANDED = 65,
	SWAP_RA = 66,
	SWAP_RA_HIT = 67,
	NR_VM_EVENT_ITEMS = 68,
};

struct l2x0_regs {
	long unsigned int phy_base;
	long unsigned int aux_ctrl;
	long unsigned int tag_latency;
	long unsigned int data_latency;
	long unsigned int filter_start;
	long unsigned int filter_end;
	long unsigned int prefetch_ctrl;
	long unsigned int pwr_ctrl;
	long unsigned int ctrl;
	long unsigned int aux2_ctrl;
};

struct outer_cache_fns {
	void (*inv_range)(long unsigned int, long unsigned int);
	void (*clean_range)(long unsigned int, long unsigned int);
	void (*flush_range)(long unsigned int, long unsigned int);
	void (*flush_all)();
	void (*disable)();
	void (*sync)();
	void (*resume)();
	void (*write_sec)(long unsigned int, unsigned int);
	void (*configure)(const struct l2x0_regs *);
};

enum reboot_mode {
	REBOOT_UNDEFINED = 4294967295,
	REBOOT_COLD = 0,
	REBOOT_WARM = 1,
	REBOOT_HARD = 2,
	REBOOT_SOFT = 3,
	REBOOT_GPIO = 4,
};

struct tag;

struct machine_desc {
	unsigned int nr;
	const char *name;
	long unsigned int atag_offset;
	const char * const *dt_compat;
	unsigned int nr_irqs;
	unsigned int video_start;
	unsigned int video_end;
	unsigned char reserve_lp0: 1;
	unsigned char reserve_lp1: 1;
	unsigned char reserve_lp2: 1;
	enum reboot_mode reboot_mode;
	unsigned int l2c_aux_val;
	unsigned int l2c_aux_mask;
	void (*l2c_write_sec)(long unsigned int, unsigned int);
	const struct smp_operations *smp;
	bool (*smp_init)();
	void (*fixup)(struct tag *, char **);
	void (*dt_fixup)();
	long long int (*pv_fixup)();
	void (*reserve)();
	void (*map_io)();
	void (*init_early)();
	void (*init_irq)();
	void (*init_time)();
	void (*init_machine)();
	void (*init_late)();
	void (*handle_irq)(struct pt_regs *);
	void (*restart)(enum reboot_mode, const char *);
};

struct svc_pt_regs {
	struct pt_regs regs;
	u32 dacr;
	u32 addr_limit;
};

struct kernel_clone_args {
	u64 flags;
	int *pidfd;
	int *child_tid;
	int *parent_tid;
	int exit_signal;
	long unsigned int stack;
	long unsigned int stack_size;
	long unsigned int tls;
	pid_t *set_tid;
	size_t set_tid_size;
	int cgroup;
	int io_thread;
	int kthread;
	int idle;
	int (*fn)(void *);
	void *fn_arg;
	struct cgroup *cgrp;
	struct css_set *cset;
	int: 32;
};

struct vm_special_mapping {
	const char *name;
	struct page **pages;
	vm_fault_t (*fault)(const struct vm_special_mapping *, struct vm_area_struct *, struct vm_fault *);
	int (*mremap)(const struct vm_special_mapping *, struct vm_area_struct *);
};

struct processor {
	void (*_data_abort)(long unsigned int);
	long unsigned int (*_prefetch_abort)(long unsigned int);
	void (*_proc_init)();
	void (*check_bugs)();
	void (*_proc_fin)();
	void (*reset)(long unsigned int, bool);
	int (*_do_idle)();
	void (*dcache_clean_area)(void *, int);
	void (*switch_mm)(phys_addr_t, struct mm_struct *);
	void (*set_pte_ext)(pte_t *, pte_t, unsigned int);
	unsigned int suspend_size;
	void (*do_suspend)(void *);
	void (*do_resume)(void *);
};

enum cpu_led_event {
	CPU_LED_IDLE_START = 0,
	CPU_LED_IDLE_END = 1,
	CPU_LED_START = 2,
	CPU_LED_STOP = 3,
	CPU_LED_HALTED = 4,
};

struct stackframe {
	long unsigned int fp;
	long unsigned int sp;
	long unsigned int lr;
	long unsigned int pc;
	long unsigned int *lr_addr;
	struct llist_node *kr_cur;
	struct task_struct *tsk;
};

struct linux_binprm;

enum perf_type_id {
	PERF_TYPE_HARDWARE = 0,
	PERF_TYPE_SOFTWARE = 1,
	PERF_TYPE_TRACEPOINT = 2,
	PERF_TYPE_HW_CACHE = 3,
	PERF_TYPE_RAW = 4,
	PERF_TYPE_BREAKPOINT = 5,
	PERF_TYPE_MAX = 6,
};

enum {
	TASKSTATS_CMD_UNSPEC = 0,
	TASKSTATS_CMD_GET = 1,
	TASKSTATS_CMD_NEW = 2,
	__TASKSTATS_CMD_MAX = 3,
};

enum ucount_type {
	UCOUNT_USER_NAMESPACES = 0,
	UCOUNT_PID_NAMESPACES = 1,
	UCOUNT_UTS_NAMESPACES = 2,
	UCOUNT_IPC_NAMESPACES = 3,
	UCOUNT_NET_NAMESPACES = 4,
	UCOUNT_MNT_NAMESPACES = 5,
	UCOUNT_CGROUP_NAMESPACES = 6,
	UCOUNT_TIME_NAMESPACES = 7,
	UCOUNT_INOTIFY_INSTANCES = 8,
	UCOUNT_INOTIFY_WATCHES = 9,
	UCOUNT_COUNTS = 10,
};

enum rlimit_type {
	UCOUNT_RLIMIT_NPROC = 0,
	UCOUNT_RLIMIT_MSGQUEUE = 1,
	UCOUNT_RLIMIT_SIGPENDING = 2,
	UCOUNT_RLIMIT_MEMLOCK = 3,
	UCOUNT_RLIMIT_COUNTS = 4,
};

enum cpu_usage_stat {
	CPUTIME_USER = 0,
	CPUTIME_NICE = 1,
	CPUTIME_SYSTEM = 2,
	CPUTIME_SOFTIRQ = 3,
	CPUTIME_IRQ = 4,
	CPUTIME_IDLE = 5,
	CPUTIME_IOWAIT = 6,
	CPUTIME_STEAL = 7,
	CPUTIME_GUEST = 8,
	CPUTIME_GUEST_NICE = 9,
	NR_STATS = 10,
};

enum cgroup_bpf_attach_type {
	CGROUP_BPF_ATTACH_TYPE_INVALID = 4294967295,
	CGROUP_INET_INGRESS = 0,
	CGROUP_INET_EGRESS = 1,
	CGROUP_INET_SOCK_CREATE = 2,
	CGROUP_SOCK_OPS = 3,
	CGROUP_DEVICE = 4,
	CGROUP_INET4_BIND = 5,
	CGROUP_INET6_BIND = 6,
	CGROUP_INET4_CONNECT = 7,
	CGROUP_INET6_CONNECT = 8,
	CGROUP_INET4_POST_BIND = 9,
	CGROUP_INET6_POST_BIND = 10,
	CGROUP_UDP4_SENDMSG = 11,
	CGROUP_UDP6_SENDMSG = 12,
	CGROUP_SYSCTL = 13,
	CGROUP_UDP4_RECVMSG = 14,
	CGROUP_UDP6_RECVMSG = 15,
	CGROUP_GETSOCKOPT = 16,
	CGROUP_SETSOCKOPT = 17,
	CGROUP_INET4_GETPEERNAME = 18,
	CGROUP_INET6_GETPEERNAME = 19,
	CGROUP_INET4_GETSOCKNAME = 20,
	CGROUP_INET6_GETSOCKNAME = 21,
	CGROUP_INET_SOCK_RELEASE = 22,
	CGROUP_LSM_START = 23,
	CGROUP_LSM_END = 22,
	MAX_CGROUP_BPF_ATTACH_TYPE = 23,
};

enum cgroup_subsys_id {
	memory_cgrp_id = 0,
	devices_cgrp_id = 1,
	freezer_cgrp_id = 2,
	net_cls_cgrp_id = 3,
	pids_cgrp_id = 4,
	CGROUP_SUBSYS_COUNT = 5,
};

enum {
	HW_BREAKPOINT_LEN_1 = 1,
	HW_BREAKPOINT_LEN_2 = 2,
	HW_BREAKPOINT_LEN_3 = 3,
	HW_BREAKPOINT_LEN_4 = 4,
	HW_BREAKPOINT_LEN_5 = 5,
	HW_BREAKPOINT_LEN_6 = 6,
	HW_BREAKPOINT_LEN_7 = 7,
	HW_BREAKPOINT_LEN_8 = 8,
};

enum {
	HW_BREAKPOINT_EMPTY = 0,
	HW_BREAKPOINT_R = 1,
	HW_BREAKPOINT_W = 2,
	HW_BREAKPOINT_RW = 3,
	HW_BREAKPOINT_X = 4,
	HW_BREAKPOINT_INVALID = 7,
};

enum bp_type_idx {
	TYPE_INST = 0,
	TYPE_DATA = 1,
	TYPE_MAX = 2,
};

struct membuf {
	void *p;
	size_t left;
};

struct user_regset;

typedef int user_regset_active_fn(struct task_struct *, const struct user_regset *);

typedef int user_regset_get2_fn(struct task_struct *, const struct user_regset *, struct membuf);

typedef int user_regset_set_fn(struct task_struct *, const struct user_regset *, unsigned int, unsigned int, const void *, const void *);

typedef int user_regset_writeback_fn(struct task_struct *, const struct user_regset *, int);

struct user_regset {
	user_regset_get2_fn *regset_get;
	user_regset_set_fn *set;
	user_regset_active_fn *active;
	user_regset_writeback_fn *writeback;
	unsigned int n;
	unsigned int size;
	unsigned int align;
	unsigned int bias;
	unsigned int core_note_type;
};

struct user_regset_view {
	const char *name;
	const struct user_regset *regsets;
	unsigned int n;
	u32 e_flags;
	u16 e_machine;
	u8 ei_osabi;
};

struct trace_event_raw_sys_enter {
	struct trace_entry ent;
	long int id;
	long unsigned int args[6];
	char __data[0];
};

struct trace_event_raw_sys_exit {
	struct trace_entry ent;
	long int id;
	long int ret;
	char __data[0];
};

struct trace_event_data_offsets_sys_enter {};

struct trace_event_data_offsets_sys_exit {};

typedef void (*btf_trace_sys_enter)(void *, struct pt_regs *, long int);

typedef void (*btf_trace_sys_exit)(void *, struct pt_regs *, long int);

struct pt_regs_offset {
	const char *name;
	int offset;
};

enum arm_regset {
	REGSET_GPR = 0,
	REGSET_FPR = 1,
	REGSET_VFP = 2,
};

enum ptrace_syscall_dir {
	PTRACE_SYSCALL_ENTER = 0,
	PTRACE_SYSCALL_EXIT = 1,
};

typedef void (*phys_reset_t)(long unsigned int, bool);

typedef u8 uint8_t;

struct cpu_user_fns {
	void (*cpu_clear_user_highpage)(struct page *, long unsigned int);
	void (*cpu_copy_user_highpage)(struct page *, struct page *, long unsigned int, struct vm_area_struct *);
};

struct screen_info {
	__u8 orig_x;
	__u8 orig_y;
	__u16 ext_mem_k;
	__u16 orig_video_page;
	__u8 orig_video_mode;
	__u8 orig_video_cols;
	__u8 flags;
	__u8 unused2;
	__u16 orig_video_ega_bx;
	__u16 unused3;
	__u8 orig_video_lines;
	__u8 orig_video_isVGA;
	__u16 orig_video_points;
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u32 lfb_base;
	__u32 lfb_size;
	__u16 cl_magic;
	__u16 cl_offset;
	__u16 lfb_linelength;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
	__u16 vesapm_seg;
	__u16 vesapm_off;
	__u16 pages;
	__u16 vesa_attributes;
	__u32 capabilities;
	__u32 ext_lfb_base;
	__u8 _reserved[2];
} __attribute__((packed));

struct cpu {
	int node_id;
	int hotpluggable;
	struct device dev;
};

struct cpu_tlb_fns {
	void (*flush_user_range)(long unsigned int, long unsigned int, struct vm_area_struct *);
	void (*flush_kern_range)(long unsigned int, long unsigned int);
	long unsigned int tlb_flags;
};

typedef __be32 fdt32_t;

struct fdt_header {
	fdt32_t magic;
	fdt32_t totalsize;
	fdt32_t off_dt_struct;
	fdt32_t off_dt_strings;
	fdt32_t off_mem_rsvmap;
	fdt32_t version;
	fdt32_t last_comp_version;
	fdt32_t boot_cpuid_phys;
	fdt32_t size_dt_strings;
	fdt32_t size_dt_struct;
};

enum memblock_flags {
	MEMBLOCK_NONE = 0,
	MEMBLOCK_HOTPLUG = 1,
	MEMBLOCK_MIRROR = 2,
	MEMBLOCK_NOMAP = 4,
	MEMBLOCK_DRIVER_MANAGED = 8,
};

struct memblock_region {
	phys_addr_t base;
	phys_addr_t size;
	enum memblock_flags flags;
};

struct memblock_type {
	long unsigned int cnt;
	long unsigned int max;
	phys_addr_t total_size;
	struct memblock_region *regions;
	char *name;
};

struct memblock {
	bool bottom_up;
	phys_addr_t current_limit;
	struct memblock_type memory;
	struct memblock_type reserved;
};

struct cpuinfo_arm {
	struct cpu cpu;
	u32 cpuid;
	unsigned int loops_per_jiffy;
};

struct cpu_cache_fns {
	void (*flush_icache_all)();
	void (*flush_kern_all)();
	void (*flush_kern_louis)();
	void (*flush_user_all)();
	void (*flush_user_range)(long unsigned int, long unsigned int, unsigned int);
	void (*coherent_kern_range)(long unsigned int, long unsigned int);
	int (*coherent_user_range)(long unsigned int, long unsigned int);
	void (*flush_kern_dcache_area)(void *, size_t);
	void (*dma_map_area)(const void *, size_t, int);
	void (*dma_unmap_area)(const void *, size_t, int);
	void (*dma_flush_range)(const void *, const void *);
};

struct mpidr_hash {
	u32 mask;
	u32 shift_aff[3];
	u32 bits;
};

struct proc_info_list {
	unsigned int cpu_val;
	unsigned int cpu_mask;
	long unsigned int __cpu_mm_mmu_flags;
	long unsigned int __cpu_io_mmu_flags;
	long unsigned int __cpu_flush;
	const char *arch_name;
	const char *elf_name;
	unsigned int elf_hwcap;
	const char *cpu_name;
	struct processor *proc;
	struct cpu_tlb_fns *tlb;
	struct cpu_user_fns *user;
	struct cpu_cache_fns *cache;
};

struct tag_header {
	__u32 size;
	__u32 tag;
};

struct tag_core {
	__u32 flags;
	__u32 pagesize;
	__u32 rootdev;
};

struct tag_mem32 {
	__u32 size;
	__u32 start;
};

struct tag_videotext {
	__u8 x;
	__u8 y;
	__u16 video_page;
	__u8 video_mode;
	__u8 video_cols;
	__u16 video_ega_bx;
	__u8 video_lines;
	__u8 video_isvga;
	__u16 video_points;
};

struct tag_ramdisk {
	__u32 flags;
	__u32 size;
	__u32 start;
};

struct tag_initrd {
	__u32 start;
	__u32 size;
};

struct tag_serialnr {
	__u32 low;
	__u32 high;
};

struct tag_revision {
	__u32 rev;
};

struct tag_videolfb {
	__u16 lfb_width;
	__u16 lfb_height;
	__u16 lfb_depth;
	__u16 lfb_linelength;
	__u32 lfb_base;
	__u32 lfb_size;
	__u8 red_size;
	__u8 red_pos;
	__u8 green_size;
	__u8 green_pos;
	__u8 blue_size;
	__u8 blue_pos;
	__u8 rsvd_size;
	__u8 rsvd_pos;
};

struct tag_cmdline {
	char cmdline[1];
};

struct tag_acorn {
	__u32 memc_control_reg;
	__u32 vram_pages;
	__u8 sounddefault;
	__u8 adfsdrives;
};

struct tag_memclk {
	__u32 fmemclk;
};

struct tag {
	struct tag_header hdr;
	union {
		struct tag_core core;
		struct tag_mem32 mem;
		struct tag_videotext videotext;
		struct tag_ramdisk ramdisk;
		struct tag_initrd initrd;
		struct tag_serialnr serialnr;
		struct tag_revision revision;
		struct tag_videolfb videolfb;
		struct tag_cmdline cmdline;
		struct tag_acorn acorn;
		struct tag_memclk memclk;
	} u;
};

struct stack {
	u32 irq[4];
	u32 abt[4];
	u32 und[4];
	u32 fiq[4];
};

struct sigaltstack {
	void *ss_sp;
	int ss_flags;
	__kernel_size_t ss_size;
};

typedef struct sigaltstack stack_t;

struct sigcontext {
	long unsigned int trap_no;
	long unsigned int error_code;
	long unsigned int oldmask;
	long unsigned int arm_r0;
	long unsigned int arm_r1;
	long unsigned int arm_r2;
	long unsigned int arm_r3;
	long unsigned int arm_r4;
	long unsigned int arm_r5;
	long unsigned int arm_r6;
	long unsigned int arm_r7;
	long unsigned int arm_r8;
	long unsigned int arm_r9;
	long unsigned int arm_r10;
	long unsigned int arm_fp;
	long unsigned int arm_ip;
	long unsigned int arm_sp;
	long unsigned int arm_lr;
	long unsigned int arm_pc;
	long unsigned int arm_cpsr;
	long unsigned int fault_address;
};

struct siginfo {
	union {
		struct {
			int si_signo;
			int si_errno;
			int si_code;
			union __sifields _sifields;
		};
		int _si_pad[32];
	};
};

struct ksignal {
	struct k_sigaction ka;
	kernel_siginfo_t info;
	int sig;
};

struct ucontext {
	long unsigned int uc_flags;
	struct ucontext *uc_link;
	stack_t uc_stack;
	struct sigcontext uc_mcontext;
	sigset_t uc_sigmask;
	int __unused[30];
	long unsigned int uc_regspace[128];
};

struct vfp_sigframe {
	long unsigned int magic;
	long unsigned int size;
	struct user_vfp ufp;
	struct user_vfp_exc ufp_exc;
	int: 32;
};

struct aux_sigframe {
	struct vfp_sigframe vfp;
	long unsigned int end_magic;
	int: 32;
};

struct sigframe {
	struct ucontext uc;
	long unsigned int retcode[4];
};

struct rt_sigframe {
	struct siginfo info;
	struct sigframe sig;
};

struct stack_trace {
	unsigned int nr_entries;
	unsigned int max_entries;
	long unsigned int *entries;
	unsigned int skip;
};

struct stack_trace_data {
	struct stack_trace *trace;
	unsigned int no_sched_functions;
	unsigned int skip;
};

typedef void (*clock_access_fn)(struct timespec64 *);

enum lockdep_ok {
	LOCKDEP_STILL_OK = 0,
	LOCKDEP_NOW_UNRELIABLE = 1,
};

enum bug_trap_type {
	BUG_TRAP_TYPE_NONE = 0,
	BUG_TRAP_TYPE_WARN = 1,
	BUG_TRAP_TYPE_BUG = 2,
};

enum die_val {
	DIE_UNUSED = 0,
	DIE_OOPS = 1,
};

enum {
	SPECTRE_UNAFFECTED = 0,
	SPECTRE_MITIGATED = 1,
	SPECTRE_VULNERABLE = 2,
};

enum {
	__SPECTRE_V2_METHOD_BPIALL = 0,
	__SPECTRE_V2_METHOD_ICIALLU = 1,
	__SPECTRE_V2_METHOD_SMC = 2,
	__SPECTRE_V2_METHOD_HVC = 3,
	__SPECTRE_V2_METHOD_LOOP8 = 4,
};

enum {
	SPECTRE_V2_METHOD_BPIALL = 1,
	SPECTRE_V2_METHOD_ICIALLU = 2,
	SPECTRE_V2_METHOD_SMC = 4,
	SPECTRE_V2_METHOD_HVC = 8,
	SPECTRE_V2_METHOD_LOOP8 = 16,
};

struct tagtable {
	__u32 tag;
	int (*parse)(const struct tag *);
};

struct proc_ops {
	unsigned int proc_flags;
	int (*proc_open)(struct inode *, struct file *);
	ssize_t (*proc_read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*proc_read_iter)(struct kiocb *, struct iov_iter *);
	ssize_t (*proc_write)(struct file *, const char *, size_t, loff_t *);
	loff_t (*proc_lseek)(struct file *, loff_t, int);
	int (*proc_release)(struct inode *, struct file *);
	__poll_t (*proc_poll)(struct file *, struct poll_table_struct *);
	long int (*proc_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*proc_mmap)(struct file *, struct vm_area_struct *);
	long unsigned int (*proc_get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
};

struct buffer {
	size_t size;
	char data[0];
};

struct cpuidle_state_usage {
	long long unsigned int disable;
	long long unsigned int usage;
	u64 time_ns;
	long long unsigned int above;
	long long unsigned int below;
	long long unsigned int rejected;
	long long unsigned int s2idle_usage;
	long long unsigned int s2idle_time;
};

struct cpuidle_device;

struct cpuidle_driver;

struct cpuidle_state {
	char name[16];
	char desc[32];
	s64 exit_latency_ns;
	s64 target_residency_ns;
	unsigned int flags;
	unsigned int exit_latency;
	int power_usage;
	unsigned int target_residency;
	int (*enter)(struct cpuidle_device *, struct cpuidle_driver *, int);
	int (*enter_dead)(struct cpuidle_device *, int);
	int (*enter_s2idle)(struct cpuidle_device *, struct cpuidle_driver *, int);
	int: 32;
};

struct cpuidle_state_kobj;

struct cpuidle_driver_kobj;

struct cpuidle_device_kobj;

struct cpuidle_device {
	unsigned int registered: 1;
	unsigned int enabled: 1;
	unsigned int poll_time_limit: 1;
	unsigned int cpu;
	ktime_t next_hrtimer;
	int last_state_idx;
	int: 32;
	u64 last_residency_ns;
	u64 poll_limit_ns;
	u64 forced_idle_latency_limit_ns;
	struct cpuidle_state_usage states_usage[10];
	struct cpuidle_state_kobj *kobjs[10];
	struct cpuidle_driver_kobj *kobj_driver;
	struct cpuidle_device_kobj *kobj_dev;
	struct list_head device_list;
};

struct cpuidle_driver {
	const char *name;
	struct module *owner;
	unsigned int bctimer: 1;
	int: 31;
	int: 32;
	struct cpuidle_state states[10];
	int state_count;
	int safe_state_index;
	struct cpumask *cpumask;
	const char *governor;
};

struct cpuidle_ops {
	int (*suspend)(long unsigned int);
	int (*init)(struct device_node *, int);
};

struct of_cpuidle_method {
	const char *method;
	const struct cpuidle_ops *ops;
};

struct elf32_rel {
	Elf32_Addr r_offset;
	Elf32_Word r_info;
};

typedef struct elf32_rel Elf32_Rel;

typedef struct elf32_hdr Elf32_Ehdr;

typedef struct elf32_shdr Elf32_Shdr;

typedef unsigned int u_int;

struct pci_device_id {
	__u32 vendor;
	__u32 device;
	__u32 subvendor;
	__u32 subdevice;
	__u32 class;
	__u32 class_mask;
	kernel_ulong_t driver_data;
	__u32 override_only;
};

struct resource_entry {
	struct list_head node;
	struct resource *res;
	resource_size_t offset;
	struct resource __res;
};

struct pci_bus;

struct hotplug_slot;

struct pci_slot {
	struct pci_bus *bus;
	struct list_head list;
	struct hotplug_slot *hotplug;
	unsigned char number;
	struct kobject kobj;
};

typedef short unsigned int pci_bus_flags_t;

struct pci_dev;

struct pci_ops;

struct pci_bus {
	struct list_head node;
	struct pci_bus *parent;
	struct list_head children;
	struct list_head devices;
	struct pci_dev *self;
	struct list_head slots;
	struct resource *resource[4];
	struct list_head resources;
	struct resource busn_res;
	struct pci_ops *ops;
	void *sysdata;
	struct proc_dir_entry *procdir;
	unsigned char number;
	unsigned char primary;
	unsigned char max_bus_speed;
	unsigned char cur_bus_speed;
	int domain_nr;
	char name[48];
	short unsigned int bridge_ctl;
	pci_bus_flags_t bus_flags;
	struct device *bridge;
	int: 32;
	struct device dev;
	struct bin_attribute *legacy_io;
	struct bin_attribute *legacy_mem;
	unsigned int is_added: 1;
	unsigned int unsafe_warn: 1;
	int: 30;
	int: 32;
};

enum {
	PCI_STD_RESOURCES = 0,
	PCI_STD_RESOURCE_END = 5,
	PCI_ROM_RESOURCE = 6,
	PCI_BRIDGE_RESOURCES = 7,
	PCI_BRIDGE_RESOURCE_END = 10,
	PCI_NUM_RESOURCES = 11,
	DEVICE_COUNT_RESOURCE = 11,
};

typedef int pci_power_t;

typedef unsigned int pci_channel_state_t;

typedef unsigned int pcie_reset_state_t;

typedef short unsigned int pci_dev_flags_t;

struct pci_vpd {
	struct mutex lock;
	unsigned int len;
	u8 cap;
};

struct pci_driver;

struct pcie_link_state;

struct pci_dev {
	struct list_head bus_list;
	struct pci_bus *bus;
	struct pci_bus *subordinate;
	void *sysdata;
	struct proc_dir_entry *procent;
	struct pci_slot *slot;
	unsigned int devfn;
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	unsigned int class;
	u8 revision;
	u8 hdr_type;
	u32 devcap;
	u8 pcie_cap;
	u8 msi_cap;
	u8 msix_cap;
	u8 pcie_mpss: 3;
	u8 rom_base_reg;
	u8 pin;
	u16 pcie_flags_reg;
	long unsigned int *dma_alias_mask;
	struct pci_driver *driver;
	int: 32;
	u64 dma_mask;
	struct device_dma_parameters dma_parms;
	pci_power_t current_state;
	unsigned int imm_ready: 1;
	u8 pm_cap;
	unsigned int pme_support: 5;
	unsigned int pme_poll: 1;
	unsigned int d1_support: 1;
	unsigned int d2_support: 1;
	unsigned int no_d1d2: 1;
	unsigned int no_d3cold: 1;
	unsigned int bridge_d3: 1;
	unsigned int d3cold_allowed: 1;
	unsigned int mmio_always_on: 1;
	unsigned int wakeup_prepared: 1;
	unsigned int skip_bus_pm: 1;
	unsigned int ignore_hotplug: 1;
	unsigned int hotplug_user_indicators: 1;
	unsigned int clear_retrain_link: 1;
	unsigned int d3hot_delay;
	unsigned int d3cold_delay;
	struct pcie_link_state *link_state;
	unsigned int ltr_path: 1;
	u16 l1ss;
	unsigned int pasid_no_tlp: 1;
	unsigned int eetlp_prefix_path: 1;
	pci_channel_state_t error_state;
	struct device dev;
	int cfg_size;
	unsigned int irq;
	struct resource resource[11];
	bool match_driver;
	unsigned int transparent: 1;
	unsigned int io_window: 1;
	unsigned int pref_window: 1;
	unsigned int pref_64_window: 1;
	unsigned int multifunction: 1;
	unsigned int is_busmaster: 1;
	unsigned int no_msi: 1;
	unsigned int no_64bit_msi: 1;
	unsigned int block_cfg_access: 1;
	unsigned int broken_parity_status: 1;
	unsigned int irq_reroute_variant: 2;
	unsigned int msi_enabled: 1;
	unsigned int msix_enabled: 1;
	unsigned int ari_enabled: 1;
	unsigned int ats_enabled: 1;
	unsigned int pasid_enabled: 1;
	unsigned int pri_enabled: 1;
	unsigned int is_managed: 1;
	unsigned int is_msi_managed: 1;
	unsigned int needs_freset: 1;
	unsigned int state_saved: 1;
	unsigned int is_physfn: 1;
	unsigned int is_virtfn: 1;
	unsigned int is_hotplug_bridge: 1;
	unsigned int shpc_managed: 1;
	unsigned int is_thunderbolt: 1;
	unsigned int untrusted: 1;
	unsigned int external_facing: 1;
	unsigned int broken_intx_masking: 1;
	unsigned int io_window_1k: 1;
	unsigned int irq_managed: 1;
	unsigned int non_compliant_bars: 1;
	unsigned int is_probed: 1;
	unsigned int link_active_reporting: 1;
	unsigned int no_vf_scan: 1;
	unsigned int no_command_memory: 1;
	unsigned int rom_bar_overlap: 1;
	pci_dev_flags_t dev_flags;
	atomic_t enable_cnt;
	u32 saved_config_space[16];
	struct hlist_head saved_cap_space;
	int rom_attr_enabled;
	struct bin_attribute *res_attr[11];
	struct bin_attribute *res_attr_wc[11];
	void *msix_base;
	raw_spinlock_t msi_lock;
	struct pci_vpd vpd;
	u16 acs_cap;
	phys_addr_t rom;
	size_t romlen;
	const char *driver_override;
	long unsigned int priv_flags;
	u8 reset_methods[7];
	int: 8;
	int: 32;
};

struct pci_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct pci_error_handlers;

struct pci_driver {
	struct list_head node;
	const char *name;
	const struct pci_device_id *id_table;
	int (*probe)(struct pci_dev *, const struct pci_device_id *);
	void (*remove)(struct pci_dev *);
	int (*suspend)(struct pci_dev *, pm_message_t);
	int (*resume)(struct pci_dev *);
	void (*shutdown)(struct pci_dev *);
	int (*sriov_configure)(struct pci_dev *, int);
	int (*sriov_set_msix_vec_count)(struct pci_dev *, int);
	u32 (*sriov_get_vf_total_msix)(struct pci_dev *);
	const struct pci_error_handlers *err_handler;
	const struct attribute_group **groups;
	const struct attribute_group **dev_groups;
	struct device_driver driver;
	struct pci_dynids dynids;
	bool driver_managed_dma;
};

struct pci_host_bridge {
	struct device dev;
	struct pci_bus *bus;
	struct pci_ops *ops;
	struct pci_ops *child_ops;
	void *sysdata;
	int busnr;
	int domain_nr;
	struct list_head windows;
	struct list_head dma_ranges;
	u8 (*swizzle_irq)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void (*release_fn)(struct pci_host_bridge *);
	void *release_data;
	unsigned int ignore_reset_delay: 1;
	unsigned int no_ext_tags: 1;
	unsigned int native_aer: 1;
	unsigned int native_pcie_hotplug: 1;
	unsigned int native_shpc_hotplug: 1;
	unsigned int native_pme: 1;
	unsigned int native_ltr: 1;
	unsigned int native_dpc: 1;
	unsigned int preserve_config: 1;
	unsigned int size_windows: 1;
	unsigned int msi_domain: 1;
	resource_size_t (*align_resource)(struct pci_dev *, const struct resource *, resource_size_t, resource_size_t, resource_size_t);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int private[0];
};

struct pci_ops {
	int (*add_bus)(struct pci_bus *);
	void (*remove_bus)(struct pci_bus *);
	void * (*map_bus)(struct pci_bus *, unsigned int, int);
	int (*read)(struct pci_bus *, unsigned int, int, int, u32 *);
	int (*write)(struct pci_bus *, unsigned int, int, int, u32);
};

typedef unsigned int pci_ers_result_t;

struct pci_error_handlers {
	pci_ers_result_t (*error_detected)(struct pci_dev *, pci_channel_state_t);
	pci_ers_result_t (*mmio_enabled)(struct pci_dev *);
	pci_ers_result_t (*slot_reset)(struct pci_dev *);
	void (*reset_prepare)(struct pci_dev *);
	void (*reset_done)(struct pci_dev *);
	void (*resume)(struct pci_dev *);
};

enum {
	PCI_REASSIGN_ALL_RSRC = 1,
	PCI_REASSIGN_ALL_BUS = 2,
	PCI_PROBE_ONLY = 4,
	PCI_CAN_SKIP_ISA_ALIGN = 8,
	PCI_ENABLE_PROC_DOMAINS = 16,
	PCI_COMPAT_DOMAIN_0 = 32,
	PCI_SCAN_ALL_PCIE_DEVS = 64,
};

struct pci_sys_data;

struct hw_pci {
	struct pci_ops *ops;
	int nr_controllers;
	void **private_data;
	int (*setup)(int, struct pci_sys_data *);
	int (*scan)(int, struct pci_host_bridge *);
	void (*preinit)();
	void (*postinit)();
	u8 (*swizzle)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
};

struct pci_sys_data {
	struct list_head node;
	int busnr;
	int: 32;
	u64 mem_offset;
	long unsigned int io_offset;
	struct pci_bus *bus;
	struct list_head resources;
	struct resource io_res;
	char io_res_name[12];
	u8 (*swizzle)(struct pci_dev *, u8 *);
	int (*map_irq)(const struct pci_dev *, u8, u8);
	void *private_data;
};

struct pci_fixup {
	u16 vendor;
	u16 device;
	u32 class;
	unsigned int class_shift;
	void (*hook)(struct pci_dev *);
};

struct map_desc {
	long unsigned int virtual;
	long unsigned int pfn;
	long unsigned int length;
	unsigned int type;
};

struct sleep_save_sp {
	u32 *save_ptr_stash;
	u32 save_ptr_stash_phys;
};

struct mpu_rgn {
	union {
		u32 drbar;
		u32 prbar;
	};
	union {
		u32 drsr;
		u32 prlar;
	};
	union {
		u32 dracr;
		u32 unused;
	};
};

struct mpu_rgn_info {
	unsigned int used;
	struct mpu_rgn rgns[16];
};

struct secondary_data {
	union {
		struct mpu_rgn_info *mpu_rgn_info;
		u64 pgdir;
	};
	long unsigned int swapper_pg_dir;
	void *stack;
	struct task_struct *task;
	int: 32;
};

struct plist_head {
	struct list_head node_list;
};

typedef struct {
	unsigned int __softirq_pending;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
} irq_cpustat_t;

enum {
	IRQ_TYPE_NONE = 0,
	IRQ_TYPE_EDGE_RISING = 1,
	IRQ_TYPE_EDGE_FALLING = 2,
	IRQ_TYPE_EDGE_BOTH = 3,
	IRQ_TYPE_LEVEL_HIGH = 4,
	IRQ_TYPE_LEVEL_LOW = 8,
	IRQ_TYPE_LEVEL_MASK = 12,
	IRQ_TYPE_SENSE_MASK = 15,
	IRQ_TYPE_DEFAULT = 15,
	IRQ_TYPE_PROBE = 16,
	IRQ_LEVEL = 256,
	IRQ_PER_CPU = 512,
	IRQ_NOPROBE = 1024,
	IRQ_NOREQUEST = 2048,
	IRQ_NOAUTOEN = 4096,
	IRQ_NO_BALANCING = 8192,
	IRQ_MOVE_PCNTXT = 16384,
	IRQ_NESTED_THREAD = 32768,
	IRQ_NOTHREAD = 65536,
	IRQ_PER_CPU_DEVID = 131072,
	IRQ_IS_POLLED = 262144,
	IRQ_DISABLE_UNLAZY = 524288,
	IRQ_HIDDEN = 1048576,
	IRQ_NO_DEBUG = 2097152,
};

enum pm_qos_type {
	PM_QOS_UNITIALIZED = 0,
	PM_QOS_MAX = 1,
	PM_QOS_MIN = 2,
};

struct pm_qos_constraints {
	struct plist_head list;
	s32 target_value;
	s32 default_value;
	s32 no_constraint_value;
	enum pm_qos_type type;
	struct blocking_notifier_head *notifiers;
};

struct freq_constraints {
	struct pm_qos_constraints min_freq;
	struct blocking_notifier_head min_freq_notifiers;
	struct pm_qos_constraints max_freq;
	struct blocking_notifier_head max_freq_notifiers;
};

struct pm_qos_flags {
	struct list_head list;
	s32 effective_flags;
};

struct dev_pm_qos_request;

struct dev_pm_qos {
	struct pm_qos_constraints resume_latency;
	struct pm_qos_constraints latency_tolerance;
	struct freq_constraints freq;
	struct pm_qos_flags flags;
	struct dev_pm_qos_request *resume_latency_req;
	struct dev_pm_qos_request *latency_tolerance_req;
	struct dev_pm_qos_request *flags_req;
};

struct pm_qos_flags_request {
	struct list_head node;
	s32 flags;
};

enum freq_qos_req_type {
	FREQ_QOS_MIN = 1,
	FREQ_QOS_MAX = 2,
};

struct freq_qos_request {
	enum freq_qos_req_type type;
	struct plist_node pnode;
	struct freq_constraints *qos;
};

enum dev_pm_qos_req_type {
	DEV_PM_QOS_RESUME_LATENCY = 1,
	DEV_PM_QOS_LATENCY_TOLERANCE = 2,
	DEV_PM_QOS_MIN_FREQUENCY = 3,
	DEV_PM_QOS_MAX_FREQUENCY = 4,
	DEV_PM_QOS_FLAGS = 5,
};

struct dev_pm_qos_request {
	enum dev_pm_qos_req_type type;
	union {
		struct plist_node pnode;
		struct pm_qos_flags_request flr;
		struct freq_qos_request freq;
	} data;
	struct device *dev;
};

enum cpufreq_table_sorting {
	CPUFREQ_TABLE_UNSORTED = 0,
	CPUFREQ_TABLE_SORTED_ASCENDING = 1,
	CPUFREQ_TABLE_SORTED_DESCENDING = 2,
};

struct cpufreq_cpuinfo {
	unsigned int max_freq;
	unsigned int min_freq;
	unsigned int transition_latency;
};

struct clk;

struct cpufreq_governor;

struct cpufreq_frequency_table;

struct cpufreq_stats;

struct thermal_cooling_device;

struct cpufreq_policy {
	cpumask_var_t cpus;
	cpumask_var_t related_cpus;
	cpumask_var_t real_cpus;
	unsigned int shared_type;
	unsigned int cpu;
	struct clk *clk;
	struct cpufreq_cpuinfo cpuinfo;
	unsigned int min;
	unsigned int max;
	unsigned int cur;
	unsigned int suspend_freq;
	unsigned int policy;
	unsigned int last_policy;
	struct cpufreq_governor *governor;
	void *governor_data;
	char last_governor[16];
	struct work_struct update;
	struct freq_constraints constraints;
	struct freq_qos_request *min_freq_req;
	struct freq_qos_request *max_freq_req;
	struct cpufreq_frequency_table *freq_table;
	enum cpufreq_table_sorting freq_table_sorted;
	struct list_head policy_list;
	struct kobject kobj;
	struct completion kobj_unregister;
	struct rw_semaphore rwsem;
	bool fast_switch_possible;
	bool fast_switch_enabled;
	bool strict_target;
	bool efficiencies_available;
	unsigned int transition_delay_us;
	bool dvfs_possible_from_any_cpu;
	unsigned int cached_target_freq;
	unsigned int cached_resolved_idx;
	bool transition_ongoing;
	spinlock_t transition_lock;
	wait_queue_head_t transition_wait;
	struct task_struct *transition_task;
	struct cpufreq_stats *stats;
	void *driver_data;
	struct thermal_cooling_device *cdev;
	struct notifier_block nb_min;
	struct notifier_block nb_max;
};

struct cpufreq_governor {
	char name[16];
	int (*init)(struct cpufreq_policy *);
	void (*exit)(struct cpufreq_policy *);
	int (*start)(struct cpufreq_policy *);
	void (*stop)(struct cpufreq_policy *);
	void (*limits)(struct cpufreq_policy *);
	ssize_t (*show_setspeed)(struct cpufreq_policy *, char *);
	int (*store_setspeed)(struct cpufreq_policy *, unsigned int);
	struct list_head governor_list;
	struct module *owner;
	u8 flags;
};

struct cpufreq_frequency_table {
	unsigned int flags;
	unsigned int driver_data;
	unsigned int frequency;
};

struct cpufreq_freqs {
	struct cpufreq_policy *policy;
	unsigned int old;
	unsigned int new;
	u8 flags;
};

struct trace_event_raw_ipi_raise {
	struct trace_entry ent;
	u32 __data_loc_target_cpus;
	const char *reason;
	char __data[0];
};

struct trace_event_raw_ipi_handler {
	struct trace_entry ent;
	const char *reason;
	char __data[0];
};

struct trace_event_data_offsets_ipi_raise {
	u32 target_cpus;
};

struct trace_event_data_offsets_ipi_handler {};

typedef void (*btf_trace_ipi_raise)(void *, const struct cpumask *, const char *);

typedef void (*btf_trace_ipi_entry)(void *, const char *);

typedef void (*btf_trace_ipi_exit)(void *, const char *);

enum ipi_msg_type {
	IPI_WAKEUP = 0,
	IPI_TIMER = 1,
	IPI_RESCHEDULE = 2,
	IPI_CALL_FUNC = 3,
	IPI_CPU_STOP = 4,
	IPI_IRQ_WORK = 5,
	IPI_COMPLETION = 6,
	NR_IPI = 7,
	IPI_CPU_BACKTRACE = 7,
	MAX_IPI = 8,
};

struct tlb_args {
	struct vm_area_struct *ta_vma;
	long unsigned int ta_start;
	long unsigned int ta_end;
};

struct clk_notifier_data {
	struct clk *clk;
	long unsigned int old_rate;
	long unsigned int new_rate;
};

typedef int (*of_init_fn_1_ret)(struct device_node *);

enum clock_event_state {
	CLOCK_EVT_STATE_DETACHED = 0,
	CLOCK_EVT_STATE_SHUTDOWN = 1,
	CLOCK_EVT_STATE_PERIODIC = 2,
	CLOCK_EVT_STATE_ONESHOT = 3,
	CLOCK_EVT_STATE_ONESHOT_STOPPED = 4,
};

struct clock_event_device {
	void (*event_handler)(struct clock_event_device *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
	int (*set_next_ktime)(ktime_t, struct clock_event_device *);
	int: 32;
	ktime_t next_event;
	u64 max_delta_ns;
	u64 min_delta_ns;
	u32 mult;
	u32 shift;
	enum clock_event_state state_use_accessors;
	unsigned int features;
	long unsigned int retries;
	int (*set_state_periodic)(struct clock_event_device *);
	int (*set_state_oneshot)(struct clock_event_device *);
	int (*set_state_oneshot_stopped)(struct clock_event_device *);
	int (*set_state_shutdown)(struct clock_event_device *);
	int (*tick_resume)(struct clock_event_device *);
	void (*broadcast)(const struct cpumask *);
	void (*suspend)(struct clock_event_device *);
	void (*resume)(struct clock_event_device *);
	long unsigned int min_delta_ticks;
	long unsigned int max_delta_ticks;
	const char *name;
	int rating;
	int irq;
	int bound_on;
	const struct cpumask *cpumask;
	struct list_head list;
	struct module *owner;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct delay_timer {
	long unsigned int (*read_current_timer)();
	long unsigned int freq;
};

struct kimage_arch {
	u32 kernel_r2;
};

typedef long unsigned int kimage_entry_t;

struct kexec_segment {
	union {
		void *buf;
		void *kbuf;
	};
	size_t bufsz;
	long unsigned int mem;
	size_t memsz;
};

struct kimage {
	kimage_entry_t head;
	kimage_entry_t *entry;
	kimage_entry_t *last_entry;
	long unsigned int start;
	struct page *control_code_page;
	struct page *swap_page;
	void *vmcoreinfo_data_copy;
	long unsigned int nr_segments;
	struct kexec_segment segment[16];
	struct list_head control_pages;
	struct list_head dest_pages;
	struct list_head unusable_pages;
	long unsigned int control_page;
	unsigned int type: 1;
	unsigned int preserve_context: 1;
	unsigned int file_mode: 1;
	struct kimage_arch arch;
	void *elf_headers;
	long unsigned int elf_headers_sz;
	long unsigned int elf_load_addr;
};

enum {
	IRQD_TRIGGER_MASK = 15,
	IRQD_SETAFFINITY_PENDING = 256,
	IRQD_ACTIVATED = 512,
	IRQD_NO_BALANCING = 1024,
	IRQD_PER_CPU = 2048,
	IRQD_AFFINITY_SET = 4096,
	IRQD_LEVEL = 8192,
	IRQD_WAKEUP_STATE = 16384,
	IRQD_MOVE_PCNTXT = 32768,
	IRQD_IRQ_DISABLED = 65536,
	IRQD_IRQ_MASKED = 131072,
	IRQD_IRQ_INPROGRESS = 262144,
	IRQD_WAKEUP_ARMED = 524288,
	IRQD_FORWARDED_TO_VCPU = 1048576,
	IRQD_AFFINITY_MANAGED = 2097152,
	IRQD_IRQ_STARTED = 4194304,
	IRQD_MANAGED_SHUTDOWN = 8388608,
	IRQD_SINGLE_TARGET = 16777216,
	IRQD_DEFAULT_TRIGGER_SET = 33554432,
	IRQD_CAN_RESERVE = 67108864,
	IRQD_MSI_NOMASK_QUIRK = 134217728,
	IRQD_HANDLE_ENFORCE_IRQCTX = 268435456,
	IRQD_AFFINITY_ON_ACTIVATE = 536870912,
	IRQD_IRQ_ENABLED_ON_SUSPEND = 1073741824,
};

struct kexec_relocate_data {
	long unsigned int kexec_start_address;
	long unsigned int kexec_indirection_page;
	long unsigned int kexec_mach_type;
	long unsigned int kexec_r2;
};

struct patch {
	void *addr;
	unsigned int insn;
};

enum unwind_reason_code {
	URC_OK = 0,
	URC_CONTINUE_UNWIND = 8,
	URC_FAILURE = 9,
};

struct unwind_ctrl_block {
	long unsigned int vrs[16];
	const long unsigned int *insn;
	long unsigned int sp_high;
	long unsigned int *lr_addr;
	int check_each_pop;
	int entries;
	int byte;
};

enum regs {
	FP = 11,
	SP = 13,
	LR = 14,
	PC = 15,
};

struct of_cpu_method {
	const char *method;
	const struct smp_operations *ops;
};

enum perf_sample_regs_abi {
	PERF_SAMPLE_REGS_ABI_NONE = 0,
	PERF_SAMPLE_REGS_ABI_32 = 1,
	PERF_SAMPLE_REGS_ABI_64 = 2,
};

enum perf_event_arm_regs {
	PERF_REG_ARM_R0 = 0,
	PERF_REG_ARM_R1 = 1,
	PERF_REG_ARM_R2 = 2,
	PERF_REG_ARM_R3 = 3,
	PERF_REG_ARM_R4 = 4,
	PERF_REG_ARM_R5 = 5,
	PERF_REG_ARM_R6 = 6,
	PERF_REG_ARM_R7 = 7,
	PERF_REG_ARM_R8 = 8,
	PERF_REG_ARM_R9 = 9,
	PERF_REG_ARM_R10 = 10,
	PERF_REG_ARM_FP = 11,
	PERF_REG_ARM_IP = 12,
	PERF_REG_ARM_SP = 13,
	PERF_REG_ARM_LR = 14,
	PERF_REG_ARM_PC = 15,
	PERF_REG_ARM_MAX = 16,
};

struct perf_callchain_entry_ctx {
	struct perf_callchain_entry *entry;
	u32 max_stack;
	u32 nr;
	short int contexts;
	bool contexts_maxed;
};

struct frame_tail {
	struct frame_tail *fp;
	long unsigned int sp;
	long unsigned int lr;
};

struct platform_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

enum perf_hw_id {
	PERF_COUNT_HW_CPU_CYCLES = 0,
	PERF_COUNT_HW_INSTRUCTIONS = 1,
	PERF_COUNT_HW_CACHE_REFERENCES = 2,
	PERF_COUNT_HW_CACHE_MISSES = 3,
	PERF_COUNT_HW_BRANCH_INSTRUCTIONS = 4,
	PERF_COUNT_HW_BRANCH_MISSES = 5,
	PERF_COUNT_HW_BUS_CYCLES = 6,
	PERF_COUNT_HW_STALLED_CYCLES_FRONTEND = 7,
	PERF_COUNT_HW_STALLED_CYCLES_BACKEND = 8,
	PERF_COUNT_HW_REF_CPU_CYCLES = 9,
	PERF_COUNT_HW_MAX = 10,
};

enum perf_hw_cache_id {
	PERF_COUNT_HW_CACHE_L1D = 0,
	PERF_COUNT_HW_CACHE_L1I = 1,
	PERF_COUNT_HW_CACHE_LL = 2,
	PERF_COUNT_HW_CACHE_DTLB = 3,
	PERF_COUNT_HW_CACHE_ITLB = 4,
	PERF_COUNT_HW_CACHE_BPU = 5,
	PERF_COUNT_HW_CACHE_NODE = 6,
	PERF_COUNT_HW_CACHE_MAX = 7,
};

enum perf_hw_cache_op_id {
	PERF_COUNT_HW_CACHE_OP_READ = 0,
	PERF_COUNT_HW_CACHE_OP_WRITE = 1,
	PERF_COUNT_HW_CACHE_OP_PREFETCH = 2,
	PERF_COUNT_HW_CACHE_OP_MAX = 3,
};

enum perf_hw_cache_op_result_id {
	PERF_COUNT_HW_CACHE_RESULT_ACCESS = 0,
	PERF_COUNT_HW_CACHE_RESULT_MISS = 1,
	PERF_COUNT_HW_CACHE_RESULT_MAX = 2,
};

enum perf_event_sample_format {
	PERF_SAMPLE_IP = 1,
	PERF_SAMPLE_TID = 2,
	PERF_SAMPLE_TIME = 4,
	PERF_SAMPLE_ADDR = 8,
	PERF_SAMPLE_READ = 16,
	PERF_SAMPLE_CALLCHAIN = 32,
	PERF_SAMPLE_ID = 64,
	PERF_SAMPLE_CPU = 128,
	PERF_SAMPLE_PERIOD = 256,
	PERF_SAMPLE_STREAM_ID = 512,
	PERF_SAMPLE_RAW = 1024,
	PERF_SAMPLE_BRANCH_STACK = 2048,
	PERF_SAMPLE_REGS_USER = 4096,
	PERF_SAMPLE_STACK_USER = 8192,
	PERF_SAMPLE_WEIGHT = 16384,
	PERF_SAMPLE_DATA_SRC = 32768,
	PERF_SAMPLE_IDENTIFIER = 65536,
	PERF_SAMPLE_TRANSACTION = 131072,
	PERF_SAMPLE_REGS_INTR = 262144,
	PERF_SAMPLE_PHYS_ADDR = 524288,
	PERF_SAMPLE_AUX = 1048576,
	PERF_SAMPLE_CGROUP = 2097152,
	PERF_SAMPLE_DATA_PAGE_SIZE = 4194304,
	PERF_SAMPLE_CODE_PAGE_SIZE = 8388608,
	PERF_SAMPLE_WEIGHT_STRUCT = 16777216,
	PERF_SAMPLE_MAX = 33554432,
};

struct pdev_archdata {};

struct device_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device *, struct device_attribute *, char *);
	ssize_t (*store)(struct device *, struct device_attribute *, const char *, size_t);
};

struct perf_pmu_events_attr {
	struct device_attribute attr;
	u64 id;
	const char *event_str;
	int: 32;
};

struct mfd_cell;

struct platform_device {
	const char *name;
	int id;
	bool id_auto;
	int: 24;
	int: 32;
	struct device dev;
	u64 platform_dma_mask;
	struct device_dma_parameters dma_parms;
	u32 num_resources;
	struct resource *resource;
	const struct platform_device_id *id_entry;
	const char *driver_override;
	struct mfd_cell *mfd_cell;
	struct pdev_archdata archdata;
};

struct platform_driver {
	int (*probe)(struct platform_device *);
	int (*remove)(struct platform_device *);
	void (*shutdown)(struct platform_device *);
	int (*suspend)(struct platform_device *, pm_message_t);
	int (*resume)(struct platform_device *);
	struct device_driver driver;
	const struct platform_device_id *id_table;
	bool prevent_deferred_probe;
	bool driver_managed_dma;
};

struct arm_pmu;

struct pmu_hw_events {
	struct perf_event *events[32];
	long unsigned int used_mask[1];
	raw_spinlock_t pmu_lock;
	struct arm_pmu *percpu_pmu;
	int irq;
};

struct arm_pmu {
	struct pmu pmu;
	cpumask_t supported_cpus;
	char *name;
	int pmuver;
	irqreturn_t (*handle_irq)(struct arm_pmu *);
	void (*enable)(struct perf_event *);
	void (*disable)(struct perf_event *);
	int (*get_event_idx)(struct pmu_hw_events *, struct perf_event *);
	void (*clear_event_idx)(struct pmu_hw_events *, struct perf_event *);
	int (*set_event_filter)(struct hw_perf_event *, struct perf_event_attr *);
	u64 (*read_counter)(struct perf_event *);
	void (*write_counter)(struct perf_event *, u64);
	void (*start)(struct arm_pmu *);
	void (*stop)(struct arm_pmu *);
	void (*reset)(void *);
	int (*map_event)(struct perf_event *);
	int (*filter_match)(struct perf_event *);
	int num_events;
	bool secure_access;
	long unsigned int pmceid_bitmap[2];
	long unsigned int pmceid_ext_bitmap[2];
	struct platform_device *plat_device;
	struct pmu_hw_events *hw_events;
	struct hlist_node node;
	struct notifier_block cpu_pm_nb;
	const struct attribute_group *attr_groups[5];
	u64 reg_pmmir;
	long unsigned int acpi_cpuid;
	int: 32;
};

enum armpmu_attr_groups {
	ARMPMU_ATTR_GROUP_COMMON = 0,
	ARMPMU_ATTR_GROUP_EVENTS = 1,
	ARMPMU_ATTR_GROUP_FORMATS = 2,
	ARMPMU_ATTR_GROUP_CAPS = 3,
	ARMPMU_NR_ATTR_GROUPS = 4,
};

typedef int (*armpmu_init_fn)(struct arm_pmu *);

struct pmu_probe_info {
	unsigned int cpuid;
	unsigned int mask;
	armpmu_init_fn init;
};

struct cpu_topology {
	int thread_id;
	int core_id;
	int cluster_id;
	int package_id;
	cpumask_t thread_sibling;
	cpumask_t core_sibling;
	cpumask_t cluster_sibling;
	cpumask_t llc_sibling;
};

struct cpu_efficiency {
	const char *compatible;
	long unsigned int efficiency;
};

struct timens_offset {
	s64 sec;
	u64 nsec;
};

struct arch_vdso_data {};

struct vdso_timestamp {
	u64 sec;
	u64 nsec;
};

struct vdso_data {
	u32 seq;
	s32 clock_mode;
	u64 cycle_last;
	u64 mask;
	u32 mult;
	u32 shift;
	union {
		struct vdso_timestamp basetime[12];
		struct timens_offset offset[12];
	};
	s32 tz_minuteswest;
	s32 tz_dsttime;
	u32 hrtimer_res;
	u32 __unused;
	struct arch_vdso_data arch_data;
};

union vdso_data_store {
	struct vdso_data data[2];
	u8 page[4096];
};

struct elfinfo {
	Elf32_Ehdr *hdr;
	Elf32_Sym *dynsym;
	long unsigned int dynsymsize;
	char *dynstr;
};

struct psci_operations {
	u32 (*get_version)();
	int (*cpu_suspend)(u32, long unsigned int);
	int (*cpu_off)(u32);
	int (*cpu_on)(long unsigned int, long unsigned int);
	int (*migrate)(long unsigned int);
	int (*affinity_info)(long unsigned int, long unsigned int);
	int (*migrate_info_type)();
};

struct bpf_run_ctx {};

enum {
	BPF_MAP_VALUE_OFF_MAX = 8,
	BPF_MAP_OFF_ARR_MAX = 10,
};

enum bpf_type_flag {
	PTR_MAYBE_NULL = 256,
	MEM_RDONLY = 512,
	MEM_ALLOC = 1024,
	MEM_USER = 2048,
	MEM_PERCPU = 4096,
	OBJ_RELEASE = 8192,
	PTR_UNTRUSTED = 16384,
	MEM_UNINIT = 32768,
	DYNPTR_TYPE_LOCAL = 65536,
	DYNPTR_TYPE_RINGBUF = 131072,
	MEM_FIXED_SIZE = 262144,
	__BPF_TYPE_FLAG_MAX = 262145,
	__BPF_TYPE_LAST_FLAG = 262144,
};

enum bpf_arg_type {
	ARG_DONTCARE = 0,
	ARG_CONST_MAP_PTR = 1,
	ARG_PTR_TO_MAP_KEY = 2,
	ARG_PTR_TO_MAP_VALUE = 3,
	ARG_PTR_TO_MEM = 4,
	ARG_CONST_SIZE = 5,
	ARG_CONST_SIZE_OR_ZERO = 6,
	ARG_PTR_TO_CTX = 7,
	ARG_ANYTHING = 8,
	ARG_PTR_TO_SPIN_LOCK = 9,
	ARG_PTR_TO_SOCK_COMMON = 10,
	ARG_PTR_TO_INT = 11,
	ARG_PTR_TO_LONG = 12,
	ARG_PTR_TO_SOCKET = 13,
	ARG_PTR_TO_BTF_ID = 14,
	ARG_PTR_TO_ALLOC_MEM = 15,
	ARG_CONST_ALLOC_SIZE_OR_ZERO = 16,
	ARG_PTR_TO_BTF_ID_SOCK_COMMON = 17,
	ARG_PTR_TO_PERCPU_BTF_ID = 18,
	ARG_PTR_TO_FUNC = 19,
	ARG_PTR_TO_STACK = 20,
	ARG_PTR_TO_CONST_STR = 21,
	ARG_PTR_TO_TIMER = 22,
	ARG_PTR_TO_KPTR = 23,
	ARG_PTR_TO_DYNPTR = 24,
	__BPF_ARG_TYPE_MAX = 25,
	ARG_PTR_TO_MAP_VALUE_OR_NULL = 259,
	ARG_PTR_TO_MEM_OR_NULL = 260,
	ARG_PTR_TO_CTX_OR_NULL = 263,
	ARG_PTR_TO_SOCKET_OR_NULL = 269,
	ARG_PTR_TO_ALLOC_MEM_OR_NULL = 271,
	ARG_PTR_TO_STACK_OR_NULL = 276,
	ARG_PTR_TO_BTF_ID_OR_NULL = 270,
	ARG_PTR_TO_UNINIT_MEM = 32772,
	ARG_PTR_TO_FIXED_SIZE_MEM = 262148,
	__BPF_ARG_TYPE_LIMIT = 524287,
};

enum bpf_return_type {
	RET_INTEGER = 0,
	RET_VOID = 1,
	RET_PTR_TO_MAP_VALUE = 2,
	RET_PTR_TO_SOCKET = 3,
	RET_PTR_TO_TCP_SOCK = 4,
	RET_PTR_TO_SOCK_COMMON = 5,
	RET_PTR_TO_ALLOC_MEM = 6,
	RET_PTR_TO_MEM_OR_BTF_ID = 7,
	RET_PTR_TO_BTF_ID = 8,
	__BPF_RET_TYPE_MAX = 9,
	RET_PTR_TO_MAP_VALUE_OR_NULL = 258,
	RET_PTR_TO_SOCKET_OR_NULL = 259,
	RET_PTR_TO_TCP_SOCK_OR_NULL = 260,
	RET_PTR_TO_SOCK_COMMON_OR_NULL = 261,
	RET_PTR_TO_ALLOC_MEM_OR_NULL = 1286,
	RET_PTR_TO_DYNPTR_MEM_OR_NULL = 262,
	RET_PTR_TO_BTF_ID_OR_NULL = 264,
	__BPF_RET_TYPE_LIMIT = 524287,
};

enum bpf_reg_type {
	NOT_INIT = 0,
	SCALAR_VALUE = 1,
	PTR_TO_CTX = 2,
	CONST_PTR_TO_MAP = 3,
	PTR_TO_MAP_VALUE = 4,
	PTR_TO_MAP_KEY = 5,
	PTR_TO_STACK = 6,
	PTR_TO_PACKET_META = 7,
	PTR_TO_PACKET = 8,
	PTR_TO_PACKET_END = 9,
	PTR_TO_FLOW_KEYS = 10,
	PTR_TO_SOCKET = 11,
	PTR_TO_SOCK_COMMON = 12,
	PTR_TO_TCP_SOCK = 13,
	PTR_TO_TP_BUFFER = 14,
	PTR_TO_XDP_SOCK = 15,
	PTR_TO_BTF_ID = 16,
	PTR_TO_MEM = 17,
	PTR_TO_BUF = 18,
	PTR_TO_FUNC = 19,
	PTR_TO_DYNPTR = 20,
	__BPF_REG_TYPE_MAX = 21,
	PTR_TO_MAP_VALUE_OR_NULL = 260,
	PTR_TO_SOCKET_OR_NULL = 267,
	PTR_TO_SOCK_COMMON_OR_NULL = 268,
	PTR_TO_TCP_SOCK_OR_NULL = 269,
	PTR_TO_BTF_ID_OR_NULL = 272,
	__BPF_REG_TYPE_LIMIT = 524287,
};

enum bpf_cgroup_storage_type {
	BPF_CGROUP_STORAGE_SHARED = 0,
	BPF_CGROUP_STORAGE_PERCPU = 1,
	__BPF_CGROUP_STORAGE_MAX = 2,
};

enum bpf_tramp_prog_type {
	BPF_TRAMP_FENTRY = 0,
	BPF_TRAMP_FEXIT = 1,
	BPF_TRAMP_MODIFY_RETURN = 2,
	BPF_TRAMP_MAX = 3,
	BPF_TRAMP_REPLACE = 4,
};

typedef u32 probes_opcode_t;

struct arch_probes_insn;

typedef void probes_insn_handler_t(probes_opcode_t, struct arch_probes_insn *, struct pt_regs *);

typedef long unsigned int probes_check_cc(long unsigned int);

typedef void probes_insn_singlestep_t(probes_opcode_t, struct arch_probes_insn *, struct pt_regs *);

typedef void probes_insn_fn_t();

struct arch_probes_insn {
	probes_opcode_t *insn;
	probes_insn_handler_t *insn_handler;
	probes_check_cc *insn_check_cc;
	probes_insn_singlestep_t *insn_singlestep;
	probes_insn_fn_t *insn_fn;
	int stack_space;
	long unsigned int register_usage_flags;
	bool kprobe_direct_exec;
};

enum vm_fault_reason {
	VM_FAULT_OOM = 1,
	VM_FAULT_SIGBUS = 2,
	VM_FAULT_MAJOR = 4,
	VM_FAULT_WRITE = 8,
	VM_FAULT_HWPOISON = 16,
	VM_FAULT_HWPOISON_LARGE = 32,
	VM_FAULT_SIGSEGV = 64,
	VM_FAULT_NOPAGE = 256,
	VM_FAULT_LOCKED = 512,
	VM_FAULT_RETRY = 1024,
	VM_FAULT_FALLBACK = 2048,
	VM_FAULT_DONE_COW = 4096,
	VM_FAULT_NEEDDSYNC = 8192,
	VM_FAULT_COMPLETED = 16384,
	VM_FAULT_HINDEX_MASK = 983040,
};

typedef u32 kprobe_opcode_t;

struct kprobe;

typedef int (*kprobe_pre_handler_t)(struct kprobe *, struct pt_regs *);

typedef void (*kprobe_post_handler_t)(struct kprobe *, struct pt_regs *, long unsigned int);

struct kprobe {
	struct hlist_node hlist;
	struct list_head list;
	long unsigned int nmissed;
	kprobe_opcode_t *addr;
	const char *symbol_name;
	unsigned int offset;
	kprobe_pre_handler_t pre_handler;
	kprobe_post_handler_t post_handler;
	kprobe_opcode_t opcode;
	struct arch_probes_insn ainsn;
	u32 flags;
};

typedef void (*harden_branch_predictor_fn_t)();

struct fsr_info {
	int (*fn)(long unsigned int, unsigned int, struct pt_regs *);
	int sig;
	int code;
	const char *name;
};

enum pageflags {
	PG_locked = 0,
	PG_referenced = 1,
	PG_uptodate = 2,
	PG_dirty = 3,
	PG_lru = 4,
	PG_active = 5,
	PG_workingset = 6,
	PG_waiters = 7,
	PG_error = 8,
	PG_slab = 9,
	PG_owner_priv_1 = 10,
	PG_arch_1 = 11,
	PG_reserved = 12,
	PG_private = 13,
	PG_private_2 = 14,
	PG_writeback = 15,
	PG_head = 16,
	PG_mappedtodisk = 17,
	PG_reclaim = 18,
	PG_swapbacked = 19,
	PG_unevictable = 20,
	PG_mlocked = 21,
	__NR_PAGEFLAGS = 22,
	PG_readahead = 18,
	PG_anon_exclusive = 17,
	PG_checked = 10,
	PG_swapcache = 10,
	PG_fscache = 14,
	PG_pinned = 10,
	PG_savepinned = 3,
	PG_foreign = 10,
	PG_xen_remapped = 10,
	PG_slob_free = 13,
	PG_double_map = 6,
	PG_isolated = 18,
	PG_reported = 2,
};

struct scatterlist {
	long unsigned int page_link;
	unsigned int offset;
	unsigned int length;
	dma_addr_t dma_address;
};

struct sg_table {
	struct scatterlist *sgl;
	unsigned int nents;
	unsigned int orig_nents;
};

struct section_perm {
	const char *name;
	long unsigned int start;
	long unsigned int end;
	pmdval_t mask;
	pmdval_t prot;
	pmdval_t clear;
};

struct gen_pool;

typedef long unsigned int (*genpool_algo_t)(long unsigned int *, long unsigned int, long unsigned int, unsigned int, void *, struct gen_pool *, long unsigned int);

struct gen_pool {
	spinlock_t lock;
	struct list_head chunks;
	int min_alloc_order;
	genpool_algo_t algo;
	void *data;
	const char *name;
};

struct iommu_group {};

enum {
	MT_UNCACHED = 5,
	MT_CACHECLEAN = 6,
	MT_MINICLEAN = 7,
	MT_LOW_VECTORS = 8,
	MT_HIGH_VECTORS = 9,
	MT_MEMORY_RWX = 10,
	MT_MEMORY_RW = 11,
	MT_MEMORY_RO = 12,
	MT_ROM = 13,
	MT_MEMORY_RWX_NONCACHED = 14,
	MT_MEMORY_RW_DTCM = 15,
	MT_MEMORY_RWX_ITCM = 16,
	MT_MEMORY_RW_SO = 17,
	MT_MEMORY_DMA_READY = 18,
};

struct arm_dma_alloc_args {
	struct device *dev;
	size_t size;
	gfp_t gfp;
	pgprot_t prot;
	const void *caller;
	bool want_vaddr;
	int coherent_flag;
};

struct arm_dma_free_args {
	struct device *dev;
	size_t size;
	void *cpu_addr;
	struct page *page;
	bool want_vaddr;
};

struct arm_dma_allocator {
	void * (*alloc)(struct arm_dma_alloc_args *, struct page **);
	void (*free)(struct arm_dma_free_args *);
};

struct arm_dma_buffer {
	struct list_head list;
	void *virt;
	struct arm_dma_allocator *allocator;
};

struct dma_contig_early_reserve {
	phys_addr_t base;
	long unsigned int size;
};

struct mem_type {
	pteval_t prot_pte;
	pteval_t prot_pte_s2;
	pmdval_t prot_l1;
	pmdval_t prot_sect;
	unsigned int domain;
};

struct static_vm {
	struct vm_struct vm;
	struct list_head list;
};

struct vm_unmapped_area_info {
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
};

struct cachepolicy {
	const char policy[16];
	unsigned int cr_mask;
	pmdval_t pmd;
	pteval_t pte;
};

struct page_change_data {
	pgprot_t set_mask;
	pgprot_t clear_mask;
};

union offset_union {
	long unsigned int un;
	long int sn;
};

enum arm_smccc_conduit {
	SMCCC_CONDUIT_NONE = 0,
	SMCCC_CONDUIT_SMC = 1,
	SMCCC_CONDUIT_HVC = 2,
};

struct arm_smccc_res {
	long unsigned int a0;
	long unsigned int a1;
	long unsigned int a2;
	long unsigned int a3;
};

struct task_struct;

struct l2c_init_data {
	const char *type;
	unsigned int way_size_0;
	unsigned int num_lock;
	void (*of_parse)(const struct device_node *, u32 *, u32 *);
	void (*enable)(void *, unsigned int);
	void (*fixup)(void *, u32, struct outer_cache_fns *);
	void (*save)(void *);
	void (*configure)(void *);
	void (*unlock)(void *, unsigned int);
	struct outer_cache_fns outer_cache;
};

struct firmware_ops {
	int (*prepare_idle)(long unsigned int);
	int (*do_idle)(long unsigned int);
	int (*set_cpu_boot_addr)(int, long unsigned int);
	int (*get_cpu_boot_addr)(int, long unsigned int *);
	int (*cpu_boot)(int);
	int (*l2x0_init)();
	int (*suspend)();
	int (*resume)();
};

enum decode_type {
	DECODE_TYPE_END = 0,
	DECODE_TYPE_TABLE = 1,
	DECODE_TYPE_CUSTOM = 2,
	DECODE_TYPE_SIMULATE = 3,
	DECODE_TYPE_EMULATE = 4,
	DECODE_TYPE_OR = 5,
	DECODE_TYPE_REJECT = 6,
	NUM_DECODE_TYPES = 7,
};

enum decode_reg_type {
	REG_TYPE_NONE = 0,
	REG_TYPE_ANY = 1,
	REG_TYPE_SAMEAS16 = 2,
	REG_TYPE_SP = 3,
	REG_TYPE_PC = 4,
	REG_TYPE_NOSP = 5,
	REG_TYPE_NOSPPC = 6,
	REG_TYPE_NOPC = 7,
	REG_TYPE_NOPCWB = 8,
	REG_TYPE_NOPCX = 9,
	REG_TYPE_NOSPPCX = 10,
	REG_TYPE_0 = 0,
};

union decode_item {
	u32 bits;
	const union decode_item *table;
	int action;
};

enum probes_insn {
	INSN_REJECTED = 0,
	INSN_GOOD = 1,
	INSN_GOOD_NO_SLOT = 2,
};

struct decode_header;

typedef enum probes_insn probes_custom_decode_t(probes_opcode_t, struct arch_probes_insn *, const struct decode_header *);

struct decode_header {
	union decode_item type_regs;
	union decode_item mask;
	union decode_item value;
};

union decode_action {
	probes_insn_handler_t *handler;
	probes_custom_decode_t *decoder;
};

typedef enum probes_insn probes_check_t(probes_opcode_t, struct arch_probes_insn *, const struct decode_header *);

struct decode_checker {
	probes_check_t *checker;
};

struct decode_table {
	struct decode_header header;
	union decode_item table;
};

struct decode_custom {
	struct decode_header header;
	union decode_item decoder;
};

struct decode_simulate {
	struct decode_header header;
	union decode_item handler;
};

struct decode_emulate {
	struct decode_header header;
	union decode_item handler;
};

enum probes_arm_action {
	PROBES_PRELOAD_IMM = 0,
	PROBES_PRELOAD_REG = 1,
	PROBES_BRANCH_IMM = 2,
	PROBES_BRANCH_REG = 3,
	PROBES_MRS = 4,
	PROBES_CLZ = 5,
	PROBES_SATURATING_ARITHMETIC = 6,
	PROBES_MUL1 = 7,
	PROBES_MUL2 = 8,
	PROBES_SWP = 9,
	PROBES_LDRSTRD = 10,
	PROBES_LOAD = 11,
	PROBES_STORE = 12,
	PROBES_LOAD_EXTRA = 13,
	PROBES_STORE_EXTRA = 14,
	PROBES_MOV_IP_SP = 15,
	PROBES_DATA_PROCESSING_REG = 16,
	PROBES_DATA_PROCESSING_IMM = 17,
	PROBES_MOV_HALFWORD = 18,
	PROBES_SEV = 19,
	PROBES_WFE = 20,
	PROBES_SATURATE = 21,
	PROBES_REV = 22,
	PROBES_MMI = 23,
	PROBES_PACK = 24,
	PROBES_EXTEND = 25,
	PROBES_EXTEND_ADD = 26,
	PROBES_MUL_ADD_LONG = 27,
	PROBES_MUL_ADD = 28,
	PROBES_BITFIELD = 29,
	PROBES_BRANCH = 30,
	PROBES_LDMSTM = 31,
	NUM_PROBES_ARM_ACTIONS = 32,
};

typedef u32 uprobe_opcode_t;

struct arch_uprobe {
	u8 insn[4];
	long unsigned int ixol[2];
	uprobe_opcode_t bpinsn;
	bool simulate;
	u32 pcreg;
	void (*prehandler)(struct arch_uprobe *, struct arch_uprobe_task *, struct pt_regs *);
	void (*posthandler)(struct arch_uprobe *, struct arch_uprobe_task *, struct pt_regs *);
	struct arch_probes_insn asi;
};

struct freelist_node {
	atomic_t refs;
	struct freelist_node *next;
};

struct freelist_head {
	struct freelist_node *head;
};

struct prev_kprobe {
	struct kprobe *kp;
	unsigned int status;
};

struct kprobe_ctlblk {
	unsigned int kprobe_status;
	struct prev_kprobe prev_kprobe;
};

struct kretprobe_instance;

typedef int (*kretprobe_handler_t)(struct kretprobe_instance *, struct pt_regs *);

struct kretprobe_holder;

struct kretprobe_instance {
	union {
		struct freelist_node freelist;
		struct callback_head rcu;
	};
	struct llist_node llist;
	struct kretprobe_holder *rph;
	kprobe_opcode_t *ret_addr;
	void *fp;
	char data[0];
};

struct kretprobe;

struct kretprobe_holder {
	struct kretprobe *rp;
	refcount_t ref;
};

struct kretprobe {
	struct kprobe kp;
	kretprobe_handler_t handler;
	kretprobe_handler_t entry_handler;
	int maxactive;
	int nmissed;
	size_t data_size;
	struct freelist_head freelist;
	struct kretprobe_holder *rph;
};

struct kprobe_insn_cache {
	struct mutex mutex;
	void * (*alloc)();
	void (*free)(void *);
	const char *sym;
	struct list_head pages;
	size_t insn_size;
	int nr_garbage;
};

typedef enum probes_insn kprobe_decode_insn_t(probes_opcode_t, struct arch_probes_insn *, bool, const union decode_action *, const struct decode_checker **);

enum {
	STACK_USE_NONE = 0,
	STACK_USE_UNKNOWN = 1,
	STACK_USE_FIXED_X0X = 2,
	STACK_USE_FIXED_XXX = 3,
	STACK_USE_STMDX = 4,
	NUM_STACK_USE_TYPES = 5,
};

struct arch_optimized_insn {
	kprobe_opcode_t copied_insn[1];
	kprobe_opcode_t *insn;
};

struct optimized_kprobe {
	struct kprobe kp;
	struct list_head list;
	struct arch_optimized_insn optinsn;
};

enum {
	BPF_REG_0 = 0,
	BPF_REG_1 = 1,
	BPF_REG_2 = 2,
	BPF_REG_3 = 3,
	BPF_REG_4 = 4,
	BPF_REG_5 = 5,
	BPF_REG_6 = 6,
	BPF_REG_7 = 7,
	BPF_REG_8 = 8,
	BPF_REG_9 = 9,
	BPF_REG_10 = 10,
	__MAX_BPF_REG = 11,
};

struct bpf_insn {
	__u8 code;
	__u8 dst_reg: 4;
	__u8 src_reg: 4;
	__s16 off;
	__s32 imm;
};

enum bpf_cgroup_iter_order {
	BPF_CGROUP_ITER_ORDER_UNSPEC = 0,
	BPF_CGROUP_ITER_SELF_ONLY = 1,
	BPF_CGROUP_ITER_DESCENDANTS_PRE = 2,
	BPF_CGROUP_ITER_DESCENDANTS_POST = 3,
	BPF_CGROUP_ITER_ANCESTORS_UP = 4,
};

enum bpf_map_type {
	BPF_MAP_TYPE_UNSPEC = 0,
	BPF_MAP_TYPE_HASH = 1,
	BPF_MAP_TYPE_ARRAY = 2,
	BPF_MAP_TYPE_PROG_ARRAY = 3,
	BPF_MAP_TYPE_PERF_EVENT_ARRAY = 4,
	BPF_MAP_TYPE_PERCPU_HASH = 5,
	BPF_MAP_TYPE_PERCPU_ARRAY = 6,
	BPF_MAP_TYPE_STACK_TRACE = 7,
	BPF_MAP_TYPE_CGROUP_ARRAY = 8,
	BPF_MAP_TYPE_LRU_HASH = 9,
	BPF_MAP_TYPE_LRU_PERCPU_HASH = 10,
	BPF_MAP_TYPE_LPM_TRIE = 11,
	BPF_MAP_TYPE_ARRAY_OF_MAPS = 12,
	BPF_MAP_TYPE_HASH_OF_MAPS = 13,
	BPF_MAP_TYPE_DEVMAP = 14,
	BPF_MAP_TYPE_SOCKMAP = 15,
	BPF_MAP_TYPE_CPUMAP = 16,
	BPF_MAP_TYPE_XSKMAP = 17,
	BPF_MAP_TYPE_SOCKHASH = 18,
	BPF_MAP_TYPE_CGROUP_STORAGE = 19,
	BPF_MAP_TYPE_REUSEPORT_SOCKARRAY = 20,
	BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE = 21,
	BPF_MAP_TYPE_QUEUE = 22,
	BPF_MAP_TYPE_STACK = 23,
	BPF_MAP_TYPE_SK_STORAGE = 24,
	BPF_MAP_TYPE_DEVMAP_HASH = 25,
	BPF_MAP_TYPE_STRUCT_OPS = 26,
	BPF_MAP_TYPE_RINGBUF = 27,
	BPF_MAP_TYPE_INODE_STORAGE = 28,
	BPF_MAP_TYPE_TASK_STORAGE = 29,
	BPF_MAP_TYPE_BLOOM_FILTER = 30,
	BPF_MAP_TYPE_USER_RINGBUF = 31,
};

enum bpf_prog_type {
	BPF_PROG_TYPE_UNSPEC = 0,
	BPF_PROG_TYPE_SOCKET_FILTER = 1,
	BPF_PROG_TYPE_KPROBE = 2,
	BPF_PROG_TYPE_SCHED_CLS = 3,
	BPF_PROG_TYPE_SCHED_ACT = 4,
	BPF_PROG_TYPE_TRACEPOINT = 5,
	BPF_PROG_TYPE_XDP = 6,
	BPF_PROG_TYPE_PERF_EVENT = 7,
	BPF_PROG_TYPE_CGROUP_SKB = 8,
	BPF_PROG_TYPE_CGROUP_SOCK = 9,
	BPF_PROG_TYPE_LWT_IN = 10,
	BPF_PROG_TYPE_LWT_OUT = 11,
	BPF_PROG_TYPE_LWT_XMIT = 12,
	BPF_PROG_TYPE_SOCK_OPS = 13,
	BPF_PROG_TYPE_SK_SKB = 14,
	BPF_PROG_TYPE_CGROUP_DEVICE = 15,
	BPF_PROG_TYPE_SK_MSG = 16,
	BPF_PROG_TYPE_RAW_TRACEPOINT = 17,
	BPF_PROG_TYPE_CGROUP_SOCK_ADDR = 18,
	BPF_PROG_TYPE_LWT_SEG6LOCAL = 19,
	BPF_PROG_TYPE_LIRC_MODE2 = 20,
	BPF_PROG_TYPE_SK_REUSEPORT = 21,
	BPF_PROG_TYPE_FLOW_DISSECTOR = 22,
	BPF_PROG_TYPE_CGROUP_SYSCTL = 23,
	BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 24,
	BPF_PROG_TYPE_CGROUP_SOCKOPT = 25,
	BPF_PROG_TYPE_TRACING = 26,
	BPF_PROG_TYPE_STRUCT_OPS = 27,
	BPF_PROG_TYPE_EXT = 28,
	BPF_PROG_TYPE_LSM = 29,
	BPF_PROG_TYPE_SK_LOOKUP = 30,
	BPF_PROG_TYPE_SYSCALL = 31,
};

enum bpf_attach_type {
	BPF_CGROUP_INET_INGRESS = 0,
	BPF_CGROUP_INET_EGRESS = 1,
	BPF_CGROUP_INET_SOCK_CREATE = 2,
	BPF_CGROUP_SOCK_OPS = 3,
	BPF_SK_SKB_STREAM_PARSER = 4,
	BPF_SK_SKB_STREAM_VERDICT = 5,
	BPF_CGROUP_DEVICE = 6,
	BPF_SK_MSG_VERDICT = 7,
	BPF_CGROUP_INET4_BIND = 8,
	BPF_CGROUP_INET6_BIND = 9,
	BPF_CGROUP_INET4_CONNECT = 10,
	BPF_CGROUP_INET6_CONNECT = 11,
	BPF_CGROUP_INET4_POST_BIND = 12,
	BPF_CGROUP_INET6_POST_BIND = 13,
	BPF_CGROUP_UDP4_SENDMSG = 14,
	BPF_CGROUP_UDP6_SENDMSG = 15,
	BPF_LIRC_MODE2 = 16,
	BPF_FLOW_DISSECTOR = 17,
	BPF_CGROUP_SYSCTL = 18,
	BPF_CGROUP_UDP4_RECVMSG = 19,
	BPF_CGROUP_UDP6_RECVMSG = 20,
	BPF_CGROUP_GETSOCKOPT = 21,
	BPF_CGROUP_SETSOCKOPT = 22,
	BPF_TRACE_RAW_TP = 23,
	BPF_TRACE_FENTRY = 24,
	BPF_TRACE_FEXIT = 25,
	BPF_MODIFY_RETURN = 26,
	BPF_LSM_MAC = 27,
	BPF_TRACE_ITER = 28,
	BPF_CGROUP_INET4_GETPEERNAME = 29,
	BPF_CGROUP_INET6_GETPEERNAME = 30,
	BPF_CGROUP_INET4_GETSOCKNAME = 31,
	BPF_CGROUP_INET6_GETSOCKNAME = 32,
	BPF_XDP_DEVMAP = 33,
	BPF_CGROUP_INET_SOCK_RELEASE = 34,
	BPF_XDP_CPUMAP = 35,
	BPF_SK_LOOKUP = 36,
	BPF_XDP = 37,
	BPF_SK_SKB_VERDICT = 38,
	BPF_SK_REUSEPORT_SELECT = 39,
	BPF_SK_REUSEPORT_SELECT_OR_MIGRATE = 40,
	BPF_PERF_EVENT = 41,
	BPF_TRACE_KPROBE_MULTI = 42,
	BPF_LSM_CGROUP = 43,
	__MAX_BPF_ATTACH_TYPE = 44,
};

union bpf_attr {
	struct {
		__u32 map_type;
		__u32 key_size;
		__u32 value_size;
		__u32 max_entries;
		__u32 map_flags;
		__u32 inner_map_fd;
		__u32 numa_node;
		char map_name[16];
		__u32 map_ifindex;
		__u32 btf_fd;
		__u32 btf_key_type_id;
		__u32 btf_value_type_id;
		__u32 btf_vmlinux_value_type_id;
		__u64 map_extra;
	};
	struct {
		__u32 map_fd;
		int: 32;
		__u64 key;
		union {
			__u64 value;
			__u64 next_key;
		};
		__u64 flags;
	};
	struct {
		__u64 in_batch;
		__u64 out_batch;
		__u64 keys;
		__u64 values;
		__u32 count;
		__u32 map_fd;
		__u64 elem_flags;
		__u64 flags;
	} batch;
	struct {
		__u32 prog_type;
		__u32 insn_cnt;
		__u64 insns;
		__u64 license;
		__u32 log_level;
		__u32 log_size;
		__u64 log_buf;
		__u32 kern_version;
		__u32 prog_flags;
		char prog_name[16];
		__u32 prog_ifindex;
		__u32 expected_attach_type;
		__u32 prog_btf_fd;
		__u32 func_info_rec_size;
		__u64 func_info;
		__u32 func_info_cnt;
		__u32 line_info_rec_size;
		__u64 line_info;
		__u32 line_info_cnt;
		__u32 attach_btf_id;
		union {
			__u32 attach_prog_fd;
			__u32 attach_btf_obj_fd;
		};
		__u32 core_relo_cnt;
		__u64 fd_array;
		__u64 core_relos;
		__u32 core_relo_rec_size;
		int: 32;
	};
	struct {
		__u64 pathname;
		__u32 bpf_fd;
		__u32 file_flags;
	};
	struct {
		__u32 target_fd;
		__u32 attach_bpf_fd;
		__u32 attach_type;
		__u32 attach_flags;
		__u32 replace_bpf_fd;
	};
	struct {
		__u32 prog_fd;
		__u32 retval;
		__u32 data_size_in;
		__u32 data_size_out;
		__u64 data_in;
		__u64 data_out;
		__u32 repeat;
		__u32 duration;
		__u32 ctx_size_in;
		__u32 ctx_size_out;
		__u64 ctx_in;
		__u64 ctx_out;
		__u32 flags;
		__u32 cpu;
		__u32 batch_size;
		int: 32;
	} test;
	struct {
		union {
			__u32 start_id;
			__u32 prog_id;
			__u32 map_id;
			__u32 btf_id;
			__u32 link_id;
		};
		__u32 next_id;
		__u32 open_flags;
	};
	struct {
		__u32 bpf_fd;
		__u32 info_len;
		__u64 info;
	} info;
	struct {
		__u32 target_fd;
		__u32 attach_type;
		__u32 query_flags;
		__u32 attach_flags;
		__u64 prog_ids;
		__u32 prog_cnt;
		int: 32;
		__u64 prog_attach_flags;
	} query;
	struct {
		__u64 name;
		__u32 prog_fd;
		int: 32;
	} raw_tracepoint;
	struct {
		__u64 btf;
		__u64 btf_log_buf;
		__u32 btf_size;
		__u32 btf_log_size;
		__u32 btf_log_level;
		int: 32;
	};
	struct {
		__u32 pid;
		__u32 fd;
		__u32 flags;
		__u32 buf_len;
		__u64 buf;
		__u32 prog_id;
		__u32 fd_type;
		__u64 probe_offset;
		__u64 probe_addr;
	} task_fd_query;
	struct {
		__u32 prog_fd;
		union {
			__u32 target_fd;
			__u32 target_ifindex;
		};
		__u32 attach_type;
		__u32 flags;
		union {
			__u32 target_btf_id;
			struct {
				__u64 iter_info;
				__u32 iter_info_len;
				int: 32;
			};
			struct {
				__u64 bpf_cookie;
			} perf_event;
			struct {
				__u32 flags;
				__u32 cnt;
				__u64 syms;
				__u64 addrs;
				__u64 cookies;
			} kprobe_multi;
			struct {
				__u32 target_btf_id;
				int: 32;
				__u64 cookie;
			} tracing;
		};
	} link_create;
	struct {
		__u32 link_fd;
		__u32 new_prog_fd;
		__u32 flags;
		__u32 old_prog_fd;
	} link_update;
	struct {
		__u32 link_fd;
	} link_detach;
	struct {
		__u32 type;
	} enable_stats;
	struct {
		__u32 link_fd;
		__u32 flags;
	} iter_create;
	struct {
		__u32 prog_fd;
		__u32 map_fd;
		__u32 flags;
	} prog_bind_map;
};

struct bpf_func_info {
	__u32 insn_off;
	__u32 type_id;
};

struct bpf_line_info {
	__u32 insn_off;
	__u32 file_name_off;
	__u32 line_off;
	__u32 line_col;
};

struct sock_filter {
	__u16 code;
	__u8 jt;
	__u8 jf;
	__u32 k;
};

enum {
	DUMP_PREFIX_NONE = 0,
	DUMP_PREFIX_ADDRESS = 1,
	DUMP_PREFIX_OFFSET = 2,
};

struct btf_type {
	__u32 name_off;
	__u32 info;
	union {
		__u32 size;
		__u32 type;
	};
};

typedef void (*btf_dtor_kfunc_t)(void *);

typedef u64 (*bpf_callback_t)(u64, u64, u64, u64, u64);

struct bpf_iter_aux_info;

typedef int (*bpf_iter_init_seq_priv_t)(void *, struct bpf_iter_aux_info *);

enum bpf_iter_task_type {
	BPF_TASK_ITER_ALL = 0,
	BPF_TASK_ITER_TID = 1,
	BPF_TASK_ITER_TGID = 2,
};

struct bpf_map;

struct bpf_iter_aux_info {
	struct bpf_map *map;
	struct {
		struct cgroup *start;
		enum bpf_cgroup_iter_order order;
	} cgroup;
	struct {
		enum bpf_iter_task_type type;
		u32 pid;
	} task;
};

typedef void (*bpf_iter_fini_seq_priv_t)(void *);

struct bpf_iter_seq_info {
	const struct seq_operations *seq_ops;
	bpf_iter_init_seq_priv_t init_seq_private;
	bpf_iter_fini_seq_priv_t fini_seq_private;
	u32 seq_priv_size;
};

struct btf;

struct bpf_prog_aux;

struct bpf_local_storage_map;

struct bpf_verifier_env;

struct bpf_func_state;

struct bpf_map_ops {
	int (*map_alloc_check)(union bpf_attr *);
	struct bpf_map * (*map_alloc)(union bpf_attr *);
	void (*map_release)(struct bpf_map *, struct file *);
	void (*map_free)(struct bpf_map *);
	int (*map_get_next_key)(struct bpf_map *, void *, void *);
	void (*map_release_uref)(struct bpf_map *);
	void * (*map_lookup_elem_sys_only)(struct bpf_map *, void *);
	int (*map_lookup_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_lookup_and_delete_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_lookup_and_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_update_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	int (*map_delete_batch)(struct bpf_map *, const union bpf_attr *, union bpf_attr *);
	void * (*map_lookup_elem)(struct bpf_map *, void *);
	int (*map_update_elem)(struct bpf_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_map *, void *);
	int (*map_push_elem)(struct bpf_map *, void *, u64);
	int (*map_pop_elem)(struct bpf_map *, void *);
	int (*map_peek_elem)(struct bpf_map *, void *);
	void * (*map_lookup_percpu_elem)(struct bpf_map *, void *, u32);
	void * (*map_fd_get_ptr)(struct bpf_map *, struct file *, int);
	void (*map_fd_put_ptr)(void *);
	int (*map_gen_lookup)(struct bpf_map *, struct bpf_insn *);
	u32 (*map_fd_sys_lookup_elem)(void *);
	void (*map_seq_show_elem)(struct bpf_map *, void *, struct seq_file *);
	int (*map_check_btf)(const struct bpf_map *, const struct btf *, const struct btf_type *, const struct btf_type *);
	int (*map_poke_track)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_untrack)(struct bpf_map *, struct bpf_prog_aux *);
	void (*map_poke_run)(struct bpf_map *, u32, struct bpf_prog *, struct bpf_prog *);
	int (*map_direct_value_addr)(const struct bpf_map *, u64 *, u32);
	int (*map_direct_value_meta)(const struct bpf_map *, u64, u32 *);
	int (*map_mmap)(struct bpf_map *, struct vm_area_struct *);
	__poll_t (*map_poll)(struct bpf_map *, struct file *, struct poll_table_struct *);
	int (*map_local_storage_charge)(struct bpf_local_storage_map *, void *, u32);
	void (*map_local_storage_uncharge)(struct bpf_local_storage_map *, void *, u32);
	struct bpf_local_storage ** (*map_owner_storage_ptr)(void *);
	int (*map_redirect)(struct bpf_map *, u32, u64);
	bool (*map_meta_equal)(const struct bpf_map *, const struct bpf_map *);
	int (*map_set_for_each_callback_args)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *);
	int (*map_for_each_callback)(struct bpf_map *, bpf_callback_t, void *, u64);
	int *map_btf_id;
	const struct bpf_iter_seq_info *iter_seq_info;
};

struct bpf_map_value_off;

struct bpf_map_off_arr;

struct bpf_map {
	const struct bpf_map_ops *ops;
	struct bpf_map *inner_map_meta;
	enum bpf_map_type map_type;
	u32 key_size;
	u32 value_size;
	u32 max_entries;
	u64 map_extra;
	u32 map_flags;
	int spin_lock_off;
	struct bpf_map_value_off *kptr_off_tab;
	int timer_off;
	u32 id;
	int numa_node;
	u32 btf_key_type_id;
	u32 btf_value_type_id;
	u32 btf_vmlinux_value_type_id;
	struct btf *btf;
	struct obj_cgroup *objcg;
	char name[16];
	struct bpf_map_off_arr *off_arr;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic64_t refcnt;
	atomic64_t usercnt;
	struct work_struct work;
	struct mutex freeze_mutex;
	int: 32;
	atomic64_t writecnt;
	struct {
		spinlock_t lock;
		enum bpf_prog_type type;
		bool jited;
		bool xdp_has_frags;
	} owner;
	bool bypass_spec_v1;
	bool frozen;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct btf_header {
	__u16 magic;
	__u8 version;
	__u8 flags;
	__u32 hdr_len;
	__u32 type_off;
	__u32 type_len;
	__u32 str_off;
	__u32 str_len;
};

struct btf_kfunc_set_tab;

struct btf_id_dtor_kfunc_tab;

struct btf {
	void *data;
	struct btf_type **types;
	u32 *resolved_ids;
	u32 *resolved_sizes;
	const char *strings;
	void *nohdr_data;
	struct btf_header hdr;
	u32 nr_types;
	u32 types_size;
	u32 data_size;
	refcount_t refcnt;
	u32 id;
	struct callback_head rcu;
	struct btf_kfunc_set_tab *kfunc_set_tab;
	struct btf_id_dtor_kfunc_tab *dtor_kfunc_tab;
	struct btf *base_btf;
	u32 start_id;
	u32 start_str_off;
	char name[60];
	bool kernel_btf;
};

struct bpf_ksym {
	long unsigned int start;
	long unsigned int end;
	char name[512];
	struct list_head lnode;
	struct latch_tree_node tnode;
	bool prog;
};

struct bpf_ctx_arg_aux;

struct bpf_trampoline;

struct bpf_jit_poke_descriptor;

struct bpf_kfunc_desc_tab;

struct bpf_kfunc_btf_tab;

struct bpf_prog_ops;

struct btf_mod_pair;

struct bpf_prog_offload;

struct bpf_func_info_aux;

struct bpf_prog_aux {
	atomic64_t refcnt;
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 max_ctx_offset;
	u32 max_pkt_offset;
	u32 max_tp_access;
	u32 stack_depth;
	u32 id;
	u32 func_cnt;
	u32 func_idx;
	u32 attach_btf_id;
	u32 ctx_arg_info_size;
	u32 max_rdonly_access;
	u32 max_rdwr_access;
	struct btf *attach_btf;
	const struct bpf_ctx_arg_aux *ctx_arg_info;
	struct mutex dst_mutex;
	struct bpf_prog *dst_prog;
	struct bpf_trampoline *dst_trampoline;
	enum bpf_prog_type saved_dst_prog_type;
	enum bpf_attach_type saved_dst_attach_type;
	bool verifier_zext;
	bool offload_requested;
	bool attach_btf_trace;
	bool func_proto_unreliable;
	bool sleepable;
	bool tail_call_reachable;
	bool xdp_has_frags;
	const struct btf_type *attach_func_proto;
	const char *attach_func_name;
	struct bpf_prog **func;
	void *jit_data;
	struct bpf_jit_poke_descriptor *poke_tab;
	struct bpf_kfunc_desc_tab *kfunc_tab;
	struct bpf_kfunc_btf_tab *kfunc_btf_tab;
	u32 size_poke_tab;
	struct bpf_ksym ksym;
	const struct bpf_prog_ops *ops;
	struct bpf_map **used_maps;
	struct mutex used_maps_mutex;
	struct btf_mod_pair *used_btfs;
	struct bpf_prog *prog;
	struct user_struct *user;
	int: 32;
	u64 load_time;
	u32 verified_insns;
	int cgroup_atype;
	struct bpf_map *cgroup_storage[2];
	char name[16];
	struct bpf_prog_offload *offload;
	struct btf *btf;
	struct bpf_func_info *func_info;
	struct bpf_func_info_aux *func_info_aux;
	struct bpf_line_info *linfo;
	void **jited_linfo;
	u32 func_info_cnt;
	u32 nr_linfo;
	u32 linfo_idx;
	u32 num_exentries;
	struct exception_table_entry *extable;
	union {
		struct work_struct work;
		struct callback_head rcu;
	};
	int: 32;
};

struct bpf_prog_stats;

struct sock_fprog_kern;

struct bpf_prog {
	u16 pages;
	u16 jited: 1;
	u16 jit_requested: 1;
	u16 gpl_compatible: 1;
	u16 cb_access: 1;
	u16 dst_needed: 1;
	u16 blinding_requested: 1;
	u16 blinded: 1;
	u16 is_func: 1;
	u16 kprobe_override: 1;
	u16 has_callchain_buf: 1;
	u16 enforce_expected_attach_type: 1;
	u16 call_get_stack: 1;
	u16 call_get_func_ip: 1;
	u16 tstamp_type_access: 1;
	enum bpf_prog_type type;
	enum bpf_attach_type expected_attach_type;
	u32 len;
	u32 jited_len;
	u8 tag[8];
	struct bpf_prog_stats *stats;
	int *active;
	unsigned int (*bpf_func)(const void *, const struct bpf_insn *);
	struct bpf_prog_aux *aux;
	struct sock_fprog_kern *orig_prog;
	union {
		struct {
			struct {			} __empty_insns;
			struct sock_filter insns[0];
		};
		struct {
			struct {			} __empty_insnsi;
			struct bpf_insn insnsi[0];
		};
	};
};

enum bpf_kptr_type {
	BPF_KPTR_UNREF = 0,
	BPF_KPTR_REF = 1,
};

struct bpf_map_value_off_desc {
	u32 offset;
	enum bpf_kptr_type type;
	struct {
		struct btf *btf;
		struct module *module;
		btf_dtor_kfunc_t dtor;
		u32 btf_id;
	} kptr;
};

struct bpf_map_value_off {
	u32 nr_off;
	struct bpf_map_value_off_desc off[0];
};

struct bpf_map_off_arr {
	u32 cnt;
	u32 field_off[10];
	u8 field_sz[10];
};

struct bpf_map_dev_ops {
	int (*map_get_next_key)(struct bpf_offloaded_map *, void *, void *);
	int (*map_lookup_elem)(struct bpf_offloaded_map *, void *, void *);
	int (*map_update_elem)(struct bpf_offloaded_map *, void *, void *, u64);
	int (*map_delete_elem)(struct bpf_offloaded_map *, void *);
};

struct bpf_offloaded_map {
	struct bpf_map map;
	struct net_device *netdev;
	const struct bpf_map_dev_ops *dev_ops;
	void *dev_priv;
	struct list_head offloads;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_prog_ops {
	int (*test_run)(struct bpf_prog *, const union bpf_attr *, union bpf_attr *);
};

struct bpf_offload_dev;

struct bpf_prog_offload {
	struct bpf_prog *prog;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	void *dev_priv;
	struct list_head offloads;
	bool dev_state;
	bool opt_failed;
	void *jited_image;
	u32 jited_len;
};

struct btf_func_model {
	u8 ret_size;
	u8 nr_args;
	u8 arg_size[12];
	u8 arg_flags[12];
};

struct bpf_tramp_image {
	void *image;
	struct bpf_ksym ksym;
	struct percpu_ref pcref;
	void *ip_after_call;
	void *ip_epilogue;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct ftrace_ops;

struct bpf_trampoline {
	struct hlist_node hlist;
	struct ftrace_ops *fops;
	struct mutex mutex;
	refcount_t refcnt;
	u32 flags;
	u64 key;
	struct {
		struct btf_func_model model;
		void *addr;
		bool ftrace_managed;
	} func;
	struct bpf_prog *extension_prog;
	struct hlist_head progs_hlist[3];
	int progs_cnt[3];
	struct bpf_tramp_image *cur_image;
	int: 32;
	u64 selector;
	struct module *mod;
	int: 32;
};

struct bpf_func_info_aux {
	u16 linkage;
	bool unreliable;
};

struct bpf_jit_poke_descriptor {
	void *tailcall_target;
	void *tailcall_bypass;
	void *bypass_addr;
	void *aux;
	union {
		struct {
			struct bpf_map *map;
			u32 key;
		} tail_call;
	};
	bool tailcall_target_stable;
	u8 adj_off;
	u16 reason;
	u32 insn_idx;
};

struct bpf_ctx_arg_aux {
	u32 offset;
	enum bpf_reg_type reg_type;
	u32 btf_id;
};

struct btf_mod_pair {
	struct btf *btf;
	struct module *module;
};

struct bpf_prog_stats {
	u64_stats_t cnt;
	u64_stats_t nsecs;
	u64_stats_t misses;
	struct u64_stats_sync syncp;
	int: 32;
};

struct sock_fprog_kern {
	u16 len;
	struct sock_filter *filter;
};

struct bpf_cgroup_storage;

struct bpf_prog_array_item {
	struct bpf_prog *prog;
	int: 32;
	union {
		struct bpf_cgroup_storage *cgroup_storage[2];
		u64 bpf_cookie;
	};
};

struct bpf_prog_array {
	struct callback_head rcu;
	struct bpf_prog_array_item items[0];
};

struct tc_stats {
	__u64 bytes;
	__u32 packets;
	__u32 drops;
	__u32 overlimits;
	__u32 bps;
	__u32 pps;
	__u32 qlen;
	__u32 backlog;
	int: 32;
};

struct tc_sizespec {
	unsigned char cell_log;
	unsigned char size_log;
	short int cell_align;
	int overhead;
	unsigned int linklayer;
	unsigned int mpu;
	unsigned int mtu;
	unsigned int tsize;
};

struct net_rate_estimator;

struct qdisc_skb_head {
	struct sk_buff *head;
	struct sk_buff *tail;
	__u32 qlen;
	spinlock_t lock;
};

struct gnet_stats_basic_sync {
	u64_stats_t bytes;
	u64_stats_t packets;
	struct u64_stats_sync syncp;
	int: 32;
	int: 32;
	int: 32;
};

struct gnet_stats_queue {
	__u32 qlen;
	__u32 backlog;
	__u32 drops;
	__u32 requeues;
	__u32 overlimits;
};

struct Qdisc_ops;

struct qdisc_size_table;

struct Qdisc {
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	unsigned int flags;
	u32 limit;
	const struct Qdisc_ops *ops;
	struct qdisc_size_table *stab;
	struct hlist_node hash;
	u32 handle;
	u32 parent;
	struct netdev_queue *dev_queue;
	struct net_rate_estimator *rate_est;
	struct gnet_stats_basic_sync *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	int pad;
	refcount_t refcnt;
	struct sk_buff_head gso_skb;
	struct qdisc_skb_head q;
	struct gnet_stats_basic_sync bstats;
	struct gnet_stats_queue qstats;
	long unsigned int state;
	long unsigned int state2;
	struct Qdisc *next_sched;
	struct sk_buff_head skb_bad_txq;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t busylock;
	spinlock_t seqlock;
	struct callback_head rcu;
	netdevice_tracker dev_tracker;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long int privdata[0];
};

struct tcf_proto;

struct tcf_block;

struct mini_Qdisc {
	struct tcf_proto *filter_list;
	struct tcf_block *block;
	struct gnet_stats_basic_sync *cpu_bstats;
	struct gnet_stats_queue *cpu_qstats;
	long unsigned int rcu_state;
};

struct tcmsg {
	unsigned char tcm_family;
	unsigned char tcm__pad1;
	short unsigned int tcm__pad2;
	int tcm_ifindex;
	__u32 tcm_handle;
	__u32 tcm_parent;
	__u32 tcm_info;
};

struct gnet_dump {
	spinlock_t *lock;
	struct sk_buff *skb;
	struct nlattr *tail;
	int compat_tc_stats;
	int compat_xstats;
	int padattr;
	void *xstats;
	int xstats_len;
	struct tc_stats tc_stats;
};

enum flow_action_hw_stats_bit {
	FLOW_ACTION_HW_STATS_IMMEDIATE_BIT = 0,
	FLOW_ACTION_HW_STATS_DELAYED_BIT = 1,
	FLOW_ACTION_HW_STATS_DISABLED_BIT = 2,
	FLOW_ACTION_HW_STATS_NUM_BITS = 3,
};

struct flow_block {
	struct list_head cb_list;
};

typedef int flow_setup_cb_t(enum tc_setup_type, void *, void *);

struct qdisc_size_table {
	struct callback_head rcu;
	struct list_head list;
	struct tc_sizespec szopts;
	int refcnt;
	u16 data[0];
};

struct Qdisc_class_ops;

struct Qdisc_ops {
	struct Qdisc_ops *next;
	const struct Qdisc_class_ops *cl_ops;
	char id[16];
	int priv_size;
	unsigned int static_flags;
	int (*enqueue)(struct sk_buff *, struct Qdisc *, struct sk_buff **);
	struct sk_buff * (*dequeue)(struct Qdisc *);
	struct sk_buff * (*peek)(struct Qdisc *);
	int (*init)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*reset)(struct Qdisc *);
	void (*destroy)(struct Qdisc *);
	int (*change)(struct Qdisc *, struct nlattr *, struct netlink_ext_ack *);
	void (*attach)(struct Qdisc *);
	int (*change_tx_queue_len)(struct Qdisc *, unsigned int);
	void (*change_real_num_tx)(struct Qdisc *, unsigned int);
	int (*dump)(struct Qdisc *, struct sk_buff *);
	int (*dump_stats)(struct Qdisc *, struct gnet_dump *);
	void (*ingress_block_set)(struct Qdisc *, u32);
	void (*egress_block_set)(struct Qdisc *, u32);
	u32 (*ingress_block_get)(struct Qdisc *);
	u32 (*egress_block_get)(struct Qdisc *);
	struct module *owner;
};

struct qdisc_walker;

struct Qdisc_class_ops {
	unsigned int flags;
	struct netdev_queue * (*select_queue)(struct Qdisc *, struct tcmsg *);
	int (*graft)(struct Qdisc *, long unsigned int, struct Qdisc *, struct Qdisc **, struct netlink_ext_ack *);
	struct Qdisc * (*leaf)(struct Qdisc *, long unsigned int);
	void (*qlen_notify)(struct Qdisc *, long unsigned int);
	long unsigned int (*find)(struct Qdisc *, u32);
	int (*change)(struct Qdisc *, u32, u32, struct nlattr **, long unsigned int *, struct netlink_ext_ack *);
	int (*delete)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	void (*walk)(struct Qdisc *, struct qdisc_walker *);
	struct tcf_block * (*tcf_block)(struct Qdisc *, long unsigned int, struct netlink_ext_ack *);
	long unsigned int (*bind_tcf)(struct Qdisc *, long unsigned int, u32);
	void (*unbind_tcf)(struct Qdisc *, long unsigned int);
	int (*dump)(struct Qdisc *, long unsigned int, struct sk_buff *, struct tcmsg *);
	int (*dump_stats)(struct Qdisc *, long unsigned int, struct gnet_dump *);
};

struct tcf_chain;

struct tcf_block {
	struct mutex lock;
	struct list_head chain_list;
	u32 index;
	u32 classid;
	refcount_t refcnt;
	struct net *net;
	struct Qdisc *q;
	struct rw_semaphore cb_lock;
	struct flow_block flow_block;
	struct list_head owner_list;
	bool keep_dst;
	atomic_t offloadcnt;
	unsigned int nooffloaddevcnt;
	unsigned int lockeddevcnt;
	struct {
		struct tcf_chain *chain;
		struct list_head filter_chain_list;
	} chain0;
	struct callback_head rcu;
	struct hlist_head proto_destroy_ht[128];
	struct mutex proto_destroy_lock;
};

struct tcf_result;

struct tcf_proto_ops;

struct tcf_proto {
	struct tcf_proto *next;
	void *root;
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	__be16 protocol;
	u32 prio;
	void *data;
	const struct tcf_proto_ops *ops;
	struct tcf_chain *chain;
	spinlock_t lock;
	bool deleting;
	refcount_t refcnt;
	struct callback_head rcu;
	struct hlist_node destroy_ht_node;
};

struct tcf_result {
	union {
		struct {
			long unsigned int class;
			u32 classid;
		};
		const struct tcf_proto *goto_tp;
	};
};

struct tcf_walker;

struct tcf_proto_ops {
	struct list_head head;
	char kind[16];
	int (*classify)(struct sk_buff *, const struct tcf_proto *, struct tcf_result *);
	int (*init)(struct tcf_proto *);
	void (*destroy)(struct tcf_proto *, bool, struct netlink_ext_ack *);
	void * (*get)(struct tcf_proto *, u32);
	void (*put)(struct tcf_proto *, void *);
	int (*change)(struct net *, struct sk_buff *, struct tcf_proto *, long unsigned int, u32, struct nlattr **, void **, u32, struct netlink_ext_ack *);
	int (*delete)(struct tcf_proto *, void *, bool *, bool, struct netlink_ext_ack *);
	bool (*delete_empty)(struct tcf_proto *);
	void (*walk)(struct tcf_proto *, struct tcf_walker *, bool);
	int (*reoffload)(struct tcf_proto *, bool, flow_setup_cb_t *, void *, struct netlink_ext_ack *);
	void (*hw_add)(struct tcf_proto *, void *);
	void (*hw_del)(struct tcf_proto *, void *);
	void (*bind_class)(void *, u32, long unsigned int, void *, long unsigned int);
	void * (*tmplt_create)(struct net *, struct tcf_chain *, struct nlattr **, struct netlink_ext_ack *);
	void (*tmplt_destroy)(void *);
	int (*dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*terse_dump)(struct net *, struct tcf_proto *, void *, struct sk_buff *, struct tcmsg *, bool);
	int (*tmplt_dump)(struct sk_buff *, struct net *, void *);
	struct module *owner;
	int flags;
};

struct tcf_chain {
	struct mutex filter_chain_lock;
	struct tcf_proto *filter_chain;
	struct list_head list;
	struct tcf_block *block;
	u32 index;
	unsigned int refcnt;
	unsigned int action_refcnt;
	bool explicitly_created;
	bool flushing;
	const struct tcf_proto_ops *tmplt_ops;
	void *tmplt_priv;
	struct callback_head rcu;
};

struct bpf_binary_header {
	u32 size;
	int: 32;
	u8 image[0];
};

enum {
	BPF_R2_HI = 0,
	BPF_R2_LO = 1,
	BPF_R3_HI = 2,
	BPF_R3_LO = 3,
	BPF_R4_HI = 4,
	BPF_R4_LO = 5,
	BPF_R5_HI = 6,
	BPF_R5_LO = 7,
	BPF_R7_HI = 8,
	BPF_R7_LO = 9,
	BPF_R8_HI = 10,
	BPF_R8_LO = 11,
	BPF_R9_HI = 12,
	BPF_R9_LO = 13,
	BPF_FP_HI = 14,
	BPF_FP_LO = 15,
	BPF_TC_HI = 16,
	BPF_TC_LO = 17,
	BPF_AX_HI = 18,
	BPF_AX_LO = 19,
	BPF_JIT_SCRATCH_REGS = 20,
};

struct jit_ctx {
	const struct bpf_prog *prog;
	unsigned int idx;
	unsigned int prologue_bytes;
	unsigned int epilogue_offset;
	unsigned int cpu_architecture;
	u32 flags;
	u32 *offsets;
	u32 *target;
	u32 stack_size;
};

struct mxc_extra_irq {
	int (*set_irq_fiq)(unsigned int, unsigned int);
};

enum ethtool_link_mode_bit_indices {
	ETHTOOL_LINK_MODE_10baseT_Half_BIT = 0,
	ETHTOOL_LINK_MODE_10baseT_Full_BIT = 1,
	ETHTOOL_LINK_MODE_100baseT_Half_BIT = 2,
	ETHTOOL_LINK_MODE_100baseT_Full_BIT = 3,
	ETHTOOL_LINK_MODE_1000baseT_Half_BIT = 4,
	ETHTOOL_LINK_MODE_1000baseT_Full_BIT = 5,
	ETHTOOL_LINK_MODE_Autoneg_BIT = 6,
	ETHTOOL_LINK_MODE_TP_BIT = 7,
	ETHTOOL_LINK_MODE_AUI_BIT = 8,
	ETHTOOL_LINK_MODE_MII_BIT = 9,
	ETHTOOL_LINK_MODE_FIBRE_BIT = 10,
	ETHTOOL_LINK_MODE_BNC_BIT = 11,
	ETHTOOL_LINK_MODE_10000baseT_Full_BIT = 12,
	ETHTOOL_LINK_MODE_Pause_BIT = 13,
	ETHTOOL_LINK_MODE_Asym_Pause_BIT = 14,
	ETHTOOL_LINK_MODE_2500baseX_Full_BIT = 15,
	ETHTOOL_LINK_MODE_Backplane_BIT = 16,
	ETHTOOL_LINK_MODE_1000baseKX_Full_BIT = 17,
	ETHTOOL_LINK_MODE_10000baseKX4_Full_BIT = 18,
	ETHTOOL_LINK_MODE_10000baseKR_Full_BIT = 19,
	ETHTOOL_LINK_MODE_10000baseR_FEC_BIT = 20,
	ETHTOOL_LINK_MODE_20000baseMLD2_Full_BIT = 21,
	ETHTOOL_LINK_MODE_20000baseKR2_Full_BIT = 22,
	ETHTOOL_LINK_MODE_40000baseKR4_Full_BIT = 23,
	ETHTOOL_LINK_MODE_40000baseCR4_Full_BIT = 24,
	ETHTOOL_LINK_MODE_40000baseSR4_Full_BIT = 25,
	ETHTOOL_LINK_MODE_40000baseLR4_Full_BIT = 26,
	ETHTOOL_LINK_MODE_56000baseKR4_Full_BIT = 27,
	ETHTOOL_LINK_MODE_56000baseCR4_Full_BIT = 28,
	ETHTOOL_LINK_MODE_56000baseSR4_Full_BIT = 29,
	ETHTOOL_LINK_MODE_56000baseLR4_Full_BIT = 30,
	ETHTOOL_LINK_MODE_25000baseCR_Full_BIT = 31,
	ETHTOOL_LINK_MODE_25000baseKR_Full_BIT = 32,
	ETHTOOL_LINK_MODE_25000baseSR_Full_BIT = 33,
	ETHTOOL_LINK_MODE_50000baseCR2_Full_BIT = 34,
	ETHTOOL_LINK_MODE_50000baseKR2_Full_BIT = 35,
	ETHTOOL_LINK_MODE_100000baseKR4_Full_BIT = 36,
	ETHTOOL_LINK_MODE_100000baseSR4_Full_BIT = 37,
	ETHTOOL_LINK_MODE_100000baseCR4_Full_BIT = 38,
	ETHTOOL_LINK_MODE_100000baseLR4_ER4_Full_BIT = 39,
	ETHTOOL_LINK_MODE_50000baseSR2_Full_BIT = 40,
	ETHTOOL_LINK_MODE_1000baseX_Full_BIT = 41,
	ETHTOOL_LINK_MODE_10000baseCR_Full_BIT = 42,
	ETHTOOL_LINK_MODE_10000baseSR_Full_BIT = 43,
	ETHTOOL_LINK_MODE_10000baseLR_Full_BIT = 44,
	ETHTOOL_LINK_MODE_10000baseLRM_Full_BIT = 45,
	ETHTOOL_LINK_MODE_10000baseER_Full_BIT = 46,
	ETHTOOL_LINK_MODE_2500baseT_Full_BIT = 47,
	ETHTOOL_LINK_MODE_5000baseT_Full_BIT = 48,
	ETHTOOL_LINK_MODE_FEC_NONE_BIT = 49,
	ETHTOOL_LINK_MODE_FEC_RS_BIT = 50,
	ETHTOOL_LINK_MODE_FEC_BASER_BIT = 51,
	ETHTOOL_LINK_MODE_50000baseKR_Full_BIT = 52,
	ETHTOOL_LINK_MODE_50000baseSR_Full_BIT = 53,
	ETHTOOL_LINK_MODE_50000baseCR_Full_BIT = 54,
	ETHTOOL_LINK_MODE_50000baseLR_ER_FR_Full_BIT = 55,
	ETHTOOL_LINK_MODE_50000baseDR_Full_BIT = 56,
	ETHTOOL_LINK_MODE_100000baseKR2_Full_BIT = 57,
	ETHTOOL_LINK_MODE_100000baseSR2_Full_BIT = 58,
	ETHTOOL_LINK_MODE_100000baseCR2_Full_BIT = 59,
	ETHTOOL_LINK_MODE_100000baseLR2_ER2_FR2_Full_BIT = 60,
	ETHTOOL_LINK_MODE_100000baseDR2_Full_BIT = 61,
	ETHTOOL_LINK_MODE_200000baseKR4_Full_BIT = 62,
	ETHTOOL_LINK_MODE_200000baseSR4_Full_BIT = 63,
	ETHTOOL_LINK_MODE_200000baseLR4_ER4_FR4_Full_BIT = 64,
	ETHTOOL_LINK_MODE_200000baseDR4_Full_BIT = 65,
	ETHTOOL_LINK_MODE_200000baseCR4_Full_BIT = 66,
	ETHTOOL_LINK_MODE_100baseT1_Full_BIT = 67,
	ETHTOOL_LINK_MODE_1000baseT1_Full_BIT = 68,
	ETHTOOL_LINK_MODE_400000baseKR8_Full_BIT = 69,
	ETHTOOL_LINK_MODE_400000baseSR8_Full_BIT = 70,
	ETHTOOL_LINK_MODE_400000baseLR8_ER8_FR8_Full_BIT = 71,
	ETHTOOL_LINK_MODE_400000baseDR8_Full_BIT = 72,
	ETHTOOL_LINK_MODE_400000baseCR8_Full_BIT = 73,
	ETHTOOL_LINK_MODE_FEC_LLRS_BIT = 74,
	ETHTOOL_LINK_MODE_100000baseKR_Full_BIT = 75,
	ETHTOOL_LINK_MODE_100000baseSR_Full_BIT = 76,
	ETHTOOL_LINK_MODE_100000baseLR_ER_FR_Full_BIT = 77,
	ETHTOOL_LINK_MODE_100000baseCR_Full_BIT = 78,
	ETHTOOL_LINK_MODE_100000baseDR_Full_BIT = 79,
	ETHTOOL_LINK_MODE_200000baseKR2_Full_BIT = 80,
	ETHTOOL_LINK_MODE_200000baseSR2_Full_BIT = 81,
	ETHTOOL_LINK_MODE_200000baseLR2_ER2_FR2_Full_BIT = 82,
	ETHTOOL_LINK_MODE_200000baseDR2_Full_BIT = 83,
	ETHTOOL_LINK_MODE_200000baseCR2_Full_BIT = 84,
	ETHTOOL_LINK_MODE_400000baseKR4_Full_BIT = 85,
	ETHTOOL_LINK_MODE_400000baseSR4_Full_BIT = 86,
	ETHTOOL_LINK_MODE_400000baseLR4_ER4_FR4_Full_BIT = 87,
	ETHTOOL_LINK_MODE_400000baseDR4_Full_BIT = 88,
	ETHTOOL_LINK_MODE_400000baseCR4_Full_BIT = 89,
	ETHTOOL_LINK_MODE_100baseFX_Half_BIT = 90,
	ETHTOOL_LINK_MODE_100baseFX_Full_BIT = 91,
	ETHTOOL_LINK_MODE_10baseT1L_Full_BIT = 92,
	__ETHTOOL_LINK_MODE_MASK_NBITS = 93,
};

enum mxc_cpu_pwr_mode {
	WAIT_CLOCKED = 0,
	WAIT_UNCLOCKED = 1,
	WAIT_UNCLOCKED_POWER_OFF = 2,
	STOP_POWER_ON = 3,
	STOP_POWER_OFF = 4,
};

typedef void (*exitcall_t)();

typedef int suspend_state_t;

enum bus_freq_mode {
	BUS_FREQ_HIGH = 0,
	BUS_FREQ_MED = 1,
	BUS_FREQ_AUDIO = 2,
	BUS_FREQ_LOW = 3,
	BUS_FREQ_ULTRA_LOW = 4,
};

struct linear_range {
	unsigned int min;
	unsigned int min_sel;
	unsigned int max_sel;
	unsigned int step;
};

struct ww_acquire_ctx;

struct ww_mutex {
	struct mutex base;
	struct ww_acquire_ctx *ctx;
};

struct ww_acquire_ctx {
	struct task_struct *task;
	long unsigned int stamp;
	unsigned int acquired;
	short unsigned int wounded;
	short unsigned int is_wait_die;
};

struct regulator_dev;

struct regulator_ops {
	int (*list_voltage)(struct regulator_dev *, unsigned int);
	int (*set_voltage)(struct regulator_dev *, int, int, unsigned int *);
	int (*map_voltage)(struct regulator_dev *, int, int);
	int (*set_voltage_sel)(struct regulator_dev *, unsigned int);
	int (*get_voltage)(struct regulator_dev *);
	int (*get_voltage_sel)(struct regulator_dev *);
	int (*set_current_limit)(struct regulator_dev *, int, int);
	int (*get_current_limit)(struct regulator_dev *);
	int (*set_input_current_limit)(struct regulator_dev *, int);
	int (*set_over_current_protection)(struct regulator_dev *, int, int, bool);
	int (*set_over_voltage_protection)(struct regulator_dev *, int, int, bool);
	int (*set_under_voltage_protection)(struct regulator_dev *, int, int, bool);
	int (*set_thermal_protection)(struct regulator_dev *, int, int, bool);
	int (*set_active_discharge)(struct regulator_dev *, bool);
	int (*enable)(struct regulator_dev *);
	int (*disable)(struct regulator_dev *);
	int (*is_enabled)(struct regulator_dev *);
	int (*set_mode)(struct regulator_dev *, unsigned int);
	unsigned int (*get_mode)(struct regulator_dev *);
	int (*get_error_flags)(struct regulator_dev *, unsigned int *);
	int (*enable_time)(struct regulator_dev *);
	int (*set_ramp_delay)(struct regulator_dev *, int);
	int (*set_voltage_time)(struct regulator_dev *, int, int);
	int (*set_voltage_time_sel)(struct regulator_dev *, unsigned int, unsigned int);
	int (*set_soft_start)(struct regulator_dev *);
	int (*get_status)(struct regulator_dev *);
	unsigned int (*get_optimum_mode)(struct regulator_dev *, int, int, int);
	int (*set_load)(struct regulator_dev *, int);
	int (*set_bypass)(struct regulator_dev *, bool);
	int (*get_bypass)(struct regulator_dev *, bool *);
	int (*set_suspend_voltage)(struct regulator_dev *, int);
	int (*set_suspend_enable)(struct regulator_dev *);
	int (*set_suspend_disable)(struct regulator_dev *);
	int (*set_suspend_mode)(struct regulator_dev *, unsigned int);
	int (*resume)(struct regulator_dev *);
	int (*set_pull_down)(struct regulator_dev *);
};

struct regulator_coupler;

struct coupling_desc {
	struct regulator_dev **coupled_rdevs;
	struct regulator_coupler *coupler;
	int n_resolved;
	int n_coupled;
};

struct regmap;

struct regulator_desc;

struct regulation_constraints;

struct regulator;

struct regulator_enable_gpio;

struct regulator_dev {
	const struct regulator_desc *desc;
	int exclusive;
	u32 use_count;
	u32 open_count;
	u32 bypass_count;
	struct list_head list;
	struct list_head consumer_list;
	struct coupling_desc coupling_desc;
	struct blocking_notifier_head notifier;
	struct ww_mutex mutex;
	struct task_struct *mutex_owner;
	int ref_cnt;
	struct module *owner;
	int: 32;
	struct device dev;
	struct regulation_constraints *constraints;
	struct regulator *supply;
	const char *supply_name;
	struct regmap *regmap;
	struct delayed_work disable_work;
	void *reg_data;
	struct dentry *debugfs;
	struct regulator_enable_gpio *ena_pin;
	unsigned int ena_gpio_state: 1;
	unsigned int is_switch: 1;
	int: 30;
	int: 32;
	ktime_t last_off;
	int cached_err;
	bool use_cached_err;
	spinlock_t err_lock;
	int: 32;
};

enum regulator_type {
	REGULATOR_VOLTAGE = 0,
	REGULATOR_CURRENT = 1,
};

struct regulator_config;

struct regulator_desc {
	const char *name;
	const char *supply_name;
	const char *of_match;
	bool of_match_full_name;
	const char *regulators_node;
	int (*of_parse_cb)(struct device_node *, const struct regulator_desc *, struct regulator_config *);
	int id;
	unsigned int continuous_voltage_range: 1;
	unsigned int n_voltages;
	unsigned int n_current_limits;
	const struct regulator_ops *ops;
	int irq;
	enum regulator_type type;
	struct module *owner;
	unsigned int min_uV;
	unsigned int uV_step;
	unsigned int linear_min_sel;
	int fixed_uV;
	unsigned int ramp_delay;
	int min_dropout_uV;
	const struct linear_range *linear_ranges;
	const unsigned int *linear_range_selectors;
	int n_linear_ranges;
	const unsigned int *volt_table;
	const unsigned int *curr_table;
	unsigned int vsel_range_reg;
	unsigned int vsel_range_mask;
	unsigned int vsel_reg;
	unsigned int vsel_mask;
	unsigned int vsel_step;
	unsigned int csel_reg;
	unsigned int csel_mask;
	unsigned int apply_reg;
	unsigned int apply_bit;
	unsigned int enable_reg;
	unsigned int enable_mask;
	unsigned int enable_val;
	unsigned int disable_val;
	bool enable_is_inverted;
	unsigned int bypass_reg;
	unsigned int bypass_mask;
	unsigned int bypass_val_on;
	unsigned int bypass_val_off;
	unsigned int active_discharge_on;
	unsigned int active_discharge_off;
	unsigned int active_discharge_mask;
	unsigned int active_discharge_reg;
	unsigned int soft_start_reg;
	unsigned int soft_start_mask;
	unsigned int soft_start_val_on;
	unsigned int pull_down_reg;
	unsigned int pull_down_mask;
	unsigned int pull_down_val_on;
	unsigned int ramp_reg;
	unsigned int ramp_mask;
	const unsigned int *ramp_delay_table;
	unsigned int n_ramp_values;
	unsigned int enable_time;
	unsigned int off_on_delay;
	unsigned int poll_enabled_time;
	unsigned int (*of_map_mode)(unsigned int);
};

struct regulator_init_data;

struct gpio_desc;

struct regulator_config {
	struct device *dev;
	const struct regulator_init_data *init_data;
	void *driver_data;
	struct device_node *of_node;
	struct regmap *regmap;
	struct gpio_desc *ena_gpiod;
};

struct regulator_state {
	int uV;
	int min_uV;
	int max_uV;
	unsigned int mode;
	int enabled;
	bool changeable;
};

struct notification_limit {
	int prot;
	int err;
	int warn;
};

struct regulation_constraints {
	const char *name;
	int min_uV;
	int max_uV;
	int uV_offset;
	int min_uA;
	int max_uA;
	int ilim_uA;
	int system_load;
	u32 *max_spread;
	int max_uV_step;
	unsigned int valid_modes_mask;
	unsigned int valid_ops_mask;
	int input_uV;
	struct regulator_state state_disk;
	struct regulator_state state_mem;
	struct regulator_state state_standby;
	struct notification_limit over_curr_limits;
	struct notification_limit over_voltage_limits;
	struct notification_limit under_voltage_limits;
	struct notification_limit temp_limits;
	suspend_state_t initial_state;
	unsigned int initial_mode;
	unsigned int ramp_delay;
	unsigned int settling_time;
	unsigned int settling_time_up;
	unsigned int settling_time_down;
	unsigned int enable_time;
	unsigned int active_discharge;
	unsigned int always_on: 1;
	unsigned int boot_on: 1;
	unsigned int apply_uV: 1;
	unsigned int ramp_disable: 1;
	unsigned int soft_start: 1;
	unsigned int pull_down: 1;
	unsigned int over_current_protection: 1;
	unsigned int over_current_detection: 1;
	unsigned int over_voltage_detection: 1;
	unsigned int under_voltage_detection: 1;
	unsigned int over_temp_detection: 1;
};

struct regulator_consumer_supply;

struct regulator_init_data {
	const char *supply_regulator;
	struct regulation_constraints constraints;
	int num_consumer_supplies;
	struct regulator_consumer_supply *consumer_supplies;
	int (*regulator_init)(void *);
	void *driver_data;
};

struct regulator_consumer_supply {
	const char *dev_name;
	const char *supply;
};

struct imx6_cpuidle_pm_info {
	u32 pm_info_size;
	u32 ttbr;
	void *mmdc_base;
	void *iomuxc_base;
	void *ccm_base;
	void *l2_base;
	void *anatop_base;
	u32 mmdc_io_num;
	u32 mmdc_io_val[38];
};

struct imx6_pm_base {
	phys_addr_t pbase;
	void *vbase;
};

struct imx6_cpuidle_pm_info___2 {
	phys_addr_t pbase;
	phys_addr_t resume_addr;
	u32 pm_info_size;
	u32 ttbr;
	struct imx6_pm_base mmdc_base;
	struct imx6_pm_base iomuxc_base;
	struct imx6_pm_base ccm_base;
	struct imx6_pm_base gpc_base;
	struct imx6_pm_base anatop_base;
	struct imx6_pm_base src_base;
	struct imx6_pm_base l2_base;
	u32 saved_diagnostic;
	u32 mmdc_io_num;
	u32 mmdc_io_val[28];
};

struct imx6_cpuidle_pm_info___3 {
	phys_addr_t pbase;
	phys_addr_t resume_addr;
	u32 pm_info_size;
	u32 ttbr;
	struct imx6_pm_base mmdc_base;
	struct imx6_pm_base iomuxc_base;
	struct imx6_pm_base ccm_base;
	struct imx6_pm_base gpc_base;
	struct imx6_pm_base l2_base;
	struct imx6_pm_base anatop_base;
	struct imx6_pm_base src_base;
	struct imx6_pm_base sema4_base;
	u32 saved_diagnostic;
	u32 mmdc_io_num;
	u32 mmdc_io_val[38];
};

struct imx6_cpuidle_pm_info___4 {
	phys_addr_t pbase;
	phys_addr_t resume_addr;
	u32 pm_info_size;
	u32 ttbr;
	struct imx6_pm_base mmdc_base;
	struct imx6_pm_base iomuxc_base;
	struct imx6_pm_base ccm_base;
	struct imx6_pm_base gpc_base;
	struct imx6_pm_base anatop_base;
	struct imx6_pm_base src_base;
	u32 mmdc_io_num;
	u32 mmdc_io_val[28];
	int: 32;
};

enum ulp_cpu_pwr_mode {
	ULP_PM_HSRUN = 0,
	ULP_PM_RUN = 1,
	ULP_PM_WAIT = 2,
	ULP_PM_STOP = 3,
	ULP_PM_VLPS = 4,
	ULP_PM_VLLS = 5,
};

enum {
	WORK_STRUCT_PENDING_BIT = 0,
	WORK_STRUCT_INACTIVE_BIT = 1,
	WORK_STRUCT_PWQ_BIT = 2,
	WORK_STRUCT_LINKED_BIT = 3,
	WORK_STRUCT_COLOR_SHIFT = 4,
	WORK_STRUCT_COLOR_BITS = 4,
	WORK_STRUCT_PENDING = 1,
	WORK_STRUCT_INACTIVE = 2,
	WORK_STRUCT_PWQ = 4,
	WORK_STRUCT_LINKED = 8,
	WORK_STRUCT_STATIC = 0,
	WORK_NR_COLORS = 16,
	WORK_CPU_UNBOUND = 4,
	WORK_STRUCT_FLAG_BITS = 8,
	WORK_OFFQ_FLAG_BASE = 4,
	__WORK_OFFQ_CANCELING = 4,
	WORK_OFFQ_CANCELING = 16,
	WORK_OFFQ_FLAG_BITS = 1,
	WORK_OFFQ_POOL_SHIFT = 5,
	WORK_OFFQ_LEFT = 27,
	WORK_OFFQ_POOL_BITS = 27,
	WORK_OFFQ_POOL_NONE = 134217727,
	WORK_STRUCT_FLAG_MASK = 255,
	WORK_STRUCT_WQ_DATA_MASK = 4294967040,
	WORK_STRUCT_NO_POOL = 4294967264,
	WORK_BUSY_PENDING = 1,
	WORK_BUSY_RUNNING = 2,
	WORKER_DESC_LEN = 24,
};

struct imx_rpmsg_head {
	u8 cate;
	u8 major;
	u8 minor;
	u8 type;
	u8 cmd;
	u8 reserved[5];
};

struct rpmsg_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct pm_qos_request {
	struct plist_node node;
	struct pm_qos_constraints *qos;
};

struct rpmsg_endpoint;

struct rpmsg_device_ops;

struct rpmsg_device {
	struct device dev;
	struct rpmsg_device_id id;
	const char *driver_override;
	u32 src;
	u32 dst;
	struct rpmsg_endpoint *ept;
	bool announce;
	bool little_endian;
	const struct rpmsg_device_ops *ops;
	int: 32;
};

typedef int (*rpmsg_rx_cb_t)(struct rpmsg_device *, void *, int, void *, u32);

struct rpmsg_endpoint_ops;

struct rpmsg_endpoint {
	struct rpmsg_device *rpdev;
	struct kref refcount;
	rpmsg_rx_cb_t cb;
	struct mutex cb_lock;
	u32 addr;
	void *priv;
	const struct rpmsg_endpoint_ops *ops;
};

struct rpmsg_channel_info;

struct rpmsg_device_ops {
	struct rpmsg_device * (*create_channel)(struct rpmsg_device *, struct rpmsg_channel_info *);
	int (*release_channel)(struct rpmsg_device *, struct rpmsg_channel_info *);
	struct rpmsg_endpoint * (*create_ept)(struct rpmsg_device *, rpmsg_rx_cb_t, void *, struct rpmsg_channel_info);
	int (*announce_create)(struct rpmsg_device *);
	int (*announce_destroy)(struct rpmsg_device *);
};

typedef struct poll_table_struct poll_table;

struct rpmsg_endpoint_ops {
	void (*destroy_ept)(struct rpmsg_endpoint *);
	int (*send)(struct rpmsg_endpoint *, void *, int);
	int (*sendto)(struct rpmsg_endpoint *, void *, int, u32);
	int (*send_offchannel)(struct rpmsg_endpoint *, u32, u32, void *, int);
	int (*trysend)(struct rpmsg_endpoint *, void *, int);
	int (*trysendto)(struct rpmsg_endpoint *, void *, int, u32);
	int (*trysend_offchannel)(struct rpmsg_endpoint *, u32, u32, void *, int);
	__poll_t (*poll)(struct rpmsg_endpoint *, struct file *, poll_table *);
	ssize_t (*get_mtu)(struct rpmsg_endpoint *);
};

struct rpmsg_driver {
	struct device_driver drv;
	const struct rpmsg_device_id *id_table;
	int (*probe)(struct rpmsg_device *);
	void (*remove)(struct rpmsg_device *);
	int (*callback)(struct rpmsg_device *, void *, int, void *, u32);
};

enum pm_rpmsg_cmd {
	PM_RPMSG_MODE = 0,
	PM_RPMSG_HEART_BEAT = 1,
	PM_RPMSG_HEART_BEAT_OFF = 2,
};

enum pm_rpmsg_power_mode {
	PM_RPMSG_HSRUN = 0,
	PM_RPMSG_RUN = 1,
	PM_RPMSG_VLPR = 2,
	PM_RPMSG_WAIT = 3,
	PM_RPMSG_VLPS = 4,
	PM_RPMSG_VLLS = 5,
	PM_RPMSG_REBOOT = 6,
	PM_RPMSG_SHUTDOWN = 7,
};

struct pm_rpmsg_data;

struct pm_rpmsg_info {
	struct rpmsg_device *rpdev;
	struct device *dev;
	struct pm_rpmsg_data *msg;
	struct pm_qos_request pm_qos_req;
	struct notifier_block restart_handler;
	struct completion cmd_complete;
	bool first_flag;
	struct mutex lock;
};

struct pm_rpmsg_data {
	struct imx_rpmsg_head header;
	u8 data;
};

struct imx7_pm_base {
	phys_addr_t pbase;
	void *vbase;
};

struct imx7_cpuidle_pm_info {
	phys_addr_t vbase;
	phys_addr_t pbase;
	phys_addr_t resume_addr;
	u32 pm_info_size;
	u32 ttbr;
	u32 num_online_cpus;
	u32 num_lpi_cpus;
	atomic_t val;
	atomic_t flag0;
	atomic_t flag1;
	struct imx7_pm_base ddrc_base;
	struct imx7_pm_base ccm_base;
	struct imx7_pm_base anatop_base;
	struct imx7_pm_base src_base;
	struct imx7_pm_base iomuxc_gpr_base;
	struct imx7_pm_base gpc_base;
	struct imx7_pm_base gic_dist_base;
};

typedef int (*of_init_fn_2)(struct device_node *, struct device_node *);

typedef int (*of_irq_init_cb_t)(struct device_node *, struct device_node *);

struct pm_domain_data {
	struct list_head list_node;
	struct device *dev;
};

enum imx_gpc_slot {
	CORE0_A7 = 0,
	CORE1_A7 = 1,
	SCU_A7 = 2,
	FAST_MEGA_MIX = 3,
	MIPI_PHY = 4,
	PCIE_PHY = 5,
	USB_OTG1_PHY = 6,
	USB_OTG2_PHY = 7,
	USB_HSIC_PHY = 8,
	CORE0_M4 = 9,
};

enum hrtimer_mode {
	HRTIMER_MODE_ABS = 0,
	HRTIMER_MODE_REL = 1,
	HRTIMER_MODE_PINNED = 2,
	HRTIMER_MODE_SOFT = 4,
	HRTIMER_MODE_HARD = 8,
	HRTIMER_MODE_ABS_PINNED = 2,
	HRTIMER_MODE_REL_PINNED = 3,
	HRTIMER_MODE_ABS_SOFT = 4,
	HRTIMER_MODE_REL_SOFT = 5,
	HRTIMER_MODE_ABS_PINNED_SOFT = 6,
	HRTIMER_MODE_REL_PINNED_SOFT = 7,
	HRTIMER_MODE_ABS_HARD = 8,
	HRTIMER_MODE_REL_HARD = 9,
	HRTIMER_MODE_ABS_PINNED_HARD = 10,
	HRTIMER_MODE_REL_PINNED_HARD = 11,
};

typedef unsigned int xa_mark_t;

enum xa_lock_type {
	XA_LOCK_IRQ = 1,
	XA_LOCK_BH = 2,
};

struct ida {
	struct xarray xa;
};

struct fsl_mmdc_devtype_data {
	unsigned int flags;
};

struct mmdc_pmu {
	struct pmu pmu;
	void *mmdc_base;
	cpumask_t cpu;
	struct hrtimer hrtimer;
	unsigned int active_events;
	struct device *dev;
	struct perf_event *mmdc_events[6];
	struct hlist_node node;
	const struct fsl_mmdc_devtype_data *devtype_data;
	struct clk *mmdc_ipg_clk;
};

struct of_phandle_args {
	struct device_node *np;
	int args_count;
	uint32_t args[16];
};

struct reset_controller_dev;

struct reset_control_ops {
	int (*reset)(struct reset_controller_dev *, long unsigned int);
	int (*assert)(struct reset_controller_dev *, long unsigned int);
	int (*deassert)(struct reset_controller_dev *, long unsigned int);
	int (*status)(struct reset_controller_dev *, long unsigned int);
};

struct reset_controller_dev {
	const struct reset_control_ops *ops;
	struct module *owner;
	struct list_head list;
	struct list_head reset_control_head;
	struct device *dev;
	struct device_node *of_node;
	int of_reset_n_cells;
	int (*of_xlate)(struct reset_controller_dev *, const struct of_phandle_args *);
	unsigned int nr_resets;
};

enum dev_prop_type {
	DEV_PROP_U8 = 0,
	DEV_PROP_U16 = 1,
	DEV_PROP_U32 = 2,
	DEV_PROP_U64 = 3,
	DEV_PROP_STRING = 4,
	DEV_PROP_REF = 5,
};

struct property_entry {
	const char *name;
	size_t length;
	bool is_inline;
	enum dev_prop_type type;
	union {
		const void *pointer;
		union {
			u8 u8_data[8];
			u16 u16_data[4];
			u32 u32_data[2];
			u64 u64_data[1];
			const char *str[2];
		} value;
	};
};

struct platform_device_info {
	struct device *parent;
	struct fwnode_handle *fwnode;
	bool of_node_reused;
	const char *name;
	int id;
	const struct resource *res;
	unsigned int num_res;
	const void *data;
	size_t size_data;
	int: 32;
	u64 dma_mask;
	const struct property_entry *properties;
	int: 32;
};

struct ethtool_wolinfo {
	__u32 cmd;
	__u32 supported;
	__u32 wolopts;
	__u8 sopass[6];
};

struct ethtool_tunable {
	__u32 cmd;
	__u32 id;
	__u32 type_id;
	__u32 len;
	void *data[0];
};

struct ethtool_eeprom {
	__u32 cmd;
	__u32 magic;
	__u32 offset;
	__u32 len;
	__u8 data[0];
};

struct ethtool_modinfo {
	__u32 cmd;
	__u32 type;
	__u32 eeprom_len;
	__u32 reserved[8];
};

struct ethtool_stats {
	__u32 cmd;
	__u32 n_stats;
	__u64 data[0];
};

struct ethtool_ts_info {
	__u32 cmd;
	__u32 so_timestamping;
	__s32 phc_index;
	__u32 tx_types;
	__u32 tx_reserved[3];
	__u32 rx_filters;
	__u32 rx_reserved[3];
};

struct reset_control;

struct mii_bus;

struct mdio_device {
	struct device dev;
	struct mii_bus *bus;
	char modalias[32];
	int (*bus_match)(struct device *, struct device_driver *);
	void (*device_free)(struct mdio_device *);
	void (*device_remove)(struct mdio_device *);
	int addr;
	int flags;
	struct gpio_desc *reset_gpio;
	struct reset_control *reset_ctrl;
	unsigned int reset_assert_delay;
	unsigned int reset_deassert_delay;
};

struct phy_c45_device_ids {
	u32 devices_in_package;
	u32 mmds_present;
	u32 device_ids[32];
};

enum phy_state {
	PHY_DOWN = 0,
	PHY_READY = 1,
	PHY_HALTED = 2,
	PHY_UP = 3,
	PHY_RUNNING = 4,
	PHY_NOLINK = 5,
	PHY_CABLETEST = 6,
};

typedef enum {
	PHY_INTERFACE_MODE_NA = 0,
	PHY_INTERFACE_MODE_INTERNAL = 1,
	PHY_INTERFACE_MODE_MII = 2,
	PHY_INTERFACE_MODE_GMII = 3,
	PHY_INTERFACE_MODE_SGMII = 4,
	PHY_INTERFACE_MODE_TBI = 5,
	PHY_INTERFACE_MODE_REVMII = 6,
	PHY_INTERFACE_MODE_RMII = 7,
	PHY_INTERFACE_MODE_REVRMII = 8,
	PHY_INTERFACE_MODE_RGMII = 9,
	PHY_INTERFACE_MODE_RGMII_ID = 10,
	PHY_INTERFACE_MODE_RGMII_RXID = 11,
	PHY_INTERFACE_MODE_RGMII_TXID = 12,
	PHY_INTERFACE_MODE_RTBI = 13,
	PHY_INTERFACE_MODE_SMII = 14,
	PHY_INTERFACE_MODE_XGMII = 15,
	PHY_INTERFACE_MODE_XLGMII = 16,
	PHY_INTERFACE_MODE_MOCA = 17,
	PHY_INTERFACE_MODE_QSGMII = 18,
	PHY_INTERFACE_MODE_TRGMII = 19,
	PHY_INTERFACE_MODE_100BASEX = 20,
	PHY_INTERFACE_MODE_1000BASEX = 21,
	PHY_INTERFACE_MODE_2500BASEX = 22,
	PHY_INTERFACE_MODE_5GBASER = 23,
	PHY_INTERFACE_MODE_RXAUI = 24,
	PHY_INTERFACE_MODE_XAUI = 25,
	PHY_INTERFACE_MODE_10GBASER = 26,
	PHY_INTERFACE_MODE_25GBASER = 27,
	PHY_INTERFACE_MODE_USXGMII = 28,
	PHY_INTERFACE_MODE_10GKR = 29,
	PHY_INTERFACE_MODE_QUSGMII = 30,
	PHY_INTERFACE_MODE_1000BASEKX = 31,
	PHY_INTERFACE_MODE_2500SGMII = 32,
	PHY_INTERFACE_MODE_MAX = 33,
} phy_interface_t;

struct pse_control;

struct phy_driver;

struct phy_package_shared;

struct phylink;

struct mii_timestamper;

struct phy_device {
	struct mdio_device mdio;
	struct phy_driver *drv;
	u32 phy_id;
	struct phy_c45_device_ids c45_ids;
	unsigned int is_c45: 1;
	unsigned int is_internal: 1;
	unsigned int is_pseudo_fixed_link: 1;
	unsigned int is_gigabit_capable: 1;
	unsigned int has_fixups: 1;
	unsigned int suspended: 1;
	unsigned int suspended_by_mdio_bus: 1;
	unsigned int sysfs_links: 1;
	unsigned int loopback_enabled: 1;
	unsigned int downshifted_rate: 1;
	unsigned int is_on_sfp_module: 1;
	unsigned int mac_managed_pm: 1;
	unsigned int autoneg: 1;
	unsigned int link: 1;
	unsigned int autoneg_complete: 1;
	unsigned int interrupts: 1;
	unsigned int irq_suspended: 1;
	unsigned int irq_rerun: 1;
	int rate_matching;
	enum phy_state state;
	u32 dev_flags;
	phy_interface_t interface;
	int speed;
	int duplex;
	int port;
	int pause;
	int asym_pause;
	u8 master_slave_get;
	u8 master_slave_set;
	u8 master_slave_state;
	long unsigned int supported[3];
	long unsigned int advertising[3];
	long unsigned int lp_advertising[3];
	long unsigned int adv_old[3];
	long unsigned int host_interfaces[2];
	u32 eee_broken_modes;
	int irq;
	void *priv;
	struct phy_package_shared *shared;
	struct sk_buff *skb;
	void *ehdr;
	struct nlattr *nest;
	struct delayed_work state_queue;
	struct mutex lock;
	bool sfp_bus_attached;
	struct sfp_bus *sfp_bus;
	struct phylink *phylink;
	struct net_device *attached_dev;
	struct mii_timestamper *mii_ts;
	struct pse_control *psec;
	u8 mdix;
	u8 mdix_ctrl;
	int pma_extable;
	void (*phy_link_change)(struct phy_device *, bool);
	void (*adjust_link)(struct net_device *);
};

struct phy_tdr_config {
	u32 first;
	u32 last;
	u32 step;
	s8 pair;
};

struct mdio_bus_stats {
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t writes;
	u64_stats_t reads;
	struct u64_stats_sync syncp;
	int: 32;
};

struct mii_bus {
	struct module *owner;
	const char *name;
	char id[61];
	void *priv;
	int (*read)(struct mii_bus *, int, int);
	int (*write)(struct mii_bus *, int, int, u16);
	int (*reset)(struct mii_bus *);
	struct mdio_bus_stats stats[32];
	struct mutex mdio_lock;
	struct device *parent;
	enum {
		MDIOBUS_ALLOCATED = 1,
		MDIOBUS_REGISTERED = 2,
		MDIOBUS_UNREGISTERED = 3,
		MDIOBUS_RELEASED = 4,
	} state;
	int: 32;
	struct device dev;
	struct mdio_device *mdio_map[32];
	u32 phy_mask;
	u32 phy_ignore_ta_mask;
	int irq[32];
	int reset_delay_us;
	int reset_post_delay_us;
	struct gpio_desc *reset_gpiod;
	enum {
		MDIOBUS_NO_CAP = 0,
		MDIOBUS_C22 = 1,
		MDIOBUS_C45 = 2,
		MDIOBUS_C22_C45 = 3,
	} probe_capabilities;
	struct mutex shared_lock;
	struct phy_package_shared *shared[32];
	int: 32;
};

struct mdio_driver_common {
	struct device_driver driver;
	int flags;
};

struct mii_timestamper {
	bool (*rxtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	void (*txtstamp)(struct mii_timestamper *, struct sk_buff *, int);
	int (*hwtstamp)(struct mii_timestamper *, struct ifreq *);
	void (*link_state)(struct mii_timestamper *, struct phy_device *);
	int (*ts_info)(struct mii_timestamper *, struct ethtool_ts_info *);
	struct device *device;
};

struct phy_package_shared {
	int addr;
	refcount_t refcnt;
	long unsigned int flags;
	size_t priv_size;
	void *priv;
};

struct phy_driver {
	struct mdio_driver_common mdiodrv;
	u32 phy_id;
	char *name;
	u32 phy_id_mask;
	const long unsigned int * const features;
	u32 flags;
	const void *driver_data;
	int (*soft_reset)(struct phy_device *);
	int (*config_init)(struct phy_device *);
	int (*probe)(struct phy_device *);
	int (*get_features)(struct phy_device *);
	int (*get_rate_matching)(struct phy_device *, phy_interface_t);
	int (*suspend)(struct phy_device *);
	int (*resume)(struct phy_device *);
	int (*config_aneg)(struct phy_device *);
	int (*validate_inband_aneg)(struct phy_device *, phy_interface_t);
	int (*config_inband_aneg)(struct phy_device *, bool);
	int (*aneg_done)(struct phy_device *);
	int (*read_status)(struct phy_device *);
	int (*config_intr)(struct phy_device *);
	irqreturn_t (*handle_interrupt)(struct phy_device *);
	void (*remove)(struct phy_device *);
	int (*match_phy_device)(struct phy_device *);
	int (*set_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*get_wol)(struct phy_device *, struct ethtool_wolinfo *);
	void (*link_change_notify)(struct phy_device *);
	int (*read_mmd)(struct phy_device *, int, u16);
	int (*write_mmd)(struct phy_device *, int, u16, u16);
	int (*read_page)(struct phy_device *);
	int (*write_page)(struct phy_device *, int);
	int (*module_info)(struct phy_device *, struct ethtool_modinfo *);
	int (*module_eeprom)(struct phy_device *, struct ethtool_eeprom *, u8 *);
	int (*cable_test_start)(struct phy_device *);
	int (*cable_test_tdr_start)(struct phy_device *, const struct phy_tdr_config *);
	int (*cable_test_get_status)(struct phy_device *, bool *);
	int (*get_sset_count)(struct phy_device *);
	void (*get_strings)(struct phy_device *, u8 *);
	void (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*get_tunable)(struct phy_device *, struct ethtool_tunable *, void *);
	int (*set_tunable)(struct phy_device *, struct ethtool_tunable *, const void *);
	int (*set_loopback)(struct phy_device *, bool);
	int (*get_sqi)(struct phy_device *);
	int (*get_sqi_max)(struct phy_device *);
};

struct platform_suspend_ops {
	int (*valid)(suspend_state_t);
	int (*begin)(suspend_state_t);
	int (*prepare)();
	int (*prepare_late)();
	int (*enter)(suspend_state_t);
	void (*wake)();
	void (*finish)();
	bool (*suspend_again)();
	void (*end)();
	void (*recover)();
};

struct imx7_cpu_pm_info {
	u32 m4_reserve0;
	u32 m4_reserve1;
	u32 m4_reserve2;
	phys_addr_t pbase;
	phys_addr_t resume_addr;
	u32 ddr_type;
	u32 pm_info_size;
	struct imx7_pm_base ddrc_base;
	struct imx7_pm_base ddrc_phy_base;
	struct imx7_pm_base src_base;
	struct imx7_pm_base iomuxc_gpr_base;
	struct imx7_pm_base ccm_base;
	struct imx7_pm_base gpc_base;
	struct imx7_pm_base snvs_base;
	struct imx7_pm_base anatop_base;
	struct imx7_pm_base lpsr_base;
	struct imx7_pm_base gic_base;
	u32 ttbr1;
	u32 ddrc_num;
	u32 ddrc_val[64];
	u32 ddrc_phy_num;
	u32 ddrc_phy_val[64];
};

struct imx7_pm_socdata {
	u32 ddr_type;
	const char *ddrc_compat;
	const char *src_compat;
	const char *iomuxc_compat;
	const char *gpc_compat;
	const u32 ddrc_num;
	const u32 (*ddrc_offset)[2];
	const u32 ddrc_phy_num;
	const u32 (*ddrc_phy_offset)[2];
};

struct imx7ulp_pm_socdata {
	u32 ddr_type;
	const char *mmdc_compat;
	const u32 mmdc_io_num;
	const u32 *mmdc_io_offset;
	const u32 mmdc_num;
	const u32 *mmdc_offset;
};

struct imx7ulp_cpu_pm_info {
	u32 m4_reserve0;
	u32 m4_reserve1;
	u32 m4_reserve2;
	phys_addr_t pbase;
	phys_addr_t resume_addr;
	u32 pm_info_size;
	void *sim_base;
	void *scg1_base;
	void *mmdc_base;
	void *mmdc_io_base;
	void *smc1_base;
	u32 scg1[17];
	u32 ttbr1;
	u32 gpio[8];
	u32 iomux_num;
	u32 iomux_val[116];
	u32 select_input_num;
	u32 select_input_val[78];
	u32 mmdc_io_num;
	u32 mmdc_io_val[128];
	u32 mmdc_num;
	u32 mmdc_val[100];
	int: 32;
};

enum busfreq_event {
	LOW_BUSFREQ_ENTER = 0,
	LOW_BUSFREQ_EXIT = 1,
};

struct busfreq_func {
	int (*init)(struct platform_device *);
	int (*update)(int);
};

struct imx6_busfreq_info {
	u32 freq;
	void *ddr_settings;
	u32 dll_off;
	void *iomux_offsets;
	u32 mu_delay_val;
	int: 32;
};

struct mmdc_settings_info {
	u32 size;
	void *settings;
	int freq;
	int: 32;
};

enum qspi_regs_valuetype {
	QSPI_PREDEFINED = 0,
	QSPI_RETRIEVED = 1,
};

struct qspi_regs {
	int offset;
	unsigned int value;
	enum qspi_regs_valuetype valuetype;
};

struct imx6_pm_socdata {
	u32 ddr_type;
	const char *mmdc_compat;
	const char *src_compat;
	const char *iomuxc_compat;
	const char *gpc_compat;
	const char *pl310_compat;
	const u32 mmdc_io_num;
	const u32 *mmdc_io_offset;
	const u32 mmdc_num;
	const u32 *mmdc_offset;
};

struct imx6_cpu_pm_info {
	phys_addr_t pbase;
	phys_addr_t resume_addr;
	u32 ddr_type;
	u32 pm_info_size;
	struct imx6_pm_base mmdc0_base;
	struct imx6_pm_base mmdc1_base;
	struct imx6_pm_base src_base;
	struct imx6_pm_base iomuxc_base;
	struct imx6_pm_base ccm_base;
	struct imx6_pm_base gpc_base;
	struct imx6_pm_base l2_base;
	struct imx6_pm_base anatop_base;
	u32 ttbr1;
	u32 mmdc_io_num;
	u32 mmdc_io_val[108];
	u32 mmdc_num;
	u32 mmdc_val[72];
	int: 32;
};

struct busfreq_sync {
	uint32_t change_ongoing;
	uint32_t wfe_status[4];
	int: 32;
};

struct maple_alloc {
	long unsigned int total;
	unsigned char node_count;
	unsigned int request_count;
	struct maple_alloc *slot[61];
};

struct maple_enode;

struct ma_state {
	struct maple_tree *tree;
	long unsigned int index;
	long unsigned int last;
	struct maple_enode *node;
	long unsigned int min;
	long unsigned int max;
	struct maple_alloc *alloc;
	unsigned char depth;
	unsigned char offset;
	unsigned char mas_flags;
};

enum tk_offsets {
	TK_OFFS_REAL = 0,
	TK_OFFS_BOOT = 1,
	TK_OFFS_TAI = 2,
	TK_OFFS_MAX = 3,
};

struct vma_iterator {
	struct ma_state mas;
};

struct clone_args {
	__u64 flags;
	__u64 pidfd;
	__u64 child_tid;
	__u64 parent_tid;
	__u64 exit_signal;
	__u64 stack;
	__u64 stack_size;
	__u64 tls;
	__u64 set_tid;
	__u64 set_tid_size;
	__u64 cgroup;
};

struct fdtable {
	unsigned int max_fds;
	struct file **fd;
	long unsigned int *close_on_exec;
	long unsigned int *open_fds;
	long unsigned int *full_fds_bits;
	struct callback_head rcu;
};

struct files_struct {
	atomic_t count;
	bool resize_in_progress;
	wait_queue_head_t resize_wait;
	struct fdtable *fdt;
	struct fdtable fdtab;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t file_lock;
	unsigned int next_fd;
	long unsigned int close_on_exec_init[1];
	long unsigned int open_fds_init[1];
	long unsigned int full_fds_bits_init[1];
	struct file *fd_array[32];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct robust_list {
	struct robust_list *next;
};

struct robust_list_head {
	struct robust_list list;
	long int futex_offset;
	struct robust_list *list_op_pending;
};

struct multiprocess_signals {
	sigset_t signal;
	struct hlist_node node;
};

typedef int (*proc_visitor)(struct task_struct *, void *);

struct io_uring_cmd {
	struct file *file;
	const void *cmd;
	union {
		void (*task_work_cb)(struct io_uring_cmd *);
		void *cookie;
	};
	u32 cmd_op;
	u32 flags;
	u8 pdu[32];
};

struct mempolicy {};

enum {
	FUTEX_STATE_OK = 0,
	FUTEX_STATE_EXITING = 1,
	FUTEX_STATE_DEAD = 2,
};

enum proc_hidepid {
	HIDEPID_OFF = 0,
	HIDEPID_NO_ACCESS = 1,
	HIDEPID_INVISIBLE = 2,
	HIDEPID_NOT_PTRACEABLE = 4,
};

enum proc_pidonly {
	PROC_PIDONLY_OFF = 0,
	PROC_PIDONLY_ON = 1,
};

struct proc_fs_info {
	struct pid_namespace *pid_ns;
	struct dentry *proc_self;
	struct dentry *proc_thread_self;
	kgid_t pid_gid;
	enum proc_hidepid hide_pid;
	enum proc_pidonly pidonly;
};

struct trace_event_raw_task_newtask {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	long unsigned int clone_flags;
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_task_rename {
	struct trace_entry ent;
	pid_t pid;
	char oldcomm[16];
	char newcomm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_data_offsets_task_newtask {};

struct trace_event_data_offsets_task_rename {};

typedef void (*btf_trace_task_newtask)(void *, struct task_struct *, long unsigned int);

typedef void (*btf_trace_task_rename)(void *, struct task_struct *, const char *);

struct vm_stack {
	struct callback_head rcu;
	struct vm_struct *stack_vm_area;
};

struct audit_context;

struct taint_flag {
	char c_true;
	char c_false;
	bool module;
};

enum ftrace_dump_mode {
	DUMP_NONE = 0,
	DUMP_ALL = 1,
	DUMP_ORIG = 2,
};

enum kmsg_dump_reason {
	KMSG_DUMP_UNDEF = 0,
	KMSG_DUMP_PANIC = 1,
	KMSG_DUMP_OOPS = 2,
	KMSG_DUMP_EMERG = 3,
	KMSG_DUMP_SHUTDOWN = 4,
	KMSG_DUMP_MAX = 5,
};

enum con_flush_mode {
	CONSOLE_FLUSH_PENDING = 0,
	CONSOLE_REPLAY_ALL = 1,
};

enum error_detector {
	ERROR_DETECTOR_KFENCE = 0,
	ERROR_DETECTOR_KASAN = 1,
	ERROR_DETECTOR_WARN = 2,
};

struct warn_args {
	const char *fmt;
	va_list args;
};

enum hk_type {
	HK_TYPE_TIMER = 0,
	HK_TYPE_RCU = 1,
	HK_TYPE_MISC = 2,
	HK_TYPE_SCHED = 3,
	HK_TYPE_TICK = 4,
	HK_TYPE_DOMAIN = 5,
	HK_TYPE_WQ = 6,
	HK_TYPE_MANAGED_IRQ = 7,
	HK_TYPE_KTHREAD = 8,
	HK_TYPE_MAX = 9,
};

enum cpuhp_smt_control {
	CPU_SMT_ENABLED = 0,
	CPU_SMT_DISABLED = 1,
	CPU_SMT_FORCE_DISABLED = 2,
	CPU_SMT_NOT_SUPPORTED = 3,
	CPU_SMT_NOT_IMPLEMENTED = 4,
};

struct smp_hotplug_thread {
	struct task_struct **store;
	struct list_head list;
	int (*thread_should_run)(unsigned int);
	void (*thread_fn)(unsigned int);
	void (*create)(unsigned int);
	void (*setup)(unsigned int);
	void (*cleanup)(unsigned int, bool);
	void (*park)(unsigned int);
	void (*unpark)(unsigned int);
	bool selfparking;
	const char *thread_comm;
};

enum cc_attr {
	CC_ATTR_MEM_ENCRYPT = 0,
	CC_ATTR_HOST_MEM_ENCRYPT = 1,
	CC_ATTR_GUEST_MEM_ENCRYPT = 2,
	CC_ATTR_GUEST_STATE_ENCRYPT = 3,
	CC_ATTR_GUEST_UNROLL_STRING_IO = 4,
	CC_ATTR_GUEST_SEV_SNP = 5,
	CC_ATTR_HOTPLUG_DISABLED = 6,
};

struct trace_event_raw_cpuhp_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_multi_enter {
	struct trace_entry ent;
	unsigned int cpu;
	int target;
	int idx;
	void *fun;
	char __data[0];
};

struct trace_event_raw_cpuhp_exit {
	struct trace_entry ent;
	unsigned int cpu;
	int state;
	int idx;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_cpuhp_enter {};

struct trace_event_data_offsets_cpuhp_multi_enter {};

struct trace_event_data_offsets_cpuhp_exit {};

typedef void (*btf_trace_cpuhp_enter)(void *, unsigned int, int, int, int (*)(unsigned int));

typedef void (*btf_trace_cpuhp_multi_enter)(void *, unsigned int, int, int, int (*)(unsigned int, struct hlist_node *), struct hlist_node *);

typedef void (*btf_trace_cpuhp_exit)(void *, unsigned int, int, int, int);

struct cpuhp_cpu_state {
	enum cpuhp_state state;
	enum cpuhp_state target;
	enum cpuhp_state fail;
	struct task_struct *thread;
	bool should_run;
	bool rollback;
	bool single;
	bool bringup;
	struct hlist_node *node;
	struct hlist_node *last;
	enum cpuhp_state cb_state;
	int result;
	struct completion done_up;
	struct completion done_down;
};

struct cpuhp_step {
	const char *name;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} startup;
	union {
		int (*single)(unsigned int);
		int (*multi)(unsigned int, struct hlist_node *);
	} teardown;
	struct hlist_head list;
	bool cant_stop;
	bool multi_instance;
};

enum cpu_mitigations {
	CPU_MITIGATIONS_OFF = 0,
	CPU_MITIGATIONS_AUTO = 1,
	CPU_MITIGATIONS_AUTO_NOSMT = 2,
};

struct __kernel_old_timeval {
	__kernel_long_t tv_sec;
	__kernel_long_t tv_usec;
};

struct rusage {
	struct __kernel_old_timeval ru_utime;
	struct __kernel_old_timeval ru_stime;
	__kernel_long_t ru_maxrss;
	__kernel_long_t ru_ixrss;
	__kernel_long_t ru_idrss;
	__kernel_long_t ru_isrss;
	__kernel_long_t ru_minflt;
	__kernel_long_t ru_majflt;
	__kernel_long_t ru_nswap;
	__kernel_long_t ru_inblock;
	__kernel_long_t ru_oublock;
	__kernel_long_t ru_msgsnd;
	__kernel_long_t ru_msgrcv;
	__kernel_long_t ru_nsignals;
	__kernel_long_t ru_nvcsw;
	__kernel_long_t ru_nivcsw;
};

enum wb_stat_item {
	WB_RECLAIMABLE = 0,
	WB_WRITEBACK = 1,
	WB_DIRTIED = 2,
	WB_WRITTEN = 3,
	NR_WB_STAT_ITEMS = 4,
};

struct waitid_info {
	pid_t pid;
	uid_t uid;
	int status;
	int cause;
};

struct wait_opts {
	enum pid_type wo_type;
	int wo_flags;
	struct pid *wo_pid;
	struct waitid_info *wo_info;
	int wo_stat;
	struct rusage *wo_rusage;
	wait_queue_entry_t child_wait;
	int notask_error;
};

struct softirq_action {
	void (*action)(struct softirq_action *);
};

struct tasklet_struct {
	struct tasklet_struct *next;
	long unsigned int state;
	atomic_t count;
	bool use_callback;
	union {
		void (*func)(long unsigned int);
		void (*callback)(struct tasklet_struct *);
	};
	long unsigned int data;
};

enum {
	TASKLET_STATE_SCHED = 0,
	TASKLET_STATE_RUN = 1,
};

struct kernel_stat {
	long unsigned int irqs_sum;
	unsigned int softirqs[10];
};

struct trace_print_flags {
	long unsigned int mask;
	const char *name;
};

struct wait_bit_key {
	void *flags;
	int bit_nr;
	long unsigned int timeout;
};

struct wait_bit_queue_entry {
	struct wait_bit_key key;
	struct wait_queue_entry wq_entry;
};

struct trace_event_raw_irq_handler_entry {
	struct trace_entry ent;
	int irq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_irq_handler_exit {
	struct trace_entry ent;
	int irq;
	int ret;
	char __data[0];
};

struct trace_event_raw_softirq {
	struct trace_entry ent;
	unsigned int vec;
	char __data[0];
};

struct trace_event_data_offsets_irq_handler_entry {
	u32 name;
};

struct trace_event_data_offsets_irq_handler_exit {};

struct trace_event_data_offsets_softirq {};

typedef void (*btf_trace_irq_handler_entry)(void *, int, struct irqaction *);

typedef void (*btf_trace_irq_handler_exit)(void *, int, struct irqaction *, int);

typedef void (*btf_trace_softirq_entry)(void *, unsigned int);

typedef void (*btf_trace_softirq_exit)(void *, unsigned int);

typedef void (*btf_trace_softirq_raise)(void *, unsigned int);

struct tasklet_head {
	struct tasklet_struct *head;
	struct tasklet_struct **tail;
};

enum {
	IORES_DESC_NONE = 0,
	IORES_DESC_CRASH_KERNEL = 1,
	IORES_DESC_ACPI_TABLES = 2,
	IORES_DESC_ACPI_NV_STORAGE = 3,
	IORES_DESC_PERSISTENT_MEMORY = 4,
	IORES_DESC_PERSISTENT_MEMORY_LEGACY = 5,
	IORES_DESC_DEVICE_PRIVATE_MEMORY = 6,
	IORES_DESC_RESERVED = 7,
	IORES_DESC_SOFT_RESERVED = 8,
	IORES_DESC_CXL = 9,
};

enum {
	REGION_INTERSECTS = 0,
	REGION_DISJOINT = 1,
	REGION_MIXED = 2,
};

struct resource_constraint {
	resource_size_t min;
	resource_size_t max;
	resource_size_t align;
	resource_size_t (*alignf)(void *, const struct resource *, resource_size_t, resource_size_t);
	void *alignf_data;
};

enum {
	MAX_IORES_LEVEL = 5,
};

struct region_devres {
	struct resource *parent;
	resource_size_t start;
	resource_size_t n;
};

struct sk_filter {
	refcount_t refcnt;
	struct callback_head rcu;
	struct bpf_prog *prog;
};

enum sysctl_writes_mode {
	SYSCTL_WRITES_LEGACY = 4294967295,
	SYSCTL_WRITES_WARN = 0,
	SYSCTL_WRITES_STRICT = 1,
};

struct do_proc_dointvec_minmax_conv_param {
	int *min;
	int *max;
};

struct do_proc_douintvec_minmax_conv_param {
	unsigned int *min;
	unsigned int *max;
};

struct __user_cap_header_struct {
	__u32 version;
	int pid;
};

typedef struct __user_cap_header_struct *cap_user_header_t;

struct __user_cap_data_struct {
	__u32 effective;
	__u32 permitted;
	__u32 inheritable;
};

typedef struct __user_cap_data_struct *cap_user_data_t;

typedef struct siginfo siginfo_t;

struct sigqueue {
	struct list_head list;
	int flags;
	kernel_siginfo_t info;
	struct ucounts *ucounts;
};

struct ptrace_peeksiginfo_args {
	__u64 off;
	__u32 flags;
	__s32 nr;
};

struct ptrace_syscall_info {
	__u8 op;
	__u8 pad[3];
	__u32 arch;
	__u64 instruction_pointer;
	__u64 stack_pointer;
	union {
		struct {
			__u64 nr;
			__u64 args[6];
		} entry;
		struct {
			__s64 rval;
			__u8 is_error;
			int: 24;
			int: 32;
		} exit;
		struct {
			__u64 nr;
			__u64 args[6];
			__u32 ret_data;
			int: 32;
		} seccomp;
	};
};

struct ptrace_rseq_configuration {
	__u64 rseq_abi_pointer;
	__u32 rseq_abi_size;
	__u32 signature;
	__u32 flags;
	__u32 pad;
};

typedef long unsigned int old_sigset_t;

struct old_sigaction {
	__sighandler_t sa_handler;
	old_sigset_t sa_mask;
	long unsigned int sa_flags;
	__sigrestore_t sa_restorer;
};

enum siginfo_layout {
	SIL_KILL = 0,
	SIL_TIMER = 1,
	SIL_POLL = 2,
	SIL_FAULT = 3,
	SIL_FAULT_TRAPNO = 4,
	SIL_FAULT_MCEERR = 5,
	SIL_FAULT_BNDERR = 6,
	SIL_FAULT_PKUERR = 7,
	SIL_FAULT_PERF_EVENT = 8,
	SIL_CHLD = 9,
	SIL_RT = 10,
	SIL_SYS = 11,
};

struct fd {
	struct file *file;
	unsigned int flags;
};

struct core_vma_metadata;

struct coredump_params {
	const kernel_siginfo_t *siginfo;
	struct pt_regs *regs;
	struct file *file;
	long unsigned int limit;
	long unsigned int mm_flags;
	int: 32;
	loff_t written;
	loff_t pos;
	loff_t to_skip;
	int vma_count;
	size_t vma_data_size;
	struct core_vma_metadata *vma_meta;
	int: 32;
};

struct core_vma_metadata {
	long unsigned int start;
	long unsigned int end;
	long unsigned int flags;
	long unsigned int dump_size;
	long unsigned int pgoff;
	struct file *file;
};

enum {
	TRACE_SIGNAL_DELIVERED = 0,
	TRACE_SIGNAL_IGNORED = 1,
	TRACE_SIGNAL_ALREADY_PENDING = 2,
	TRACE_SIGNAL_OVERFLOW_FAIL = 3,
	TRACE_SIGNAL_LOSE_INFO = 4,
};

struct trace_event_raw_signal_generate {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	char comm[16];
	pid_t pid;
	int group;
	int result;
	char __data[0];
};

struct trace_event_raw_signal_deliver {
	struct trace_entry ent;
	int sig;
	int errno;
	int code;
	long unsigned int sa_handler;
	long unsigned int sa_flags;
	char __data[0];
};

struct trace_event_data_offsets_signal_generate {};

struct trace_event_data_offsets_signal_deliver {};

typedef void (*btf_trace_signal_generate)(void *, int, struct kernel_siginfo *, struct task_struct *, int, int);

typedef void (*btf_trace_signal_deliver)(void *, int, struct kernel_siginfo *, struct k_sigaction *);

enum sig_handler {
	HANDLER_CURRENT = 0,
	HANDLER_SIG_DFL = 1,
	HANDLER_EXIT = 2,
};

struct sysinfo {
	__kernel_long_t uptime;
	__kernel_ulong_t loads[3];
	__kernel_ulong_t totalram;
	__kernel_ulong_t freeram;
	__kernel_ulong_t sharedram;
	__kernel_ulong_t bufferram;
	__kernel_ulong_t totalswap;
	__kernel_ulong_t freeswap;
	__u16 procs;
	__u16 pad;
	__kernel_ulong_t totalhigh;
	__kernel_ulong_t freehigh;
	__u32 mem_unit;
	char _f[8];
};

struct rlimit64 {
	__u64 rlim_cur;
	__u64 rlim_max;
};

struct timens_offsets {
	struct timespec64 monotonic;
	struct timespec64 boottime;
};

struct time_namespace {
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct ns_common ns;
	struct timens_offsets offsets;
	struct page *vvar_page;
	bool frozen_offsets;
};

enum uts_proc {
	UTS_PROC_ARCH = 0,
	UTS_PROC_OSTYPE = 1,
	UTS_PROC_OSRELEASE = 2,
	UTS_PROC_VERSION = 3,
	UTS_PROC_HOSTNAME = 4,
	UTS_PROC_DOMAINNAME = 5,
};

struct prctl_mm_map {
	__u64 start_code;
	__u64 end_code;
	__u64 start_data;
	__u64 end_data;
	__u64 start_brk;
	__u64 brk;
	__u64 start_stack;
	__u64 arg_start;
	__u64 arg_end;
	__u64 env_start;
	__u64 env_end;
	__u64 *auxv;
	__u32 auxv_size;
	__u32 exe_fd;
	int: 32;
};

struct tms {
	__kernel_clock_t tms_utime;
	__kernel_clock_t tms_stime;
	__kernel_clock_t tms_cutime;
	__kernel_clock_t tms_cstime;
};

struct getcpu_cache {
	long unsigned int blob[32];
};

struct wq_flusher;

struct worker;

struct workqueue_attrs;

struct pool_workqueue;

struct wq_device;

struct workqueue_struct {
	struct list_head pwqs;
	struct list_head list;
	struct mutex mutex;
	int work_color;
	int flush_color;
	atomic_t nr_pwqs_to_flush;
	struct wq_flusher *first_flusher;
	struct list_head flusher_queue;
	struct list_head flusher_overflow;
	struct list_head maydays;
	struct worker *rescuer;
	int nr_drainers;
	int saved_max_active;
	struct workqueue_attrs *unbound_attrs;
	struct pool_workqueue *dfl_pwq;
	struct wq_device *wq_dev;
	char name[24];
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	unsigned int flags;
	struct pool_workqueue *cpu_pwqs;
	struct pool_workqueue *numa_pwq_tbl[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct workqueue_attrs {
	int nice;
	cpumask_var_t cpumask;
	bool no_numa;
};

struct execute_work {
	struct work_struct work;
};

enum {
	WQ_UNBOUND = 2,
	WQ_FREEZABLE = 4,
	WQ_MEM_RECLAIM = 8,
	WQ_HIGHPRI = 16,
	WQ_CPU_INTENSIVE = 32,
	WQ_SYSFS = 64,
	WQ_POWER_EFFICIENT = 128,
	__WQ_DRAINING = 65536,
	__WQ_ORDERED = 131072,
	__WQ_LEGACY = 262144,
	__WQ_ORDERED_EXPLICIT = 524288,
	WQ_MAX_ACTIVE = 512,
	WQ_MAX_UNBOUND_PER_CPU = 4,
	WQ_DFL_ACTIVE = 256,
};

enum kobject_action {
	KOBJ_ADD = 0,
	KOBJ_REMOVE = 1,
	KOBJ_CHANGE = 2,
	KOBJ_MOVE = 3,
	KOBJ_ONLINE = 4,
	KOBJ_OFFLINE = 5,
	KOBJ_BIND = 6,
	KOBJ_UNBIND = 7,
};

struct __una_u32 {
	u32 x;
};

struct worker_pool;

struct worker {
	union {
		struct list_head entry;
		struct hlist_node hentry;
	};
	struct work_struct *current_work;
	work_func_t current_func;
	struct pool_workqueue *current_pwq;
	unsigned int current_color;
	struct list_head scheduled;
	struct task_struct *task;
	struct worker_pool *pool;
	struct list_head node;
	long unsigned int last_active;
	unsigned int flags;
	int id;
	int sleeping;
	char desc[24];
	struct workqueue_struct *rescue_wq;
	work_func_t last_func;
};

struct pool_workqueue {
	struct worker_pool *pool;
	struct workqueue_struct *wq;
	int work_color;
	int flush_color;
	int refcnt;
	int nr_in_flight[16];
	int nr_active;
	int max_active;
	struct list_head inactive_works;
	struct list_head pwqs_node;
	struct list_head mayday_node;
	struct work_struct unbound_release_work;
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct worker_pool {
	raw_spinlock_t lock;
	int cpu;
	int node;
	int id;
	unsigned int flags;
	long unsigned int watchdog_ts;
	int nr_running;
	struct list_head worklist;
	int nr_workers;
	int nr_idle;
	struct list_head idle_list;
	struct timer_list idle_timer;
	struct timer_list mayday_timer;
	struct hlist_head busy_hash[64];
	struct worker *manager;
	struct list_head workers;
	struct completion *detach_completion;
	struct ida worker_ida;
	struct workqueue_attrs *attrs;
	struct hlist_node hash_node;
	int refcnt;
	struct callback_head rcu;
};

enum {
	POOL_MANAGER_ACTIVE = 1,
	POOL_DISASSOCIATED = 4,
	WORKER_DIE = 2,
	WORKER_IDLE = 4,
	WORKER_PREP = 8,
	WORKER_CPU_INTENSIVE = 64,
	WORKER_UNBOUND = 128,
	WORKER_REBOUND = 256,
	WORKER_NOT_RUNNING = 456,
	NR_STD_WORKER_POOLS = 2,
	UNBOUND_POOL_HASH_ORDER = 6,
	BUSY_WORKER_HASH_ORDER = 6,
	MAX_IDLE_WORKERS_RATIO = 4,
	IDLE_WORKER_TIMEOUT = 30000,
	MAYDAY_INITIAL_TIMEOUT = 2,
	MAYDAY_INTERVAL = 10,
	CREATE_COOLDOWN = 100,
	RESCUER_NICE_LEVEL = 4294967276,
	HIGHPRI_NICE_LEVEL = 4294967276,
	WQ_NAME_LEN = 24,
};

struct wq_flusher {
	struct list_head list;
	int flush_color;
	struct completion done;
};

struct wq_device {
	struct workqueue_struct *wq;
	int: 32;
	struct device dev;
};

struct trace_event_raw_workqueue_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	u32 __data_loc_workqueue;
	int req_cpu;
	int cpu;
	char __data[0];
};

struct trace_event_raw_workqueue_activate_work {
	struct trace_entry ent;
	void *work;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_workqueue_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_data_offsets_workqueue_queue_work {
	u32 workqueue;
};

struct trace_event_data_offsets_workqueue_activate_work {};

struct trace_event_data_offsets_workqueue_execute_start {};

struct trace_event_data_offsets_workqueue_execute_end {};

typedef void (*btf_trace_workqueue_queue_work)(void *, int, struct pool_workqueue *, struct work_struct *);

typedef void (*btf_trace_workqueue_activate_work)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_start)(void *, struct work_struct *);

typedef void (*btf_trace_workqueue_execute_end)(void *, struct work_struct *, work_func_t);

struct wq_barrier {
	struct work_struct work;
	struct completion done;
	struct task_struct *task;
};

struct cwt_wait {
	wait_queue_entry_t wait;
	struct work_struct *work;
};

struct apply_wqattrs_ctx {
	struct workqueue_struct *wq;
	struct workqueue_attrs *attrs;
	struct list_head list;
	struct pool_workqueue *dfl_pwq;
	struct pool_workqueue *pwq_tbl[0];
};

struct work_for_cpu {
	struct work_struct work;
	long int (*fn)(void *);
	void *arg;
	long int ret;
};

typedef struct {} local_lock_t;

struct xa_node {
	unsigned char shift;
	unsigned char offset;
	unsigned char count;
	unsigned char nr_values;
	struct xa_node *parent;
	struct xarray *array;
	union {
		struct list_head private_list;
		struct callback_head callback_head;
	};
	void *slots[64];
	union {
		long unsigned int tags[6];
		long unsigned int marks[6];
	};
};

struct radix_tree_preload {
	local_lock_t lock;
	unsigned int nr;
	struct xa_node *nodes;
};

typedef void (*task_work_func_t)(struct callback_head *);

enum task_work_notify_mode {
	TWA_NONE = 0,
	TWA_RESUME = 1,
	TWA_SIGNAL = 2,
	TWA_SIGNAL_NO_IPI = 3,
};

enum {
	KERNEL_PARAM_OPS_FL_NOARG = 1,
};

enum {
	KERNEL_PARAM_FL_UNSAFE = 1,
	KERNEL_PARAM_FL_HWPARAM = 2,
};

struct param_attribute {
	struct module_attribute mattr;
	const struct kernel_param *param;
};

struct module_param_attrs {
	unsigned int num;
	struct attribute_group grp;
	struct param_attribute attrs[0];
};

struct module_version_attribute {
	struct module_attribute mattr;
	const char *module_name;
	const char *version;
};

enum lockdown_reason {
	LOCKDOWN_NONE = 0,
	LOCKDOWN_MODULE_SIGNATURE = 1,
	LOCKDOWN_DEV_MEM = 2,
	LOCKDOWN_EFI_TEST = 3,
	LOCKDOWN_KEXEC = 4,
	LOCKDOWN_HIBERNATION = 5,
	LOCKDOWN_PCI_ACCESS = 6,
	LOCKDOWN_IOPORT = 7,
	LOCKDOWN_MSR = 8,
	LOCKDOWN_ACPI_TABLES = 9,
	LOCKDOWN_DEVICE_TREE = 10,
	LOCKDOWN_PCMCIA_CIS = 11,
	LOCKDOWN_TIOCSSERIAL = 12,
	LOCKDOWN_MODULE_PARAMETERS = 13,
	LOCKDOWN_MMIOTRACE = 14,
	LOCKDOWN_DEBUGFS = 15,
	LOCKDOWN_XMON_WR = 16,
	LOCKDOWN_BPF_WRITE_USER = 17,
	LOCKDOWN_DBG_WRITE_KERNEL = 18,
	LOCKDOWN_RTAS_ERROR_INJECTION = 19,
	LOCKDOWN_INTEGRITY_MAX = 20,
	LOCKDOWN_KCORE = 21,
	LOCKDOWN_KPROBES = 22,
	LOCKDOWN_BPF_READ_KERNEL = 23,
	LOCKDOWN_DBG_READ_KERNEL = 24,
	LOCKDOWN_PERF = 25,
	LOCKDOWN_TRACEFS = 26,
	LOCKDOWN_XMON_RW = 27,
	LOCKDOWN_XFRM_SECRET = 28,
	LOCKDOWN_CONFIDENTIALITY_MAX = 29,
};

struct kmalloced_param {
	struct list_head list;
	char val[0];
};

struct sched_param {
	int sched_priority;
};

struct kthread_work;

typedef void (*kthread_work_func_t)(struct kthread_work *);

struct kthread_worker;

struct kthread_work {
	struct list_head node;
	kthread_work_func_t func;
	struct kthread_worker *worker;
	int canceling;
};

enum {
	KTW_FREEZABLE = 1,
};

struct kthread_worker {
	unsigned int flags;
	raw_spinlock_t lock;
	struct list_head work_list;
	struct list_head delayed_work_list;
	struct task_struct *task;
	struct kthread_work *current_work;
};

struct kthread_delayed_work {
	struct kthread_work work;
	struct timer_list timer;
};

struct kthread_create_info {
	int (*threadfn)(void *);
	void *data;
	int node;
	struct task_struct *result;
	struct completion *done;
	struct list_head list;
};

struct kthread {
	long unsigned int flags;
	unsigned int cpu;
	int result;
	int (*threadfn)(void *);
	void *data;
	struct completion parked;
	struct completion exited;
	char *full_name;
};

enum KTHREAD_BITS {
	KTHREAD_IS_PER_CPU = 0,
	KTHREAD_SHOULD_STOP = 1,
	KTHREAD_SHOULD_PARK = 2,
};

struct kthread_flush_work {
	struct kthread_work work;
	struct completion done;
};

struct ipc_ids {
	int in_use;
	short unsigned int seq;
	struct rw_semaphore rwsem;
	struct idr ipcs_idr;
	int max_idx;
	int last_idx;
	struct rhashtable key_ht;
};

struct ipc_namespace {
	struct ipc_ids ids[3];
	int sem_ctls[4];
	int used_sems;
	unsigned int msg_ctlmax;
	unsigned int msg_ctlmnb;
	unsigned int msg_ctlmni;
	int: 32;
	struct percpu_counter percpu_msg_bytes;
	struct percpu_counter percpu_msg_hdrs;
	size_t shm_ctlmax;
	size_t shm_ctlall;
	long unsigned int shm_tot;
	int shm_ctlmni;
	int shm_rmid_forced;
	struct notifier_block ipcns_nb;
	struct vfsmount *mq_mnt;
	unsigned int mq_queues_count;
	unsigned int mq_queues_max;
	unsigned int mq_msg_max;
	unsigned int mq_msgsize_max;
	unsigned int mq_msg_default;
	unsigned int mq_msgsize_default;
	struct ctl_table_set mq_set;
	struct ctl_table_header *mq_sysctls;
	struct ctl_table_set ipc_set;
	struct ctl_table_header *ipc_sysctls;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	struct llist_node mnt_llist;
	struct ns_common ns;
};

struct die_args {
	struct pt_regs *regs;
	const char *str;
	long int err;
	int trapnr;
	int signr;
};

struct srcu_notifier_head {
	struct mutex mutex;
	struct srcu_struct srcu;
	struct notifier_block *head;
};

struct kobj_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kobject *, struct kobj_attribute *, char *);
	ssize_t (*store)(struct kobject *, struct kobj_attribute *, const char *, size_t);
};

enum what {
	PROC_EVENT_NONE = 0,
	PROC_EVENT_FORK = 1,
	PROC_EVENT_EXEC = 2,
	PROC_EVENT_UID = 4,
	PROC_EVENT_GID = 64,
	PROC_EVENT_SID = 128,
	PROC_EVENT_PTRACE = 256,
	PROC_EVENT_COMM = 512,
	PROC_EVENT_COREDUMP = 1073741824,
	PROC_EVENT_EXIT = 2147483648,
};

enum reboot_type {
	BOOT_TRIPLE = 116,
	BOOT_KBD = 107,
	BOOT_BIOS = 98,
	BOOT_ACPI = 97,
	BOOT_EFI = 101,
	BOOT_CF9_FORCE = 112,
	BOOT_CF9_SAFE = 113,
};

enum sys_off_mode {
	SYS_OFF_MODE_POWER_OFF_PREPARE = 0,
	SYS_OFF_MODE_POWER_OFF = 1,
	SYS_OFF_MODE_RESTART_PREPARE = 2,
	SYS_OFF_MODE_RESTART = 3,
};

struct sys_off_data {
	int mode;
	void *cb_data;
	const char *cmd;
};

struct sys_off_handler {
	struct notifier_block nb;
	int (*sys_off_cb)(struct sys_off_data *);
	void *cb_data;
	enum sys_off_mode mode;
	bool blocking;
	void *list;
};

struct async_entry {
	struct list_head domain_list;
	struct list_head global_list;
	struct work_struct work;
	async_cookie_t cookie;
	async_func_t func;
	void *data;
	struct async_domain *domain;
	int: 32;
};

struct smpboot_thread_data {
	unsigned int cpu;
	unsigned int status;
	struct smp_hotplug_thread *ht;
};

enum {
	HP_THREAD_NONE = 0,
	HP_THREAD_ACTIVE = 1,
	HP_THREAD_PARKED = 2,
};

struct umd_info {
	const char *driver_name;
	struct file *pipe_to_umh;
	struct file *pipe_from_umh;
	struct path wd;
	struct pid *tgid;
};

struct pin_cookie {};

enum {
	CSD_FLAG_LOCK = 1,
	IRQ_WORK_PENDING = 1,
	IRQ_WORK_BUSY = 2,
	IRQ_WORK_LAZY = 4,
	IRQ_WORK_HARD_IRQ = 8,
	IRQ_WORK_CLAIMED = 3,
	CSD_TYPE_ASYNC = 0,
	CSD_TYPE_SYNC = 16,
	CSD_TYPE_IRQ_WORK = 32,
	CSD_TYPE_TTWU = 48,
	CSD_FLAG_TYPE_MASK = 240,
};

struct __call_single_data {
	struct __call_single_node node;
	smp_call_func_t func;
	void *info;
};

typedef struct __call_single_data call_single_data_t;

typedef int (*task_call_f)(struct task_struct *, void *);

struct dl_bw {
	raw_spinlock_t lock;
	int: 32;
	u64 bw;
	u64 total_bw;
};

struct cpudl_item;

struct cpudl {
	raw_spinlock_t lock;
	int size;
	cpumask_var_t free_cpus;
	struct cpudl_item *elements;
};

struct cpupri_vec {
	atomic_t count;
	cpumask_var_t mask;
};

struct cpupri {
	struct cpupri_vec pri_to_cpu[101];
	int *cpu_to_pri;
};

struct perf_domain;

struct root_domain {
	atomic_t refcount;
	atomic_t rto_count;
	struct callback_head rcu;
	cpumask_var_t span;
	cpumask_var_t online;
	int overload;
	int overutilized;
	cpumask_var_t dlo_mask;
	atomic_t dlo_count;
	struct dl_bw dl_bw;
	struct cpudl cpudl;
	u64 visit_gen;
	struct irq_work rto_push_work;
	raw_spinlock_t rto_lock;
	int rto_loop;
	int rto_cpu;
	atomic_t rto_loop_next;
	atomic_t rto_loop_start;
	cpumask_var_t rto_mask;
	struct cpupri cpupri;
	long unsigned int max_cpu_capacity;
	struct perf_domain *pd;
	int: 32;
};

struct io_ring_ctx;

struct io_wq;

struct io_uring_task {
	int cached_refs;
	const struct io_ring_ctx *last;
	struct io_wq *io_wq;
	struct file *registered_rings[16];
	struct xarray xa;
	struct wait_queue_head wait;
	atomic_t in_idle;
	atomic_t inflight_tracked;
	int: 32;
	struct percpu_counter inflight;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct {
		struct llist_head task_list;
		struct callback_head task_work;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
};

enum {
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_READY = 1,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED = 2,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED_READY = 4,
	MEMBARRIER_STATE_GLOBAL_EXPEDITED = 8,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE_READY = 16,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ_READY = 64,
	MEMBARRIER_STATE_PRIVATE_EXPEDITED_RSEQ = 128,
};

typedef int __kernel_rwf_t;

enum ctx_state {
	CONTEXT_DISABLED = 4294967295,
	CONTEXT_KERNEL = 0,
	CONTEXT_IDLE = 1,
	CONTEXT_USER = 2,
	CONTEXT_GUEST = 3,
	CONTEXT_MAX = 4,
};

struct sched_domain_shared {
	atomic_t ref;
	atomic_t nr_busy_cpus;
	int has_idle_cores;
	int nr_idle_scan;
};

struct sched_group;

struct sched_domain {
	struct sched_domain *parent;
	struct sched_domain *child;
	struct sched_group *groups;
	long unsigned int min_interval;
	long unsigned int max_interval;
	unsigned int busy_factor;
	unsigned int imbalance_pct;
	unsigned int cache_nice_tries;
	unsigned int imb_numa_nr;
	int nohz_idle;
	int flags;
	int level;
	long unsigned int last_balance;
	unsigned int balance_interval;
	unsigned int nr_balance_failed;
	int: 32;
	u64 max_newidle_lb_cost;
	long unsigned int last_decay_max_lb_cost;
	int: 32;
	u64 avg_scan_cost;
	union {
		void *private;
		struct callback_head rcu;
	};
	struct sched_domain_shared *shared;
	unsigned int span_weight;
	long unsigned int span[0];
};

struct sched_group_capacity;

struct sched_group {
	struct sched_group *next;
	atomic_t ref;
	unsigned int group_weight;
	struct sched_group_capacity *sgc;
	int asym_prefer_cpu;
	int flags;
	long unsigned int cpumask[0];
};

struct sched_group_capacity {
	atomic_t ref;
	long unsigned int capacity;
	long unsigned int min_capacity;
	long unsigned int max_capacity;
	long unsigned int next_update;
	int imbalance;
	long unsigned int cpumask[0];
};

struct em_perf_state {
	long unsigned int frequency;
	long unsigned int power;
	long unsigned int cost;
	long unsigned int flags;
};

struct em_perf_domain {
	struct em_perf_state *table;
	int nr_perf_states;
	long unsigned int flags;
	long unsigned int cpus[0];
};

struct kernel_cpustat {
	u64 cpustat[10];
};

struct wake_q_head {
	struct wake_q_node *first;
	struct wake_q_node **lastp;
};

struct sched_attr {
	__u32 size;
	__u32 sched_policy;
	__u64 sched_flags;
	__s32 sched_nice;
	__u32 sched_priority;
	__u64 sched_runtime;
	__u64 sched_deadline;
	__u64 sched_period;
	__u32 sched_util_min;
	__u32 sched_util_max;
};

struct trace_event_raw_sched_kthread_stop {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	char __data[0];
};

struct trace_event_raw_sched_kthread_stop_ret {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_queue_work {
	struct trace_entry ent;
	void *work;
	void *function;
	void *worker;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_start {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_kthread_work_execute_end {
	struct trace_entry ent;
	void *work;
	void *function;
	char __data[0];
};

struct trace_event_raw_sched_wakeup_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int target_cpu;
	char __data[0];
};

struct trace_event_raw_sched_switch {
	struct trace_entry ent;
	char prev_comm[16];
	pid_t prev_pid;
	int prev_prio;
	long int prev_state;
	char next_comm[16];
	pid_t next_pid;
	int next_prio;
	char __data[0];
};

struct trace_event_raw_sched_migrate_task {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	int orig_cpu;
	int dest_cpu;
	char __data[0];
};

struct trace_event_raw_sched_process_template {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_wait {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int prio;
	char __data[0];
};

struct trace_event_raw_sched_process_fork {
	struct trace_entry ent;
	char parent_comm[16];
	pid_t parent_pid;
	char child_comm[16];
	pid_t child_pid;
	char __data[0];
};

struct trace_event_raw_sched_process_exec {
	struct trace_entry ent;
	u32 __data_loc_filename;
	pid_t pid;
	pid_t old_pid;
	char __data[0];
};

struct trace_event_raw_sched_stat_runtime {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int: 32;
	u64 runtime;
	u64 vruntime;
	char __data[0];
};

struct trace_event_raw_sched_pi_setprio {
	struct trace_entry ent;
	char comm[16];
	pid_t pid;
	int oldprio;
	int newprio;
	char __data[0];
};

struct trace_event_raw_sched_move_numa {
	struct trace_entry ent;
	pid_t pid;
	pid_t tgid;
	pid_t ngid;
	int src_cpu;
	int src_nid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_numa_pair_template {
	struct trace_entry ent;
	pid_t src_pid;
	pid_t src_tgid;
	pid_t src_ngid;
	int src_cpu;
	int src_nid;
	pid_t dst_pid;
	pid_t dst_tgid;
	pid_t dst_ngid;
	int dst_cpu;
	int dst_nid;
	char __data[0];
};

struct trace_event_raw_sched_wake_idle_without_ipi {
	struct trace_entry ent;
	int cpu;
	char __data[0];
};

struct trace_event_data_offsets_sched_kthread_stop {};

struct trace_event_data_offsets_sched_kthread_stop_ret {};

struct trace_event_data_offsets_sched_kthread_work_queue_work {};

struct trace_event_data_offsets_sched_kthread_work_execute_start {};

struct trace_event_data_offsets_sched_kthread_work_execute_end {};

struct trace_event_data_offsets_sched_wakeup_template {};

struct trace_event_data_offsets_sched_switch {};

struct trace_event_data_offsets_sched_migrate_task {};

struct trace_event_data_offsets_sched_process_template {};

struct trace_event_data_offsets_sched_process_wait {};

struct trace_event_data_offsets_sched_process_fork {};

struct trace_event_data_offsets_sched_process_exec {
	u32 filename;
};

struct trace_event_data_offsets_sched_stat_runtime {};

struct trace_event_data_offsets_sched_pi_setprio {};

struct trace_event_data_offsets_sched_move_numa {};

struct trace_event_data_offsets_sched_numa_pair_template {};

struct trace_event_data_offsets_sched_wake_idle_without_ipi {};

typedef void (*btf_trace_sched_kthread_stop)(void *, struct task_struct *);

typedef void (*btf_trace_sched_kthread_stop_ret)(void *, int);

typedef void (*btf_trace_sched_kthread_work_queue_work)(void *, struct kthread_worker *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_start)(void *, struct kthread_work *);

typedef void (*btf_trace_sched_kthread_work_execute_end)(void *, struct kthread_work *, kthread_work_func_t);

typedef void (*btf_trace_sched_waking)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wakeup_new)(void *, struct task_struct *);

typedef void (*btf_trace_sched_switch)(void *, bool, struct task_struct *, struct task_struct *, unsigned int);

typedef void (*btf_trace_sched_migrate_task)(void *, struct task_struct *, int);

typedef void (*btf_trace_sched_process_free)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_exit)(void *, struct task_struct *);

typedef void (*btf_trace_sched_wait_task)(void *, struct task_struct *);

typedef void (*btf_trace_sched_process_wait)(void *, struct pid *);

typedef void (*btf_trace_sched_process_fork)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_process_exec)(void *, struct task_struct *, pid_t, struct linux_binprm *);

typedef void (*btf_trace_sched_stat_runtime)(void *, struct task_struct *, u64, u64);

typedef void (*btf_trace_sched_pi_setprio)(void *, struct task_struct *, struct task_struct *);

typedef void (*btf_trace_sched_move_numa)(void *, struct task_struct *, int, int);

typedef void (*btf_trace_sched_stick_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_swap_numa)(void *, struct task_struct *, int, struct task_struct *, int);

typedef void (*btf_trace_sched_wake_idle_without_ipi)(void *, int);

struct cfs_rq;

typedef void (*btf_trace_pelt_cfs_tp)(void *, struct cfs_rq *);

struct cfs_rq {
	struct load_weight load;
	unsigned int nr_running;
	unsigned int h_nr_running;
	unsigned int idle_nr_running;
	unsigned int idle_h_nr_running;
	u64 exec_clock;
	u64 min_vruntime;
	u64 min_vruntime_copy;
	struct rb_root_cached tasks_timeline;
	struct sched_entity *curr;
	struct sched_entity *next;
	struct sched_entity *last;
	struct sched_entity *skip;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sched_avg avg;
	u64 last_update_time_copy;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct {
		raw_spinlock_t lock;
		int nr;
		long unsigned int load_avg;
		long unsigned int util_avg;
		long unsigned int runnable_avg;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	} removed;
};

typedef void (*btf_trace_pelt_rt_tp)(void *, struct rq *);

struct rt_prio_array {
	long unsigned int bitmap[4];
	struct list_head queue[100];
};

struct rt_rq {
	struct rt_prio_array active;
	unsigned int rt_nr_running;
	unsigned int rr_nr_running;
	struct {
		int curr;
		int next;
	} highest_prio;
	unsigned int rt_nr_migratory;
	unsigned int rt_nr_total;
	int overloaded;
	struct plist_head pushable_tasks;
	int rt_queued;
	int rt_throttled;
	int: 32;
	u64 rt_time;
	u64 rt_runtime;
	raw_spinlock_t rt_runtime_lock;
	int: 32;
};

struct dl_rq {
	struct rb_root_cached root;
	unsigned int dl_nr_running;
	int: 32;
	struct {
		u64 curr;
		u64 next;
	} earliest_dl;
	unsigned int dl_nr_migratory;
	int overloaded;
	struct rb_root_cached pushable_dl_tasks_root;
	u64 running_bw;
	u64 this_bw;
	u64 extra_bw;
	u64 bw_ratio;
};

typedef int (*cpu_stop_fn_t)(void *);

struct cpu_stop_done;

struct cpu_stop_work {
	struct list_head list;
	cpu_stop_fn_t fn;
	long unsigned int caller;
	void *arg;
	struct cpu_stop_done *done;
};

struct balance_callback;

struct rq {
	raw_spinlock_t __lock;
	unsigned int nr_running;
	long unsigned int last_blocked_load_update_tick;
	unsigned int has_blocked_load;
	call_single_data_t nohz_csd;
	unsigned int nohz_tick_stopped;
	atomic_t nohz_flags;
	unsigned int ttwu_pending;
	int: 32;
	u64 nr_switches;
	int: 32;
	int: 32;
	struct cfs_rq cfs;
	struct rt_rq rt;
	struct dl_rq dl;
	unsigned int nr_uninterruptible;
	struct task_struct *curr;
	struct task_struct *idle;
	struct task_struct *stop;
	long unsigned int next_balance;
	struct mm_struct *prev_mm;
	unsigned int clock_update_flags;
	int: 32;
	u64 clock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u64 clock_task;
	u64 clock_pelt;
	long unsigned int lost_idle_time;
	int: 32;
	u64 clock_pelt_idle;
	u64 clock_idle;
	u64 clock_pelt_idle_copy;
	u64 clock_idle_copy;
	atomic_t nr_iowait;
	int membarrier_state;
	struct root_domain *rd;
	struct sched_domain *sd;
	long unsigned int cpu_capacity;
	long unsigned int cpu_capacity_orig;
	struct balance_callback *balance_callback;
	unsigned char nohz_idle_balance;
	unsigned char idle_balance;
	long unsigned int misfit_task_load;
	int active_balance;
	int push_cpu;
	struct cpu_stop_work active_balance_work;
	int cpu;
	int online;
	struct list_head cfs_tasks;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sched_avg avg_rt;
	struct sched_avg avg_dl;
	struct sched_avg avg_thermal;
	u64 idle_stamp;
	u64 avg_idle;
	long unsigned int wake_stamp;
	int: 32;
	u64 wake_avg_idle;
	u64 max_idle_balance_cost;
	struct rcuwait hotplug_wait;
	long unsigned int calc_load_update;
	long int calc_load_active;
	int: 32;
	int: 32;
	int: 32;
	call_single_data_t hrtick_csd;
	struct hrtimer hrtick_timer;
	ktime_t hrtick_time;
	struct cpuidle_state *idle_state;
	unsigned int nr_pinned;
	unsigned int push_busy;
	struct cpu_stop_work push_work;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef void (*btf_trace_pelt_dl_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_thermal_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_irq_tp)(void *, struct rq *);

typedef void (*btf_trace_pelt_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_cpu_capacity_tp)(void *, struct rq *);

typedef void (*btf_trace_sched_overutilized_tp)(void *, struct root_domain *, bool);

typedef void (*btf_trace_sched_util_est_cfs_tp)(void *, struct cfs_rq *);

typedef void (*btf_trace_sched_util_est_se_tp)(void *, struct sched_entity *);

typedef void (*btf_trace_sched_update_nr_running_tp)(void *, struct rq *, int);

struct cpudl_item {
	u64 dl;
	int cpu;
	int idx;
};

struct rt_bandwidth {
	raw_spinlock_t rt_runtime_lock;
	int: 32;
	ktime_t rt_period;
	u64 rt_runtime;
	struct hrtimer rt_period_timer;
	unsigned int rt_period_active;
	int: 32;
};

struct perf_domain {
	struct em_perf_domain *em_pd;
	struct perf_domain *next;
	struct callback_head rcu;
};

struct balance_callback {
	struct balance_callback *next;
	void (*func)(struct rq *);
};

struct rq_flags {
	long unsigned int flags;
	struct pin_cookie cookie;
};

enum {
	__SCHED_FEAT_GENTLE_FAIR_SLEEPERS = 0,
	__SCHED_FEAT_START_DEBIT = 1,
	__SCHED_FEAT_NEXT_BUDDY = 2,
	__SCHED_FEAT_LAST_BUDDY = 3,
	__SCHED_FEAT_CACHE_HOT_BUDDY = 4,
	__SCHED_FEAT_WAKEUP_PREEMPTION = 5,
	__SCHED_FEAT_HRTICK = 6,
	__SCHED_FEAT_HRTICK_DL = 7,
	__SCHED_FEAT_DOUBLE_TICK = 8,
	__SCHED_FEAT_NONTASK_CAPACITY = 9,
	__SCHED_FEAT_TTWU_QUEUE = 10,
	__SCHED_FEAT_SIS_PROP = 11,
	__SCHED_FEAT_SIS_UTIL = 12,
	__SCHED_FEAT_WARN_DOUBLE_CLOCK = 13,
	__SCHED_FEAT_RT_PUSH_IPI = 14,
	__SCHED_FEAT_RT_RUNTIME_SHARE = 15,
	__SCHED_FEAT_LB_MIN = 16,
	__SCHED_FEAT_ATTACH_AGE_LOAD = 17,
	__SCHED_FEAT_WA_IDLE = 18,
	__SCHED_FEAT_WA_WEIGHT = 19,
	__SCHED_FEAT_WA_BIAS = 20,
	__SCHED_FEAT_UTIL_EST = 21,
	__SCHED_FEAT_UTIL_EST_FASTUP = 22,
	__SCHED_FEAT_LATENCY_WARN = 23,
	__SCHED_FEAT_ALT_PERIOD = 24,
	__SCHED_FEAT_BASE_SLICE = 25,
	__SCHED_FEAT_NR = 26,
};

enum cpu_util_type {
	FREQUENCY_UTIL = 0,
	ENERGY_UTIL = 1,
};

struct io_uring_sqe {
	__u8 opcode;
	__u8 flags;
	__u16 ioprio;
	__s32 fd;
	union {
		__u64 off;
		__u64 addr2;
		struct {
			__u32 cmd_op;
			__u32 __pad1;
		};
	};
	union {
		__u64 addr;
		__u64 splice_off_in;
	};
	__u32 len;
	union {
		__kernel_rwf_t rw_flags;
		__u32 fsync_flags;
		__u16 poll_events;
		__u32 poll32_events;
		__u32 sync_range_flags;
		__u32 msg_flags;
		__u32 timeout_flags;
		__u32 accept_flags;
		__u32 cancel_flags;
		__u32 open_flags;
		__u32 statx_flags;
		__u32 fadvise_advice;
		__u32 splice_flags;
		__u32 rename_flags;
		__u32 unlink_flags;
		__u32 hardlink_flags;
		__u32 xattr_flags;
		__u32 msg_ring_flags;
		__u32 uring_cmd_flags;
	};
	__u64 user_data;
	union {
		__u16 buf_index;
		__u16 buf_group;
	};
	__u16 personality;
	union {
		__s32 splice_fd_in;
		__u32 file_index;
		struct {
			__u16 addr_len;
			__u16 __pad3[1];
		};
	};
	union {
		struct {
			__u64 addr3;
			__u64 __pad2[1];
		};
		__u8 cmd[0];
	};
};

enum {
	IOSQE_FIXED_FILE_BIT = 0,
	IOSQE_IO_DRAIN_BIT = 1,
	IOSQE_IO_LINK_BIT = 2,
	IOSQE_IO_HARDLINK_BIT = 3,
	IOSQE_ASYNC_BIT = 4,
	IOSQE_BUFFER_SELECT_BIT = 5,
	IOSQE_CQE_SKIP_SUCCESS_BIT = 6,
};

enum io_uring_op {
	IORING_OP_NOP = 0,
	IORING_OP_READV = 1,
	IORING_OP_WRITEV = 2,
	IORING_OP_FSYNC = 3,
	IORING_OP_READ_FIXED = 4,
	IORING_OP_WRITE_FIXED = 5,
	IORING_OP_POLL_ADD = 6,
	IORING_OP_POLL_REMOVE = 7,
	IORING_OP_SYNC_FILE_RANGE = 8,
	IORING_OP_SENDMSG = 9,
	IORING_OP_RECVMSG = 10,
	IORING_OP_TIMEOUT = 11,
	IORING_OP_TIMEOUT_REMOVE = 12,
	IORING_OP_ACCEPT = 13,
	IORING_OP_ASYNC_CANCEL = 14,
	IORING_OP_LINK_TIMEOUT = 15,
	IORING_OP_CONNECT = 16,
	IORING_OP_FALLOCATE = 17,
	IORING_OP_OPENAT = 18,
	IORING_OP_CLOSE = 19,
	IORING_OP_FILES_UPDATE = 20,
	IORING_OP_STATX = 21,
	IORING_OP_READ = 22,
	IORING_OP_WRITE = 23,
	IORING_OP_FADVISE = 24,
	IORING_OP_MADVISE = 25,
	IORING_OP_SEND = 26,
	IORING_OP_RECV = 27,
	IORING_OP_OPENAT2 = 28,
	IORING_OP_EPOLL_CTL = 29,
	IORING_OP_SPLICE = 30,
	IORING_OP_PROVIDE_BUFFERS = 31,
	IORING_OP_REMOVE_BUFFERS = 32,
	IORING_OP_TEE = 33,
	IORING_OP_SHUTDOWN = 34,
	IORING_OP_RENAMEAT = 35,
	IORING_OP_UNLINKAT = 36,
	IORING_OP_MKDIRAT = 37,
	IORING_OP_SYMLINKAT = 38,
	IORING_OP_LINKAT = 39,
	IORING_OP_MSG_RING = 40,
	IORING_OP_FSETXATTR = 41,
	IORING_OP_SETXATTR = 42,
	IORING_OP_FGETXATTR = 43,
	IORING_OP_GETXATTR = 44,
	IORING_OP_SOCKET = 45,
	IORING_OP_URING_CMD = 46,
	IORING_OP_SEND_ZC = 47,
	IORING_OP_SENDMSG_ZC = 48,
	IORING_OP_LAST = 49,
};

struct io_uring_cqe {
	__u64 user_data;
	__s32 res;
	__u32 flags;
	__u64 big_cqe[0];
};

enum {
	IORING_REGISTER_BUFFERS = 0,
	IORING_UNREGISTER_BUFFERS = 1,
	IORING_REGISTER_FILES = 2,
	IORING_UNREGISTER_FILES = 3,
	IORING_REGISTER_EVENTFD = 4,
	IORING_UNREGISTER_EVENTFD = 5,
	IORING_REGISTER_FILES_UPDATE = 6,
	IORING_REGISTER_EVENTFD_ASYNC = 7,
	IORING_REGISTER_PROBE = 8,
	IORING_REGISTER_PERSONALITY = 9,
	IORING_UNREGISTER_PERSONALITY = 10,
	IORING_REGISTER_RESTRICTIONS = 11,
	IORING_REGISTER_ENABLE_RINGS = 12,
	IORING_REGISTER_FILES2 = 13,
	IORING_REGISTER_FILES_UPDATE2 = 14,
	IORING_REGISTER_BUFFERS2 = 15,
	IORING_REGISTER_BUFFERS_UPDATE = 16,
	IORING_REGISTER_IOWQ_AFF = 17,
	IORING_UNREGISTER_IOWQ_AFF = 18,
	IORING_REGISTER_IOWQ_MAX_WORKERS = 19,
	IORING_REGISTER_RING_FDS = 20,
	IORING_UNREGISTER_RING_FDS = 21,
	IORING_REGISTER_PBUF_RING = 22,
	IORING_UNREGISTER_PBUF_RING = 23,
	IORING_REGISTER_SYNC_CANCEL = 24,
	IORING_REGISTER_FILE_ALLOC_RANGE = 25,
	IORING_REGISTER_LAST = 26,
};

struct io_wq_work_node {
	struct io_wq_work_node *next;
};

struct io_wq_work_list {
	struct io_wq_work_node *first;
	struct io_wq_work_node *last;
};

struct io_wq_work {
	struct io_wq_work_node list;
	unsigned int flags;
	int cancel_seq;
};

struct io_fixed_file {
	long unsigned int file_ptr;
};

struct io_file_table {
	struct io_fixed_file *files;
	long unsigned int *bitmap;
	unsigned int alloc_hint;
};

struct io_hash_bucket {
	spinlock_t lock;
	struct hlist_head list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct io_hash_table {
	struct io_hash_bucket *hbs;
	unsigned int hash_bits;
};

struct io_kiocb;

struct io_submit_link {
	struct io_kiocb *head;
	struct io_kiocb *last;
};

struct io_submit_state {
	struct io_wq_work_node free_list;
	struct io_wq_work_list compl_reqs;
	struct io_submit_link link;
	bool plug_started;
	bool need_plug;
	short unsigned int submit_nr;
	struct blk_plug plug;
};

struct io_alloc_cache {
	struct hlist_head list;
	unsigned int nr_cached;
};

struct io_restriction {
	long unsigned int register_op[1];
	long unsigned int sqe_op[2];
	u8 sqe_flags_allowed;
	u8 sqe_flags_required;
	bool registered;
};

struct io_rings;

struct io_rsrc_node;

struct io_mapped_ubuf;

struct io_buffer_list;

struct io_sq_data;

struct io_ev_fd;

struct io_rsrc_data;

struct io_wq_hash;

struct io_ring_ctx {
	struct {
		struct percpu_ref refs;
		struct io_rings *rings;
		unsigned int flags;
		enum task_work_notify_mode notify_method;
		unsigned int compat: 1;
		unsigned int drain_next: 1;
		unsigned int restricted: 1;
		unsigned int off_timeout_used: 1;
		unsigned int drain_active: 1;
		unsigned int drain_disabled: 1;
		unsigned int has_evfd: 1;
		unsigned int syscall_iopoll: 1;
		int: 24;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		struct mutex uring_lock;
		u32 *sq_array;
		struct io_uring_sqe *sq_sqes;
		unsigned int cached_sq_head;
		unsigned int sq_entries;
		struct io_rsrc_node *rsrc_node;
		int rsrc_cached_refs;
		atomic_t cancel_seq;
		struct io_file_table file_table;
		unsigned int nr_user_files;
		unsigned int nr_user_bufs;
		struct io_mapped_ubuf **user_bufs;
		struct io_submit_state submit_state;
		struct io_buffer_list *io_bl;
		struct xarray io_bl_xa;
		struct list_head io_buffers_cache;
		struct io_hash_table cancel_table_locked;
		struct list_head cq_overflow_list;
		struct io_alloc_cache apoll_cache;
		struct io_alloc_cache netmsg_cache;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct io_wq_work_list locked_free_list;
	unsigned int locked_free_nr;
	const struct cred *sq_creds;
	struct io_sq_data *sq_data;
	struct wait_queue_head sqo_sq_wait;
	struct list_head sqd_list;
	long unsigned int check_cq;
	unsigned int file_alloc_start;
	unsigned int file_alloc_end;
	struct xarray personalities;
	u32 pers_next;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct {
		struct io_uring_cqe *cqe_cached;
		struct io_uring_cqe *cqe_sentinel;
		unsigned int cached_cq_tail;
		unsigned int cq_entries;
		struct io_ev_fd *io_ev_fd;
		struct wait_queue_head cq_wait;
		unsigned int cq_extra;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		spinlock_t completion_lock;
		struct io_wq_work_list iopoll_list;
		struct io_hash_table cancel_table;
		bool poll_multi_queue;
		struct llist_head work_llist;
		struct list_head io_buffers_comp;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		spinlock_t timeout_lock;
		atomic_t cq_timeouts;
		struct list_head timeout_list;
		struct list_head ltimeout_list;
		unsigned int cq_last_tm_flush;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct io_restriction restrictions;
	struct task_struct *submitter_task;
	struct io_rsrc_node *rsrc_backup_node;
	struct io_mapped_ubuf *dummy_ubuf;
	struct io_rsrc_data *file_data;
	struct io_rsrc_data *buf_data;
	struct delayed_work rsrc_put_work;
	struct llist_head rsrc_put_llist;
	struct list_head rsrc_ref_list;
	spinlock_t rsrc_ref_lock;
	struct list_head io_buffers_pages;
	struct socket *ring_sock;
	struct io_wq_hash *hash_map;
	struct user_struct *user;
	struct mm_struct *mm_account;
	struct llist_head fallback_llist;
	struct delayed_work fallback_work;
	struct work_struct exit_work;
	struct list_head tctx_list;
	struct completion ref_comp;
	u32 iowq_limits[2];
	bool iowq_limits_set;
	struct list_head defer_list;
	unsigned int sq_thread_idle;
	unsigned int evfd_last_cq_tail;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct io_uring {
	u32 head;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u32 tail;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct io_rings {
	struct io_uring sq;
	struct io_uring cq;
	u32 sq_ring_mask;
	u32 cq_ring_mask;
	u32 sq_ring_entries;
	u32 cq_ring_entries;
	u32 sq_dropped;
	atomic_t sq_flags;
	u32 cq_flags;
	u32 cq_overflow;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct io_uring_cqe cqes[0];
};

struct io_cmd_data {
	struct file *file;
	__u8 data[56];
};

struct io_cqe {
	__u64 user_data;
	__s32 res;
	union {
		__u32 flags;
		int fd;
	};
};

typedef void (*io_req_tw_func_t)(struct io_kiocb *, bool *);

struct io_task_work {
	struct llist_node node;
	io_req_tw_func_t func;
};

struct io_buffer;

struct async_poll;

struct io_kiocb {
	union {
		struct file *file;
		struct io_cmd_data cmd;
	};
	u8 opcode;
	u8 iopoll_completed;
	u16 buf_index;
	unsigned int flags;
	int: 32;
	struct io_cqe cqe;
	struct io_ring_ctx *ctx;
	struct task_struct *task;
	struct io_rsrc_node *rsrc_node;
	union {
		struct io_mapped_ubuf *imu;
		struct io_buffer *kbuf;
		struct io_buffer_list *buf_list;
	};
	union {
		struct io_wq_work_node comp_list;
		__poll_t apoll_events;
	};
	atomic_t refs;
	atomic_t poll_refs;
	struct io_task_work io_task_work;
	int: 32;
	union {
		struct hlist_node hash_node;
		struct {
			u64 extra1;
			u64 extra2;
		};
	};
	struct async_poll *apoll;
	void *async_data;
	struct io_kiocb *link;
	const struct cred *creds;
	struct io_wq_work work;
	int: 32;
};

struct io_ev_fd {
	struct eventfd_ctx *cq_ev_fd;
	unsigned int eventfd_async: 1;
	struct callback_head rcu;
	atomic_t refs;
	atomic_t ops;
};

struct io_wq_hash {
	refcount_t refs;
	long unsigned int map;
	struct wait_queue_head wait;
};

enum {
	REQ_F_FIXED_FILE_BIT = 0,
	REQ_F_IO_DRAIN_BIT = 1,
	REQ_F_LINK_BIT = 2,
	REQ_F_HARDLINK_BIT = 3,
	REQ_F_FORCE_ASYNC_BIT = 4,
	REQ_F_BUFFER_SELECT_BIT = 5,
	REQ_F_CQE_SKIP_BIT = 6,
	REQ_F_FAIL_BIT = 8,
	REQ_F_INFLIGHT_BIT = 9,
	REQ_F_CUR_POS_BIT = 10,
	REQ_F_NOWAIT_BIT = 11,
	REQ_F_LINK_TIMEOUT_BIT = 12,
	REQ_F_NEED_CLEANUP_BIT = 13,
	REQ_F_POLLED_BIT = 14,
	REQ_F_BUFFER_SELECTED_BIT = 15,
	REQ_F_BUFFER_RING_BIT = 16,
	REQ_F_REISSUE_BIT = 17,
	REQ_F_CREDS_BIT = 18,
	REQ_F_REFCOUNT_BIT = 19,
	REQ_F_ARM_LTIMEOUT_BIT = 20,
	REQ_F_ASYNC_DATA_BIT = 21,
	REQ_F_SKIP_LINK_CQES_BIT = 22,
	REQ_F_SINGLE_POLL_BIT = 23,
	REQ_F_DOUBLE_POLL_BIT = 24,
	REQ_F_PARTIAL_IO_BIT = 25,
	REQ_F_CQE32_INIT_BIT = 26,
	REQ_F_APOLL_MULTISHOT_BIT = 27,
	REQ_F_CLEAR_POLLIN_BIT = 28,
	REQ_F_HASH_LOCKED_BIT = 29,
	REQ_F_SUPPORT_NOWAIT_BIT = 30,
	REQ_F_ISREG_BIT = 31,
	__REQ_F_LAST_BIT = 32,
};

struct set_affinity_pending;

struct migration_arg {
	struct task_struct *task;
	int dest_cpu;
	struct set_affinity_pending *pending;
};

struct set_affinity_pending {
	refcount_t refs;
	unsigned int stop_pending;
	struct completion done;
	struct cpu_stop_work stop_work;
	struct migration_arg arg;
};

enum {
	cpuset = 0,
	possible = 1,
	fail = 2,
};

struct update_util_data {
	void (*func)(struct update_util_data *, u64, unsigned int);
};

enum cpu_idle_type {
	CPU_IDLE = 0,
	CPU_NOT_IDLE = 1,
	CPU_NEWLY_IDLE = 2,
	CPU_MAX_IDLE_TYPES = 3,
};

enum {
	SD_BALANCE_NEWIDLE = 1,
	SD_BALANCE_EXEC = 2,
	SD_BALANCE_FORK = 4,
	SD_BALANCE_WAKE = 8,
	SD_WAKE_AFFINE = 16,
	SD_ASYM_CPUCAPACITY = 32,
	SD_ASYM_CPUCAPACITY_FULL = 64,
	SD_SHARE_CPUCAPACITY = 128,
	SD_SHARE_PKG_RESOURCES = 256,
	SD_SERIALIZE = 512,
	SD_ASYM_PACKING = 1024,
	SD_PREFER_SIBLING = 2048,
	SD_OVERLAP = 4096,
	SD_NUMA = 8192,
};

enum sched_tunable_scaling {
	SCHED_TUNABLESCALING_NONE = 0,
	SCHED_TUNABLESCALING_LOG = 1,
	SCHED_TUNABLESCALING_LINEAR = 2,
	SCHED_TUNABLESCALING_END = 3,
};

struct cfs_bandwidth {};

struct energy_env {
	long unsigned int task_busy_time;
	long unsigned int pd_busy_time;
	long unsigned int cpu_cap;
	long unsigned int pd_cap;
};

enum fbq_type {
	regular = 0,
	remote = 1,
	all = 2,
};

enum group_type {
	group_has_spare = 0,
	group_fully_busy = 1,
	group_misfit_task = 2,
	group_asym_packing = 3,
	group_imbalanced = 4,
	group_overloaded = 5,
};

enum migration_type {
	migrate_load = 0,
	migrate_util = 1,
	migrate_task = 2,
	migrate_misfit = 3,
};

struct lb_env {
	struct sched_domain *sd;
	struct rq *src_rq;
	int src_cpu;
	int dst_cpu;
	struct rq *dst_rq;
	struct cpumask *dst_grpmask;
	int new_dst_cpu;
	enum cpu_idle_type idle;
	long int imbalance;
	struct cpumask *cpus;
	unsigned int flags;
	unsigned int loop;
	unsigned int loop_break;
	unsigned int loop_max;
	enum fbq_type fbq_type;
	enum migration_type migration_type;
	struct list_head tasks;
};

struct sg_lb_stats {
	long unsigned int avg_load;
	long unsigned int group_load;
	long unsigned int group_capacity;
	long unsigned int group_util;
	long unsigned int group_runnable;
	unsigned int sum_nr_running;
	unsigned int sum_h_nr_running;
	unsigned int idle_cpus;
	unsigned int group_weight;
	enum group_type group_type;
	unsigned int group_asym_packing;
	long unsigned int group_misfit_task_load;
};

struct sd_lb_stats {
	struct sched_group *busiest;
	struct sched_group *local;
	long unsigned int total_load;
	long unsigned int total_capacity;
	long unsigned int avg_load;
	unsigned int prefer_sibling;
	struct sg_lb_stats busiest_stat;
	struct sg_lb_stats local_stat;
};

struct task_group;

enum s2idle_states {
	S2IDLE_STATE_NONE = 0,
	S2IDLE_STATE_ENTER = 1,
	S2IDLE_STATE_WAKE = 2,
};

struct dl_bandwidth {
	raw_spinlock_t dl_runtime_lock;
	int: 32;
	u64 dl_runtime;
	u64 dl_period;
};

struct idle_timer {
	struct hrtimer timer;
	int done;
	int: 32;
};

typedef struct rt_rq *rt_rq_iter_t;

struct swait_queue {
	struct task_struct *task;
	struct list_head task_list;
};

enum {
	MEMBARRIER_FLAG_SYNC_CORE = 1,
	MEMBARRIER_FLAG_RSEQ = 2,
};

struct sched_domain_attr {
	int relax_domain_level;
};

typedef const struct cpumask * (*sched_domain_mask_f)(int);

typedef int (*sched_domain_flags_f)();

struct sd_data {
	struct sched_domain **sd;
	struct sched_domain_shared **sds;
	struct sched_group **sg;
	struct sched_group_capacity **sgc;
};

struct sched_domain_topology_level {
	sched_domain_mask_f mask;
	sched_domain_flags_f sd_flags;
	int flags;
	int numa_level;
	struct sd_data data;
};

typedef int wait_bit_action_f(struct wait_bit_key *, int);

enum membarrier_cmd {
	MEMBARRIER_CMD_QUERY = 0,
	MEMBARRIER_CMD_GLOBAL = 1,
	MEMBARRIER_CMD_GLOBAL_EXPEDITED = 2,
	MEMBARRIER_CMD_REGISTER_GLOBAL_EXPEDITED = 4,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED = 8,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED = 16,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_SYNC_CORE = 32,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_SYNC_CORE = 64,
	MEMBARRIER_CMD_PRIVATE_EXPEDITED_RSEQ = 128,
	MEMBARRIER_CMD_REGISTER_PRIVATE_EXPEDITED_RSEQ = 256,
	MEMBARRIER_CMD_SHARED = 1,
};

enum membarrier_cmd_flag {
	MEMBARRIER_CMD_FLAG_CPU = 1,
};

struct s_data {
	struct sched_domain **sd;
	struct root_domain *rd;
};

enum s_alloc {
	sa_rootdomain = 0,
	sa_sd = 1,
	sa_sd_storage = 2,
	sa_none = 3,
};

struct asym_cap_data {
	struct list_head link;
	long unsigned int capacity;
	long unsigned int cpus[0];
};

enum hk_flags {
	HK_FLAG_TIMER = 1,
	HK_FLAG_RCU = 2,
	HK_FLAG_MISC = 4,
	HK_FLAG_SCHED = 8,
	HK_FLAG_TICK = 16,
	HK_FLAG_DOMAIN = 32,
	HK_FLAG_WQ = 64,
	HK_FLAG_MANAGED_IRQ = 128,
	HK_FLAG_KTHREAD = 256,
};

struct housekeeping {
	struct cpumask cpumasks[9];
	long unsigned int flags;
};

struct trace_event_raw_contention_begin {
	struct trace_entry ent;
	void *lock_addr;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_contention_end {
	struct trace_entry ent;
	void *lock_addr;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_contention_begin {};

struct trace_event_data_offsets_contention_end {};

typedef void (*btf_trace_contention_begin)(void *, void *, unsigned int);

typedef void (*btf_trace_contention_end)(void *, void *, int);

struct mutex_waiter {
	struct list_head list;
	struct task_struct *task;
	struct ww_acquire_ctx *ww_ctx;
};

struct semaphore {
	raw_spinlock_t lock;
	unsigned int count;
	struct list_head wait_list;
};

struct semaphore_waiter {
	struct list_head list;
	struct task_struct *task;
	bool up;
};

enum rwsem_waiter_type {
	RWSEM_WAITING_FOR_WRITE = 0,
	RWSEM_WAITING_FOR_READ = 1,
};

struct rwsem_waiter {
	struct list_head list;
	struct task_struct *task;
	enum rwsem_waiter_type type;
	long unsigned int timeout;
	bool handoff_set;
};

enum rwsem_wake_type {
	RWSEM_WAKE_ANY = 0,
	RWSEM_WAKE_READERS = 1,
	RWSEM_WAKE_READ_OWNED = 2,
};

enum owner_state {
	OWNER_NULL = 1,
	OWNER_WRITER = 2,
	OWNER_READER = 4,
	OWNER_NONSPINNABLE = 8,
};

struct optimistic_spin_node {
	struct optimistic_spin_node *next;
	struct optimistic_spin_node *prev;
	int locked;
	int cpu;
};

struct hrtimer_sleeper {
	struct hrtimer timer;
	struct task_struct *task;
	int: 32;
};

struct rt_mutex_base;

struct rt_mutex_waiter {
	struct rb_node tree_entry;
	struct rb_node pi_tree_entry;
	struct task_struct *task;
	struct rt_mutex_base *lock;
	unsigned int wake_state;
	int prio;
	u64 deadline;
	struct ww_acquire_ctx *ww_ctx;
	int: 32;
};

struct rt_mutex_base {
	raw_spinlock_t wait_lock;
	struct rb_root_cached waiters;
	struct task_struct *owner;
};

struct rt_mutex {
	struct rt_mutex_base rtmutex;
};

struct rt_wake_q_head {
	struct wake_q_head head;
	struct task_struct *rtlock_task;
};

enum rtmutex_chainwalk {
	RT_MUTEX_MIN_CHAINWALK = 0,
	RT_MUTEX_FULL_CHAINWALK = 1,
};

enum pm_qos_req_action {
	PM_QOS_ADD_REQ = 0,
	PM_QOS_UPDATE_REQ = 1,
	PM_QOS_REMOVE_REQ = 2,
};

struct miscdevice {
	int minor;
	const char *name;
	const struct file_operations *fops;
	struct list_head list;
	struct device *parent;
	struct device *this_device;
	const struct attribute_group **groups;
	const char *nodename;
	umode_t mode;
};

enum suspend_stat_step {
	SUSPEND_FREEZE = 1,
	SUSPEND_PREPARE = 2,
	SUSPEND_SUSPEND = 3,
	SUSPEND_SUSPEND_LATE = 4,
	SUSPEND_SUSPEND_NOIRQ = 5,
	SUSPEND_RESUME_NOIRQ = 6,
	SUSPEND_RESUME_EARLY = 7,
	SUSPEND_RESUME = 8,
};

struct suspend_stats {
	int success;
	int fail;
	int failed_freeze;
	int failed_prepare;
	int failed_suspend;
	int failed_suspend_late;
	int failed_suspend_noirq;
	int failed_resume;
	int failed_resume_early;
	int failed_resume_noirq;
	int last_failed_dev;
	char failed_devs[80];
	int last_failed_errno;
	int errno[2];
	int last_failed_step;
	enum suspend_stat_step failed_steps[2];
};

enum {
	TEST_NONE = 0,
	TEST_CORE = 1,
	TEST_CPUS = 2,
	TEST_PLATFORM = 3,
	TEST_DEVICES = 4,
	TEST_FREEZER = 5,
	__TEST_AFTER_LAST = 6,
};

struct pm_vt_switch {
	struct list_head head;
	struct device *dev;
	bool required;
};

struct platform_s2idle_ops {
	int (*begin)();
	int (*prepare)();
	int (*prepare_late)();
	void (*check)();
	bool (*wake)();
	void (*restore_early)();
	void (*restore)();
	void (*end)();
};

typedef __u64 timeu64_t;

struct rtc_time {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	int tm_year;
	int tm_wday;
	int tm_yday;
	int tm_isdst;
};

struct rtc_wkalrm {
	unsigned char enabled;
	unsigned char pending;
	struct rtc_time time;
};

struct rtc_param {
	__u64 param;
	union {
		__u64 uvalue;
		__s64 svalue;
		__u64 ptr;
	};
	__u32 index;
	__u32 __pad;
};

struct rtc_class_ops {
	int (*ioctl)(struct device *, unsigned int, long unsigned int);
	int (*read_time)(struct device *, struct rtc_time *);
	int (*set_time)(struct device *, struct rtc_time *);
	int (*read_alarm)(struct device *, struct rtc_wkalrm *);
	int (*set_alarm)(struct device *, struct rtc_wkalrm *);
	int (*proc)(struct device *, struct seq_file *);
	int (*alarm_irq_enable)(struct device *, unsigned int);
	int (*read_offset)(struct device *, long int *);
	int (*set_offset)(struct device *, long int);
	int (*param_get)(struct device *, struct rtc_param *);
	int (*param_set)(struct device *, struct rtc_param *);
};

struct rtc_device;

struct rtc_timer {
	struct timerqueue_node node;
	ktime_t period;
	void (*func)(struct rtc_device *);
	struct rtc_device *rtc;
	int enabled;
	int: 32;
};

struct rtc_device {
	struct device dev;
	struct module *owner;
	int id;
	const struct rtc_class_ops *ops;
	struct mutex ops_lock;
	struct cdev char_dev;
	long unsigned int flags;
	long unsigned int irq_data;
	spinlock_t irq_lock;
	wait_queue_head_t irq_queue;
	struct fasync_struct *async_queue;
	int irq_freq;
	int max_user_freq;
	struct timerqueue_head timerqueue;
	struct rtc_timer aie_timer;
	struct rtc_timer uie_rtctimer;
	struct hrtimer pie_timer;
	int pie_enabled;
	struct work_struct irqwork;
	long unsigned int set_offset_nsec;
	long unsigned int features[1];
	int: 32;
	time64_t range_min;
	timeu64_t range_max;
	time64_t start_secs;
	time64_t offset_secs;
	bool set_start_time;
	struct work_struct uie_task;
	struct timer_list uie_timer;
	unsigned int oldsecs;
	unsigned int uie_irq_active: 1;
	unsigned int stop_uie_polling: 1;
	unsigned int uie_task_active: 1;
	unsigned int uie_timer_active: 1;
};

struct sysrq_key_op {
	void (* const handler)(int);
	const char * const help_msg;
	const char * const action_msg;
	const int enable_mask;
};

typedef unsigned int uint;

typedef struct {
	seqcount_t seqcount;
} seqcount_latch_t;

struct dev_printk_info {
	char subsystem[16];
	char device[48];
};

struct console {
	char name[16];
	void (*write)(struct console *, const char *, unsigned int);
	int (*read)(struct console *, char *, unsigned int);
	struct tty_driver * (*device)(struct console *, int *);
	void (*unblank)();
	int (*setup)(struct console *, char *);
	int (*exit)(struct console *);
	int (*match)(struct console *, char *, int, char *);
	short int flags;
	short int index;
	int cflag;
	uint ispeed;
	uint ospeed;
	int: 32;
	u64 seq;
	long unsigned int dropped;
	void *data;
	struct console *next;
	int: 32;
};

struct kmsg_dump_iter {
	u64 cur_seq;
	u64 next_seq;
};

struct kmsg_dumper {
	struct list_head list;
	void (*dump)(struct kmsg_dumper *, enum kmsg_dump_reason);
	enum kmsg_dump_reason max_reason;
	bool registered;
};

struct trace_event_raw_console {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_console {
	u32 msg;
};

typedef void (*btf_trace_console)(void *, const char *, size_t);

struct printk_info {
	u64 seq;
	u64 ts_nsec;
	u16 text_len;
	u8 facility;
	u8 flags: 5;
	u8 level: 3;
	u32 caller_id;
	struct dev_printk_info dev_info;
};

struct printk_record {
	struct printk_info *info;
	char *text_buf;
	unsigned int text_buf_size;
};

struct prb_data_blk_lpos {
	long unsigned int begin;
	long unsigned int next;
};

struct prb_desc {
	atomic_long_t state_var;
	struct prb_data_blk_lpos text_blk_lpos;
};

struct prb_data_ring {
	unsigned int size_bits;
	char *data;
	atomic_long_t head_lpos;
	atomic_long_t tail_lpos;
};

struct prb_desc_ring {
	unsigned int count_bits;
	struct prb_desc *descs;
	struct printk_info *infos;
	atomic_long_t head_id;
	atomic_long_t tail_id;
	atomic_long_t last_finalized_id;
};

struct printk_ringbuffer {
	struct prb_desc_ring desc_ring;
	struct prb_data_ring text_data_ring;
	atomic_long_t fail;
};

struct prb_reserved_entry {
	struct printk_ringbuffer *rb;
	long unsigned int irqflags;
	long unsigned int id;
	unsigned int text_space;
};

enum desc_state {
	desc_miss = 4294967295,
	desc_reserved = 0,
	desc_committed = 1,
	desc_finalized = 2,
	desc_reusable = 3,
};

struct console_cmdline {
	char name[16];
	int index;
	bool user_specified;
	char *options;
};

enum printk_info_flags {
	LOG_NEWLINE = 2,
	LOG_CONT = 8,
};

enum devkmsg_log_bits {
	__DEVKMSG_LOG_BIT_ON = 0,
	__DEVKMSG_LOG_BIT_OFF = 1,
	__DEVKMSG_LOG_BIT_LOCK = 2,
};

enum devkmsg_log_masks {
	DEVKMSG_LOG_MASK_ON = 1,
	DEVKMSG_LOG_MASK_OFF = 2,
	DEVKMSG_LOG_MASK_LOCK = 4,
};

enum con_msg_format_flags {
	MSG_FORMAT_DEFAULT = 0,
	MSG_FORMAT_SYSLOG = 1,
};

struct latched_seq {
	seqcount_latch_t latch;
	int: 32;
	u64 val[2];
};

struct devkmsg_user {
	atomic64_t seq;
	struct ratelimit_state rs;
	struct mutex lock;
	char buf[8192];
	struct printk_info info;
	char text_buf[8192];
	struct printk_record record;
	int: 32;
};

struct prb_data_block {
	long unsigned int id;
	char data[0];
};

struct irq_affinity_desc {
	struct cpumask mask;
	unsigned int is_managed: 1;
};

enum {
	IRQS_AUTODETECT = 1,
	IRQS_SPURIOUS_DISABLED = 2,
	IRQS_POLL_INPROGRESS = 8,
	IRQS_ONESHOT = 32,
	IRQS_REPLAY = 64,
	IRQS_WAITING = 128,
	IRQS_PENDING = 512,
	IRQS_SUSPENDED = 2048,
	IRQS_TIMINGS = 4096,
	IRQS_NMI = 8192,
};

enum {
	_IRQ_DEFAULT_INIT_FLAGS = 3072,
	_IRQ_PER_CPU = 512,
	_IRQ_LEVEL = 256,
	_IRQ_NOPROBE = 1024,
	_IRQ_NOREQUEST = 2048,
	_IRQ_NOTHREAD = 65536,
	_IRQ_NOAUTOEN = 4096,
	_IRQ_MOVE_PCNTXT = 16384,
	_IRQ_NO_BALANCING = 8192,
	_IRQ_NESTED_THREAD = 32768,
	_IRQ_PER_CPU_DEVID = 131072,
	_IRQ_IS_POLLED = 262144,
	_IRQ_DISABLE_UNLAZY = 524288,
	_IRQ_HIDDEN = 1048576,
	_IRQ_NO_DEBUG = 2097152,
	_IRQF_MODIFY_MASK = 2096911,
};

enum {
	IRQTF_RUNTHREAD = 0,
	IRQTF_WARNED = 1,
	IRQTF_AFFINITY = 2,
	IRQTF_FORCED_THREAD = 3,
	IRQTF_READY = 4,
};

enum {
	IRQ_SET_MASK_OK = 0,
	IRQ_SET_MASK_OK_NOCOPY = 1,
	IRQ_SET_MASK_OK_DONE = 2,
};

enum {
	IRQCHIP_SET_TYPE_MASKED = 1,
	IRQCHIP_EOI_IF_HANDLED = 2,
	IRQCHIP_MASK_ON_SUSPEND = 4,
	IRQCHIP_ONOFFLINE_ENABLED = 8,
	IRQCHIP_SKIP_SET_WAKE = 16,
	IRQCHIP_ONESHOT_SAFE = 32,
	IRQCHIP_EOI_THREADED = 64,
	IRQCHIP_SUPPORTS_LEVEL_MSI = 128,
	IRQCHIP_SUPPORTS_NMI = 256,
	IRQCHIP_ENABLE_WAKEUP_ON_SUSPEND = 512,
	IRQCHIP_AFFINITY_PRE_STARTUP = 1024,
	IRQCHIP_IMMUTABLE = 2048,
};

enum {
	IRQC_IS_HARDIRQ = 0,
	IRQC_IS_NESTED = 1,
};

struct arch_msi_msg_addr_lo {
	u32 address_lo;
};

typedef struct arch_msi_msg_addr_lo arch_msi_msg_addr_lo_t;

struct arch_msi_msg_addr_hi {
	u32 address_hi;
};

typedef struct arch_msi_msg_addr_hi arch_msi_msg_addr_hi_t;

struct arch_msi_msg_data {
	u32 data;
};

typedef struct arch_msi_msg_data arch_msi_msg_data_t;

struct msi_msg {
	union {
		u32 address_lo;
		arch_msi_msg_addr_lo_t arch_addr_lo;
	};
	union {
		u32 address_hi;
		arch_msi_msg_addr_hi_t arch_addr_hi;
	};
	union {
		u32 data;
		arch_msi_msg_data_t arch_data;
	};
};

struct pci_msi_desc {
	union {
		u32 msi_mask;
		u32 msix_ctrl;
	};
	struct {
		u8 is_msix: 1;
		u8 multiple: 3;
		u8 multi_cap: 3;
		u8 can_mask: 1;
		u8 is_64: 1;
		u8 is_virtual: 1;
		unsigned int default_irq;
	} msi_attrib;
	union {
		u8 mask_pos;
		void *mask_base;
	};
};

struct msi_desc {
	unsigned int irq;
	unsigned int nvec_used;
	struct device *dev;
	struct msi_msg msg;
	struct irq_affinity_desc *affinity;
	struct device_attribute *sysfs_attrs;
	void (*write_msi_msg)(struct msi_desc *, void *);
	void *write_msi_msg_data;
	u16 msi_index;
	struct pci_msi_desc pci;
};

struct platform_msi_priv_data;

struct msi_device_data {
	long unsigned int properties;
	struct platform_msi_priv_data *platform_data;
	struct mutex mutex;
	struct xarray __store;
	long unsigned int __iter_idx;
};

enum {
	IRQ_STARTUP_NORMAL = 0,
	IRQ_STARTUP_MANAGED = 1,
	IRQ_STARTUP_ABORT = 2,
};

struct irq_devres {
	unsigned int irq;
	void *dev_id;
};

struct irq_desc_devres {
	unsigned int from;
	unsigned int cnt;
};

struct irq_generic_chip_devres {
	struct irq_chip_generic *gc;
	u32 msk;
	unsigned int clr;
	unsigned int set;
};

struct syscore_ops {
	struct list_head node;
	int (*suspend)();
	void (*resume)();
	void (*shutdown)();
};

enum {
	IRQ_DOMAIN_FLAG_HIERARCHY = 1,
	IRQ_DOMAIN_NAME_ALLOCATED = 2,
	IRQ_DOMAIN_FLAG_IPI_PER_CPU = 4,
	IRQ_DOMAIN_FLAG_IPI_SINGLE = 8,
	IRQ_DOMAIN_FLAG_MSI = 16,
	IRQ_DOMAIN_FLAG_MSI_REMAP = 32,
	IRQ_DOMAIN_MSI_NOMASK_QUIRK = 64,
	IRQ_DOMAIN_FLAG_NO_MAP = 128,
	IRQ_DOMAIN_FLAG_NONCORE = 65536,
};

enum {
	IRQCHIP_FWNODE_REAL = 0,
	IRQCHIP_FWNODE_NAMED = 1,
	IRQCHIP_FWNODE_NAMED_ID = 2,
};

struct irqchip_fwid {
	struct fwnode_handle fwnode;
	unsigned int type;
	char *name;
	phys_addr_t *pa;
};

enum {
	AFFINITY = 0,
	AFFINITY_LIST = 1,
	EFFECTIVE = 2,
	EFFECTIVE_LIST = 3,
};

struct msi_alloc_info {
	struct msi_desc *desc;
	irq_hw_number_t hwirq;
	long unsigned int flags;
	union {
		long unsigned int ul;
		void *ptr;
	} scratchpad[2];
};

typedef struct msi_alloc_info msi_alloc_info_t;

enum msi_desc_filter {
	MSI_DESC_ALL = 0,
	MSI_DESC_NOTASSOCIATED = 1,
	MSI_DESC_ASSOCIATED = 2,
};

struct msi_domain_info;

struct msi_domain_ops {
	irq_hw_number_t (*get_hwirq)(struct msi_domain_info *, msi_alloc_info_t *);
	int (*msi_init)(struct irq_domain *, struct msi_domain_info *, unsigned int, irq_hw_number_t, msi_alloc_info_t *);
	void (*msi_free)(struct irq_domain *, struct msi_domain_info *, unsigned int);
	int (*msi_check)(struct irq_domain *, struct msi_domain_info *, struct device *);
	int (*msi_prepare)(struct irq_domain *, struct device *, int, msi_alloc_info_t *);
	void (*set_desc)(msi_alloc_info_t *, struct msi_desc *);
	int (*domain_alloc_irqs)(struct irq_domain *, struct device *, int);
	void (*domain_free_irqs)(struct irq_domain *, struct device *);
};

struct msi_domain_info {
	u32 flags;
	struct msi_domain_ops *ops;
	struct irq_chip *chip;
	void *chip_data;
	irq_flow_handler_t handler;
	void *handler_data;
	const char *handler_name;
	void *data;
};

enum {
	MSI_FLAG_USE_DEF_DOM_OPS = 1,
	MSI_FLAG_USE_DEF_CHIP_OPS = 2,
	MSI_FLAG_MULTI_PCI_MSI = 4,
	MSI_FLAG_PCI_MSIX = 8,
	MSI_FLAG_ACTIVATE_EARLY = 16,
	MSI_FLAG_MUST_REACTIVATE = 32,
	MSI_FLAG_LEVEL_CAPABLE = 64,
	MSI_FLAG_DEV_SYSFS = 128,
	MSI_FLAG_MSIX_CONTIGUOUS = 256,
	MSI_FLAG_ALLOC_SIMPLE_MSI_DESCS = 512,
	MSI_FLAG_FREE_MSI_DESCS = 1024,
};

struct irq_affinity {
	unsigned int pre_vectors;
	unsigned int post_vectors;
	unsigned int nr_sets;
	unsigned int set_size[4];
	void (*calc_sets)(struct irq_affinity *, unsigned int);
	void *priv;
};

struct node_vectors {
	unsigned int id;
	union {
		unsigned int nvectors;
		unsigned int ncpus;
	};
};

typedef void (*rcu_callback_t)(struct callback_head *);

typedef void (*call_rcu_func_t)(struct callback_head *, rcu_callback_t);

struct rcu_cblist {
	struct callback_head *head;
	struct callback_head **tail;
	long int len;
};

struct rcu_synchronize {
	struct callback_head head;
	struct completion completion;
};

struct trace_event_raw_rcu_utilization {
	struct trace_entry ent;
	const char *s;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_future_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	long int gp_seq_req;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_grace_period_init {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	u8 level;
	int grplo;
	int grphi;
	long unsigned int qsmask;
	char __data[0];
};

struct trace_event_raw_rcu_exp_grace_period {
	struct trace_entry ent;
	const char *rcuname;
	long int gpseq;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_exp_funnel_lock {
	struct trace_entry ent;
	const char *rcuname;
	u8 level;
	int grplo;
	int grphi;
	const char *gpevent;
	char __data[0];
};

struct trace_event_raw_rcu_preempt_task {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_unlock_preempted_task {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int pid;
	char __data[0];
};

struct trace_event_raw_rcu_quiescent_state_report {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	long unsigned int mask;
	long unsigned int qsmask;
	u8 level;
	int grplo;
	int grphi;
	u8 gp_tasks;
	char __data[0];
};

struct trace_event_raw_rcu_fqs {
	struct trace_entry ent;
	const char *rcuname;
	long int gp_seq;
	int cpu;
	const char *qsevent;
	char __data[0];
};

struct trace_event_raw_rcu_stall_warning {
	struct trace_entry ent;
	const char *rcuname;
	const char *msg;
	char __data[0];
};

struct trace_event_raw_rcu_dyntick {
	struct trace_entry ent;
	const char *polarity;
	long int oldnesting;
	long int newnesting;
	int dynticks;
	char __data[0];
};

struct trace_event_raw_rcu_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	long int qlen;
	char __data[0];
};

struct trace_event_raw_rcu_segcb_stats {
	struct trace_entry ent;
	const char *ctx;
	long unsigned int gp_seq[4];
	long int seglen[4];
	char __data[0];
};

struct trace_event_raw_rcu_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	long unsigned int offset;
	long int qlen;
	char __data[0];
};

struct trace_event_raw_rcu_batch_start {
	struct trace_entry ent;
	const char *rcuname;
	long int qlen;
	long int blimit;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	void *func;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kvfree_callback {
	struct trace_entry ent;
	const char *rcuname;
	void *rhp;
	long unsigned int offset;
	char __data[0];
};

struct trace_event_raw_rcu_invoke_kfree_bulk_callback {
	struct trace_entry ent;
	const char *rcuname;
	long unsigned int nr_records;
	void **p;
	char __data[0];
};

struct trace_event_raw_rcu_batch_end {
	struct trace_entry ent;
	const char *rcuname;
	int callbacks_invoked;
	char cb;
	char nr;
	char iit;
	char risk;
	char __data[0];
};

struct trace_event_raw_rcu_torture_read {
	struct trace_entry ent;
	char rcutorturename[8];
	struct callback_head *rhp;
	long unsigned int secs;
	long unsigned int c_old;
	long unsigned int c;
	char __data[0];
};

struct trace_event_raw_rcu_barrier {
	struct trace_entry ent;
	const char *rcuname;
	const char *s;
	int cpu;
	int cnt;
	long unsigned int done;
	char __data[0];
};

struct trace_event_data_offsets_rcu_utilization {};

struct trace_event_data_offsets_rcu_grace_period {};

struct trace_event_data_offsets_rcu_future_grace_period {};

struct trace_event_data_offsets_rcu_grace_period_init {};

struct trace_event_data_offsets_rcu_exp_grace_period {};

struct trace_event_data_offsets_rcu_exp_funnel_lock {};

struct trace_event_data_offsets_rcu_preempt_task {};

struct trace_event_data_offsets_rcu_unlock_preempted_task {};

struct trace_event_data_offsets_rcu_quiescent_state_report {};

struct trace_event_data_offsets_rcu_fqs {};

struct trace_event_data_offsets_rcu_stall_warning {};

struct trace_event_data_offsets_rcu_dyntick {};

struct trace_event_data_offsets_rcu_callback {};

struct trace_event_data_offsets_rcu_segcb_stats {};

struct trace_event_data_offsets_rcu_kvfree_callback {};

struct trace_event_data_offsets_rcu_batch_start {};

struct trace_event_data_offsets_rcu_invoke_callback {};

struct trace_event_data_offsets_rcu_invoke_kvfree_callback {};

struct trace_event_data_offsets_rcu_invoke_kfree_bulk_callback {};

struct trace_event_data_offsets_rcu_batch_end {};

struct trace_event_data_offsets_rcu_torture_read {};

struct trace_event_data_offsets_rcu_barrier {};

typedef void (*btf_trace_rcu_utilization)(void *, const char *);

typedef void (*btf_trace_rcu_grace_period)(void *, const char *, long unsigned int, const char *);

typedef void (*btf_trace_rcu_future_grace_period)(void *, const char *, long unsigned int, long unsigned int, u8, int, int, const char *);

typedef void (*btf_trace_rcu_grace_period_init)(void *, const char *, long unsigned int, u8, int, int, long unsigned int);

typedef void (*btf_trace_rcu_exp_grace_period)(void *, const char *, long unsigned int, const char *);

typedef void (*btf_trace_rcu_exp_funnel_lock)(void *, const char *, u8, int, int, const char *);

typedef void (*btf_trace_rcu_preempt_task)(void *, const char *, int, long unsigned int);

typedef void (*btf_trace_rcu_unlock_preempted_task)(void *, const char *, long unsigned int, int);

typedef void (*btf_trace_rcu_quiescent_state_report)(void *, const char *, long unsigned int, long unsigned int, long unsigned int, u8, int, int, int);

typedef void (*btf_trace_rcu_fqs)(void *, const char *, long unsigned int, int, const char *);

typedef void (*btf_trace_rcu_stall_warning)(void *, const char *, const char *);

typedef void (*btf_trace_rcu_dyntick)(void *, const char *, long int, long int, int);

typedef void (*btf_trace_rcu_callback)(void *, const char *, struct callback_head *, long int);

typedef void (*btf_trace_rcu_segcb_stats)(void *, struct rcu_segcblist *, const char *);

typedef void (*btf_trace_rcu_kvfree_callback)(void *, const char *, struct callback_head *, long unsigned int, long int);

typedef void (*btf_trace_rcu_batch_start)(void *, const char *, long int, long int);

typedef void (*btf_trace_rcu_invoke_callback)(void *, const char *, struct callback_head *);

typedef void (*btf_trace_rcu_invoke_kvfree_callback)(void *, const char *, struct callback_head *, long unsigned int);

typedef void (*btf_trace_rcu_invoke_kfree_bulk_callback)(void *, const char *, long unsigned int, void **);

typedef void (*btf_trace_rcu_batch_end)(void *, const char *, int, char, char, char, char);

typedef void (*btf_trace_rcu_torture_read)(void *, const char *, struct callback_head *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_rcu_barrier)(void *, const char *, const char *, int, int, long unsigned int);

struct rcu_tasks;

typedef void (*rcu_tasks_gp_func_t)(struct rcu_tasks *);

typedef void (*pregp_func_t)(struct list_head *);

typedef void (*pertask_func_t)(struct task_struct *, struct list_head *);

typedef void (*postscan_func_t)(struct list_head *);

typedef void (*holdouts_func_t)(struct list_head *, bool, bool *);

typedef void (*postgp_func_t)(struct rcu_tasks *);

struct rcu_tasks_percpu;

struct rcu_tasks {
	struct rcuwait cbs_wait;
	raw_spinlock_t cbs_gbl_lock;
	struct mutex tasks_gp_mutex;
	int gp_state;
	int gp_sleep;
	int init_fract;
	long unsigned int gp_jiffies;
	long unsigned int gp_start;
	long unsigned int tasks_gp_seq;
	long unsigned int n_ipis;
	long unsigned int n_ipis_fails;
	struct task_struct *kthread_ptr;
	rcu_tasks_gp_func_t gp_func;
	pregp_func_t pregp_func;
	pertask_func_t pertask_func;
	postscan_func_t postscan_func;
	holdouts_func_t holdouts_func;
	postgp_func_t postgp_func;
	call_rcu_func_t call_func;
	struct rcu_tasks_percpu *rtpcpu;
	int percpu_enqueue_shift;
	int percpu_enqueue_lim;
	int percpu_dequeue_lim;
	long unsigned int percpu_dequeue_gpseq;
	struct mutex barrier_q_mutex;
	atomic_t barrier_q_count;
	struct completion barrier_q_completion;
	long unsigned int barrier_q_seq;
	char *name;
	char *kname;
};

struct rcu_tasks_percpu {
	struct rcu_segcblist cblist;
	raw_spinlock_t lock;
	long unsigned int rtp_jiffies;
	long unsigned int rtp_n_lock_retries;
	struct work_struct rtp_work;
	struct irq_work rtp_irq_work;
	struct callback_head barrier_q_head;
	struct list_head rtp_blkd_tasks;
	int cpu;
	struct rcu_tasks *rtpp;
};

struct trc_stall_chk_rdr {
	int nesting;
	int ipi_to_cpu;
	u8 needqs;
};

enum {
	GP_IDLE = 0,
	GP_ENTER = 1,
	GP_PASSED = 2,
	GP_EXIT = 3,
	GP_REPLAY = 4,
};

typedef long unsigned int ulong;

enum rcutorture_type {
	RCU_FLAVOR = 0,
	RCU_TASKS_FLAVOR = 1,
	RCU_TASKS_RUDE_FLAVOR = 2,
	RCU_TASKS_TRACING_FLAVOR = 3,
	RCU_TRIVIAL_FLAVOR = 4,
	SRCU_FLAVOR = 5,
	INVALID_RCU_FLAVOR = 6,
};

struct rcu_gp_oldstate {
	long unsigned int rgos_norm;
	long unsigned int rgos_exp;
};

struct context_tracking {
	atomic_t state;
	long int dynticks_nesting;
	long int dynticks_nmi_nesting;
};

struct rcu_exp_work {
	long unsigned int rew_s;
	struct work_struct rew_work;
};

struct rcu_node {
	raw_spinlock_t lock;
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	long unsigned int completedqs;
	long unsigned int qsmask;
	long unsigned int rcu_gp_init_mask;
	long unsigned int qsmaskinit;
	long unsigned int qsmaskinitnext;
	long unsigned int expmask;
	long unsigned int expmaskinit;
	long unsigned int expmaskinitnext;
	long unsigned int cbovldmask;
	long unsigned int ffmask;
	long unsigned int grpmask;
	int grplo;
	int grphi;
	u8 grpnum;
	u8 level;
	bool wait_blkd_tasks;
	struct rcu_node *parent;
	struct list_head blkd_tasks;
	struct list_head *gp_tasks;
	struct list_head *exp_tasks;
	struct list_head *boost_tasks;
	struct rt_mutex boost_mtx;
	long unsigned int boost_time;
	struct mutex boost_kthread_mutex;
	struct task_struct *boost_kthread_task;
	unsigned int boost_kthread_status;
	long unsigned int n_boosts;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	raw_spinlock_t fqslock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t exp_lock;
	long unsigned int exp_seq_rq;
	wait_queue_head_t exp_wq[4];
	struct rcu_exp_work rew;
	bool exp_need_flush;
	raw_spinlock_t exp_poll_lock;
	long unsigned int exp_seq_poll_rq;
	struct work_struct exp_poll_wq;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum tick_dep_bits {
	TICK_DEP_BIT_POSIX_TIMER = 0,
	TICK_DEP_BIT_PERF_EVENTS = 1,
	TICK_DEP_BIT_SCHED = 2,
	TICK_DEP_BIT_CLOCK_UNSTABLE = 3,
	TICK_DEP_BIT_RCU = 4,
	TICK_DEP_BIT_RCU_EXP = 5,
};

union rcu_noqs {
	struct {
		u8 norm;
		u8 exp;
	} b;
	u16 s;
};

struct rcu_data {
	long unsigned int gp_seq;
	long unsigned int gp_seq_needed;
	union rcu_noqs cpu_no_qs;
	bool core_needs_qs;
	bool beenonline;
	bool gpwrap;
	bool cpu_started;
	struct rcu_node *mynode;
	long unsigned int grpmask;
	long unsigned int ticks_this_gp;
	struct irq_work defer_qs_iw;
	bool defer_qs_iw_pending;
	struct work_struct strict_work;
	struct rcu_segcblist cblist;
	long int qlen_last_fqs_check;
	long unsigned int n_cbs_invoked;
	long unsigned int n_force_qs_snap;
	long int blimit;
	int dynticks_snap;
	bool rcu_need_heavy_qs;
	bool rcu_urgent_qs;
	bool rcu_forced_tick;
	bool rcu_forced_tick_exp;
	long unsigned int barrier_seq_snap;
	struct callback_head barrier_head;
	int exp_dynticks_snap;
	struct task_struct *rcu_cpu_kthread_task;
	unsigned int rcu_cpu_kthread_status;
	char rcu_cpu_has_work;
	long unsigned int rcuc_activity;
	unsigned int softirq_snap;
	struct irq_work rcu_iw;
	bool rcu_iw_pending;
	long unsigned int rcu_iw_gp_seq;
	long unsigned int rcu_ofl_gp_seq;
	short int rcu_ofl_gp_flags;
	long unsigned int rcu_onl_gp_seq;
	short int rcu_onl_gp_flags;
	long unsigned int last_fqs_resched;
	long unsigned int last_sched_clock;
	int cpu;
};

struct rcu_state {
	struct rcu_node node[1];
	struct rcu_node *level[2];
	int ncpus;
	int n_online_cpus;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int gp_seq;
	long unsigned int gp_max;
	struct task_struct *gp_kthread;
	struct swait_queue_head gp_wq;
	short int gp_flags;
	short int gp_state;
	long unsigned int gp_wake_time;
	long unsigned int gp_wake_seq;
	long unsigned int gp_seq_polled;
	long unsigned int gp_seq_polled_snap;
	long unsigned int gp_seq_polled_exp_snap;
	struct mutex barrier_mutex;
	atomic_t barrier_cpu_count;
	struct completion barrier_completion;
	long unsigned int barrier_sequence;
	raw_spinlock_t barrier_lock;
	struct mutex exp_mutex;
	struct mutex exp_wake_mutex;
	long unsigned int expedited_sequence;
	atomic_t expedited_need_qs;
	struct swait_queue_head expedited_wq;
	int ncpus_snap;
	u8 cbovld;
	u8 cbovldnext;
	long unsigned int jiffies_force_qs;
	long unsigned int jiffies_kick_kthreads;
	long unsigned int n_force_qs;
	long unsigned int gp_start;
	long unsigned int gp_end;
	long unsigned int gp_activity;
	long unsigned int gp_req_activity;
	long unsigned int jiffies_stall;
	long unsigned int jiffies_resched;
	long unsigned int n_force_qs_gpstart;
	const char *name;
	char abbr;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	arch_spinlock_t ofl_lock;
	int nocb_is_setup;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct kvfree_rcu_bulk_data {
	long unsigned int nr_records;
	struct kvfree_rcu_bulk_data *next;
	void *records[0];
};

struct kfree_rcu_cpu;

struct kfree_rcu_cpu_work {
	struct rcu_work rcu_work;
	struct callback_head *head_free;
	struct kvfree_rcu_bulk_data *bkvhead_free[2];
	struct kfree_rcu_cpu *krcp;
};

struct kfree_rcu_cpu {
	struct callback_head *head;
	struct kvfree_rcu_bulk_data *bkvhead[2];
	struct kfree_rcu_cpu_work krw_arr[2];
	raw_spinlock_t lock;
	struct delayed_work monitor_work;
	bool initialized;
	int count;
	struct delayed_work page_cache_work;
	atomic_t backoff_page_cache_fill;
	atomic_t work_in_progress;
	struct hrtimer hrtimer;
	struct llist_head bkvcache;
	int nr_bkv_objs;
};

struct rcu_stall_chk_rdr {
	int nesting;
	union rcu_special rs;
	bool on_blkd_list;
};

struct dma_sgt_handle {
	struct sg_table sgt;
	struct page **pages;
};

struct dma_devres {
	size_t size;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int attrs;
};

enum pci_p2pdma_map_type {
	PCI_P2PDMA_MAP_UNKNOWN = 0,
	PCI_P2PDMA_MAP_NOT_SUPPORTED = 1,
	PCI_P2PDMA_MAP_BUS_ADDR = 2,
	PCI_P2PDMA_MAP_THRU_HOST_BRIDGE = 3,
};

struct pci_p2pdma_map_state {
	struct dev_pagemap *pgmap;
	int map;
	u64 bus_off;
};

struct reserved_mem_ops;

struct reserved_mem {
	const char *name;
	long unsigned int fdt_node;
	long unsigned int phandle;
	const struct reserved_mem_ops *ops;
	phys_addr_t base;
	phys_addr_t size;
	void *priv;
};

struct reserved_mem_ops {
	int (*device_init)(struct reserved_mem *, struct device *);
	void (*device_release)(struct reserved_mem *, struct device *);
};

typedef int (*reservedmem_of_init_fn)(struct reserved_mem *);

enum {
	MEMREMAP_WB = 1,
	MEMREMAP_WT = 2,
	MEMREMAP_WC = 4,
	MEMREMAP_ENC = 8,
	MEMREMAP_DEC = 16,
};

struct dma_coherent_mem {
	void *virt_base;
	dma_addr_t device_base;
	long unsigned int pfn_base;
	int size;
	long unsigned int *bitmap;
	spinlock_t spinlock;
	bool use_dev_dma_pfn_offset;
};

struct latch_tree_root {
	seqcount_latch_t seq;
	struct rb_root tree[2];
};

struct module_use {
	struct list_head source_list;
	struct list_head target_list;
	struct module *source;
	struct module *target;
};

enum kernel_read_file_id {
	READING_UNKNOWN = 0,
	READING_FIRMWARE = 1,
	READING_MODULE = 2,
	READING_KEXEC_IMAGE = 3,
	READING_KEXEC_INITRAMFS = 4,
	READING_POLICY = 5,
	READING_X509_CERTIFICATE = 6,
	READING_MAX_ID = 7,
};

enum kernel_load_data_id {
	LOADING_UNKNOWN = 0,
	LOADING_FIRMWARE = 1,
	LOADING_MODULE = 2,
	LOADING_KEXEC_IMAGE = 3,
	LOADING_KEXEC_INITRAMFS = 4,
	LOADING_POLICY = 5,
	LOADING_X509_CERTIFICATE = 6,
	LOADING_MAX_ID = 7,
};

struct _ddebug {
	const char *modname;
	const char *function;
	const char *filename;
	const char *format;
	unsigned int lineno: 18;
	unsigned int class_id: 6;
	unsigned int flags: 8;
	int: 32;
};

enum class_map_type {
	DD_CLASS_TYPE_DISJOINT_BITS = 0,
	DD_CLASS_TYPE_LEVEL_NUM = 1,
	DD_CLASS_TYPE_DISJOINT_NAMES = 2,
	DD_CLASS_TYPE_LEVEL_NAMES = 3,
};

struct ddebug_class_map {
	struct list_head link;
	struct module *mod;
	const char *mod_name;
	const char **class_names;
	const int length;
	const int base;
	enum class_map_type map_type;
};

struct _ddebug_info {
	struct _ddebug *descs;
	struct ddebug_class_map *classes;
	unsigned int num_descs;
	unsigned int num_classes;
};

struct load_info {
	const char *name;
	struct module *mod;
	Elf32_Ehdr *hdr;
	long unsigned int len;
	Elf32_Shdr *sechdrs;
	char *secstrings;
	char *strtab;
	long unsigned int symoffs;
	long unsigned int stroffs;
	long unsigned int init_typeoffs;
	long unsigned int core_typeoffs;
	struct _ddebug_info dyndbg;
	bool sig_ok;
	long unsigned int mod_kallsyms_init_off;
	struct {
		unsigned int sym;
		unsigned int str;
		unsigned int mod;
		unsigned int vers;
		unsigned int info;
		unsigned int pcpu;
	} index;
};

enum mod_license {
	NOT_GPL_ONLY = 0,
	GPL_ONLY = 1,
};

struct find_symbol_arg {
	const char *name;
	bool gplok;
	bool warn;
	struct module *owner;
	const s32 *crc;
	const struct kernel_symbol *sym;
	enum mod_license license;
};

struct mod_tree_root {
	struct latch_tree_root root;
	long unsigned int addr_min;
	long unsigned int addr_max;
};

struct trace_event_raw_module_load {
	struct trace_entry ent;
	unsigned int taints;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_free {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_refcnt {
	struct trace_entry ent;
	long unsigned int ip;
	int refcnt;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_module_request {
	struct trace_entry ent;
	long unsigned int ip;
	bool wait;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_module_load {
	u32 name;
};

struct trace_event_data_offsets_module_free {
	u32 name;
};

struct trace_event_data_offsets_module_refcnt {
	u32 name;
};

struct trace_event_data_offsets_module_request {
	u32 name;
};

typedef void (*btf_trace_module_load)(void *, struct module *);

typedef void (*btf_trace_module_free)(void *, struct module *);

typedef void (*btf_trace_module_get)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_put)(void *, struct module *, long unsigned int);

typedef void (*btf_trace_module_request)(void *, char *, bool, long unsigned int);

struct symsearch {
	const struct kernel_symbol *start;
	const struct kernel_symbol *stop;
	const s32 *crcs;
	enum mod_license license;
};

struct mod_initfree {
	struct llist_node node;
	void *module_init;
};

struct latch_tree_ops {
	bool (*less)(struct latch_tree_node *, struct latch_tree_node *);
	int (*comp)(void *, struct latch_tree_node *);
};

enum {
	PROC_ENTRY_PERMANENT = 1,
};

struct module_sect_attr {
	struct bin_attribute battr;
	long unsigned int address;
};

struct module_sect_attrs {
	struct attribute_group grp;
	unsigned int nsections;
	struct module_sect_attr attrs[0];
};

struct module_notes_attrs {
	struct kobject *dir;
	unsigned int notes;
	struct bin_attribute attrs[0];
};

struct modversion_info {
	long unsigned int crc;
	char name[60];
};

enum kcmp_type {
	KCMP_FILE = 0,
	KCMP_VM = 1,
	KCMP_FILES = 2,
	KCMP_FS = 3,
	KCMP_SIGHAND = 4,
	KCMP_IO = 5,
	KCMP_SYSVSEM = 6,
	KCMP_EPOLL_TFD = 7,
	KCMP_TYPES = 8,
};

struct kcmp_epoll_slot {
	__u32 efd;
	__u32 tfd;
	__u32 toff;
};

typedef __kernel_long_t __kernel_suseconds_t;

typedef __kernel_suseconds_t suseconds_t;

typedef __kernel_clock_t clock_t;

struct __kernel_itimerspec {
	struct __kernel_timespec it_interval;
	struct __kernel_timespec it_value;
};

struct timezone {
	int tz_minuteswest;
	int tz_dsttime;
};

struct itimerspec64 {
	struct timespec64 it_interval;
	struct timespec64 it_value;
};

struct old_timeval32 {
	old_time32_t tv_sec;
	s32 tv_usec;
};

struct old_itimerspec32 {
	struct old_timespec32 it_interval;
	struct old_timespec32 it_value;
};

struct old_timex32 {
	u32 modes;
	s32 offset;
	s32 freq;
	s32 maxerror;
	s32 esterror;
	s32 status;
	s32 constant;
	s32 precision;
	s32 tolerance;
	struct old_timeval32 time;
	s32 tick;
	s32 ppsfreq;
	s32 jitter;
	s32 shift;
	s32 stabil;
	s32 jitcnt;
	s32 calcnt;
	s32 errcnt;
	s32 stbcnt;
	s32 tai;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct __kernel_timex_timeval {
	__kernel_time64_t tv_sec;
	long long int tv_usec;
};

struct __kernel_timex {
	unsigned int modes;
	int: 32;
	long long int offset;
	long long int freq;
	long long int maxerror;
	long long int esterror;
	int status;
	int: 32;
	long long int constant;
	long long int precision;
	long long int tolerance;
	struct __kernel_timex_timeval time;
	long long int tick;
	long long int ppsfreq;
	long long int jitter;
	int shift;
	int: 32;
	long long int stabil;
	long long int jitcnt;
	long long int calcnt;
	long long int errcnt;
	long long int stbcnt;
	int tai;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct trace_event_raw_timer_class {
	struct trace_entry ent;
	void *timer;
	char __data[0];
};

struct trace_event_raw_timer_start {
	struct trace_entry ent;
	void *timer;
	void *function;
	long unsigned int expires;
	long unsigned int now;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_timer_expire_entry {
	struct trace_entry ent;
	void *timer;
	long unsigned int now;
	void *function;
	long unsigned int baseclk;
	char __data[0];
};

struct trace_event_raw_hrtimer_init {
	struct trace_entry ent;
	void *hrtimer;
	clockid_t clockid;
	enum hrtimer_mode mode;
	char __data[0];
};

struct trace_event_raw_hrtimer_start {
	struct trace_entry ent;
	void *hrtimer;
	void *function;
	s64 expires;
	s64 softexpires;
	enum hrtimer_mode mode;
	char __data[0];
	int: 32;
};

struct trace_event_raw_hrtimer_expire_entry {
	struct trace_entry ent;
	void *hrtimer;
	int: 32;
	s64 now;
	void *function;
	char __data[0];
	int: 32;
};

struct trace_event_raw_hrtimer_class {
	struct trace_entry ent;
	void *hrtimer;
	char __data[0];
};

struct trace_event_raw_itimer_state {
	struct trace_entry ent;
	int which;
	int: 32;
	long long unsigned int expires;
	long int value_sec;
	long int value_nsec;
	long int interval_sec;
	long int interval_nsec;
	char __data[0];
};

struct trace_event_raw_itimer_expire {
	struct trace_entry ent;
	int which;
	pid_t pid;
	long long unsigned int now;
	char __data[0];
};

struct trace_event_raw_tick_stop {
	struct trace_entry ent;
	int success;
	int dependency;
	char __data[0];
};

struct trace_event_data_offsets_timer_class {};

struct trace_event_data_offsets_timer_start {};

struct trace_event_data_offsets_timer_expire_entry {};

struct trace_event_data_offsets_hrtimer_init {};

struct trace_event_data_offsets_hrtimer_start {};

struct trace_event_data_offsets_hrtimer_expire_entry {};

struct trace_event_data_offsets_hrtimer_class {};

struct trace_event_data_offsets_itimer_state {};

struct trace_event_data_offsets_itimer_expire {};

struct trace_event_data_offsets_tick_stop {};

typedef void (*btf_trace_timer_init)(void *, struct timer_list *);

typedef void (*btf_trace_timer_start)(void *, struct timer_list *, long unsigned int, unsigned int);

typedef void (*btf_trace_timer_expire_entry)(void *, struct timer_list *, long unsigned int);

typedef void (*btf_trace_timer_expire_exit)(void *, struct timer_list *);

typedef void (*btf_trace_timer_cancel)(void *, struct timer_list *);

typedef void (*btf_trace_hrtimer_init)(void *, struct hrtimer *, clockid_t, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_start)(void *, struct hrtimer *, enum hrtimer_mode);

typedef void (*btf_trace_hrtimer_expire_entry)(void *, struct hrtimer *, ktime_t *);

typedef void (*btf_trace_hrtimer_expire_exit)(void *, struct hrtimer *);

typedef void (*btf_trace_hrtimer_cancel)(void *, struct hrtimer *);

typedef void (*btf_trace_itimer_state)(void *, int, const struct itimerspec64 * const, long long unsigned int);

typedef void (*btf_trace_itimer_expire)(void *, int, struct pid *, long long unsigned int);

typedef void (*btf_trace_tick_stop)(void *, int, int);

struct timer_base {
	raw_spinlock_t lock;
	struct timer_list *running_timer;
	long unsigned int clk;
	long unsigned int next_expiry;
	unsigned int cpu;
	bool next_expiry_recalc;
	bool is_idle;
	bool timers_pending;
	long unsigned int pending_map[16];
	struct hlist_head vectors[512];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct process_timer {
	struct timer_list timer;
	struct task_struct *task;
};

enum tick_device_mode {
	TICKDEV_MODE_PERIODIC = 0,
	TICKDEV_MODE_ONESHOT = 1,
};

struct tick_device {
	struct clock_event_device *evtdev;
	enum tick_device_mode mode;
};

enum clocksource_ids {
	CSID_GENERIC = 0,
	CSID_ARM_ARCH_COUNTER = 1,
	CSID_MAX = 2,
};

struct ktime_timestamps {
	u64 mono;
	u64 boot;
	u64 real;
};

struct system_time_snapshot {
	u64 cycles;
	ktime_t real;
	ktime_t raw;
	enum clocksource_ids cs_id;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	int: 24;
	int: 32;
};

struct system_device_crosststamp {
	ktime_t device;
	ktime_t sys_realtime;
	ktime_t sys_monoraw;
};

struct clocksource;

struct system_counterval_t {
	u64 cycles;
	struct clocksource *cs;
	int: 32;
};

enum vdso_clock_mode {
	VDSO_CLOCKMODE_NONE = 0,
	VDSO_CLOCKMODE_ARCHTIMER = 1,
	VDSO_CLOCKMODE_MAX = 2,
	VDSO_CLOCKMODE_TIMENS = 2147483647,
};

struct clocksource {
	u64 (*read)(struct clocksource *);
	int: 32;
	u64 mask;
	u32 mult;
	u32 shift;
	u64 max_idle_ns;
	u32 maxadj;
	u32 uncertainty_margin;
	u64 max_cycles;
	const char *name;
	struct list_head list;
	int rating;
	enum clocksource_ids id;
	enum vdso_clock_mode vdso_clock_mode;
	long unsigned int flags;
	int (*enable)(struct clocksource *);
	void (*disable)(struct clocksource *);
	void (*suspend)(struct clocksource *);
	void (*resume)(struct clocksource *);
	void (*mark_unstable)(struct clocksource *);
	void (*tick_stable)(struct clocksource *);
	struct module *owner;
};

struct tk_read_base {
	struct clocksource *clock;
	int: 32;
	u64 mask;
	u64 cycle_last;
	u32 mult;
	u32 shift;
	u64 xtime_nsec;
	ktime_t base;
	u64 base_real;
};

struct timekeeper {
	struct tk_read_base tkr_mono;
	struct tk_read_base tkr_raw;
	u64 xtime_sec;
	long unsigned int ktime_sec;
	int: 32;
	struct timespec64 wall_to_monotonic;
	ktime_t offs_real;
	ktime_t offs_boot;
	ktime_t offs_tai;
	s32 tai_offset;
	unsigned int clock_was_set_seq;
	u8 cs_was_changed_seq;
	int: 24;
	int: 32;
	ktime_t next_leap_ktime;
	u64 raw_sec;
	struct timespec64 monotonic_to_boot;
	u64 cycle_interval;
	u64 xtime_interval;
	s64 xtime_remainder;
	u64 raw_interval;
	u64 ntp_tick;
	s64 ntp_error;
	u32 ntp_error_shift;
	u32 ntp_err_mult;
	u32 skip_second_overflow;
	int: 32;
};

struct audit_ntp_data {};

enum timekeeping_adv_mode {
	TK_ADV_TICK = 0,
	TK_ADV_FREQ = 1,
};

struct tk_fast {
	seqcount_latch_t seq;
	int: 32;
	struct tk_read_base base[2];
};

enum audit_ntp_type {
	AUDIT_NTP_OFFSET = 0,
	AUDIT_NTP_FREQ = 1,
	AUDIT_NTP_STATUS = 2,
	AUDIT_NTP_TAI = 3,
	AUDIT_NTP_TICK = 4,
	AUDIT_NTP_ADJUST = 5,
	AUDIT_NTP_NVALS = 6,
};

enum tick_nohz_mode {
	NOHZ_MODE_INACTIVE = 0,
	NOHZ_MODE_LOWRES = 1,
	NOHZ_MODE_HIGHRES = 2,
};

struct tick_sched {
	struct hrtimer sched_timer;
	long unsigned int check_clocks;
	enum tick_nohz_mode nohz_mode;
	unsigned int inidle: 1;
	unsigned int tick_stopped: 1;
	unsigned int idle_active: 1;
	unsigned int do_timer_last: 1;
	unsigned int got_idle_tick: 1;
	int: 27;
	int: 32;
	ktime_t last_tick;
	ktime_t next_tick;
	long unsigned int idle_jiffies;
	long unsigned int idle_calls;
	long unsigned int idle_sleeps;
	int: 32;
	ktime_t idle_entrytime;
	ktime_t idle_waketime;
	ktime_t idle_exittime;
	ktime_t idle_sleeptime;
	ktime_t iowait_sleeptime;
	long unsigned int last_jiffies;
	int: 32;
	u64 timer_expires;
	u64 timer_expires_base;
	u64 next_timer;
	ktime_t idle_expires;
	atomic_t tick_dep_mask;
	long unsigned int last_tick_jiffies;
	unsigned int stalled_jiffies;
	int: 32;
};

struct timer_list_iter {
	int cpu;
	bool second_pass;
	u64 now;
};

struct tm {
	int tm_sec;
	int tm_min;
	int tm_hour;
	int tm_mday;
	int tm_mon;
	long int tm_year;
	int tm_wday;
	int tm_yday;
};

struct cyclecounter {
	u64 (*read)(const struct cyclecounter *);
	int: 32;
	u64 mask;
	u32 mult;
	u32 shift;
};

struct timecounter {
	const struct cyclecounter *cc;
	int: 32;
	u64 cycle_last;
	u64 nsec;
	u64 mask;
	u64 frac;
};

typedef __kernel_timer_t timer_t;

enum alarmtimer_type {
	ALARM_REALTIME = 0,
	ALARM_BOOTTIME = 1,
	ALARM_NUMTYPE = 2,
	ALARM_REALTIME_FREEZER = 3,
	ALARM_BOOTTIME_FREEZER = 4,
};

enum alarmtimer_restart {
	ALARMTIMER_NORESTART = 0,
	ALARMTIMER_RESTART = 1,
};

struct alarm {
	struct timerqueue_node node;
	struct hrtimer timer;
	enum alarmtimer_restart (*function)(struct alarm *, ktime_t);
	enum alarmtimer_type type;
	int state;
	void *data;
};

struct cpu_timer {
	struct timerqueue_node node;
	struct timerqueue_head *head;
	struct pid *pid;
	struct list_head elist;
	int firing;
	int: 32;
};

struct k_clock;

struct k_itimer {
	struct list_head list;
	struct hlist_node t_hash;
	spinlock_t it_lock;
	const struct k_clock *kclock;
	clockid_t it_clock;
	timer_t it_id;
	int it_active;
	int: 32;
	s64 it_overrun;
	s64 it_overrun_last;
	int it_requeue_pending;
	int it_sigev_notify;
	ktime_t it_interval;
	struct signal_struct *it_signal;
	union {
		struct pid *it_pid;
		struct task_struct *it_process;
	};
	struct sigqueue *sigq;
	int: 32;
	union {
		struct {
			struct hrtimer timer;
		} real;
		struct cpu_timer cpu;
		struct {
			struct alarm alarmtimer;
		} alarm;
	} it;
	struct callback_head rcu;
};

struct k_clock {
	int (*clock_getres)(const clockid_t, struct timespec64 *);
	int (*clock_set)(const clockid_t, const struct timespec64 *);
	int (*clock_get_timespec)(const clockid_t, struct timespec64 *);
	ktime_t (*clock_get_ktime)(const clockid_t);
	int (*clock_adj)(const clockid_t, struct __kernel_timex *);
	int (*timer_create)(struct k_itimer *);
	int (*nsleep)(const clockid_t, int, const struct timespec64 *);
	int (*timer_set)(struct k_itimer *, int, struct itimerspec64 *, struct itimerspec64 *);
	int (*timer_del)(struct k_itimer *);
	void (*timer_get)(struct k_itimer *, struct itimerspec64 *);
	void (*timer_rearm)(struct k_itimer *);
	s64 (*timer_forward)(struct k_itimer *, ktime_t);
	ktime_t (*timer_remaining)(struct k_itimer *, ktime_t);
	int (*timer_try_to_cancel)(struct k_itimer *);
	void (*timer_arm)(struct k_itimer *, ktime_t, bool, bool);
	void (*timer_wait_running)(struct k_itimer *);
};

struct class_interface {
	struct list_head node;
	struct class *class;
	int (*add_dev)(struct device *, struct class_interface *);
	void (*remove_dev)(struct device *, struct class_interface *);
};

struct trace_event_raw_alarmtimer_suspend {
	struct trace_entry ent;
	s64 expires;
	unsigned char alarm_type;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_alarm_class {
	struct trace_entry ent;
	void *alarm;
	unsigned char alarm_type;
	s64 expires;
	s64 now;
	char __data[0];
};

struct trace_event_data_offsets_alarmtimer_suspend {};

struct trace_event_data_offsets_alarm_class {};

typedef void (*btf_trace_alarmtimer_suspend)(void *, ktime_t, int);

typedef void (*btf_trace_alarmtimer_fired)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_start)(void *, struct alarm *, ktime_t);

typedef void (*btf_trace_alarmtimer_cancel)(void *, struct alarm *, ktime_t);

struct alarm_base {
	spinlock_t lock;
	struct timerqueue_head timerqueue;
	ktime_t (*get_ktime)();
	void (*get_timespec)(struct timespec64 *);
	clockid_t base_clockid;
};

struct sigevent {
	sigval_t sigev_value;
	int sigev_signo;
	int sigev_notify;
	union {
		int _pad[13];
		int _tid;
		struct {
			void (*_function)(sigval_t);
			void *_attribute;
		} _sigev_thread;
	} _sigev_un;
};

typedef struct sigevent sigevent_t;

struct posix_clock;

struct posix_clock_operations {
	struct module *owner;
	int (*clock_adjtime)(struct posix_clock *, struct __kernel_timex *);
	int (*clock_gettime)(struct posix_clock *, struct timespec64 *);
	int (*clock_getres)(struct posix_clock *, struct timespec64 *);
	int (*clock_settime)(struct posix_clock *, const struct timespec64 *);
	long int (*ioctl)(struct posix_clock *, unsigned int, long unsigned int);
	int (*open)(struct posix_clock *, fmode_t);
	__poll_t (*poll)(struct posix_clock *, struct file *, poll_table *);
	int (*release)(struct posix_clock *);
	ssize_t (*read)(struct posix_clock *, uint, char *, size_t);
};

struct posix_clock {
	struct posix_clock_operations ops;
	struct cdev cdev;
	struct device *dev;
	struct rw_semaphore rwsem;
	bool zombie;
};

struct posix_clock_desc {
	struct file *fp;
	struct posix_clock *clk;
};

struct __kernel_old_itimerval {
	struct __kernel_old_timeval it_interval;
	struct __kernel_old_timeval it_value;
};

typedef s64 int64_t;

struct ce_unbind {
	struct clock_event_device *ce;
	int res;
};

enum tick_broadcast_state {
	TICK_BROADCAST_EXIT = 0,
	TICK_BROADCAST_ENTER = 1,
};

enum tick_broadcast_mode {
	TICK_BROADCAST_OFF = 0,
	TICK_BROADCAST_ON = 1,
	TICK_BROADCAST_FORCE = 2,
};

struct clock_read_data {
	u64 epoch_ns;
	u64 epoch_cyc;
	u64 sched_clock_mask;
	u64 (*read_sched_clock)();
	u32 mult;
	u32 shift;
	int: 32;
};

struct clock_data {
	seqcount_latch_t seq;
	int: 32;
	struct clock_read_data read_data[2];
	ktime_t wrap_kt;
	long unsigned int rate;
	u64 (*actual_read_sched_clock)();
};

union futex_key {
	struct {
		u64 i_seq;
		long unsigned int pgoff;
		unsigned int offset;
	} shared;
	struct {
		union {
			struct mm_struct *mm;
			u64 __tmp;
		};
		long unsigned int address;
		unsigned int offset;
	} private;
	struct {
		u64 ptr;
		long unsigned int word;
		unsigned int offset;
	} both;
};

struct futex_pi_state {
	struct list_head list;
	struct rt_mutex_base pi_mutex;
	struct task_struct *owner;
	refcount_t refcount;
	union futex_key key;
};

struct futex_hash_bucket {
	atomic_t waiters;
	spinlock_t lock;
	struct plist_head chain;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct futex_q {
	struct plist_node list;
	struct task_struct *task;
	spinlock_t *lock_ptr;
	int: 32;
	union futex_key key;
	struct futex_pi_state *pi_state;
	struct rt_mutex_waiter *rt_waiter;
	union futex_key *requeue_pi_key;
	u32 bitset;
	atomic_t requeue_state;
	int: 32;
};

enum futex_access {
	FUTEX_READ = 0,
	FUTEX_WRITE = 1,
};

struct futex_waitv {
	__u64 val;
	__u64 uaddr;
	__u32 flags;
	__u32 __reserved;
};

struct futex_vector {
	struct futex_waitv w;
	struct futex_q q;
};

enum {
	Q_REQUEUE_PI_NONE = 0,
	Q_REQUEUE_PI_IGNORE = 1,
	Q_REQUEUE_PI_IN_PROGRESS = 2,
	Q_REQUEUE_PI_WAIT = 3,
	Q_REQUEUE_PI_DONE = 4,
	Q_REQUEUE_PI_LOCKED = 5,
};

typedef bool (*smp_cond_func_t)(int, void *);

struct cfd_percpu {
	call_single_data_t csd;
};

struct call_function_data {
	struct cfd_percpu *pcpu;
	cpumask_var_t cpumask;
	cpumask_var_t cpumask_ipi;
};

struct smp_call_on_cpu_struct {
	struct work_struct work;
	struct completion done;
	int (*func)(void *);
	void *data;
	int ret;
	int cpu;
};

typedef short unsigned int __kernel_uid_t;

typedef short unsigned int __kernel_gid_t;

typedef __kernel_uid_t __kernel_old_uid_t;

typedef __kernel_gid_t __kernel_old_gid_t;

typedef __kernel_old_uid_t old_uid_t;

typedef __kernel_old_gid_t old_gid_t;

union bpf_iter_link_info {
	struct {
		__u32 map_fd;
	} map;
	struct {
		enum bpf_cgroup_iter_order order;
		__u32 cgroup_fd;
		__u64 cgroup_id;
	} cgroup;
	struct {
		__u32 tid;
		__u32 pid;
		__u32 pid_fd;
	} task;
};

enum bpf_func_id {
	BPF_FUNC_unspec = 0,
	BPF_FUNC_map_lookup_elem = 1,
	BPF_FUNC_map_update_elem = 2,
	BPF_FUNC_map_delete_elem = 3,
	BPF_FUNC_probe_read = 4,
	BPF_FUNC_ktime_get_ns = 5,
	BPF_FUNC_trace_printk = 6,
	BPF_FUNC_get_prandom_u32 = 7,
	BPF_FUNC_get_smp_processor_id = 8,
	BPF_FUNC_skb_store_bytes = 9,
	BPF_FUNC_l3_csum_replace = 10,
	BPF_FUNC_l4_csum_replace = 11,
	BPF_FUNC_tail_call = 12,
	BPF_FUNC_clone_redirect = 13,
	BPF_FUNC_get_current_pid_tgid = 14,
	BPF_FUNC_get_current_uid_gid = 15,
	BPF_FUNC_get_current_comm = 16,
	BPF_FUNC_get_cgroup_classid = 17,
	BPF_FUNC_skb_vlan_push = 18,
	BPF_FUNC_skb_vlan_pop = 19,
	BPF_FUNC_skb_get_tunnel_key = 20,
	BPF_FUNC_skb_set_tunnel_key = 21,
	BPF_FUNC_perf_event_read = 22,
	BPF_FUNC_redirect = 23,
	BPF_FUNC_get_route_realm = 24,
	BPF_FUNC_perf_event_output = 25,
	BPF_FUNC_skb_load_bytes = 26,
	BPF_FUNC_get_stackid = 27,
	BPF_FUNC_csum_diff = 28,
	BPF_FUNC_skb_get_tunnel_opt = 29,
	BPF_FUNC_skb_set_tunnel_opt = 30,
	BPF_FUNC_skb_change_proto = 31,
	BPF_FUNC_skb_change_type = 32,
	BPF_FUNC_skb_under_cgroup = 33,
	BPF_FUNC_get_hash_recalc = 34,
	BPF_FUNC_get_current_task = 35,
	BPF_FUNC_probe_write_user = 36,
	BPF_FUNC_current_task_under_cgroup = 37,
	BPF_FUNC_skb_change_tail = 38,
	BPF_FUNC_skb_pull_data = 39,
	BPF_FUNC_csum_update = 40,
	BPF_FUNC_set_hash_invalid = 41,
	BPF_FUNC_get_numa_node_id = 42,
	BPF_FUNC_skb_change_head = 43,
	BPF_FUNC_xdp_adjust_head = 44,
	BPF_FUNC_probe_read_str = 45,
	BPF_FUNC_get_socket_cookie = 46,
	BPF_FUNC_get_socket_uid = 47,
	BPF_FUNC_set_hash = 48,
	BPF_FUNC_setsockopt = 49,
	BPF_FUNC_skb_adjust_room = 50,
	BPF_FUNC_redirect_map = 51,
	BPF_FUNC_sk_redirect_map = 52,
	BPF_FUNC_sock_map_update = 53,
	BPF_FUNC_xdp_adjust_meta = 54,
	BPF_FUNC_perf_event_read_value = 55,
	BPF_FUNC_perf_prog_read_value = 56,
	BPF_FUNC_getsockopt = 57,
	BPF_FUNC_override_return = 58,
	BPF_FUNC_sock_ops_cb_flags_set = 59,
	BPF_FUNC_msg_redirect_map = 60,
	BPF_FUNC_msg_apply_bytes = 61,
	BPF_FUNC_msg_cork_bytes = 62,
	BPF_FUNC_msg_pull_data = 63,
	BPF_FUNC_bind = 64,
	BPF_FUNC_xdp_adjust_tail = 65,
	BPF_FUNC_skb_get_xfrm_state = 66,
	BPF_FUNC_get_stack = 67,
	BPF_FUNC_skb_load_bytes_relative = 68,
	BPF_FUNC_fib_lookup = 69,
	BPF_FUNC_sock_hash_update = 70,
	BPF_FUNC_msg_redirect_hash = 71,
	BPF_FUNC_sk_redirect_hash = 72,
	BPF_FUNC_lwt_push_encap = 73,
	BPF_FUNC_lwt_seg6_store_bytes = 74,
	BPF_FUNC_lwt_seg6_adjust_srh = 75,
	BPF_FUNC_lwt_seg6_action = 76,
	BPF_FUNC_rc_repeat = 77,
	BPF_FUNC_rc_keydown = 78,
	BPF_FUNC_skb_cgroup_id = 79,
	BPF_FUNC_get_current_cgroup_id = 80,
	BPF_FUNC_get_local_storage = 81,
	BPF_FUNC_sk_select_reuseport = 82,
	BPF_FUNC_skb_ancestor_cgroup_id = 83,
	BPF_FUNC_sk_lookup_tcp = 84,
	BPF_FUNC_sk_lookup_udp = 85,
	BPF_FUNC_sk_release = 86,
	BPF_FUNC_map_push_elem = 87,
	BPF_FUNC_map_pop_elem = 88,
	BPF_FUNC_map_peek_elem = 89,
	BPF_FUNC_msg_push_data = 90,
	BPF_FUNC_msg_pop_data = 91,
	BPF_FUNC_rc_pointer_rel = 92,
	BPF_FUNC_spin_lock = 93,
	BPF_FUNC_spin_unlock = 94,
	BPF_FUNC_sk_fullsock = 95,
	BPF_FUNC_tcp_sock = 96,
	BPF_FUNC_skb_ecn_set_ce = 97,
	BPF_FUNC_get_listener_sock = 98,
	BPF_FUNC_skc_lookup_tcp = 99,
	BPF_FUNC_tcp_check_syncookie = 100,
	BPF_FUNC_sysctl_get_name = 101,
	BPF_FUNC_sysctl_get_current_value = 102,
	BPF_FUNC_sysctl_get_new_value = 103,
	BPF_FUNC_sysctl_set_new_value = 104,
	BPF_FUNC_strtol = 105,
	BPF_FUNC_strtoul = 106,
	BPF_FUNC_sk_storage_get = 107,
	BPF_FUNC_sk_storage_delete = 108,
	BPF_FUNC_send_signal = 109,
	BPF_FUNC_tcp_gen_syncookie = 110,
	BPF_FUNC_skb_output = 111,
	BPF_FUNC_probe_read_user = 112,
	BPF_FUNC_probe_read_kernel = 113,
	BPF_FUNC_probe_read_user_str = 114,
	BPF_FUNC_probe_read_kernel_str = 115,
	BPF_FUNC_tcp_send_ack = 116,
	BPF_FUNC_send_signal_thread = 117,
	BPF_FUNC_jiffies64 = 118,
	BPF_FUNC_read_branch_records = 119,
	BPF_FUNC_get_ns_current_pid_tgid = 120,
	BPF_FUNC_xdp_output = 121,
	BPF_FUNC_get_netns_cookie = 122,
	BPF_FUNC_get_current_ancestor_cgroup_id = 123,
	BPF_FUNC_sk_assign = 124,
	BPF_FUNC_ktime_get_boot_ns = 125,
	BPF_FUNC_seq_printf = 126,
	BPF_FUNC_seq_write = 127,
	BPF_FUNC_sk_cgroup_id = 128,
	BPF_FUNC_sk_ancestor_cgroup_id = 129,
	BPF_FUNC_ringbuf_output = 130,
	BPF_FUNC_ringbuf_reserve = 131,
	BPF_FUNC_ringbuf_submit = 132,
	BPF_FUNC_ringbuf_discard = 133,
	BPF_FUNC_ringbuf_query = 134,
	BPF_FUNC_csum_level = 135,
	BPF_FUNC_skc_to_tcp6_sock = 136,
	BPF_FUNC_skc_to_tcp_sock = 137,
	BPF_FUNC_skc_to_tcp_timewait_sock = 138,
	BPF_FUNC_skc_to_tcp_request_sock = 139,
	BPF_FUNC_skc_to_udp6_sock = 140,
	BPF_FUNC_get_task_stack = 141,
	BPF_FUNC_load_hdr_opt = 142,
	BPF_FUNC_store_hdr_opt = 143,
	BPF_FUNC_reserve_hdr_opt = 144,
	BPF_FUNC_inode_storage_get = 145,
	BPF_FUNC_inode_storage_delete = 146,
	BPF_FUNC_d_path = 147,
	BPF_FUNC_copy_from_user = 148,
	BPF_FUNC_snprintf_btf = 149,
	BPF_FUNC_seq_printf_btf = 150,
	BPF_FUNC_skb_cgroup_classid = 151,
	BPF_FUNC_redirect_neigh = 152,
	BPF_FUNC_per_cpu_ptr = 153,
	BPF_FUNC_this_cpu_ptr = 154,
	BPF_FUNC_redirect_peer = 155,
	BPF_FUNC_task_storage_get = 156,
	BPF_FUNC_task_storage_delete = 157,
	BPF_FUNC_get_current_task_btf = 158,
	BPF_FUNC_bprm_opts_set = 159,
	BPF_FUNC_ktime_get_coarse_ns = 160,
	BPF_FUNC_ima_inode_hash = 161,
	BPF_FUNC_sock_from_file = 162,
	BPF_FUNC_check_mtu = 163,
	BPF_FUNC_for_each_map_elem = 164,
	BPF_FUNC_snprintf = 165,
	BPF_FUNC_sys_bpf = 166,
	BPF_FUNC_btf_find_by_name_kind = 167,
	BPF_FUNC_sys_close = 168,
	BPF_FUNC_timer_init = 169,
	BPF_FUNC_timer_set_callback = 170,
	BPF_FUNC_timer_start = 171,
	BPF_FUNC_timer_cancel = 172,
	BPF_FUNC_get_func_ip = 173,
	BPF_FUNC_get_attach_cookie = 174,
	BPF_FUNC_task_pt_regs = 175,
	BPF_FUNC_get_branch_snapshot = 176,
	BPF_FUNC_trace_vprintk = 177,
	BPF_FUNC_skc_to_unix_sock = 178,
	BPF_FUNC_kallsyms_lookup_name = 179,
	BPF_FUNC_find_vma = 180,
	BPF_FUNC_loop = 181,
	BPF_FUNC_strncmp = 182,
	BPF_FUNC_get_func_arg = 183,
	BPF_FUNC_get_func_ret = 184,
	BPF_FUNC_get_func_arg_cnt = 185,
	BPF_FUNC_get_retval = 186,
	BPF_FUNC_set_retval = 187,
	BPF_FUNC_xdp_get_buff_len = 188,
	BPF_FUNC_xdp_load_bytes = 189,
	BPF_FUNC_xdp_store_bytes = 190,
	BPF_FUNC_copy_from_user_task = 191,
	BPF_FUNC_skb_set_tstamp = 192,
	BPF_FUNC_ima_file_hash = 193,
	BPF_FUNC_kptr_xchg = 194,
	BPF_FUNC_map_lookup_percpu_elem = 195,
	BPF_FUNC_skc_to_mptcp_sock = 196,
	BPF_FUNC_dynptr_from_mem = 197,
	BPF_FUNC_ringbuf_reserve_dynptr = 198,
	BPF_FUNC_ringbuf_submit_dynptr = 199,
	BPF_FUNC_ringbuf_discard_dynptr = 200,
	BPF_FUNC_dynptr_read = 201,
	BPF_FUNC_dynptr_write = 202,
	BPF_FUNC_dynptr_data = 203,
	BPF_FUNC_tcp_raw_gen_syncookie_ipv4 = 204,
	BPF_FUNC_tcp_raw_gen_syncookie_ipv6 = 205,
	BPF_FUNC_tcp_raw_check_syncookie_ipv4 = 206,
	BPF_FUNC_tcp_raw_check_syncookie_ipv6 = 207,
	BPF_FUNC_ktime_get_tai_ns = 208,
	BPF_FUNC_user_ringbuf_drain = 209,
	__BPF_FUNC_MAX_ID = 210,
};

struct bpf_link_info {
	__u32 type;
	__u32 id;
	__u32 prog_id;
	int: 32;
	union {
		struct {
			__u64 tp_name;
			__u32 tp_name_len;
			int: 32;
		} raw_tracepoint;
		struct {
			__u32 attach_type;
			__u32 target_obj_id;
			__u32 target_btf_id;
		} tracing;
		struct {
			__u64 cgroup_id;
			__u32 attach_type;
			int: 32;
		} cgroup;
		struct {
			__u64 target_name;
			__u32 target_name_len;
			union {
				struct {
					__u32 map_id;
				} map;
			};
			union {
				struct {
					__u64 cgroup_id;
					__u32 order;
					int: 32;
				} cgroup;
				struct {
					__u32 tid;
					__u32 pid;
				} task;
			};
		} iter;
		struct {
			__u32 netns_ino;
			__u32 attach_type;
		} netns;
		struct {
			__u32 ifindex;
		} xdp;
	};
};

struct bpf_func_proto {
	u64 (*func)(u64, u64, u64, u64, u64);
	bool gpl_only;
	bool pkt_access;
	enum bpf_return_type ret_type;
	union {
		struct {
			enum bpf_arg_type arg1_type;
			enum bpf_arg_type arg2_type;
			enum bpf_arg_type arg3_type;
			enum bpf_arg_type arg4_type;
			enum bpf_arg_type arg5_type;
		};
		enum bpf_arg_type arg_type[5];
	};
	union {
		struct {
			u32 *arg1_btf_id;
			u32 *arg2_btf_id;
			u32 *arg3_btf_id;
			u32 *arg4_btf_id;
			u32 *arg5_btf_id;
		};
		u32 *arg_btf_id[5];
		struct {
			size_t arg1_size;
			size_t arg2_size;
			size_t arg3_size;
			size_t arg4_size;
			size_t arg5_size;
		};
		size_t arg_size[5];
	};
	int *ret_btf_id;
	bool (*allowed)(const struct bpf_prog *);
};

typedef int (*bpf_iter_attach_target_t)(struct bpf_prog *, union bpf_iter_link_info *, struct bpf_iter_aux_info *);

typedef void (*bpf_iter_detach_target_t)(struct bpf_iter_aux_info *);

typedef void (*bpf_iter_show_fdinfo_t)(const struct bpf_iter_aux_info *, struct seq_file *);

typedef int (*bpf_iter_fill_link_info_t)(const struct bpf_iter_aux_info *, struct bpf_link_info *);

typedef const struct bpf_func_proto * (*bpf_iter_get_func_proto_t)(enum bpf_func_id, const struct bpf_prog *);

enum bpf_iter_feature {
	BPF_ITER_RESCHED = 1,
};

struct bpf_iter_reg {
	const char *target;
	bpf_iter_attach_target_t attach_target;
	bpf_iter_detach_target_t detach_target;
	bpf_iter_show_fdinfo_t show_fdinfo;
	bpf_iter_fill_link_info_t fill_link_info;
	bpf_iter_get_func_proto_t get_func_proto;
	u32 ctx_arg_info_size;
	u32 feature;
	struct bpf_ctx_arg_aux ctx_arg_info[2];
	const struct bpf_iter_seq_info *seq_info;
};

struct bpf_iter_meta {
	union {
		struct seq_file *seq;
	};
	u64 session_id;
	u64 seq_num;
};

struct kallsym_iter {
	loff_t pos;
	loff_t pos_arch_end;
	loff_t pos_mod_end;
	loff_t pos_ftrace_mod_end;
	loff_t pos_bpf_end;
	long unsigned int value;
	unsigned int nameoff;
	char type;
	char name[512];
	char module_name[60];
	int exported;
	int show_value;
};

struct bpf_iter__ksym {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct kallsym_iter *ksym;
	};
};

typedef long unsigned int elf_greg_t;

typedef elf_greg_t elf_gregset_t[18];

struct elf_siginfo {
	int si_signo;
	int si_code;
	int si_errno;
};

struct elf_prstatus_common {
	struct elf_siginfo pr_info;
	short int pr_cursig;
	long unsigned int pr_sigpend;
	long unsigned int pr_sighold;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	struct __kernel_old_timeval pr_utime;
	struct __kernel_old_timeval pr_stime;
	struct __kernel_old_timeval pr_cutime;
	struct __kernel_old_timeval pr_cstime;
};

struct elf_prstatus {
	struct elf_prstatus_common common;
	elf_gregset_t pr_reg;
	int pr_fpvalid;
};

typedef u32 note_buf_t[45];

typedef __kernel_ulong_t ino_t;

struct static_key_true {
	struct static_key key;
};

enum {
	__PERCPU_REF_ATOMIC = 1,
	__PERCPU_REF_DEAD = 2,
	__PERCPU_REF_ATOMIC_DEAD = 3,
	__PERCPU_REF_FLAG_BITS = 2,
};

enum kernfs_node_type {
	KERNFS_DIR = 1,
	KERNFS_FILE = 2,
	KERNFS_LINK = 4,
};

enum kernfs_root_flag {
	KERNFS_ROOT_CREATE_DEACTIVATED = 1,
	KERNFS_ROOT_EXTRA_OPEN_PERM_CHECK = 2,
	KERNFS_ROOT_SUPPORT_EXPORTOP = 4,
	KERNFS_ROOT_SUPPORT_USER_XATTR = 8,
};

struct kernfs_syscall_ops {
	int (*show_options)(struct seq_file *, struct kernfs_root *);
	int (*mkdir)(struct kernfs_node *, const char *, umode_t);
	int (*rmdir)(struct kernfs_node *);
	int (*rename)(struct kernfs_node *, struct kernfs_node *, const char *);
	int (*show_path)(struct seq_file *, struct kernfs_node *, struct kernfs_root *);
};

struct kernfs_fs_context {
	struct kernfs_root *root;
	void *ns_tag;
	long unsigned int magic;
	bool new_sb_created;
};

enum {
	CSS_NO_REF = 1,
	CSS_ONLINE = 2,
	CSS_RELEASED = 4,
	CSS_VISIBLE = 8,
	CSS_DYING = 16,
};

enum {
	CGRP_NOTIFY_ON_RELEASE = 0,
	CGRP_CPUSET_CLONE_CHILDREN = 1,
	CGRP_FREEZE = 2,
	CGRP_FROZEN = 3,
	CGRP_KILL = 4,
};

enum {
	CGRP_ROOT_NOPREFIX = 2,
	CGRP_ROOT_XATTR = 4,
	CGRP_ROOT_NS_DELEGATE = 8,
	CGRP_ROOT_FAVOR_DYNMODS = 16,
	CGRP_ROOT_CPUSET_V2_MODE = 65536,
	CGRP_ROOT_MEMORY_LOCAL_EVENTS = 131072,
	CGRP_ROOT_MEMORY_RECURSIVE_PROT = 262144,
};

enum {
	CFTYPE_ONLY_ON_ROOT = 1,
	CFTYPE_NOT_ON_ROOT = 2,
	CFTYPE_NS_DELEGATABLE = 4,
	CFTYPE_NO_PREFIX = 8,
	CFTYPE_WORLD_WRITABLE = 16,
	CFTYPE_DEBUG = 32,
	__CFTYPE_ONLY_ON_DFL = 65536,
	__CFTYPE_NOT_ON_DFL = 131072,
	__CFTYPE_ADDED = 262144,
};

struct cgroup_taskset {
	struct list_head src_csets;
	struct list_head dst_csets;
	int nr_tasks;
	int ssid;
	struct list_head *csets;
	struct css_set *cur_cset;
	struct task_struct *cur_task;
};

struct css_task_iter {
	struct cgroup_subsys *ss;
	unsigned int flags;
	struct list_head *cset_pos;
	struct list_head *cset_head;
	struct list_head *tcset_pos;
	struct list_head *tcset_head;
	struct list_head *task_pos;
	struct list_head *cur_tasks_head;
	struct css_set *cur_cset;
	struct css_set *cur_dcset;
	struct task_struct *cur_task;
	struct list_head iters_node;
};

struct cgroup_fs_context {
	struct kernfs_fs_context kfc;
	struct cgroup_root *root;
	struct cgroup_namespace *ns;
	unsigned int flags;
	bool cpuset_clone_children;
	bool none;
	bool all_ss;
	u16 subsys_mask;
	char *name;
	char *release_agent;
};

struct cgroup_pidlist;

struct cgroup_file_ctx {
	struct cgroup_namespace *ns;
	struct {
		void *trigger;
	} psi;
	struct {
		bool started;
		struct css_task_iter iter;
	} procs;
	struct {
		struct cgroup_pidlist *pidlist;
	} procs1;
};

struct cgrp_cset_link {
	struct cgroup *cgrp;
	struct css_set *cset;
	struct list_head cset_link;
	struct list_head cgrp_link;
};

struct cgroup_mgctx {
	struct list_head preloaded_src_csets;
	struct list_head preloaded_dst_csets;
	struct cgroup_taskset tset;
	u16 ss_mask;
};

struct bpf_cgroup_storage_key {
	__u64 cgroup_inode_id;
	__u32 attach_type;
	int: 32;
};

struct bpf_storage_buffer;

struct bpf_cgroup_storage_map;

struct bpf_cgroup_storage {
	union {
		struct bpf_storage_buffer *buf;
		void *percpu_buf;
	};
	struct bpf_cgroup_storage_map *map;
	struct bpf_cgroup_storage_key key;
	struct list_head list_map;
	struct list_head list_cg;
	struct rb_node node;
	struct callback_head rcu;
	int: 32;
};

struct bpf_storage_buffer {
	struct callback_head rcu;
	char data[0];
};

struct trace_event_raw_cgroup_root {
	struct trace_entry ent;
	int root;
	u16 ss_mask;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_cgroup {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	char __data[0];
	int: 32;
};

struct trace_event_raw_cgroup_migrate {
	struct trace_entry ent;
	int dst_root;
	int dst_level;
	u64 dst_id;
	int pid;
	u32 __data_loc_dst_path;
	u32 __data_loc_comm;
	char __data[0];
	int: 32;
};

struct trace_event_raw_cgroup_event {
	struct trace_entry ent;
	int root;
	int level;
	u64 id;
	u32 __data_loc_path;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_cgroup_root {
	u32 name;
};

struct trace_event_data_offsets_cgroup {
	u32 path;
};

struct trace_event_data_offsets_cgroup_migrate {
	u32 dst_path;
	u32 comm;
};

struct trace_event_data_offsets_cgroup_event {
	u32 path;
};

typedef void (*btf_trace_cgroup_setup_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_destroy_root)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_remount)(void *, struct cgroup_root *);

typedef void (*btf_trace_cgroup_mkdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rmdir)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_release)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_rename)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_freeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_unfreeze)(void *, struct cgroup *, const char *);

typedef void (*btf_trace_cgroup_attach_task)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_transfer_tasks)(void *, struct cgroup *, const char *, struct task_struct *, bool);

typedef void (*btf_trace_cgroup_notify_populated)(void *, struct cgroup *, const char *, int);

typedef void (*btf_trace_cgroup_notify_frozen)(void *, struct cgroup *, const char *, int);

enum cgroup_opt_features {
	OPT_FEATURE_COUNT = 0,
};

enum cgroup2_param {
	Opt_nsdelegate = 0,
	Opt_favordynmods = 1,
	Opt_memory_localevents = 2,
	Opt_memory_recursiveprot = 3,
	nr__cgroup2_params = 4,
};

struct btf_id_set8;

struct btf_kfunc_id_set {
	struct module *owner;
	struct btf_id_set8 *set;
};

struct btf_id_set8 {
	u32 cnt;
	u32 flags;
	struct {
		u32 id;
		u32 flags;
	} pairs[0];
};

struct cgroupstats {
	__u64 nr_sleeping;
	__u64 nr_running;
	__u64 nr_stopped;
	__u64 nr_uninterruptible;
	__u64 nr_io_wait;
};

enum cgroup_filetype {
	CGROUP_FILE_PROCS = 0,
	CGROUP_FILE_TASKS = 1,
};

struct cgroup_pidlist {
	struct {
		enum cgroup_filetype type;
		struct pid_namespace *ns;
	} key;
	pid_t *list;
	int length;
	struct list_head links;
	struct cgroup *owner;
	struct delayed_work destroy_dwork;
};

enum cgroup1_param {
	Opt_all = 0,
	Opt_clone_children = 1,
	Opt_cpuset_v2_mode = 2,
	Opt_name = 3,
	Opt_none = 4,
	Opt_noprefix = 5,
	Opt_release_agent = 6,
	Opt_xattr = 7,
	Opt_favordynmods___2 = 8,
	Opt_nofavordynmods = 9,
};

enum freezer_state_flags {
	CGROUP_FREEZER_ONLINE = 1,
	CGROUP_FREEZING_SELF = 2,
	CGROUP_FREEZING_PARENT = 4,
	CGROUP_FROZEN = 8,
	CGROUP_FREEZING = 6,
};

struct freezer {
	struct cgroup_subsys_state css;
	unsigned int state;
	int: 32;
};

struct pids_cgroup {
	struct cgroup_subsys_state css;
	atomic64_t counter;
	atomic64_t limit;
	int64_t watermark;
	struct cgroup_file events_file;
	int: 32;
	atomic64_t events_limit;
};

struct kernel_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
};

enum kernel_pkey_operation {
	kernel_pkey_encrypt = 0,
	kernel_pkey_decrypt = 1,
	kernel_pkey_sign = 2,
	kernel_pkey_verify = 3,
};

struct kernel_pkey_params {
	struct key *key;
	const char *encoding;
	const char *hash_algo;
	char *info;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	enum kernel_pkey_operation op: 8;
};

struct key_preparsed_payload {
	const char *orig_description;
	char *description;
	union key_payload payload;
	const void *data;
	size_t datalen;
	size_t quotalen;
	int: 32;
	time64_t expiry;
};

struct key_match_data {
	bool (*cmp)(const struct key *, const struct key_match_data *);
	const void *raw_data;
	void *preparsed;
	unsigned int lookup_type;
};

struct idmap_key {
	bool map_up;
	u32 id;
	u32 count;
};

struct cpu_stop_done {
	atomic_t nr_todo;
	int ret;
	struct completion completion;
};

struct cpu_stopper {
	struct task_struct *thread;
	raw_spinlock_t lock;
	bool enabled;
	struct list_head works;
	struct cpu_stop_work stop_work;
	long unsigned int caller;
	cpu_stop_fn_t fn;
};

enum multi_stop_state {
	MULTI_STOP_NONE = 0,
	MULTI_STOP_PREPARE = 1,
	MULTI_STOP_DISABLE_IRQ = 2,
	MULTI_STOP_RUN = 3,
	MULTI_STOP_EXIT = 4,
};

struct multi_stop_data {
	cpu_stop_fn_t fn;
	void *data;
	unsigned int num_threads;
	const struct cpumask *active_cpus;
	enum multi_stop_state state;
	atomic_t thread_ack;
};

struct kprobe_blacklist_entry {
	struct list_head list;
	long unsigned int start_addr;
	long unsigned int end_addr;
};

enum perf_record_ksymbol_type {
	PERF_RECORD_KSYMBOL_TYPE_UNKNOWN = 0,
	PERF_RECORD_KSYMBOL_TYPE_BPF = 1,
	PERF_RECORD_KSYMBOL_TYPE_OOL = 2,
	PERF_RECORD_KSYMBOL_TYPE_MAX = 3,
};

struct kprobe_insn_page {
	struct list_head list;
	kprobe_opcode_t *insns;
	struct kprobe_insn_cache *cache;
	int nused;
	int ngarbage;
	char slot_used[0];
};

enum kprobe_slot_state {
	SLOT_CLEAN = 0,
	SLOT_DIRTY = 1,
	SLOT_USED = 2,
};

struct seccomp_data {
	int nr;
	__u32 arch;
	__u64 instruction_pointer;
	__u64 args[6];
};

struct seccomp_notif_sizes {
	__u16 seccomp_notif;
	__u16 seccomp_notif_resp;
	__u16 seccomp_data;
};

struct seccomp_notif {
	__u64 id;
	__u32 pid;
	__u32 flags;
	struct seccomp_data data;
};

struct seccomp_notif_resp {
	__u64 id;
	__s64 val;
	__s32 error;
	__u32 flags;
};

struct seccomp_notif_addfd {
	__u64 id;
	__u32 flags;
	__u32 srcfd;
	__u32 newfd;
	__u32 newfd_flags;
};

struct action_cache {
	long unsigned int allow_native[15];
};

struct notification;

struct seccomp_filter {
	refcount_t refs;
	refcount_t users;
	bool log;
	bool wait_killable_recv;
	struct action_cache cache;
	struct seccomp_filter *prev;
	struct bpf_prog *prog;
	struct notification *notif;
	struct mutex notify_lock;
	wait_queue_head_t wqh;
};

struct ctl_path {
	const char *procname;
};

struct sock_fprog {
	short unsigned int len;
	struct sock_filter *filter;
};

typedef unsigned int (*bpf_func_t)(const void *, const struct bpf_insn *);

typedef unsigned int (*bpf_dispatcher_fn)(const void *, const struct bpf_insn *, unsigned int (*)(const void *, const struct bpf_insn *));

enum notify_state {
	SECCOMP_NOTIFY_INIT = 0,
	SECCOMP_NOTIFY_SENT = 1,
	SECCOMP_NOTIFY_REPLIED = 2,
};

struct seccomp_knotif {
	struct task_struct *task;
	int: 32;
	u64 id;
	const struct seccomp_data *data;
	enum notify_state state;
	int error;
	long int val;
	u32 flags;
	struct completion ready;
	struct list_head list;
	struct list_head addfd;
	int: 32;
};

struct seccomp_kaddfd {
	struct file *file;
	int fd;
	unsigned int flags;
	__u32 ioctl_flags;
	union {
		bool setfd;
		int ret;
	};
	struct completion completion;
	struct list_head list;
};

struct notification {
	struct semaphore request;
	u64 next_id;
	struct list_head notifications;
};

struct seccomp_log_name {
	u32 log;
	const char *name;
};

struct rchan;

struct rchan_buf {
	void *start;
	void *data;
	size_t offset;
	size_t subbufs_produced;
	size_t subbufs_consumed;
	struct rchan *chan;
	wait_queue_head_t read_wait;
	struct irq_work wakeup_work;
	struct dentry *dentry;
	struct kref kref;
	struct page **page_array;
	unsigned int page_count;
	unsigned int finalized;
	size_t *padding;
	size_t prev_padding;
	size_t bytes_consumed;
	size_t early_bytes;
	unsigned int cpu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct rchan_callbacks;

struct rchan {
	u32 version;
	size_t subbuf_size;
	size_t n_subbufs;
	size_t alloc_size;
	const struct rchan_callbacks *cb;
	struct kref kref;
	void *private_data;
	size_t last_toobig;
	struct rchan_buf **buf;
	int is_global;
	struct list_head list;
	struct dentry *parent;
	int has_base_filename;
	char base_filename[255];
};

struct rchan_callbacks {
	int (*subbuf_start)(struct rchan_buf *, void *, void *, size_t);
	struct dentry * (*create_buf_file)(const char *, struct dentry *, umode_t, struct rchan_buf *, int *);
	int (*remove_buf_file)(struct dentry *);
};

struct partial_page {
	unsigned int offset;
	unsigned int len;
	long unsigned int private;
};

struct splice_pipe_desc {
	struct page **pages;
	struct partial_page *partial;
	int nr_pages;
	unsigned int nr_pages_max;
	const struct pipe_buf_operations *ops;
	void (*spd_release)(struct splice_pipe_desc *, unsigned int);
};

struct rchan_percpu_buf_dispatcher {
	struct rchan_buf *buf;
	struct dentry *dentry;
};

struct tp_module {
	struct list_head list;
	struct module *mod;
};

enum tp_func_state {
	TP_FUNC_0 = 0,
	TP_FUNC_1 = 1,
	TP_FUNC_2 = 2,
	TP_FUNC_N = 3,
};

enum tp_transition_sync {
	TP_TRANSITION_SYNC_1_0_1 = 0,
	TP_TRANSITION_SYNC_N_2_1 = 1,
	_NR_TP_TRANSITION_SYNC = 2,
};

struct tp_transition_snapshot {
	long unsigned int rcu;
	long unsigned int srcu;
	bool ongoing;
};

struct tp_probes {
	struct callback_head rcu;
	struct tracepoint_func probes[0];
};

enum ring_buffer_type {
	RINGBUF_TYPE_DATA_TYPE_LEN_MAX = 28,
	RINGBUF_TYPE_PADDING = 29,
	RINGBUF_TYPE_TIME_EXTEND = 30,
	RINGBUF_TYPE_TIME_STAMP = 31,
};

enum ring_buffer_flags {
	RB_FL_OVERWRITE = 1,
};

struct ring_buffer_per_cpu;

struct buffer_page;

struct ring_buffer_iter {
	struct ring_buffer_per_cpu *cpu_buffer;
	long unsigned int head;
	long unsigned int next_event;
	struct buffer_page *head_page;
	struct buffer_page *cache_reader_page;
	long unsigned int cache_read;
	u64 read_stamp;
	u64 page_stamp;
	struct ring_buffer_event *event;
	int missed_events;
};

struct rb_irq_work {
	struct irq_work work;
	wait_queue_head_t waiters;
	wait_queue_head_t full_waiters;
	long int wait_index;
	bool waiters_pending;
	bool full_waiters_pending;
	bool wakeup_full;
};

struct trace_buffer {
	unsigned int flags;
	int cpus;
	atomic_t record_disabled;
	cpumask_var_t cpumask;
	struct lock_class_key *reader_lock_key;
	struct mutex mutex;
	struct ring_buffer_per_cpu **buffers;
	struct hlist_node node;
	u64 (*clock)();
	struct rb_irq_work irq_work;
	bool time_stamp_abs;
};

enum {
	RB_LEN_TIME_EXTEND = 8,
	RB_LEN_TIME_STAMP = 8,
};

struct buffer_data_page {
	u64 time_stamp;
	local_t commit;
	unsigned char data[0];
	int: 32;
};

struct buffer_page {
	struct list_head list;
	local_t write;
	unsigned int read;
	local_t entries;
	long unsigned int real_end;
	struct buffer_data_page *page;
};

struct rb_event_info {
	u64 ts;
	u64 delta;
	u64 before;
	u64 after;
	long unsigned int length;
	struct buffer_page *tail_page;
	int add_timestamp;
	int: 32;
};

enum {
	RB_ADD_STAMP_NONE = 0,
	RB_ADD_STAMP_EXTEND = 2,
	RB_ADD_STAMP_ABSOLUTE = 4,
	RB_ADD_STAMP_FORCE = 8,
};

enum {
	RB_CTX_TRANSITION = 0,
	RB_CTX_NMI = 1,
	RB_CTX_IRQ = 2,
	RB_CTX_SOFTIRQ = 3,
	RB_CTX_NORMAL = 4,
	RB_CTX_MAX = 5,
};

struct rb_time_struct {
	local_t cnt;
	local_t top;
	local_t bottom;
	local_t msb;
};

typedef struct rb_time_struct rb_time_t;

struct ring_buffer_per_cpu {
	int cpu;
	atomic_t record_disabled;
	atomic_t resize_disabled;
	struct trace_buffer *buffer;
	raw_spinlock_t reader_lock;
	arch_spinlock_t lock;
	struct lock_class_key lock_key;
	struct buffer_data_page *free_page;
	long unsigned int nr_pages;
	unsigned int current_context;
	struct list_head *pages;
	struct buffer_page *head_page;
	struct buffer_page *tail_page;
	struct buffer_page *commit_page;
	struct buffer_page *reader_page;
	long unsigned int lost_events;
	long unsigned int last_overrun;
	long unsigned int nest;
	local_t entries_bytes;
	local_t entries;
	local_t overrun;
	local_t commit_overrun;
	local_t dropped_events;
	local_t committing;
	local_t commits;
	local_t pages_touched;
	local_t pages_lost;
	local_t pages_read;
	long int last_pages_touch;
	size_t shortest_full;
	long unsigned int read;
	long unsigned int read_bytes;
	rb_time_t write_stamp;
	rb_time_t before_stamp;
	int: 32;
	u64 event_stamp[5];
	u64 read_stamp;
	long int nr_pages_to_update;
	struct list_head new_pages;
	struct work_struct update_pages_work;
	struct completion update_done;
	struct rb_irq_work irq_work;
	int: 32;
};

typedef struct {
	int val[2];
} __kernel_fsid_t;

typedef struct fsnotify_mark_connector *fsnotify_connp_t;

struct fsnotify_mark_connector {
	spinlock_t lock;
	short unsigned int type;
	short unsigned int flags;
	__kernel_fsid_t fsid;
	union {
		fsnotify_connp_t *obj;
		struct fsnotify_mark_connector *destroy_next;
	};
	struct hlist_head list;
};

struct trace_export {
	struct trace_export *next;
	void (*write)(struct trace_export *, const void *, unsigned int);
	int flags;
};

enum fsnotify_iter_type {
	FSNOTIFY_ITER_TYPE_INODE = 0,
	FSNOTIFY_ITER_TYPE_VFSMOUNT = 1,
	FSNOTIFY_ITER_TYPE_SB = 2,
	FSNOTIFY_ITER_TYPE_PARENT = 3,
	FSNOTIFY_ITER_TYPE_INODE2 = 4,
	FSNOTIFY_ITER_TYPE_COUNT = 5,
};

struct prog_entry;

struct event_filter {
	struct prog_entry *prog;
	char *filter_string;
};

struct trace_array_cpu;

struct array_buffer {
	struct trace_array *tr;
	struct trace_buffer *buffer;
	struct trace_array_cpu *data;
	int: 32;
	u64 time_start;
	int cpu;
	int: 32;
};

struct trace_pid_list;

struct trace_options;

struct trace_func_repeats;

struct trace_array {
	struct list_head list;
	char *name;
	int: 32;
	struct array_buffer array_buffer;
	struct trace_pid_list *filtered_pids;
	struct trace_pid_list *filtered_no_pids;
	arch_spinlock_t max_lock;
	int buffer_disabled;
	int stop_count;
	int clock_id;
	int nr_topts;
	bool clear_trace;
	int buffer_percent;
	unsigned int n_err_log_entries;
	struct tracer *current_trace;
	unsigned int trace_flags;
	unsigned char trace_flags_index[32];
	unsigned int flags;
	raw_spinlock_t start_lock;
	struct list_head err_log;
	struct dentry *dir;
	struct dentry *options;
	struct dentry *percpu_dir;
	struct dentry *event_dir;
	struct trace_options *topts;
	struct list_head systems;
	struct list_head events;
	struct trace_event_file *trace_marker_file;
	cpumask_var_t tracing_cpumask;
	int ref;
	int trace_ref;
	int no_filter_buffering_ref;
	struct list_head hist_vars;
	struct trace_func_repeats *last_func_repeats;
	int: 32;
};

struct tracer_flags;

struct tracer {
	const char *name;
	int (*init)(struct trace_array *);
	void (*reset)(struct trace_array *);
	void (*start)(struct trace_array *);
	void (*stop)(struct trace_array *);
	int (*update_thresh)(struct trace_array *);
	void (*open)(struct trace_iterator *);
	void (*pipe_open)(struct trace_iterator *);
	void (*close)(struct trace_iterator *);
	void (*pipe_close)(struct trace_iterator *);
	ssize_t (*read)(struct trace_iterator *, struct file *, char *, size_t, loff_t *);
	ssize_t (*splice_read)(struct trace_iterator *, struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);
	void (*print_header)(struct seq_file *);
	enum print_line_t (*print_line)(struct trace_iterator *);
	int (*set_flag)(struct trace_array *, u32, u32, int);
	int (*flag_changed)(struct trace_array *, u32, int);
	struct tracer *next;
	struct tracer_flags *flags;
	int enabled;
	bool print_max;
	bool allow_instances;
	bool noboot;
};

enum trace_iter_flags {
	TRACE_FILE_LAT_FMT = 1,
	TRACE_FILE_ANNOTATE = 2,
	TRACE_FILE_TIME_IN_NS = 4,
};

enum trace_flag_type {
	TRACE_FLAG_IRQS_OFF = 1,
	TRACE_FLAG_IRQS_NOSUPPORT = 2,
	TRACE_FLAG_NEED_RESCHED = 4,
	TRACE_FLAG_HARDIRQ = 8,
	TRACE_FLAG_SOFTIRQ = 16,
	TRACE_FLAG_PREEMPT_RESCHED = 32,
	TRACE_FLAG_NMI = 64,
	TRACE_FLAG_BH_OFF = 128,
};

struct event_subsystem;

struct trace_subsystem_dir {
	struct list_head list;
	struct event_subsystem *subsystem;
	struct trace_array *tr;
	struct dentry *entry;
	int ref_count;
	int nr_events;
};

enum event_trigger_type {
	ETT_NONE = 0,
	ETT_TRACE_ONOFF = 1,
	ETT_SNAPSHOT = 2,
	ETT_STACKTRACE = 4,
	ETT_EVENT_ENABLE = 8,
	ETT_EVENT_HIST = 16,
	ETT_HIST_ENABLE = 32,
	ETT_EVENT_EPROBE = 64,
};

union lower_chunk {
	union lower_chunk *next;
	long unsigned int data[512];
};

union upper_chunk {
	union upper_chunk *next;
	union lower_chunk *data[256];
};

struct trace_pid_list {
	raw_spinlock_t lock;
	struct irq_work refill_irqwork;
	union upper_chunk *upper[256];
	union upper_chunk *upper_list;
	union lower_chunk *lower_list;
	int free_upper_chunks;
	int free_lower_chunks;
};

enum trace_type {
	__TRACE_FIRST_TYPE = 0,
	TRACE_FN = 1,
	TRACE_CTX = 2,
	TRACE_WAKE = 3,
	TRACE_STACK = 4,
	TRACE_PRINT = 5,
	TRACE_BPRINT = 6,
	TRACE_MMIO_RW = 7,
	TRACE_MMIO_MAP = 8,
	TRACE_BRANCH = 9,
	TRACE_GRAPH_RET = 10,
	TRACE_GRAPH_ENT = 11,
	TRACE_USER_STACK = 12,
	TRACE_BLK = 13,
	TRACE_BPUTS = 14,
	TRACE_HWLAT = 15,
	TRACE_OSNOISE = 16,
	TRACE_TIMERLAT = 17,
	TRACE_RAW_DATA = 18,
	TRACE_FUNC_REPEATS = 19,
	__TRACE_LAST_TYPE = 20,
};

struct ftrace_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
};

struct stack_entry {
	struct trace_entry ent;
	int size;
	long unsigned int caller[8];
};

struct bprint_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *fmt;
	u32 buf[0];
};

struct print_entry {
	struct trace_entry ent;
	long unsigned int ip;
	char buf[0];
};

struct raw_data_entry {
	struct trace_entry ent;
	unsigned int id;
	char buf[0];
};

struct bputs_entry {
	struct trace_entry ent;
	long unsigned int ip;
	const char *str;
};

struct func_repeats_entry {
	struct trace_entry ent;
	long unsigned int ip;
	long unsigned int parent_ip;
	u16 count;
	u16 top_delta_ts;
	u32 bottom_delta_ts;
};

struct trace_array_cpu {
	atomic_t disabled;
	void *buffer_page;
	long unsigned int entries;
	long unsigned int saved_latency;
	long unsigned int critical_start;
	long unsigned int critical_end;
	long unsigned int critical_sequence;
	long unsigned int nice;
	long unsigned int policy;
	long unsigned int rt_priority;
	long unsigned int skipped_entries;
	int: 32;
	u64 preempt_timestamp;
	pid_t pid;
	kuid_t uid;
	char comm[16];
	bool ignore_pid;
	int: 24;
	int: 32;
};

struct trace_option_dentry;

struct trace_options {
	struct tracer *tracer;
	struct trace_option_dentry *topts;
};

struct tracer_opt;

struct trace_option_dentry {
	struct tracer_opt *opt;
	struct tracer_flags *flags;
	struct trace_array *tr;
	struct dentry *entry;
};

typedef bool (*cond_update_fn_t)(struct trace_array *, void *);

struct trace_func_repeats {
	long unsigned int ip;
	long unsigned int parent_ip;
	long unsigned int count;
	int: 32;
	u64 ts_last_call;
};

enum {
	TRACE_ARRAY_FL_GLOBAL = 1,
};

struct tracer_opt {
	const char *name;
	u32 bit;
};

struct tracer_flags {
	u32 val;
	struct tracer_opt *opts;
	struct tracer *trace;
};

struct trace_parser {
	bool cont;
	char *buffer;
	unsigned int idx;
	unsigned int size;
};

enum trace_iterator_bits {
	TRACE_ITER_PRINT_PARENT_BIT = 0,
	TRACE_ITER_SYM_OFFSET_BIT = 1,
	TRACE_ITER_SYM_ADDR_BIT = 2,
	TRACE_ITER_VERBOSE_BIT = 3,
	TRACE_ITER_RAW_BIT = 4,
	TRACE_ITER_HEX_BIT = 5,
	TRACE_ITER_BIN_BIT = 6,
	TRACE_ITER_BLOCK_BIT = 7,
	TRACE_ITER_PRINTK_BIT = 8,
	TRACE_ITER_ANNOTATE_BIT = 9,
	TRACE_ITER_USERSTACKTRACE_BIT = 10,
	TRACE_ITER_SYM_USEROBJ_BIT = 11,
	TRACE_ITER_PRINTK_MSGONLY_BIT = 12,
	TRACE_ITER_CONTEXT_INFO_BIT = 13,
	TRACE_ITER_LATENCY_FMT_BIT = 14,
	TRACE_ITER_RECORD_CMD_BIT = 15,
	TRACE_ITER_RECORD_TGID_BIT = 16,
	TRACE_ITER_OVERWRITE_BIT = 17,
	TRACE_ITER_STOP_ON_FREE_BIT = 18,
	TRACE_ITER_IRQ_INFO_BIT = 19,
	TRACE_ITER_MARKERS_BIT = 20,
	TRACE_ITER_EVENT_FORK_BIT = 21,
	TRACE_ITER_PAUSE_ON_TRACE_BIT = 22,
	TRACE_ITER_HASH_PTR_BIT = 23,
	TRACE_ITER_STACKTRACE_BIT = 24,
	TRACE_ITER_LAST_BIT = 25,
};

enum trace_iterator_flags {
	TRACE_ITER_PRINT_PARENT = 1,
	TRACE_ITER_SYM_OFFSET = 2,
	TRACE_ITER_SYM_ADDR = 4,
	TRACE_ITER_VERBOSE = 8,
	TRACE_ITER_RAW = 16,
	TRACE_ITER_HEX = 32,
	TRACE_ITER_BIN = 64,
	TRACE_ITER_BLOCK = 128,
	TRACE_ITER_PRINTK = 256,
	TRACE_ITER_ANNOTATE = 512,
	TRACE_ITER_USERSTACKTRACE = 1024,
	TRACE_ITER_SYM_USEROBJ = 2048,
	TRACE_ITER_PRINTK_MSGONLY = 4096,
	TRACE_ITER_CONTEXT_INFO = 8192,
	TRACE_ITER_LATENCY_FMT = 16384,
	TRACE_ITER_RECORD_CMD = 32768,
	TRACE_ITER_RECORD_TGID = 65536,
	TRACE_ITER_OVERWRITE = 131072,
	TRACE_ITER_STOP_ON_FREE = 262144,
	TRACE_ITER_IRQ_INFO = 524288,
	TRACE_ITER_MARKERS = 1048576,
	TRACE_ITER_EVENT_FORK = 2097152,
	TRACE_ITER_PAUSE_ON_TRACE = 4194304,
	TRACE_ITER_HASH_PTR = 8388608,
	TRACE_ITER_STACKTRACE = 16777216,
};

struct event_subsystem {
	struct list_head list;
	const char *name;
	struct event_filter *filter;
	int ref_count;
};

struct trace_min_max_param {
	struct mutex *lock;
	u64 *val;
	u64 *min;
	u64 *max;
};

struct saved_cmdlines_buffer {
	unsigned int map_pid_to_cmdline[32769];
	unsigned int *map_cmdline_to_pid;
	unsigned int cmdline_num;
	int cmdline_idx;
	char *saved_cmdlines;
};

struct ftrace_stack {
	long unsigned int calls[1024];
};

struct ftrace_stacks {
	struct ftrace_stack stacks[4];
};

struct trace_buffer_struct {
	int nesting;
	char buffer[4096];
};

struct ftrace_buffer_info {
	struct trace_iterator iter;
	void *spare;
	unsigned int spare_cpu;
	unsigned int read;
	int: 32;
};

struct err_info {
	const char **errs;
	u8 type;
	u16 pos;
	u64 ts;
};

struct tracing_log_err {
	struct list_head list;
	struct err_info info;
	char loc[128];
	char *cmd;
	int: 32;
};

struct buffer_ref {
	struct trace_buffer *buffer;
	void *page;
	int cpu;
	refcount_t refcount;
};

struct trace_print_flags_u64 {
	long long unsigned int mask;
	const char *name;
	int: 32;
};

struct ctx_switch_entry {
	struct trace_entry ent;
	unsigned int prev_pid;
	unsigned int next_pid;
	unsigned int next_cpu;
	unsigned char prev_prio;
	unsigned char prev_state;
	unsigned char next_prio;
	unsigned char next_state;
};

struct userstack_entry {
	struct trace_entry ent;
	unsigned int tgid;
	long unsigned int caller[8];
};

struct hwlat_entry {
	struct trace_entry ent;
	u64 duration;
	u64 outer_duration;
	u64 nmi_total_ts;
	struct timespec64 timestamp;
	unsigned int nmi_count;
	unsigned int seqnum;
	unsigned int count;
	int: 32;
};

struct osnoise_entry {
	struct trace_entry ent;
	u64 noise;
	u64 runtime;
	u64 max_sample;
	unsigned int hw_count;
	unsigned int nmi_count;
	unsigned int irq_count;
	unsigned int softirq_count;
	unsigned int thread_count;
	int: 32;
};

struct timerlat_entry {
	struct trace_entry ent;
	unsigned int seqnum;
	int context;
	u64 timer_latency;
};

struct trace_mark {
	long long unsigned int val;
	char sym;
	int: 24;
	int: 32;
};

typedef int (*cmp_func_t)(const void *, const void *);

struct tracer_stat {
	const char *name;
	void * (*stat_start)(struct tracer_stat *);
	void * (*stat_next)(void *, int);
	cmp_func_t stat_cmp;
	int (*stat_show)(struct seq_file *, void *);
	void (*stat_release)(void *);
	int (*stat_headers)(struct seq_file *);
};

struct stat_node {
	struct rb_node node;
	void *stat;
};

struct stat_session {
	struct list_head session_list;
	struct tracer_stat *ts;
	struct rb_root stat_root;
	struct mutex stat_mutex;
	struct dentry *file;
};

struct trace_bprintk_fmt {
	struct list_head list;
	const char *fmt;
};

enum {
	TRACE_NOP_OPT_ACCEPT = 1,
	TRACE_NOP_OPT_REFUSE = 2,
};

enum req_flag_bits {
	__REQ_FAILFAST_DEV = 8,
	__REQ_FAILFAST_TRANSPORT = 9,
	__REQ_FAILFAST_DRIVER = 10,
	__REQ_SYNC = 11,
	__REQ_META = 12,
	__REQ_PRIO = 13,
	__REQ_NOMERGE = 14,
	__REQ_IDLE = 15,
	__REQ_INTEGRITY = 16,
	__REQ_FUA = 17,
	__REQ_PREFLUSH = 18,
	__REQ_RAHEAD = 19,
	__REQ_BACKGROUND = 20,
	__REQ_NOWAIT = 21,
	__REQ_CGROUP_PUNT = 22,
	__REQ_POLLED = 23,
	__REQ_ALLOC_CACHE = 24,
	__REQ_SWAP = 25,
	__REQ_DRV = 26,
	__REQ_NOUNMAP = 27,
	__REQ_NR_BITS = 28,
};

enum {
	TRACE_PIDS = 1,
	TRACE_NO_PIDS = 2,
};

struct ftrace_event_field {
	struct list_head link;
	const char *name;
	const char *type;
	int filter_type;
	int offset;
	int size;
	int is_signed;
};

struct module_string {
	struct list_head next;
	struct module *module;
	char *str;
};

enum {
	FORMAT_HEADER = 1,
	FORMAT_FIELD_SEPERATOR = 2,
	FORMAT_PRINTFMT = 3,
};

typedef long unsigned int perf_trace_t[2048];

struct filter_pred;

struct prog_entry {
	int target;
	int when_to_branch;
	struct filter_pred *pred;
};

struct regex;

typedef int (*regex_match_func)(char *, struct regex *, int);

struct regex {
	char pattern[256];
	int len;
	int field_len;
	regex_match_func match;
};

enum regex_type {
	MATCH_FULL = 0,
	MATCH_FRONT_ONLY = 1,
	MATCH_MIDDLE_ONLY = 2,
	MATCH_END_ONLY = 3,
	MATCH_GLOB = 4,
	MATCH_INDEX = 5,
};

enum filter_op_ids {
	OP_GLOB = 0,
	OP_NE = 1,
	OP_EQ = 2,
	OP_LE = 3,
	OP_LT = 4,
	OP_GE = 5,
	OP_GT = 6,
	OP_BAND = 7,
	OP_MAX = 8,
};

enum filter_pred_fn {
	FILTER_PRED_FN_NOP = 0,
	FILTER_PRED_FN_64 = 1,
	FILTER_PRED_FN_S64 = 2,
	FILTER_PRED_FN_U64 = 3,
	FILTER_PRED_FN_32 = 4,
	FILTER_PRED_FN_S32 = 5,
	FILTER_PRED_FN_U32 = 6,
	FILTER_PRED_FN_16 = 7,
	FILTER_PRED_FN_S16 = 8,
	FILTER_PRED_FN_U16 = 9,
	FILTER_PRED_FN_8 = 10,
	FILTER_PRED_FN_S8 = 11,
	FILTER_PRED_FN_U8 = 12,
	FILTER_PRED_FN_COMM = 13,
	FILTER_PRED_FN_STRING = 14,
	FILTER_PRED_FN_STRLOC = 15,
	FILTER_PRED_FN_STRRELLOC = 16,
	FILTER_PRED_FN_PCHAR_USER = 17,
	FILTER_PRED_FN_PCHAR = 18,
	FILTER_PRED_FN_CPU = 19,
	FILTER_PRED_FN_ = 20,
	FILTER_PRED_TEST_VISITED = 21,
};

struct filter_pred {
	enum filter_pred_fn fn_num;
	int: 32;
	u64 val;
	struct regex regex;
	short unsigned int *ops;
	struct ftrace_event_field *field;
	int offset;
	int not;
	int op;
};

enum {
	FILT_ERR_NONE = 0,
	FILT_ERR_INVALID_OP = 1,
	FILT_ERR_TOO_MANY_OPEN = 2,
	FILT_ERR_TOO_MANY_CLOSE = 3,
	FILT_ERR_MISSING_QUOTE = 4,
	FILT_ERR_OPERAND_TOO_LONG = 5,
	FILT_ERR_EXPECT_STRING = 6,
	FILT_ERR_EXPECT_DIGIT = 7,
	FILT_ERR_ILLEGAL_FIELD_OP = 8,
	FILT_ERR_FIELD_NOT_FOUND = 9,
	FILT_ERR_ILLEGAL_INTVAL = 10,
	FILT_ERR_BAD_SUBSYS_FILTER = 11,
	FILT_ERR_TOO_MANY_PREDS = 12,
	FILT_ERR_INVALID_FILTER = 13,
	FILT_ERR_IP_FIELD_ONLY = 14,
	FILT_ERR_INVALID_VALUE = 15,
	FILT_ERR_ERRNO = 16,
	FILT_ERR_NO_FILTER = 17,
};

struct filter_parse_error {
	int lasterr;
	int lasterr_pos;
};

typedef int (*parse_pred_fn)(const char *, void *, int, struct filter_parse_error *, struct filter_pred **);

enum {
	INVERT = 1,
	PROCESS_AND = 2,
	PROCESS_OR = 4,
};

struct ustring_buffer {
	char buffer[1024];
};

enum {
	TOO_MANY_CLOSE = 4294967295,
	TOO_MANY_OPEN = 4294967294,
	MISSING_QUOTE = 4294967293,
};

struct filter_list {
	struct list_head list;
	struct event_filter *filter;
};

enum {
	EVENT_TRIGGER_FL_PROBE = 1,
};

struct event_trigger_ops;

struct event_command;

struct event_trigger_data {
	long unsigned int count;
	int ref;
	int flags;
	struct event_trigger_ops *ops;
	struct event_command *cmd_ops;
	struct event_filter *filter;
	char *filter_str;
	void *private_data;
	bool paused;
	bool paused_tmp;
	struct list_head list;
	char *name;
	struct list_head named_list;
	struct event_trigger_data *named_data;
};

struct event_trigger_ops {
	void (*trigger)(struct event_trigger_data *, struct trace_buffer *, void *, struct ring_buffer_event *);
	int (*init)(struct event_trigger_data *);
	void (*free)(struct event_trigger_data *);
	int (*print)(struct seq_file *, struct event_trigger_data *);
};

struct event_command {
	struct list_head list;
	char *name;
	enum event_trigger_type trigger_type;
	int flags;
	int (*parse)(struct event_command *, struct trace_event_file *, char *, char *, char *);
	int (*reg)(char *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg)(char *, struct event_trigger_data *, struct trace_event_file *);
	void (*unreg_all)(struct trace_event_file *);
	int (*set_filter)(char *, struct event_trigger_data *, struct trace_event_file *);
	struct event_trigger_ops * (*get_trigger_ops)(char *, char *);
};

struct enable_trigger_data {
	struct trace_event_file *file;
	bool enable;
	bool hist;
};

enum event_command_flags {
	EVENT_CMD_FL_POST_TRIGGER = 1,
	EVENT_CMD_FL_NEEDS_REC = 2,
};

struct eprobe_trace_entry_head {
	struct trace_entry ent;
};

struct dyn_event;

struct dyn_event_operations {
	struct list_head list;
	int (*create)(const char *);
	int (*show)(struct seq_file *, struct dyn_event *);
	bool (*is_busy)(struct dyn_event *);
	int (*free)(struct dyn_event *);
	bool (*match)(const char *, const char *, int, const char **, struct dyn_event *);
};

struct dyn_event {
	struct list_head list;
	struct dyn_event_operations *ops;
};

typedef int (*print_type_func_t)(struct trace_seq *, void *, void *);

enum fetch_op {
	FETCH_OP_NOP = 0,
	FETCH_OP_REG = 1,
	FETCH_OP_STACK = 2,
	FETCH_OP_STACKP = 3,
	FETCH_OP_RETVAL = 4,
	FETCH_OP_IMM = 5,
	FETCH_OP_COMM = 6,
	FETCH_OP_ARG = 7,
	FETCH_OP_FOFFS = 8,
	FETCH_OP_DATA = 9,
	FETCH_OP_DEREF = 10,
	FETCH_OP_UDEREF = 11,
	FETCH_OP_ST_RAW = 12,
	FETCH_OP_ST_MEM = 13,
	FETCH_OP_ST_UMEM = 14,
	FETCH_OP_ST_STRING = 15,
	FETCH_OP_ST_USTRING = 16,
	FETCH_OP_MOD_BF = 17,
	FETCH_OP_LP_ARRAY = 18,
	FETCH_OP_TP_ARG = 19,
	FETCH_OP_END = 20,
	FETCH_NOP_SYMBOL = 21,
};

struct fetch_insn {
	enum fetch_op op;
	union {
		unsigned int param;
		struct {
			unsigned int size;
			int offset;
		};
		struct {
			unsigned char basesize;
			unsigned char lshift;
			unsigned char rshift;
		};
		long unsigned int immediate;
		void *data;
	};
};

struct fetch_type {
	const char *name;
	size_t size;
	int is_signed;
	print_type_func_t print;
	const char *fmt;
	const char *fmttype;
};

struct probe_arg {
	struct fetch_insn *code;
	bool dynamic;
	unsigned int offset;
	unsigned int count;
	const char *name;
	const char *comm;
	char *fmt;
	const struct fetch_type *type;
};

struct trace_uprobe_filter {
	rwlock_t rwlock;
	int nr_systemwide;
	struct list_head perf_events;
};

struct trace_probe_event {
	unsigned int flags;
	struct trace_event_class class;
	struct trace_event_call call;
	struct list_head files;
	struct list_head probes;
	struct trace_uprobe_filter filter[0];
};

struct trace_probe {
	struct list_head list;
	struct trace_probe_event *event;
	ssize_t size;
	unsigned int nr_args;
	struct probe_arg args[0];
};

enum probe_print_type {
	PROBE_PRINT_NORMAL = 0,
	PROBE_PRINT_RETURN = 1,
	PROBE_PRINT_EVENT = 2,
};

enum {
	TP_ERR_FILE_NOT_FOUND = 0,
	TP_ERR_NO_REGULAR_FILE = 1,
	TP_ERR_BAD_REFCNT = 2,
	TP_ERR_REFCNT_OPEN_BRACE = 3,
	TP_ERR_BAD_REFCNT_SUFFIX = 4,
	TP_ERR_BAD_UPROBE_OFFS = 5,
	TP_ERR_MAXACT_NO_KPROBE = 6,
	TP_ERR_BAD_MAXACT = 7,
	TP_ERR_MAXACT_TOO_BIG = 8,
	TP_ERR_BAD_PROBE_ADDR = 9,
	TP_ERR_BAD_RETPROBE = 10,
	TP_ERR_BAD_ADDR_SUFFIX = 11,
	TP_ERR_NO_GROUP_NAME = 12,
	TP_ERR_GROUP_TOO_LONG = 13,
	TP_ERR_BAD_GROUP_NAME = 14,
	TP_ERR_NO_EVENT_NAME = 15,
	TP_ERR_EVENT_TOO_LONG = 16,
	TP_ERR_BAD_EVENT_NAME = 17,
	TP_ERR_EVENT_EXIST = 18,
	TP_ERR_RETVAL_ON_PROBE = 19,
	TP_ERR_BAD_STACK_NUM = 20,
	TP_ERR_BAD_ARG_NUM = 21,
	TP_ERR_BAD_VAR = 22,
	TP_ERR_BAD_REG_NAME = 23,
	TP_ERR_BAD_MEM_ADDR = 24,
	TP_ERR_BAD_IMM = 25,
	TP_ERR_IMMSTR_NO_CLOSE = 26,
	TP_ERR_FILE_ON_KPROBE = 27,
	TP_ERR_BAD_FILE_OFFS = 28,
	TP_ERR_SYM_ON_UPROBE = 29,
	TP_ERR_TOO_MANY_OPS = 30,
	TP_ERR_DEREF_NEED_BRACE = 31,
	TP_ERR_BAD_DEREF_OFFS = 32,
	TP_ERR_DEREF_OPEN_BRACE = 33,
	TP_ERR_COMM_CANT_DEREF = 34,
	TP_ERR_BAD_FETCH_ARG = 35,
	TP_ERR_ARRAY_NO_CLOSE = 36,
	TP_ERR_BAD_ARRAY_SUFFIX = 37,
	TP_ERR_BAD_ARRAY_NUM = 38,
	TP_ERR_ARRAY_TOO_BIG = 39,
	TP_ERR_BAD_TYPE = 40,
	TP_ERR_BAD_STRING = 41,
	TP_ERR_BAD_BITFIELD = 42,
	TP_ERR_ARG_NAME_TOO_LONG = 43,
	TP_ERR_NO_ARG_NAME = 44,
	TP_ERR_BAD_ARG_NAME = 45,
	TP_ERR_USED_ARG_NAME = 46,
	TP_ERR_ARG_TOO_LONG = 47,
	TP_ERR_NO_ARG_BODY = 48,
	TP_ERR_BAD_INSN_BNDRY = 49,
	TP_ERR_FAIL_REG_PROBE = 50,
	TP_ERR_DIFF_PROBE_TYPE = 51,
	TP_ERR_DIFF_ARG_TYPE = 52,
	TP_ERR_SAME_PROBE = 53,
	TP_ERR_NO_EVENT_INFO = 54,
	TP_ERR_BAD_ATTACH_EVENT = 55,
	TP_ERR_BAD_ATTACH_ARG = 56,
	TP_ERR_NO_EP_FILTER = 57,
};

struct trace_eprobe {
	const char *event_system;
	const char *event_name;
	char *filter_str;
	struct trace_event_call *event;
	struct dyn_event devent;
	struct trace_probe tp;
};

struct eprobe_data {
	struct trace_event_file *file;
	struct trace_eprobe *ep;
};

enum {
	BPF_F_INDEX_MASK = 4294967295,
	BPF_F_CURRENT_CPU = 4294967295,
	BPF_F_CTXLEN_MASK = 0,
};

enum {
	BPF_F_GET_BRANCH_RECORDS_SIZE = 1,
};

struct bpf_perf_event_value {
	__u64 counter;
	__u64 enabled;
	__u64 running;
};

struct bpf_raw_tracepoint_args {
	__u64 args[0];
};

enum bpf_task_fd_type {
	BPF_FD_TYPE_RAW_TRACEPOINT = 0,
	BPF_FD_TYPE_TRACEPOINT = 1,
	BPF_FD_TYPE_KPROBE = 2,
	BPF_FD_TYPE_KRETPROBE = 3,
	BPF_FD_TYPE_UPROBE = 4,
	BPF_FD_TYPE_URETPROBE = 5,
};

struct btf_ptr {
	void *ptr;
	__u32 type_id;
	__u32 flags;
};

enum {
	BTF_F_COMPACT = 1,
	BTF_F_NONAME = 2,
	BTF_F_PTR_RAW = 4,
	BTF_F_ZERO = 8,
};

struct bpf_local_storage_data;

struct bpf_local_storage {
	struct bpf_local_storage_data *cache[16];
	struct hlist_head list;
	void *owner;
	struct callback_head rcu;
	raw_spinlock_t lock;
};

enum key_need_perm {
	KEY_NEED_UNSPECIFIED = 0,
	KEY_NEED_VIEW = 1,
	KEY_NEED_READ = 2,
	KEY_NEED_WRITE = 3,
	KEY_NEED_SEARCH = 4,
	KEY_NEED_LINK = 5,
	KEY_NEED_SETATTR = 6,
	KEY_NEED_UNLINK = 7,
	KEY_SYSADMIN_OVERRIDE = 8,
	KEY_AUTHTOKEN_OVERRIDE = 9,
	KEY_DEFER_PERM_CHECK = 10,
};

enum key_lookup_flag {
	KEY_LOOKUP_CREATE = 1,
	KEY_LOOKUP_PARTIAL = 2,
	KEY_LOOKUP_ALL = 3,
};

struct __key_reference_with_attributes;

typedef struct __key_reference_with_attributes *key_ref_t;

struct bpf_local_storage_map_bucket;

struct bpf_local_storage_map {
	struct bpf_map map;
	struct bpf_local_storage_map_bucket *buckets;
	u32 bucket_log;
	u16 elem_size;
	u16 cache_idx;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum bpf_access_type {
	BPF_READ = 1,
	BPF_WRITE = 2,
};

struct bpf_verifier_log;

struct bpf_insn_access_aux {
	enum bpf_reg_type reg_type;
	union {
		int ctx_field_size;
		struct {
			struct btf *btf;
			u32 btf_id;
		};
	};
	struct bpf_verifier_log *log;
};

struct bpf_verifier_ops {
	const struct bpf_func_proto * (*get_func_proto)(enum bpf_func_id, const struct bpf_prog *);
	bool (*is_valid_access)(int, int, enum bpf_access_type, const struct bpf_prog *, struct bpf_insn_access_aux *);
	int (*gen_prologue)(struct bpf_insn *, bool, const struct bpf_prog *);
	int (*gen_ld_abs)(const struct bpf_insn *, struct bpf_insn *);
	u32 (*convert_ctx_access)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);
	int (*btf_struct_access)(struct bpf_verifier_log *, const struct btf *, const struct btf_type *, int, int, enum bpf_access_type, u32 *, enum bpf_type_flag *);
};

struct bpf_array_aux {
	struct list_head poke_progs;
	struct bpf_map *map;
	struct mutex poke_mutex;
	struct work_struct work;
};

struct bpf_array {
	struct bpf_map map;
	u32 elem_size;
	u32 index_mask;
	struct bpf_array_aux *aux;
	int: 32;
	union {
		char value[0];
		void *ptrs[0];
		void *pptrs[0];
	};
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_event_entry {
	struct perf_event *event;
	struct file *perf_file;
	struct file *map_file;
	struct callback_head rcu;
};

typedef long unsigned int (*bpf_ctx_copy_t)(void *, const void *, long unsigned int, long unsigned int);

struct bpf_trace_run_ctx {
	struct bpf_run_ctx run_ctx;
	u64 bpf_cookie;
};

typedef u32 (*bpf_prog_run_fn)(const struct bpf_prog *, const void *);

struct bpf_key {
	struct key *key;
	bool has_ref;
};

typedef struct pt_regs bpf_user_pt_regs_t;

struct bpf_perf_event_data {
	bpf_user_pt_regs_t regs;
	__u64 sample_period;
	__u64 addr;
};

struct perf_event_query_bpf {
	__u32 ids_len;
	__u32 prog_cnt;
	__u32 ids[0];
};

struct bpf_perf_event_data_kern {
	bpf_user_pt_regs_t *regs;
	struct perf_sample_data *data;
	struct perf_event *event;
};

struct btf_id_set {
	u32 cnt;
	u32 ids[0];
};

enum {
	BTF_TRACING_TYPE_TASK = 0,
	BTF_TRACING_TYPE_FILE = 1,
	BTF_TRACING_TYPE_VMA = 2,
	MAX_BTF_TRACING_TYPE = 3,
};

struct bpf_local_storage_map_bucket {
	struct hlist_head list;
	raw_spinlock_t lock;
};

struct bpf_local_storage_data {
	struct bpf_local_storage_map *smap;
	int: 32;
	u8 data[0];
};

struct trace_event_raw_bpf_trace_printk {
	struct trace_entry ent;
	u32 __data_loc_bpf_string;
	char __data[0];
};

struct trace_event_data_offsets_bpf_trace_printk {
	u32 bpf_string;
};

typedef void (*btf_trace_bpf_trace_printk)(void *, const char *);

struct bpf_trace_module {
	struct module *module;
	struct list_head list;
};

typedef u64 (*btf_bpf_probe_read_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_user_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_kernel_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_read_compat_str)(void *, u32, const void *);

typedef u64 (*btf_bpf_probe_write_user)(void *, const void *, u32);

typedef u64 (*btf_bpf_trace_printk)(char *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_trace_vprintk)(char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_printf)(struct seq_file *, char *, u32, const void *, u32);

typedef u64 (*btf_bpf_seq_write)(struct seq_file *, const void *, u32);

typedef u64 (*btf_bpf_seq_printf_btf)(struct seq_file *, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_perf_event_read)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_perf_event_read_value)(struct bpf_map *, u64, struct bpf_perf_event_value *, u32);

struct bpf_trace_sample_data {
	struct perf_sample_data sds[3];
};

typedef u64 (*btf_bpf_perf_event_output)(struct pt_regs *, struct bpf_map *, u64, void *, u64);

struct bpf_nested_pt_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_get_current_task)();

typedef u64 (*btf_bpf_get_current_task_btf)();

typedef u64 (*btf_bpf_task_pt_regs)(struct task_struct *);

typedef u64 (*btf_bpf_current_task_under_cgroup)(struct bpf_map *, u32);

struct send_signal_irq_work {
	struct irq_work irq_work;
	struct task_struct *task;
	u32 sig;
	enum pid_type type;
};

typedef u64 (*btf_bpf_send_signal)(u32);

typedef u64 (*btf_bpf_send_signal_thread)(u32);

typedef u64 (*btf_bpf_d_path)(struct path *, char *, u32);

typedef u64 (*btf_bpf_snprintf_btf)(char *, u32, struct btf_ptr *, u32, u64);

typedef u64 (*btf_bpf_get_func_ip_tracing)(void *);

typedef u64 (*btf_bpf_get_func_ip_kprobe)(struct pt_regs *);

typedef u64 (*btf_bpf_get_func_ip_kprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_attach_cookie_kprobe_multi)(struct pt_regs *);

typedef u64 (*btf_bpf_get_attach_cookie_trace)(void *);

typedef u64 (*btf_bpf_get_attach_cookie_pe)(struct bpf_perf_event_data_kern *);

typedef u64 (*btf_bpf_get_attach_cookie_tracing)(void *);

typedef u64 (*btf_bpf_get_branch_snapshot)(void *, u32, u64);

typedef u64 (*btf_get_func_arg)(void *, u32, u64 *);

typedef u64 (*btf_get_func_ret)(void *, u64 *);

typedef u64 (*btf_get_func_arg_cnt)(void *);

typedef u64 (*btf_bpf_perf_event_output_tp)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_tp)(void *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_tp)(void *, void *, u32, u64);

typedef u64 (*btf_bpf_perf_prog_read_value)(struct bpf_perf_event_data_kern *, struct bpf_perf_event_value *, u32);

typedef u64 (*btf_bpf_read_branch_records)(struct bpf_perf_event_data_kern *, void *, u32, u64);

struct bpf_raw_tp_regs {
	struct pt_regs regs[3];
};

typedef u64 (*btf_bpf_perf_event_output_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_stackid_raw_tp)(struct bpf_raw_tracepoint_args *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack_raw_tp)(struct bpf_raw_tracepoint_args *, void *, u32, u64);

enum dynevent_type {
	DYNEVENT_TYPE_SYNTH = 1,
	DYNEVENT_TYPE_KPROBE = 2,
	DYNEVENT_TYPE_NONE = 3,
};

struct dynevent_cmd;

typedef int (*dynevent_create_fn_t)(struct dynevent_cmd *);

struct dynevent_cmd {
	struct seq_buf seq;
	const char *event_name;
	unsigned int n_fields;
	enum dynevent_type type;
	dynevent_create_fn_t run_command;
	void *private_data;
	int: 32;
};

struct kprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int ip;
};

struct kretprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int func;
	long unsigned int ret_ip;
};

struct dynevent_arg {
	const char *str;
	char separator;
};

struct event_file_link {
	struct trace_event_file *file;
	struct list_head list;
};

struct trace_kprobe {
	struct dyn_event devent;
	struct kretprobe rp;
	long unsigned int *nhit;
	const char *symbol;
	struct trace_probe tp;
};

struct trace_event_raw_error_report_template {
	struct trace_entry ent;
	enum error_detector error_detector;
	long unsigned int id;
	char __data[0];
};

struct trace_event_data_offsets_error_report_template {};

typedef void (*btf_trace_error_report_end)(void *, enum error_detector, long unsigned int);

struct trace_event_raw_cpu {
	struct trace_entry ent;
	u32 state;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_idle_miss {
	struct trace_entry ent;
	u32 cpu_id;
	u32 state;
	bool below;
	char __data[0];
};

struct trace_event_raw_powernv_throttle {
	struct trace_entry ent;
	int chip_id;
	u32 __data_loc_reason;
	int pmax;
	char __data[0];
};

struct trace_event_raw_pstate_sample {
	struct trace_entry ent;
	u32 core_busy;
	u32 scaled_busy;
	u32 from;
	u32 to;
	u64 mperf;
	u64 aperf;
	u64 tsc;
	u32 freq;
	u32 io_boost;
	char __data[0];
};

struct trace_event_raw_cpu_frequency_limits {
	struct trace_entry ent;
	u32 min_freq;
	u32 max_freq;
	u32 cpu_id;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_start {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	u32 __data_loc_parent;
	u32 __data_loc_pm_ops;
	int event;
	char __data[0];
};

struct trace_event_raw_device_pm_callback_end {
	struct trace_entry ent;
	u32 __data_loc_device;
	u32 __data_loc_driver;
	int error;
	char __data[0];
};

struct trace_event_raw_suspend_resume {
	struct trace_entry ent;
	const char *action;
	int val;
	bool start;
	char __data[0];
};

struct trace_event_raw_wakeup_source {
	struct trace_entry ent;
	u32 __data_loc_name;
	int: 32;
	u64 state;
	char __data[0];
};

struct trace_event_raw_clock {
	struct trace_entry ent;
	u32 __data_loc_name;
	int: 32;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_power_domain {
	struct trace_entry ent;
	u32 __data_loc_name;
	int: 32;
	u64 state;
	u64 cpu_id;
	char __data[0];
};

struct trace_event_raw_cpu_latency_qos_request {
	struct trace_entry ent;
	s32 value;
	char __data[0];
};

struct trace_event_raw_pm_qos_update {
	struct trace_entry ent;
	enum pm_qos_req_action action;
	int prev_value;
	int curr_value;
	char __data[0];
};

struct trace_event_raw_dev_pm_qos_request {
	struct trace_entry ent;
	u32 __data_loc_name;
	enum dev_pm_qos_req_type type;
	s32 new_value;
	char __data[0];
};

struct trace_event_raw_guest_halt_poll_ns {
	struct trace_entry ent;
	bool grow;
	unsigned int new;
	unsigned int old;
	char __data[0];
};

struct trace_event_data_offsets_cpu {};

struct trace_event_data_offsets_cpu_idle_miss {};

struct trace_event_data_offsets_powernv_throttle {
	u32 reason;
};

struct trace_event_data_offsets_pstate_sample {};

struct trace_event_data_offsets_cpu_frequency_limits {};

struct trace_event_data_offsets_device_pm_callback_start {
	u32 device;
	u32 driver;
	u32 parent;
	u32 pm_ops;
};

struct trace_event_data_offsets_device_pm_callback_end {
	u32 device;
	u32 driver;
};

struct trace_event_data_offsets_suspend_resume {};

struct trace_event_data_offsets_wakeup_source {
	u32 name;
};

struct trace_event_data_offsets_clock {
	u32 name;
};

struct trace_event_data_offsets_power_domain {
	u32 name;
};

struct trace_event_data_offsets_cpu_latency_qos_request {};

struct trace_event_data_offsets_pm_qos_update {};

struct trace_event_data_offsets_dev_pm_qos_request {
	u32 name;
};

struct trace_event_data_offsets_guest_halt_poll_ns {};

typedef void (*btf_trace_cpu_idle)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_idle_miss)(void *, unsigned int, unsigned int, bool);

typedef void (*btf_trace_powernv_throttle)(void *, int, const char *, int);

typedef void (*btf_trace_pstate_sample)(void *, u32, u32, u32, u32, u64, u64, u64, u32, u32);

typedef void (*btf_trace_cpu_frequency)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_cpu_frequency_limits)(void *, struct cpufreq_policy *);

typedef void (*btf_trace_device_pm_callback_start)(void *, struct device *, const char *, int);

typedef void (*btf_trace_device_pm_callback_end)(void *, struct device *, int);

typedef void (*btf_trace_suspend_resume)(void *, const char *, int, bool);

typedef void (*btf_trace_wakeup_source_activate)(void *, const char *, unsigned int);

typedef void (*btf_trace_wakeup_source_deactivate)(void *, const char *, unsigned int);

typedef void (*btf_trace_clock_enable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_disable)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_clock_set_rate)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_power_domain_target)(void *, const char *, unsigned int, unsigned int);

typedef void (*btf_trace_pm_qos_add_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_request)(void *, s32);

typedef void (*btf_trace_pm_qos_remove_request)(void *, s32);

typedef void (*btf_trace_pm_qos_update_target)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_pm_qos_update_flags)(void *, enum pm_qos_req_action, int, int);

typedef void (*btf_trace_dev_pm_qos_add_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_update_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_dev_pm_qos_remove_request)(void *, const char *, enum dev_pm_qos_req_type, s32);

typedef void (*btf_trace_guest_halt_poll_ns)(void *, bool, unsigned int, unsigned int);

struct trace_event_raw_rpm_internal {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flags;
	int usage_count;
	int disable_depth;
	int runtime_auto;
	int request_pending;
	int irq_safe;
	int child_count;
	char __data[0];
};

struct trace_event_raw_rpm_return_int {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int ip;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_rpm_internal {
	u32 name;
};

struct trace_event_data_offsets_rpm_return_int {
	u32 name;
};

typedef void (*btf_trace_rpm_suspend)(void *, struct device *, int);

typedef void (*btf_trace_rpm_resume)(void *, struct device *, int);

typedef void (*btf_trace_rpm_idle)(void *, struct device *, int);

typedef void (*btf_trace_rpm_usage)(void *, struct device *, int);

typedef void (*btf_trace_rpm_return_int)(void *, struct device *, long unsigned int, int);

typedef int (*dynevent_check_arg_fn_t)(void *);

struct dynevent_arg_pair {
	const char *lhs;
	const char *rhs;
	char operator;
	char separator;
};

struct trace_probe_log {
	const char *subsystem;
	const char **argv;
	int argc;
	int index;
};

enum uprobe_filter_ctx {
	UPROBE_FILTER_REGISTER = 0,
	UPROBE_FILTER_UNREGISTER = 1,
	UPROBE_FILTER_MMAP = 2,
};

struct uprobe_consumer {
	int (*handler)(struct uprobe_consumer *, struct pt_regs *);
	int (*ret_handler)(struct uprobe_consumer *, long unsigned int, struct pt_regs *);
	bool (*filter)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);
	struct uprobe_consumer *next;
};

struct uprobe_trace_entry_head {
	struct trace_entry ent;
	long unsigned int vaddr[0];
};

struct trace_uprobe {
	struct dyn_event devent;
	struct uprobe_consumer consumer;
	struct path path;
	struct inode *inode;
	char *filename;
	long unsigned int offset;
	long unsigned int ref_ctr_offset;
	long unsigned int nhit;
	struct trace_probe tp;
};

struct uprobe_dispatch_data {
	struct trace_uprobe *tu;
	long unsigned int bp_addr;
};

struct uprobe_cpu_buffer {
	struct mutex mutex;
	void *buf;
};

typedef bool (*filter_func_t)(struct uprobe_consumer *, enum uprobe_filter_ctx, struct mm_struct *);

typedef __u64 __be64;

enum xdp_action {
	XDP_ABORTED = 0,
	XDP_DROP = 1,
	XDP_PASS = 2,
	XDP_TX = 3,
	XDP_REDIRECT = 4,
};

struct rnd_state {
	__u32 s1;
	__u32 s2;
	__u32 s3;
	__u32 s4;
};

struct rhash_lock_head;

struct bucket_table {
	unsigned int size;
	unsigned int nest;
	u32 hash_rnd;
	struct list_head walkers;
	struct callback_head rcu;
	struct bucket_table *future_tbl;
	struct lockdep_map dep_map;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct rhash_lock_head *buckets[0];
};

typedef sockptr_t bpfptr_t;

struct bpf_verifier_log {
	u32 level;
	char kbuf[1024];
	char *ubuf;
	u32 len_used;
	u32 len_total;
};

struct bpf_subprog_info {
	u32 start;
	u32 linfo_idx;
	u16 stack_depth;
	bool has_tail_call;
	bool tail_call_reachable;
	bool has_ld_abs;
	bool is_async_cb;
};

struct bpf_id_pair {
	u32 old;
	u32 cur;
};

struct bpf_verifier_stack_elem;

struct bpf_verifier_state;

struct bpf_verifier_state_list;

struct bpf_insn_aux_data;

struct bpf_verifier_env {
	u32 insn_idx;
	u32 prev_insn_idx;
	struct bpf_prog *prog;
	const struct bpf_verifier_ops *ops;
	struct bpf_verifier_stack_elem *head;
	int stack_size;
	bool strict_alignment;
	bool test_state_freq;
	struct bpf_verifier_state *cur_state;
	struct bpf_verifier_state_list **explored_states;
	struct bpf_verifier_state_list *free_list;
	struct bpf_map *used_maps[64];
	struct btf_mod_pair used_btfs[64];
	u32 used_map_cnt;
	u32 used_btf_cnt;
	u32 id_gen;
	bool explore_alu_limits;
	bool allow_ptr_leaks;
	bool allow_uninit_stack;
	bool allow_ptr_to_map_access;
	bool bpf_capable;
	bool bypass_spec_v1;
	bool bypass_spec_v4;
	bool seen_direct_write;
	struct bpf_insn_aux_data *insn_aux_data;
	const struct bpf_line_info *prev_linfo;
	struct bpf_verifier_log log;
	struct bpf_subprog_info subprog_info[257];
	struct bpf_id_pair idmap_scratch[75];
	struct {
		int *insn_state;
		int *insn_stack;
		int cur_stack;
	} cfg;
	u32 pass_cnt;
	u32 subprog_cnt;
	u32 prev_insn_processed;
	u32 insn_processed;
	u32 prev_jmps_processed;
	u32 jmps_processed;
	u64 verification_time;
	u32 max_states_per_insn;
	u32 total_states;
	u32 peak_states;
	u32 longest_mark_read_walk;
	bpfptr_t fd_array;
	u32 scratched_regs;
	int: 32;
	u64 scratched_stack_slots;
	u32 prev_log_len;
	u32 prev_insn_print_len;
	char type_str_buf[64];
};

enum bpf_dynptr_type {
	BPF_DYNPTR_TYPE_INVALID = 0,
	BPF_DYNPTR_TYPE_LOCAL = 1,
	BPF_DYNPTR_TYPE_RINGBUF = 2,
};

struct tnum {
	u64 value;
	u64 mask;
};

enum bpf_reg_liveness {
	REG_LIVE_NONE = 0,
	REG_LIVE_READ32 = 1,
	REG_LIVE_READ64 = 2,
	REG_LIVE_READ = 3,
	REG_LIVE_WRITTEN = 4,
	REG_LIVE_DONE = 8,
};

struct bpf_reg_state {
	enum bpf_reg_type type;
	s32 off;
	union {
		int range;
		struct {
			struct bpf_map *map_ptr;
			u32 map_uid;
		};
		struct {
			struct btf *btf;
			u32 btf_id;
		};
		u32 mem_size;
		struct {
			enum bpf_dynptr_type type;
			bool first_slot;
		} dynptr;
		struct {
			long unsigned int raw1;
			long unsigned int raw2;
		} raw;
		u32 subprogno;
	};
	u32 id;
	u32 ref_obj_id;
	struct tnum var_off;
	s64 smin_value;
	s64 smax_value;
	u64 umin_value;
	u64 umax_value;
	s32 s32_min_value;
	s32 s32_max_value;
	u32 u32_min_value;
	u32 u32_max_value;
	struct bpf_reg_state *parent;
	u32 frameno;
	s32 subreg_def;
	enum bpf_reg_liveness live;
	bool precise;
	int: 24;
	int: 32;
};

struct bpf_reference_state;

struct bpf_stack_state;

struct bpf_func_state {
	struct bpf_reg_state regs[11];
	int callsite;
	u32 frameno;
	u32 subprogno;
	u32 async_entry_cnt;
	bool in_callback_fn;
	int: 24;
	int: 32;
	struct tnum callback_ret_range;
	bool in_async_callback_fn;
	int acquired_refs;
	struct bpf_reference_state *refs;
	int allocated_stack;
	struct bpf_stack_state *stack;
	int: 32;
};

enum bpf_jit_poke_reason {
	BPF_POKE_REASON_TAIL_CALL = 0,
};

struct bpf_empty_prog_array {
	struct bpf_prog_array hdr;
	struct bpf_prog *null_prog;
	int: 32;
};

enum bpf_text_poke_type {
	BPF_MOD_CALL = 0,
	BPF_MOD_JUMP = 1,
};

enum xdp_mem_type {
	MEM_TYPE_PAGE_SHARED = 0,
	MEM_TYPE_PAGE_ORDER0 = 1,
	MEM_TYPE_PAGE_POOL = 2,
	MEM_TYPE_XSK_BUFF_POOL = 3,
	MEM_TYPE_MAX = 4,
};

struct xdp_cpumap_stats {
	unsigned int redirect;
	unsigned int pass;
	unsigned int drop;
};

typedef void (*bpf_jit_fill_hole_t)(void *, unsigned int);

struct bpf_stack_state {
	struct bpf_reg_state spilled_ptr;
	u8 slot_type[8];
};

struct bpf_reference_state {
	int id;
	int insn_idx;
	int callback_ref;
};

struct bpf_idx_pair {
	u32 prev_idx;
	u32 idx;
};

struct bpf_verifier_state {
	struct bpf_func_state *frame[8];
	struct bpf_verifier_state *parent;
	u32 branches;
	u32 insn_idx;
	u32 curframe;
	u32 active_spin_lock;
	bool speculative;
	u32 first_insn_idx;
	u32 last_insn_idx;
	struct bpf_idx_pair *jmp_history;
	u32 jmp_history_cnt;
};

struct bpf_verifier_state_list {
	struct bpf_verifier_state state;
	struct bpf_verifier_state_list *next;
	int miss_cnt;
	int hit_cnt;
};

struct bpf_loop_inline_state {
	unsigned int initialized: 1;
	unsigned int fit_for_inline: 1;
	u32 callback_subprogno;
};

struct bpf_insn_aux_data {
	union {
		enum bpf_reg_type ptr_type;
		long unsigned int map_ptr_state;
		s32 call_imm;
		u32 alu_limit;
		struct {
			u32 map_index;
			u32 map_off;
		};
		struct {
			enum bpf_reg_type reg_type;
			union {
				struct {
					struct btf *btf;
					u32 btf_id;
				};
				u32 mem_size;
			};
		} btf_var;
		struct bpf_loop_inline_state loop_inline_state;
	};
	int: 32;
	u64 map_key_state;
	int ctx_field_size;
	u32 seen;
	bool sanitize_stack_spill;
	bool zext_dst;
	u8 alu_state;
	unsigned int orig_idx;
	bool prune_point;
	int: 24;
	int: 32;
};

struct bpf_prog_pack {
	struct list_head list;
	void *ptr;
	long unsigned int bitmap[0];
};

struct bpf_prog_dummy {
	struct bpf_prog prog;
};

typedef u64 (*btf_bpf_user_rnd_u32)();

typedef u64 (*btf_bpf_get_raw_cpu_id)();

struct _bpf_dtab_netdev {
	struct net_device *dev;
};

struct rhash_lock_head {};

struct xdp_mem_allocator {
	struct xdp_mem_info mem;
	union {
		void *allocator;
		struct page_pool *page_pool;
	};
	struct rhash_head node;
	struct callback_head rcu;
};

struct trace_event_raw_xdp_exception {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_xdp_bulk_tx {
	struct trace_entry ent;
	int ifindex;
	u32 act;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_xdp_redirect_template {
	struct trace_entry ent;
	int prog_id;
	u32 act;
	int ifindex;
	int err;
	int to_ifindex;
	u32 map_id;
	int map_index;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_kthread {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int sched;
	unsigned int xdp_pass;
	unsigned int xdp_drop;
	unsigned int xdp_redirect;
	char __data[0];
};

struct trace_event_raw_xdp_cpumap_enqueue {
	struct trace_entry ent;
	int map_id;
	u32 act;
	int cpu;
	unsigned int drops;
	unsigned int processed;
	int to_cpu;
	char __data[0];
};

struct trace_event_raw_xdp_devmap_xmit {
	struct trace_entry ent;
	int from_ifindex;
	u32 act;
	int to_ifindex;
	int drops;
	int sent;
	int err;
	char __data[0];
};

struct trace_event_raw_mem_disconnect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	char __data[0];
};

struct trace_event_raw_mem_connect {
	struct trace_entry ent;
	const struct xdp_mem_allocator *xa;
	u32 mem_id;
	u32 mem_type;
	const void *allocator;
	const struct xdp_rxq_info *rxq;
	int ifindex;
	char __data[0];
};

struct trace_event_raw_mem_return_failed {
	struct trace_entry ent;
	const struct page *page;
	u32 mem_id;
	u32 mem_type;
	char __data[0];
};

struct trace_event_data_offsets_xdp_exception {};

struct trace_event_data_offsets_xdp_bulk_tx {};

struct trace_event_data_offsets_xdp_redirect_template {};

struct trace_event_data_offsets_xdp_cpumap_kthread {};

struct trace_event_data_offsets_xdp_cpumap_enqueue {};

struct trace_event_data_offsets_xdp_devmap_xmit {};

struct trace_event_data_offsets_mem_disconnect {};

struct trace_event_data_offsets_mem_connect {};

struct trace_event_data_offsets_mem_return_failed {};

typedef void (*btf_trace_xdp_exception)(void *, const struct net_device *, const struct bpf_prog *, u32);

typedef void (*btf_trace_xdp_bulk_tx)(void *, const struct net_device *, int, int, int);

typedef void (*btf_trace_xdp_redirect)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_redirect_map_err)(void *, const struct net_device *, const struct bpf_prog *, const void *, int, enum bpf_map_type, u32, u32);

typedef void (*btf_trace_xdp_cpumap_kthread)(void *, int, unsigned int, unsigned int, int, struct xdp_cpumap_stats *);

typedef void (*btf_trace_xdp_cpumap_enqueue)(void *, int, unsigned int, unsigned int, int);

typedef void (*btf_trace_xdp_devmap_xmit)(void *, const struct net_device *, const struct net_device *, int, int, int);

typedef void (*btf_trace_mem_disconnect)(void *, const struct xdp_mem_allocator *);

typedef void (*btf_trace_mem_connect)(void *, const struct xdp_mem_allocator *, const struct xdp_rxq_info *);

typedef void (*btf_trace_mem_return_failed)(void *, const struct xdp_mem_info *, const struct page *);

enum bpf_cmd {
	BPF_MAP_CREATE = 0,
	BPF_MAP_LOOKUP_ELEM = 1,
	BPF_MAP_UPDATE_ELEM = 2,
	BPF_MAP_DELETE_ELEM = 3,
	BPF_MAP_GET_NEXT_KEY = 4,
	BPF_PROG_LOAD = 5,
	BPF_OBJ_PIN = 6,
	BPF_OBJ_GET = 7,
	BPF_PROG_ATTACH = 8,
	BPF_PROG_DETACH = 9,
	BPF_PROG_TEST_RUN = 10,
	BPF_PROG_RUN = 10,
	BPF_PROG_GET_NEXT_ID = 11,
	BPF_MAP_GET_NEXT_ID = 12,
	BPF_PROG_GET_FD_BY_ID = 13,
	BPF_MAP_GET_FD_BY_ID = 14,
	BPF_OBJ_GET_INFO_BY_FD = 15,
	BPF_PROG_QUERY = 16,
	BPF_RAW_TRACEPOINT_OPEN = 17,
	BPF_BTF_LOAD = 18,
	BPF_BTF_GET_FD_BY_ID = 19,
	BPF_TASK_FD_QUERY = 20,
	BPF_MAP_LOOKUP_AND_DELETE_ELEM = 21,
	BPF_MAP_FREEZE = 22,
	BPF_BTF_GET_NEXT_ID = 23,
	BPF_MAP_LOOKUP_BATCH = 24,
	BPF_MAP_LOOKUP_AND_DELETE_BATCH = 25,
	BPF_MAP_UPDATE_BATCH = 26,
	BPF_MAP_DELETE_BATCH = 27,
	BPF_LINK_CREATE = 28,
	BPF_LINK_UPDATE = 29,
	BPF_LINK_GET_FD_BY_ID = 30,
	BPF_LINK_GET_NEXT_ID = 31,
	BPF_ENABLE_STATS = 32,
	BPF_ITER_CREATE = 33,
	BPF_LINK_DETACH = 34,
	BPF_PROG_BIND_MAP = 35,
};

enum bpf_link_type {
	BPF_LINK_TYPE_UNSPEC = 0,
	BPF_LINK_TYPE_RAW_TRACEPOINT = 1,
	BPF_LINK_TYPE_TRACING = 2,
	BPF_LINK_TYPE_CGROUP = 3,
	BPF_LINK_TYPE_ITER = 4,
	BPF_LINK_TYPE_NETNS = 5,
	BPF_LINK_TYPE_XDP = 6,
	BPF_LINK_TYPE_PERF_EVENT = 7,
	BPF_LINK_TYPE_KPROBE_MULTI = 8,
	BPF_LINK_TYPE_STRUCT_OPS = 9,
	MAX_BPF_LINK_TYPE = 10,
};

enum {
	BPF_ANY = 0,
	BPF_NOEXIST = 1,
	BPF_EXIST = 2,
	BPF_F_LOCK = 4,
};

enum {
	BPF_F_NO_PREALLOC = 1,
	BPF_F_NO_COMMON_LRU = 2,
	BPF_F_NUMA_NODE = 4,
	BPF_F_RDONLY = 8,
	BPF_F_WRONLY = 16,
	BPF_F_STACK_BUILD_ID = 32,
	BPF_F_ZERO_SEED = 64,
	BPF_F_RDONLY_PROG = 128,
	BPF_F_WRONLY_PROG = 256,
	BPF_F_CLONE = 512,
	BPF_F_MMAPABLE = 1024,
	BPF_F_PRESERVE_ELEMS = 2048,
	BPF_F_INNER_MAP = 4096,
};

enum bpf_stats_type {
	BPF_STATS_RUN_TIME = 0,
};

struct bpf_prog_info {
	__u32 type;
	__u32 id;
	__u8 tag[8];
	__u32 jited_prog_len;
	__u32 xlated_prog_len;
	__u64 jited_prog_insns;
	__u64 xlated_prog_insns;
	__u64 load_time;
	__u32 created_by_uid;
	__u32 nr_map_ids;
	__u64 map_ids;
	char name[16];
	__u32 ifindex;
	__u32 gpl_compatible: 1;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 nr_jited_ksyms;
	__u32 nr_jited_func_lens;
	__u64 jited_ksyms;
	__u64 jited_func_lens;
	__u32 btf_id;
	__u32 func_info_rec_size;
	__u64 func_info;
	__u32 nr_func_info;
	__u32 nr_line_info;
	__u64 line_info;
	__u64 jited_line_info;
	__u32 nr_jited_line_info;
	__u32 line_info_rec_size;
	__u32 jited_line_info_rec_size;
	__u32 nr_prog_tags;
	__u64 prog_tags;
	__u64 run_time_ns;
	__u64 run_cnt;
	__u64 recursion_misses;
	__u32 verified_insns;
	__u32 attach_btf_obj_id;
	__u32 attach_btf_id;
	int: 32;
};

struct bpf_map_info {
	__u32 type;
	__u32 id;
	__u32 key_size;
	__u32 value_size;
	__u32 max_entries;
	__u32 map_flags;
	char name[16];
	__u32 ifindex;
	__u32 btf_vmlinux_value_type_id;
	__u64 netns_dev;
	__u64 netns_ino;
	__u32 btf_id;
	__u32 btf_key_type_id;
	__u32 btf_value_type_id;
	int: 32;
	__u64 map_extra;
};

struct bpf_btf_info {
	__u64 btf;
	__u32 btf_size;
	__u32 id;
	__u64 name;
	__u32 name_len;
	__u32 kernel_btf;
};

struct bpf_link_ops;

struct bpf_link {
	atomic64_t refcnt;
	u32 id;
	enum bpf_link_type type;
	const struct bpf_link_ops *ops;
	struct bpf_prog *prog;
	struct work_struct work;
};

struct bpf_tramp_link {
	struct bpf_link link;
	struct hlist_node tramp_hlist;
	u64 cookie;
};

struct bpf_attach_target_info {
	struct btf_func_model fmodel;
	long int tgt_addr;
	const char *tgt_name;
	const struct btf_type *tgt_type;
};

struct bpf_link_ops {
	void (*release)(struct bpf_link *);
	void (*dealloc)(struct bpf_link *);
	int (*detach)(struct bpf_link *);
	int (*update_prog)(struct bpf_link *, struct bpf_prog *, struct bpf_prog *);
	void (*show_fdinfo)(const struct bpf_link *, struct seq_file *);
	int (*fill_link_info)(const struct bpf_link *, struct bpf_link_info *);
};

struct bpf_tracing_link {
	struct bpf_tramp_link link;
	enum bpf_attach_type attach_type;
	struct bpf_trampoline *trampoline;
	struct bpf_prog *tgt_prog;
	int: 32;
};

struct bpf_link_primer {
	struct bpf_link *link;
	struct file *file;
	int fd;
	u32 id;
};

struct bpf_tramp_run_ctx {
	struct bpf_run_ctx run_ctx;
	u64 bpf_cookie;
	struct bpf_run_ctx *saved_run_ctx;
	int: 32;
};

enum perf_bpf_event_type {
	PERF_BPF_EVENT_UNKNOWN = 0,
	PERF_BPF_EVENT_PROG_LOAD = 1,
	PERF_BPF_EVENT_PROG_UNLOAD = 2,
	PERF_BPF_EVENT_MAX = 3,
};

enum bpf_audit {
	BPF_AUDIT_LOAD = 0,
	BPF_AUDIT_UNLOAD = 1,
	BPF_AUDIT_MAX = 2,
};

struct bpf_prog_kstats {
	u64 nsecs;
	u64 cnt;
	u64 misses;
};

struct bpf_raw_tp_link {
	struct bpf_link link;
	struct bpf_raw_event_map *btp;
	int: 32;
};

struct bpf_perf_link {
	struct bpf_link link;
	struct file *perf_file;
	int: 32;
};

typedef u64 (*btf_bpf_sys_bpf)(int, union bpf_attr *, u32);

typedef u64 (*btf_bpf_sys_close)(u32);

typedef u64 (*btf_bpf_kallsyms_lookup_name)(const char *, int, int, u64 *);

struct audit_buffer;

enum {
	BTF_KIND_UNKN = 0,
	BTF_KIND_INT = 1,
	BTF_KIND_PTR = 2,
	BTF_KIND_ARRAY = 3,
	BTF_KIND_STRUCT = 4,
	BTF_KIND_UNION = 5,
	BTF_KIND_ENUM = 6,
	BTF_KIND_FWD = 7,
	BTF_KIND_TYPEDEF = 8,
	BTF_KIND_VOLATILE = 9,
	BTF_KIND_CONST = 10,
	BTF_KIND_RESTRICT = 11,
	BTF_KIND_FUNC = 12,
	BTF_KIND_FUNC_PROTO = 13,
	BTF_KIND_VAR = 14,
	BTF_KIND_DATASEC = 15,
	BTF_KIND_FLOAT = 16,
	BTF_KIND_DECL_TAG = 17,
	BTF_KIND_TYPE_TAG = 18,
	BTF_KIND_ENUM64 = 19,
	NR_BTF_KINDS = 20,
	BTF_KIND_MAX = 19,
};

struct btf_member {
	__u32 name_off;
	__u32 type;
	__u32 offset;
};

struct btf_param {
	__u32 name_off;
	__u32 type;
};

enum btf_func_linkage {
	BTF_FUNC_STATIC = 0,
	BTF_FUNC_GLOBAL = 1,
	BTF_FUNC_EXTERN = 2,
};

struct btf_var_secinfo {
	__u32 type;
	__u32 offset;
	__u32 size;
};

enum sk_action {
	SK_DROP = 0,
	SK_PASS = 1,
};

enum bpf_core_relo_kind {
	BPF_CORE_FIELD_BYTE_OFFSET = 0,
	BPF_CORE_FIELD_BYTE_SIZE = 1,
	BPF_CORE_FIELD_EXISTS = 2,
	BPF_CORE_FIELD_SIGNED = 3,
	BPF_CORE_FIELD_LSHIFT_U64 = 4,
	BPF_CORE_FIELD_RSHIFT_U64 = 5,
	BPF_CORE_TYPE_ID_LOCAL = 6,
	BPF_CORE_TYPE_ID_TARGET = 7,
	BPF_CORE_TYPE_EXISTS = 8,
	BPF_CORE_TYPE_SIZE = 9,
	BPF_CORE_ENUMVAL_EXISTS = 10,
	BPF_CORE_ENUMVAL_VALUE = 11,
	BPF_CORE_TYPE_MATCHES = 12,
};

struct bpf_core_relo {
	__u32 insn_off;
	__u32 type_id;
	__u32 access_str_off;
	enum bpf_core_relo_kind kind;
};

struct bpf_kfunc_desc {
	struct btf_func_model func_model;
	u32 func_id;
	s32 imm;
	u16 offset;
};

struct bpf_kfunc_desc_tab {
	struct bpf_kfunc_desc descs[256];
	u32 nr_descs;
};

struct bpf_kfunc_btf {
	struct btf *btf;
	struct module *module;
	u16 offset;
};

struct bpf_kfunc_btf_tab {
	struct bpf_kfunc_btf descs[256];
	u32 nr_descs;
};

struct bpf_struct_ops {
	const struct bpf_verifier_ops *verifier_ops;
	int (*init)(struct btf *);
	int (*check_member)(const struct btf_type *, const struct btf_member *);
	int (*init_member)(const struct btf_type *, const struct btf_member *, void *, const void *);
	int (*reg)(void *);
	void (*unreg)(void *);
	const struct btf_type *type;
	const struct btf_type *value_type;
	const char *name;
	struct btf_func_model func_models[64];
	u32 type_id;
	u32 value_id;
};

typedef u32 (*bpf_convert_ctx_access_t)(enum bpf_access_type, const struct bpf_insn *, struct bpf_insn *, struct bpf_prog *, u32 *);

struct bpf_kfunc_arg_meta {
	u64 r0_size;
	bool r0_rdonly;
	int ref_obj_id;
	u32 flags;
	int: 32;
};

struct bpf_core_ctx {
	struct bpf_verifier_log *log;
	const struct btf *btf;
};

enum bpf_stack_slot_type {
	STACK_INVALID = 0,
	STACK_SPILL = 1,
	STACK_MISC = 2,
	STACK_ZERO = 3,
	STACK_DYNPTR = 4,
};

struct bpf_verifier_stack_elem {
	struct bpf_verifier_state st;
	int insn_idx;
	int prev_insn_idx;
	struct bpf_verifier_stack_elem *next;
	u32 log_pos;
};

enum {
	BTF_SOCK_TYPE_INET = 0,
	BTF_SOCK_TYPE_INET_CONN = 1,
	BTF_SOCK_TYPE_INET_REQ = 2,
	BTF_SOCK_TYPE_INET_TW = 3,
	BTF_SOCK_TYPE_REQ = 4,
	BTF_SOCK_TYPE_SOCK = 5,
	BTF_SOCK_TYPE_SOCK_COMMON = 6,
	BTF_SOCK_TYPE_TCP = 7,
	BTF_SOCK_TYPE_TCP_REQ = 8,
	BTF_SOCK_TYPE_TCP_TW = 9,
	BTF_SOCK_TYPE_TCP6 = 10,
	BTF_SOCK_TYPE_UDP = 11,
	BTF_SOCK_TYPE_UDP6 = 12,
	BTF_SOCK_TYPE_UNIX = 13,
	BTF_SOCK_TYPE_MPTCP = 14,
	BTF_SOCK_TYPE_SOCKET = 15,
	MAX_BTF_SOCK_TYPE = 16,
};

typedef void (*bpf_insn_print_t)(void *, const char *, ...);

typedef const char * (*bpf_insn_revmap_call_t)(void *, const struct bpf_insn *);

typedef const char * (*bpf_insn_print_imm_t)(void *, const struct bpf_insn *, __u64);

struct bpf_insn_cbs {
	bpf_insn_print_t cb_print;
	bpf_insn_revmap_call_t cb_call;
	bpf_insn_print_imm_t cb_imm;
	void *private_data;
};

struct bpf_call_arg_meta {
	struct bpf_map *map_ptr;
	bool raw_mode;
	bool pkt_access;
	u8 release_regno;
	int regno;
	int access_size;
	int mem_size;
	int: 32;
	u64 msize_max_value;
	int ref_obj_id;
	int map_uid;
	int func_id;
	struct btf *btf;
	u32 btf_id;
	struct btf *ret_btf;
	u32 ret_btf_id;
	u32 subprogno;
	struct bpf_map_value_off_desc *kptr_off_desc;
	u8 uninit_dynptr_regno;
};

enum reg_arg_type {
	SRC_OP = 0,
	DST_OP = 1,
	DST_OP_NO_MARK = 2,
};

enum bpf_access_src {
	ACCESS_DIRECT = 1,
	ACCESS_HELPER = 2,
};

struct bpf_reg_types {
	const enum bpf_reg_type types[10];
	u32 *btf_id;
};

enum {
	AT_PKT_END = 4294967295,
	BEYOND_PKT_END = 4294967294,
};

typedef int (*set_callee_state_fn)(struct bpf_verifier_env *, struct bpf_func_state *, struct bpf_func_state *, int);

enum {
	REASON_BOUNDS = 4294967295,
	REASON_TYPE = 4294967294,
	REASON_PATHS = 4294967293,
	REASON_LIMIT = 4294967292,
	REASON_STACK = 4294967291,
};

struct bpf_sanitize_info {
	struct bpf_insn_aux_data aux;
	bool mask_to_left;
	int: 24;
	int: 32;
};

enum {
	DISCOVERED = 16,
	EXPLORED = 32,
	FALLTHROUGH = 1,
	BRANCH = 2,
};

enum {
	DONE_EXPLORING = 0,
	KEEP_EXPLORING = 1,
};

struct tree_descr {
	const char *name;
	const struct file_operations *ops;
	int mode;
};

struct bpf_preload_info {
	char link_name[16];
	struct bpf_link *link;
};

struct bpf_preload_ops {
	int (*preload)(struct bpf_preload_info *);
	struct module *owner;
};

enum bpf_type {
	BPF_TYPE_UNSPEC = 0,
	BPF_TYPE_PROG = 1,
	BPF_TYPE_MAP = 2,
	BPF_TYPE_LINK = 3,
};

struct map_iter {
	void *key;
	bool done;
};

enum {
	OPT_MODE = 0,
};

struct bpf_mount_opts {
	umode_t mode;
};

struct bpf_spin_lock {
	__u32 val;
};

struct bpf_timer {
	int: 32;
	int: 32;
	int: 32;
	int: 32;};

struct bpf_dynptr {
	int: 32;
	int: 32;
	int: 32;
	int: 32;};

struct bpf_pidns_info {
	__u32 pid;
	__u32 tgid;
};

struct bpf_dynptr_kern {
	void *data;
	u32 size;
	u32 offset;
	int: 32;
};

typedef u64 (*btf_bpf_map_lookup_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_update_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_map_delete_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_push_elem)(struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_map_pop_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_peek_elem)(struct bpf_map *, void *);

typedef u64 (*btf_bpf_map_lookup_percpu_elem)(struct bpf_map *, void *, u32);

typedef u64 (*btf_bpf_get_smp_processor_id)();

typedef u64 (*btf_bpf_get_numa_node_id)();

typedef u64 (*btf_bpf_ktime_get_ns)();

typedef u64 (*btf_bpf_ktime_get_boot_ns)();

typedef u64 (*btf_bpf_ktime_get_coarse_ns)();

typedef u64 (*btf_bpf_ktime_get_tai_ns)();

typedef u64 (*btf_bpf_get_current_pid_tgid)();

typedef u64 (*btf_bpf_get_current_uid_gid)();

typedef u64 (*btf_bpf_get_current_comm)(char *, u32);

typedef u64 (*btf_bpf_spin_lock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_spin_unlock)(struct bpf_spin_lock *);

typedef u64 (*btf_bpf_jiffies64)();

typedef u64 (*btf_bpf_get_current_cgroup_id)();

typedef u64 (*btf_bpf_get_current_ancestor_cgroup_id)(int);

typedef u64 (*btf_bpf_strtol)(const char *, size_t, u64, long int *);

typedef u64 (*btf_bpf_strtoul)(const char *, size_t, u64, long unsigned int *);

typedef u64 (*btf_bpf_strncmp)(const char *, u32, const char *);

typedef u64 (*btf_bpf_get_ns_current_pid_tgid)(u64, u64, struct bpf_pidns_info *, u32);

typedef u64 (*btf_bpf_event_output_data)(void *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_copy_from_user)(void *, u32, const void *);

typedef u64 (*btf_bpf_copy_from_user_task)(void *, u32, const void *, struct task_struct *, u64);

typedef u64 (*btf_bpf_per_cpu_ptr)(const void *, u32);

typedef u64 (*btf_bpf_this_cpu_ptr)(const void *);

struct bpf_bprintf_buffers {
	char tmp_bufs[1536];
};

typedef u64 (*btf_bpf_snprintf)(char *, u32, char *, const void *, u32);

struct bpf_hrtimer {
	struct hrtimer timer;
	struct bpf_map *map;
	struct bpf_prog *prog;
	void *callback_fn;
	void *value;
};

struct bpf_timer_kern {
	struct bpf_hrtimer *timer;
	struct bpf_spin_lock lock;
};

typedef u64 (*btf_bpf_timer_init)(struct bpf_timer_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_timer_set_callback)(struct bpf_timer_kern *, void *, struct bpf_prog_aux *);

typedef u64 (*btf_bpf_timer_start)(struct bpf_timer_kern *, u64, u64);

typedef u64 (*btf_bpf_timer_cancel)(struct bpf_timer_kern *);

typedef u64 (*btf_bpf_kptr_xchg)(void *, void *);

typedef u64 (*btf_bpf_dynptr_from_mem)(void *, u32, u64, struct bpf_dynptr_kern *);

typedef u64 (*btf_bpf_dynptr_read)(void *, u32, struct bpf_dynptr_kern *, u32, u64);

typedef u64 (*btf_bpf_dynptr_write)(struct bpf_dynptr_kern *, u32, void *, u32, u64);

typedef u64 (*btf_bpf_dynptr_data)(struct bpf_dynptr_kern *, u32, u32);

struct bpf_iter_target_info {
	struct list_head list;
	const struct bpf_iter_reg *reg_info;
	u32 btf_id;
};

struct bpf_iter_link {
	struct bpf_link link;
	struct bpf_iter_aux_info aux;
	struct bpf_iter_target_info *tinfo;
};

struct bpf_iter_priv_data {
	struct bpf_iter_target_info *tinfo;
	const struct bpf_iter_seq_info *seq_info;
	struct bpf_prog *prog;
	int: 32;
	u64 session_id;
	u64 seq_num;
	bool done_stop;
	int: 24;
	int: 32;
	u8 target_private[0];
};

typedef u64 (*btf_bpf_for_each_map_elem)(struct bpf_map *, void *, void *, u64);

typedef u64 (*btf_bpf_loop)(u32, void *, void *, u64);

struct bpf_iter_seq_map_info {
	u32 map_id;
};

struct bpf_iter__bpf_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
};

struct mmap_unlock_irq_work {
	struct irq_work irq_work;
	struct mm_struct *mm;
};

struct bpf_iter_seq_task_common {
	struct pid_namespace *ns;
	enum bpf_iter_task_type type;
	u32 pid;
	u32 pid_visiting;
};

struct bpf_iter_seq_task_info {
	struct bpf_iter_seq_task_common common;
	u32 tid;
};

struct bpf_iter__task {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
};

struct bpf_iter_seq_task_file_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	u32 tid;
	u32 fd;
};

struct bpf_iter__task_file {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	u32 fd;
	int: 32;
	union {
		struct file *file;
	};
};

struct bpf_iter_seq_task_vma_info {
	struct bpf_iter_seq_task_common common;
	struct task_struct *task;
	struct vm_area_struct *vma;
	u32 tid;
	long unsigned int prev_vm_start;
	long unsigned int prev_vm_end;
};

enum bpf_task_vma_iter_find_op {
	task_vma_iter_first_vma = 0,
	task_vma_iter_next_vma = 1,
	task_vma_iter_find_vma = 2,
};

struct bpf_iter__task_vma {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct task_struct *task;
	};
	union {
		struct vm_area_struct *vma;
	};
};

typedef u64 (*btf_bpf_find_vma)(struct task_struct *, u64, bpf_callback_t, void *, u64);

struct bpf_iter_seq_prog_info {
	u32 prog_id;
};

struct bpf_iter__bpf_prog {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_prog *prog;
	};
};

struct bpf_iter_seq_link_info {
	u32 link_id;
};

struct bpf_iter__bpf_link {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_link *link;
	};
};

struct bpf_iter__bpf_map_elem {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		void *value;
	};
};

struct hlist_nulls_head {
	struct hlist_nulls_node *first;
};

struct pcpu_freelist_node;

struct pcpu_freelist_head {
	struct pcpu_freelist_node *first;
	raw_spinlock_t lock;
};

struct pcpu_freelist_node {
	struct pcpu_freelist_node *next;
};

struct pcpu_freelist {
	struct pcpu_freelist_head *freelist;
	struct pcpu_freelist_head extralist;
};

struct bpf_lru_node {
	struct list_head list;
	u16 cpu;
	u8 type;
	u8 ref;
};

struct bpf_lru_list {
	struct list_head lists[3];
	unsigned int counts[2];
	struct list_head *next_inactive_rotation;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	raw_spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_lru_locallist {
	struct list_head lists[2];
	u16 next_steal;
	raw_spinlock_t lock;
};

struct bpf_common_lru {
	struct bpf_lru_list lru_list;
	struct bpf_lru_locallist *local_list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef bool (*del_from_htab_func)(void *, struct bpf_lru_node *);

struct bpf_lru {
	union {
		struct bpf_common_lru common_lru;
		struct bpf_lru_list *percpu_lru;
	};
	del_from_htab_func del_from_htab;
	void *del_arg;
	unsigned int hash_offset;
	unsigned int nr_scans;
	bool percpu;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_mem_caches;

struct bpf_mem_cache;

struct bpf_mem_alloc {
	struct bpf_mem_caches *caches;
	struct bpf_mem_cache *cache;
	struct work_struct work;
};

struct bucket {
	struct hlist_nulls_head head;
	raw_spinlock_t raw_lock;
};

struct htab_elem;

struct bpf_htab {
	struct bpf_map map;
	struct bpf_mem_alloc ma;
	struct bpf_mem_alloc pcpu_ma;
	struct bucket *buckets;
	void *elems;
	int: 32;
	int: 32;
	union {
		struct pcpu_freelist freelist;
		struct bpf_lru lru;
	};
	struct htab_elem **extra_elems;
	int: 32;
	struct percpu_counter pcount;
	atomic_t count;
	bool use_percpu_counter;
	u32 n_buckets;
	u32 elem_size;
	u32 hashrnd;
	struct lock_class_key lockdep_key;
	int *map_locked[8];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct htab_elem {
	union {
		struct hlist_nulls_node hash_node;
		struct {
			void *padding;
			union {
				struct pcpu_freelist_node fnode;
				struct htab_elem *batch_flink;
			};
		};
	};
	union {
		void *ptr_to_pptr;
		struct bpf_lru_node lru_node;
	};
	u32 hash;
	char key[0];
};

struct bpf_iter_seq_hash_map_info {
	struct bpf_map *map;
	struct bpf_htab *htab;
	void *percpu_value_buf;
	u32 bucket_id;
	u32 skip_elems;
};

struct bpf_iter_seq_array_map_info {
	struct bpf_map *map;
	void *percpu_value_buf;
	u32 index;
};

struct prog_poke_elem {
	struct list_head list;
	struct bpf_prog_aux *aux;
};

enum bpf_lru_list_type {
	BPF_LRU_LIST_T_ACTIVE = 0,
	BPF_LRU_LIST_T_INACTIVE = 1,
	BPF_LRU_LIST_T_FREE = 2,
	BPF_LRU_LOCAL_LIST_T_FREE = 3,
	BPF_LRU_LOCAL_LIST_T_PENDING = 4,
};

struct bpf_lpm_trie_key {
	__u32 prefixlen;
	__u8 data[0];
};

struct lpm_trie_node {
	struct callback_head rcu;
	struct lpm_trie_node *child[2];
	u32 prefixlen;
	u32 flags;
	u8 data[0];
};

struct lpm_trie {
	struct bpf_map map;
	struct lpm_trie_node *root;
	size_t n_entries;
	size_t max_prefixlen;
	size_t data_size;
	spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_bloom_filter {
	struct bpf_map map;
	u32 bitset_mask;
	u32 hash_seed;
	u32 aligned_u32_count;
	u32 nr_hash_funcs;
	long unsigned int bitset[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_cgroup_storage_map {
	struct bpf_map map;
	spinlock_t lock;
	struct rb_root root;
	struct list_head list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_queue_stack {
	struct bpf_map map;
	raw_spinlock_t lock;
	u32 head;
	u32 tail;
	u32 size;
	char elements[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum {
	BPF_RB_NO_WAKEUP = 1,
	BPF_RB_FORCE_WAKEUP = 2,
};

enum {
	BPF_RB_AVAIL_DATA = 0,
	BPF_RB_RING_SIZE = 1,
	BPF_RB_CONS_POS = 2,
	BPF_RB_PROD_POS = 3,
};

enum {
	BPF_RINGBUF_BUSY_BIT = 2147483648,
	BPF_RINGBUF_DISCARD_BIT = 1073741824,
	BPF_RINGBUF_HDR_SZ = 8,
};

struct bpf_ringbuf {
	wait_queue_head_t waitq;
	struct irq_work work;
	int: 32;
	u64 mask;
	struct page **pages;
	int nr_pages;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t spinlock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic_t busy;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int consumer_pos;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int producer_pos;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	char data[0];
};

struct bpf_ringbuf_map {
	struct bpf_map map;
	struct bpf_ringbuf *rb;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_ringbuf_hdr {
	u32 len;
	u32 pg_off;
};

typedef u64 (*btf_bpf_ringbuf_reserve)(struct bpf_map *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_submit)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_discard)(void *, u64);

typedef u64 (*btf_bpf_ringbuf_output)(struct bpf_map *, void *, u64, u64);

typedef u64 (*btf_bpf_ringbuf_query)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_ringbuf_reserve_dynptr)(struct bpf_map *, u32, u64, struct bpf_dynptr_kern *);

typedef u64 (*btf_bpf_ringbuf_submit_dynptr)(struct bpf_dynptr_kern *, u64);

typedef u64 (*btf_bpf_ringbuf_discard_dynptr)(struct bpf_dynptr_kern *, u64);

typedef u64 (*btf_bpf_user_ringbuf_drain)(struct bpf_map *, void *, void *, u64);

struct bpf_local_storage_elem {
	struct hlist_node map_node;
	struct hlist_node snode;
	struct bpf_local_storage *local_storage;
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct bpf_local_storage_data sdata;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_local_storage_cache {
	spinlock_t idx_lock;
	int: 32;
	u64 idx_usage_counts[16];
};

enum {
	BPF_LOCAL_STORAGE_GET_F_CREATE = 1,
	BPF_SK_STORAGE_GET_F_CREATE = 1,
};

typedef u64 (*btf_bpf_task_storage_get)(struct bpf_map *, struct task_struct *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_task_storage_delete)(struct bpf_map *, struct task_struct *);

struct bpf_tramp_links {
	struct bpf_tramp_link *links[38];
	int nr_links;
};

struct btf_enum {
	__u32 name_off;
	__s32 val;
};

struct btf_array {
	__u32 type;
	__u32 index_type;
	__u32 nelems;
};

enum {
	BTF_VAR_STATIC = 0,
	BTF_VAR_GLOBAL_ALLOCATED = 1,
	BTF_VAR_GLOBAL_EXTERN = 2,
};

struct btf_var {
	__u32 linkage;
};

struct btf_decl_tag {
	__s32 component_idx;
};

struct btf_enum64 {
	__u32 name_off;
	__u32 val_lo32;
	__u32 val_hi32;
};

struct bpf_flow_keys {
	__u16 nhoff;
	__u16 thoff;
	__u16 addr_proto;
	__u8 is_frag;
	__u8 is_first_frag;
	__u8 is_encap;
	__u8 ip_proto;
	__be16 n_proto;
	__be16 sport;
	__be16 dport;
	union {
		struct {
			__be32 ipv4_src;
			__be32 ipv4_dst;
		};
		struct {
			__u32 ipv6_src[4];
			__u32 ipv6_dst[4];
		};
	};
	__u32 flags;
	__be32 flow_label;
};

struct bpf_sock {
	__u32 bound_dev_if;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 mark;
	__u32 priority;
	__u32 src_ip4;
	__u32 src_ip6[4];
	__u32 src_port;
	__be16 dst_port;
	__u32 dst_ip4;
	__u32 dst_ip6[4];
	__u32 state;
	__s32 rx_queue_mapping;
};

struct __sk_buff {
	__u32 len;
	__u32 pkt_type;
	__u32 mark;
	__u32 queue_mapping;
	__u32 protocol;
	__u32 vlan_present;
	__u32 vlan_tci;
	__u32 vlan_proto;
	__u32 priority;
	__u32 ingress_ifindex;
	__u32 ifindex;
	__u32 tc_index;
	__u32 cb[5];
	__u32 hash;
	__u32 tc_classid;
	__u32 data;
	__u32 data_end;
	__u32 napi_id;
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 data_meta;
	union {
		struct bpf_flow_keys *flow_keys;
	};
	__u64 tstamp;
	__u32 wire_len;
	__u32 gso_segs;
	union {
		struct bpf_sock *sk;
	};
	__u32 gso_size;
	__u8 tstamp_type;
	__u64 hwtstamp;
};

struct xdp_md {
	__u32 data;
	__u32 data_end;
	__u32 data_meta;
	__u32 ingress_ifindex;
	__u32 rx_queue_index;
	__u32 egress_ifindex;
};

struct sk_msg_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 size;
	union {
		struct bpf_sock *sk;
	};
};

struct sk_reuseport_md {
	union {
		void *data;
	};
	union {
		void *data_end;
	};
	__u32 len;
	__u32 eth_protocol;
	__u32 ip_protocol;
	__u32 bind_inany;
	__u32 hash;
	int: 32;
	union {
		struct bpf_sock *sk;
	};
	union {
		struct bpf_sock *migrating_sk;
	};
};

struct bpf_sock_addr {
	__u32 user_family;
	__u32 user_ip4;
	__u32 user_ip6[4];
	__u32 user_port;
	__u32 family;
	__u32 type;
	__u32 protocol;
	__u32 msg_src_ip4;
	__u32 msg_src_ip6[4];
	int: 32;
	union {
		struct bpf_sock *sk;
	};
};

struct bpf_sock_ops {
	__u32 op;
	union {
		__u32 args[4];
		__u32 reply;
		__u32 replylong[4];
	};
	__u32 family;
	__u32 remote_ip4;
	__u32 local_ip4;
	__u32 remote_ip6[4];
	__u32 local_ip6[4];
	__u32 remote_port;
	__u32 local_port;
	__u32 is_fullsock;
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 bpf_sock_ops_cb_flags;
	__u32 state;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u32 sk_txhash;
	__u64 bytes_received;
	__u64 bytes_acked;
	union {
		struct bpf_sock *sk;
	};
	union {
		void *skb_data;
	};
	union {
		void *skb_data_end;
	};
	__u32 skb_len;
	__u32 skb_tcp_flags;
};

struct bpf_cgroup_dev_ctx {
	__u32 access_type;
	__u32 major;
	__u32 minor;
};

struct bpf_sysctl {
	__u32 write;
	__u32 file_pos;
};

struct bpf_sockopt {
	union {
		struct bpf_sock *sk;
	};
	union {
		void *optval;
	};
	union {
		void *optval_end;
	};
	__s32 level;
	__s32 optname;
	__s32 optlen;
	__s32 retval;
};

struct bpf_sk_lookup {
	union {
		union {
			struct bpf_sock *sk;
		};
		__u64 cookie;
	};
	__u32 family;
	__u32 protocol;
	__u32 remote_ip4;
	__u32 remote_ip6[4];
	__be16 remote_port;
	__u32 local_ip4;
	__u32 local_ip6[4];
	__u32 local_port;
	__u32 ingress_ifindex;
	int: 32;
};

struct btf_id_dtor_kfunc {
	u32 btf_id;
	u32 kfunc_btf_id;
};

struct sk_reuseport_kern {
	struct sk_buff *skb;
	struct sock *sk;
	struct sock *selected_sk;
	struct sock *migrating_sk;
	void *data_end;
	u32 hash;
	u32 reuseport_id;
	bool bind_inany;
};

struct bpf_flow_dissector {
	struct bpf_flow_keys *flow_keys;
	const struct sk_buff *skb;
	const void *data;
	const void *data_end;
};

struct inet_ehash_bucket;

struct inet_bind_hashbucket;

struct inet_listen_hashbucket;

struct inet_hashinfo {
	struct inet_ehash_bucket *ehash;
	spinlock_t *ehash_locks;
	unsigned int ehash_mask;
	unsigned int ehash_locks_mask;
	struct kmem_cache *bind_bucket_cachep;
	struct inet_bind_hashbucket *bhash;
	struct kmem_cache *bind2_bucket_cachep;
	struct inet_bind_hashbucket *bhash2;
	unsigned int bhash_size;
	unsigned int lhash2_mask;
	struct inet_listen_hashbucket *lhash2;
	bool pernet;
};

struct ip_ra_chain {
	struct ip_ra_chain *next;
	struct sock *sk;
	union {
		void (*destructor)(struct sock *);
		struct sock *saved_sk;
	};
	struct callback_head rcu;
};

struct inet_peer_base {
	struct rb_root rb_root;
	seqlock_t lock;
	int total;
};

struct tcp_fastopen_context {
	siphash_key_t key[2];
	int num;
	struct callback_head rcu;
	int: 32;
};

struct bpf_sock_addr_kern {
	struct sock *sk;
	struct sockaddr *uaddr;
	u64 tmp_reg;
	void *t_ctx;
	int: 32;
};

struct bpf_sock_ops_kern {
	struct sock *sk;
	union {
		u32 args[4];
		u32 reply;
		u32 replylong[4];
	};
	struct sk_buff *syn_skb;
	struct sk_buff *skb;
	void *skb_data_end;
	u8 op;
	u8 is_fullsock;
	u8 remaining_opt_len;
	int: 8;
	int: 32;
	u64 temp;
};

struct bpf_sysctl_kern {
	struct ctl_table_header *head;
	struct ctl_table *table;
	void *cur_val;
	size_t cur_len;
	void *new_val;
	size_t new_len;
	int new_updated;
	int write;
	loff_t *ppos;
	int: 32;
	u64 tmp_reg;
};

struct bpf_sockopt_kern {
	struct sock *sk;
	u8 *optval;
	u8 *optval_end;
	s32 level;
	s32 optname;
	s32 optlen;
	struct task_struct *current_task;
	int: 32;
	u64 tmp_reg;
};

struct bpf_sk_lookup_kern {
	u16 family;
	u16 protocol;
	__be16 sport;
	u16 dport;
	struct {
		__be32 saddr;
		__be32 daddr;
	} v4;
	struct {
		const struct in6_addr *saddr;
		const struct in6_addr *daddr;
	} v6;
	struct sock *selected_sk;
	u32 ingress_ifindex;
	bool no_reuseport;
};

struct lwtunnel_state {
	__u16 type;
	__u16 flags;
	__u16 headroom;
	atomic_t refcnt;
	int (*orig_output)(struct net *, struct sock *, struct sk_buff *);
	int (*orig_input)(struct sk_buff *);
	struct callback_head rcu;
	__u8 data[0];
};

struct sock_reuseport {
	struct callback_head rcu;
	u16 max_socks;
	u16 num_socks;
	u16 num_closed_socks;
	unsigned int synq_overflow_ts;
	unsigned int reuseport_id;
	unsigned int bind_inany: 1;
	unsigned int has_conns: 1;
	struct bpf_prog *prog;
	struct sock *socks[0];
};

struct sk_psock_progs {
	struct bpf_prog *msg_parser;
	struct bpf_prog *stream_parser;
	struct bpf_prog *stream_verdict;
	struct bpf_prog *skb_verdict;
};

struct strp_stats {
	long long unsigned int msgs;
	long long unsigned int bytes;
	unsigned int mem_fail;
	unsigned int need_more_hdr;
	unsigned int msg_too_big;
	unsigned int msg_timeouts;
	unsigned int bad_hdr_len;
	int: 32;
};

struct strparser;

struct strp_callbacks {
	int (*parse_msg)(struct strparser *, struct sk_buff *);
	void (*rcv_msg)(struct strparser *, struct sk_buff *);
	int (*read_sock_done)(struct strparser *, int);
	void (*abort_parser)(struct strparser *, int);
	void (*lock)(struct strparser *);
	void (*unlock)(struct strparser *);
};

struct strparser {
	struct sock *sk;
	u32 stopped: 1;
	u32 paused: 1;
	u32 aborted: 1;
	u32 interrupted: 1;
	u32 unrecov_intr: 1;
	struct sk_buff **skb_nextp;
	struct sk_buff *skb_head;
	unsigned int need_bytes;
	struct delayed_work msg_timer_work;
	struct work_struct work;
	struct strp_stats stats;
	struct strp_callbacks cb;
};

struct sk_psock_work_state {
	struct sk_buff *skb;
	u32 len;
	u32 off;
};

struct sk_msg;

struct sk_psock {
	struct sock *sk;
	struct sock *sk_redir;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 eval;
	struct sk_msg *cork;
	struct sk_psock_progs progs;
	struct strparser strp;
	struct sk_buff_head ingress_skb;
	struct list_head ingress_msg;
	spinlock_t ingress_lock;
	long unsigned int state;
	struct list_head link;
	spinlock_t link_lock;
	refcount_t refcnt;
	void (*saved_unhash)(struct sock *);
	void (*saved_destroy)(struct sock *);
	void (*saved_close)(struct sock *, long int);
	void (*saved_write_space)(struct sock *);
	void (*saved_data_ready)(struct sock *);
	int (*psock_update_sk_prot)(struct sock *, struct sk_psock *, bool);
	struct proto *sk_proto;
	struct mutex work_mutex;
	struct sk_psock_work_state work_state;
	struct work_struct work;
	struct rcu_work rwork;
};

enum {
	__ND_OPT_PREFIX_INFO_END = 0,
	ND_OPT_SOURCE_LL_ADDR = 1,
	ND_OPT_TARGET_LL_ADDR = 2,
	ND_OPT_PREFIX_INFO = 3,
	ND_OPT_REDIRECT_HDR = 4,
	ND_OPT_MTU = 5,
	ND_OPT_NONCE = 14,
	__ND_OPT_ARRAY_MAX = 15,
	ND_OPT_ROUTE_INFO = 24,
	ND_OPT_RDNSS = 25,
	ND_OPT_DNSSL = 31,
	ND_OPT_6CO = 34,
	ND_OPT_CAPTIVE_PORTAL = 37,
	ND_OPT_PREF64 = 38,
	__ND_OPT_MAX = 39,
};

struct nd_opt_hdr {
	__u8 nd_opt_type;
	__u8 nd_opt_len;
};

struct ndisc_options {
	struct nd_opt_hdr *nd_opt_array[15];
	struct nd_opt_hdr *nd_useropts;
	struct nd_opt_hdr *nd_useropts_end;
};

struct prefix_info {
	__u8 type;
	__u8 length;
	__u8 prefix_len;
	__u8 reserved: 6;
	__u8 autoconf: 1;
	__u8 onlink: 1;
	__be32 valid;
	__be32 prefered;
	__be32 reserved2;
	struct in6_addr prefix;
};

struct inet_ehash_bucket {
	struct hlist_nulls_head chain;
};

struct inet_bind_hashbucket {
	spinlock_t lock;
	struct hlist_head chain;
};

struct inet_listen_hashbucket {
	spinlock_t lock;
	struct hlist_nulls_head nulls_head;
};

struct ack_sample {
	u32 pkts_acked;
	s32 rtt_us;
	u32 in_flight;
};

struct rate_sample {
	u64 prior_mstamp;
	u32 prior_delivered;
	u32 prior_delivered_ce;
	s32 delivered;
	s32 delivered_ce;
	long int interval_us;
	u32 snd_interval_us;
	u32 rcv_interval_us;
	long int rtt_us;
	int losses;
	u32 acked_sacked;
	u32 prior_in_flight;
	u32 last_end_seq;
	bool is_app_limited;
	bool is_retrans;
	bool is_ack_delayed;
	int: 8;
	int: 32;
};

struct sk_msg_sg {
	u32 start;
	u32 curr;
	u32 end;
	u32 size;
	u32 copybreak;
	long unsigned int copy[1];
	struct scatterlist data[19];
};

struct sk_msg {
	struct sk_msg_sg sg;
	void *data;
	void *data_end;
	u32 apply_bytes;
	u32 cork_bytes;
	u32 flags;
	struct sk_buff *skb;
	struct sock *sk_redir;
	struct sock *sk;
	struct list_head list;
};

struct bpf_core_cand {
	const struct btf *btf;
	__u32 id;
};

struct bpf_core_cand_list {
	struct bpf_core_cand *cands;
	int len;
};

struct bpf_core_accessor {
	__u32 type_id;
	__u32 idx;
	const char *name;
};

struct bpf_core_spec {
	const struct btf *btf;
	struct bpf_core_accessor spec[64];
	__u32 root_type_id;
	enum bpf_core_relo_kind relo_kind;
	int len;
	int raw_spec[64];
	int raw_len;
	__u32 bit_offset;
};

struct bpf_core_relo_res {
	__u64 orig_val;
	__u64 new_val;
	bool poison;
	bool validate;
	bool fail_memsz_adjust;
	__u32 orig_sz;
	__u32 orig_type_id;
	__u32 new_sz;
	__u32 new_type_id;
	int: 32;
};

enum btf_kfunc_hook {
	BTF_KFUNC_HOOK_XDP = 0,
	BTF_KFUNC_HOOK_TC = 1,
	BTF_KFUNC_HOOK_STRUCT_OPS = 2,
	BTF_KFUNC_HOOK_TRACING = 3,
	BTF_KFUNC_HOOK_SYSCALL = 4,
	BTF_KFUNC_HOOK_MAX = 5,
};

enum {
	BTF_KFUNC_SET_MAX_CNT = 256,
	BTF_DTOR_KFUNC_MAX_CNT = 256,
};

struct btf_kfunc_set_tab {
	struct btf_id_set8 *sets[5];
};

struct btf_id_dtor_kfunc_tab {
	u32 cnt;
	struct btf_id_dtor_kfunc dtors[0];
};

enum verifier_phase {
	CHECK_META = 0,
	CHECK_TYPE = 1,
};

struct resolve_vertex {
	const struct btf_type *t;
	u32 type_id;
	u16 next_member;
};

enum visit_state {
	NOT_VISITED = 0,
	VISITED = 1,
	RESOLVED = 2,
};

enum resolve_mode {
	RESOLVE_TBD = 0,
	RESOLVE_PTR = 1,
	RESOLVE_STRUCT_OR_ARRAY = 2,
};

struct btf_sec_info {
	u32 off;
	u32 len;
};

struct btf_verifier_env {
	struct btf *btf;
	u8 *visit_states;
	struct resolve_vertex stack[32];
	struct bpf_verifier_log log;
	u32 log_type_id;
	u32 top_stack;
	enum verifier_phase phase;
	enum resolve_mode resolve_mode;
};

struct btf_show {
	u64 flags;
	void *target;
	void (*showfn)(struct btf_show *, const char *, va_list);
	const struct btf *btf;
	struct {
		u8 depth;
		u8 depth_to_show;
		u8 depth_check;
		u8 array_member: 1;
		u8 array_terminated: 1;
		u16 array_encoding;
		u32 type_id;
		int status;
		const struct btf_type *type;
		const struct btf_member *member;
		char name[80];
	} state;
	struct {
		u32 size;
		void *head;
		void *data;
		u8 safe[32];
	} obj;
};

struct btf_kind_operations {
	s32 (*check_meta)(struct btf_verifier_env *, const struct btf_type *, u32);
	int (*resolve)(struct btf_verifier_env *, const struct resolve_vertex *);
	int (*check_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	int (*check_kflag_member)(struct btf_verifier_env *, const struct btf_type *, const struct btf_member *, const struct btf_type *);
	void (*log_details)(struct btf_verifier_env *, const struct btf_type *);
	void (*show)(const struct btf *, const struct btf_type *, u32, void *, u8, struct btf_show *);
};

enum btf_field_type {
	BTF_FIELD_SPIN_LOCK = 0,
	BTF_FIELD_TIMER = 1,
	BTF_FIELD_KPTR = 2,
};

enum {
	BTF_FIELD_IGNORE = 0,
	BTF_FIELD_FOUND = 1,
};

struct btf_field_info {
	u32 type_id;
	u32 off;
	enum bpf_kptr_type type;
};

struct bpf_ctx_convert {
	struct __sk_buff BPF_PROG_TYPE_SOCKET_FILTER_prog;
	struct sk_buff BPF_PROG_TYPE_SOCKET_FILTER_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_CLS_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_CLS_kern;
	struct __sk_buff BPF_PROG_TYPE_SCHED_ACT_prog;
	struct sk_buff BPF_PROG_TYPE_SCHED_ACT_kern;
	struct xdp_md BPF_PROG_TYPE_XDP_prog;
	struct xdp_buff BPF_PROG_TYPE_XDP_kern;
	struct __sk_buff BPF_PROG_TYPE_CGROUP_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_CGROUP_SKB_kern;
	struct bpf_sock BPF_PROG_TYPE_CGROUP_SOCK_prog;
	struct sock BPF_PROG_TYPE_CGROUP_SOCK_kern;
	struct bpf_sock_addr BPF_PROG_TYPE_CGROUP_SOCK_ADDR_prog;
	struct bpf_sock_addr_kern BPF_PROG_TYPE_CGROUP_SOCK_ADDR_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_IN_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_IN_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_OUT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_OUT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_XMIT_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_XMIT_kern;
	struct __sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_prog;
	struct sk_buff BPF_PROG_TYPE_LWT_SEG6LOCAL_kern;
	struct bpf_sock_ops BPF_PROG_TYPE_SOCK_OPS_prog;
	struct bpf_sock_ops_kern BPF_PROG_TYPE_SOCK_OPS_kern;
	struct __sk_buff BPF_PROG_TYPE_SK_SKB_prog;
	struct sk_buff BPF_PROG_TYPE_SK_SKB_kern;
	struct sk_msg_md BPF_PROG_TYPE_SK_MSG_prog;
	struct sk_msg BPF_PROG_TYPE_SK_MSG_kern;
	struct __sk_buff BPF_PROG_TYPE_FLOW_DISSECTOR_prog;
	struct bpf_flow_dissector BPF_PROG_TYPE_FLOW_DISSECTOR_kern;
	bpf_user_pt_regs_t BPF_PROG_TYPE_KPROBE_prog;
	struct pt_regs BPF_PROG_TYPE_KPROBE_kern;
	__u64 BPF_PROG_TYPE_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_TRACEPOINT_kern;
	struct bpf_perf_event_data BPF_PROG_TYPE_PERF_EVENT_prog;
	struct bpf_perf_event_data_kern BPF_PROG_TYPE_PERF_EVENT_kern;
	int: 32;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_kern;
	struct bpf_raw_tracepoint_args BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_prog;
	u64 BPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE_kern;
	void *BPF_PROG_TYPE_TRACING_prog;
	void *BPF_PROG_TYPE_TRACING_kern;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_prog;
	struct bpf_cgroup_dev_ctx BPF_PROG_TYPE_CGROUP_DEVICE_kern;
	struct bpf_sysctl BPF_PROG_TYPE_CGROUP_SYSCTL_prog;
	struct bpf_sysctl_kern BPF_PROG_TYPE_CGROUP_SYSCTL_kern;
	struct bpf_sockopt BPF_PROG_TYPE_CGROUP_SOCKOPT_prog;
	struct bpf_sockopt_kern BPF_PROG_TYPE_CGROUP_SOCKOPT_kern;
	struct sk_reuseport_md BPF_PROG_TYPE_SK_REUSEPORT_prog;
	struct sk_reuseport_kern BPF_PROG_TYPE_SK_REUSEPORT_kern;
	struct bpf_sk_lookup BPF_PROG_TYPE_SK_LOOKUP_prog;
	struct bpf_sk_lookup_kern BPF_PROG_TYPE_SK_LOOKUP_kern;
	void *BPF_PROG_TYPE_STRUCT_OPS_prog;
	void *BPF_PROG_TYPE_STRUCT_OPS_kern;
	void *BPF_PROG_TYPE_EXT_prog;
	void *BPF_PROG_TYPE_EXT_kern;
	void *BPF_PROG_TYPE_SYSCALL_prog;
	void *BPF_PROG_TYPE_SYSCALL_kern;
	int: 32;
};

enum {
	__ctx_convertBPF_PROG_TYPE_SOCKET_FILTER = 0,
	__ctx_convertBPF_PROG_TYPE_SCHED_CLS = 1,
	__ctx_convertBPF_PROG_TYPE_SCHED_ACT = 2,
	__ctx_convertBPF_PROG_TYPE_XDP = 3,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SKB = 4,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK = 5,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCK_ADDR = 6,
	__ctx_convertBPF_PROG_TYPE_LWT_IN = 7,
	__ctx_convertBPF_PROG_TYPE_LWT_OUT = 8,
	__ctx_convertBPF_PROG_TYPE_LWT_XMIT = 9,
	__ctx_convertBPF_PROG_TYPE_LWT_SEG6LOCAL = 10,
	__ctx_convertBPF_PROG_TYPE_SOCK_OPS = 11,
	__ctx_convertBPF_PROG_TYPE_SK_SKB = 12,
	__ctx_convertBPF_PROG_TYPE_SK_MSG = 13,
	__ctx_convertBPF_PROG_TYPE_FLOW_DISSECTOR = 14,
	__ctx_convertBPF_PROG_TYPE_KPROBE = 15,
	__ctx_convertBPF_PROG_TYPE_TRACEPOINT = 16,
	__ctx_convertBPF_PROG_TYPE_PERF_EVENT = 17,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT = 18,
	__ctx_convertBPF_PROG_TYPE_RAW_TRACEPOINT_WRITABLE = 19,
	__ctx_convertBPF_PROG_TYPE_TRACING = 20,
	__ctx_convertBPF_PROG_TYPE_CGROUP_DEVICE = 21,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SYSCTL = 22,
	__ctx_convertBPF_PROG_TYPE_CGROUP_SOCKOPT = 23,
	__ctx_convertBPF_PROG_TYPE_SK_REUSEPORT = 24,
	__ctx_convertBPF_PROG_TYPE_SK_LOOKUP = 25,
	__ctx_convertBPF_PROG_TYPE_STRUCT_OPS = 26,
	__ctx_convertBPF_PROG_TYPE_EXT = 27,
	__ctx_convertBPF_PROG_TYPE_SYSCALL = 28,
	__ctx_convert_unused = 29,
};

enum bpf_struct_walk_result {
	WALK_SCALAR = 0,
	WALK_PTR = 1,
	WALK_STRUCT = 2,
};

struct btf_show_snprintf {
	struct btf_show show;
	int len_left;
	int len;
};

enum {
	BTF_MODULE_F_LIVE = 1,
};

struct btf_module {
	struct list_head list;
	struct module *module;
	struct btf *btf;
	struct bin_attribute *sysfs_attr;
	int flags;
};

typedef u64 (*btf_bpf_btf_find_by_name_kind)(char *, int, u32, int);

struct bpf_cand_cache {
	const char *name;
	u32 name_len;
	u16 kind;
	u16 cnt;
	struct {
		const struct btf *btf;
		u32 id;
	} cands[0];
};

struct bpf_mem_cache {
	struct llist_head free_llist;
	local_t active;
	struct llist_head free_llist_extra;
	struct irq_work refill_work;
	struct obj_cgroup *objcg;
	int unit_size;
	int free_cnt;
	int low_watermark;
	int high_watermark;
	int batch;
	int percpu_size;
	struct callback_head rcu;
	struct llist_head free_by_rcu;
	struct llist_head waiting_for_gp;
	atomic_t call_rcu_in_progress;
};

struct bpf_mem_caches {
	struct bpf_mem_cache cache[11];
};

struct bpf_dispatcher_prog {
	struct bpf_prog *prog;
	refcount_t users;
};

struct bpf_dispatcher {
	struct mutex mutex;
	void *func;
	struct bpf_dispatcher_prog progs[48];
	int num_progs;
	void *image;
	void *rw_image;
	u32 image_off;
	struct bpf_ksym ksym;
};

enum {
	BPF_F_BROADCAST = 8,
	BPF_F_EXCLUDE_INGRESS = 16,
};

struct bpf_devmap_val {
	__u32 ifindex;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

enum skb_drop_reason {
	SKB_NOT_DROPPED_YET = 0,
	SKB_DROP_REASON_NOT_SPECIFIED = 1,
	SKB_DROP_REASON_NO_SOCKET = 2,
	SKB_DROP_REASON_PKT_TOO_SMALL = 3,
	SKB_DROP_REASON_TCP_CSUM = 4,
	SKB_DROP_REASON_SOCKET_FILTER = 5,
	SKB_DROP_REASON_UDP_CSUM = 6,
	SKB_DROP_REASON_NETFILTER_DROP = 7,
	SKB_DROP_REASON_OTHERHOST = 8,
	SKB_DROP_REASON_IP_CSUM = 9,
	SKB_DROP_REASON_IP_INHDR = 10,
	SKB_DROP_REASON_IP_RPFILTER = 11,
	SKB_DROP_REASON_UNICAST_IN_L2_MULTICAST = 12,
	SKB_DROP_REASON_XFRM_POLICY = 13,
	SKB_DROP_REASON_IP_NOPROTO = 14,
	SKB_DROP_REASON_SOCKET_RCVBUFF = 15,
	SKB_DROP_REASON_PROTO_MEM = 16,
	SKB_DROP_REASON_TCP_MD5NOTFOUND = 17,
	SKB_DROP_REASON_TCP_MD5UNEXPECTED = 18,
	SKB_DROP_REASON_TCP_MD5FAILURE = 19,
	SKB_DROP_REASON_SOCKET_BACKLOG = 20,
	SKB_DROP_REASON_TCP_FLAGS = 21,
	SKB_DROP_REASON_TCP_ZEROWINDOW = 22,
	SKB_DROP_REASON_TCP_OLD_DATA = 23,
	SKB_DROP_REASON_TCP_OVERWINDOW = 24,
	SKB_DROP_REASON_TCP_OFOMERGE = 25,
	SKB_DROP_REASON_TCP_RFC7323_PAWS = 26,
	SKB_DROP_REASON_TCP_INVALID_SEQUENCE = 27,
	SKB_DROP_REASON_TCP_RESET = 28,
	SKB_DROP_REASON_TCP_INVALID_SYN = 29,
	SKB_DROP_REASON_TCP_CLOSE = 30,
	SKB_DROP_REASON_TCP_FASTOPEN = 31,
	SKB_DROP_REASON_TCP_OLD_ACK = 32,
	SKB_DROP_REASON_TCP_TOO_OLD_ACK = 33,
	SKB_DROP_REASON_TCP_ACK_UNSENT_DATA = 34,
	SKB_DROP_REASON_TCP_OFO_QUEUE_PRUNE = 35,
	SKB_DROP_REASON_TCP_OFO_DROP = 36,
	SKB_DROP_REASON_IP_OUTNOROUTES = 37,
	SKB_DROP_REASON_BPF_CGROUP_EGRESS = 38,
	SKB_DROP_REASON_IPV6DISABLED = 39,
	SKB_DROP_REASON_NEIGH_CREATEFAIL = 40,
	SKB_DROP_REASON_NEIGH_FAILED = 41,
	SKB_DROP_REASON_NEIGH_QUEUEFULL = 42,
	SKB_DROP_REASON_NEIGH_DEAD = 43,
	SKB_DROP_REASON_TC_EGRESS = 44,
	SKB_DROP_REASON_QDISC_DROP = 45,
	SKB_DROP_REASON_CPU_BACKLOG = 46,
	SKB_DROP_REASON_XDP = 47,
	SKB_DROP_REASON_TC_INGRESS = 48,
	SKB_DROP_REASON_UNHANDLED_PROTO = 49,
	SKB_DROP_REASON_SKB_CSUM = 50,
	SKB_DROP_REASON_SKB_GSO_SEG = 51,
	SKB_DROP_REASON_SKB_UCOPY_FAULT = 52,
	SKB_DROP_REASON_DEV_HDR = 53,
	SKB_DROP_REASON_DEV_READY = 54,
	SKB_DROP_REASON_FULL_RING = 55,
	SKB_DROP_REASON_NOMEM = 56,
	SKB_DROP_REASON_HDR_TRUNC = 57,
	SKB_DROP_REASON_TAP_FILTER = 58,
	SKB_DROP_REASON_TAP_TXFILTER = 59,
	SKB_DROP_REASON_ICMP_CSUM = 60,
	SKB_DROP_REASON_INVALID_PROTO = 61,
	SKB_DROP_REASON_IP_INADDRERRORS = 62,
	SKB_DROP_REASON_IP_INNOROUTES = 63,
	SKB_DROP_REASON_PKT_TOO_BIG = 64,
	SKB_DROP_REASON_MAX = 65,
};

typedef struct bio_vec skb_frag_t;

struct skb_shared_info {
	__u8 flags;
	__u8 meta_len;
	__u8 nr_frags;
	__u8 tx_flags;
	short unsigned int gso_size;
	short unsigned int gso_segs;
	struct sk_buff *frag_list;
	int: 32;
	struct skb_shared_hwtstamps hwtstamps;
	unsigned int gso_type;
	u32 tskey;
	atomic_t dataref;
	unsigned int xdp_frags_size;
	void *destructor_arg;
	skb_frag_t frags[17];
};

enum xdp_buff_flags {
	XDP_FLAGS_HAS_FRAGS = 1,
	XDP_FLAGS_FRAGS_PF_MEMALLOC = 2,
};

enum net_device_flags {
	IFF_UP = 1,
	IFF_BROADCAST = 2,
	IFF_DEBUG = 4,
	IFF_LOOPBACK = 8,
	IFF_POINTOPOINT = 16,
	IFF_NOTRAILERS = 32,
	IFF_RUNNING = 64,
	IFF_NOARP = 128,
	IFF_PROMISC = 256,
	IFF_ALLMULTI = 512,
	IFF_MASTER = 1024,
	IFF_SLAVE = 2048,
	IFF_MULTICAST = 4096,
	IFF_PORTSEL = 8192,
	IFF_AUTOMEDIA = 16384,
	IFF_DYNAMIC = 32768,
	IFF_LOWER_UP = 65536,
	IFF_DORMANT = 131072,
	IFF_ECHO = 262144,
};

enum netdev_priv_flags {
	IFF_802_1Q_VLAN = 1,
	IFF_EBRIDGE = 2,
	IFF_BONDING = 4,
	IFF_ISATAP = 8,
	IFF_WAN_HDLC = 16,
	IFF_XMIT_DST_RELEASE = 32,
	IFF_DONT_BRIDGE = 64,
	IFF_DISABLE_NETPOLL = 128,
	IFF_MACVLAN_PORT = 256,
	IFF_BRIDGE_PORT = 512,
	IFF_OVS_DATAPATH = 1024,
	IFF_TX_SKB_SHARING = 2048,
	IFF_UNICAST_FLT = 4096,
	IFF_TEAM_PORT = 8192,
	IFF_SUPP_NOFCS = 16384,
	IFF_LIVE_ADDR_CHANGE = 32768,
	IFF_MACVLAN = 65536,
	IFF_XMIT_DST_RELEASE_PERM = 131072,
	IFF_L3MDEV_MASTER = 262144,
	IFF_NO_QUEUE = 524288,
	IFF_OPENVSWITCH = 1048576,
	IFF_L3MDEV_SLAVE = 2097152,
	IFF_TEAM = 4194304,
	IFF_RXFH_CONFIGURED = 8388608,
	IFF_PHONY_HEADROOM = 16777216,
	IFF_MACSEC = 33554432,
	IFF_NO_RX_HANDLER = 67108864,
	IFF_FAILOVER = 134217728,
	IFF_FAILOVER_SLAVE = 268435456,
	IFF_L3MDEV_RX_HANDLER = 536870912,
	IFF_LIVE_RENAME_OK = 1073741824,
	IFF_TX_SKB_NO_LINEAR = 2147483648,
	IFF_CHANGE_PROTO_DOWN = 0,
};

struct xdp_dev_bulk_queue {
	struct xdp_frame *q[16];
	struct list_head flush_node;
	struct net_device *dev;
	struct net_device *dev_rx;
	struct bpf_prog *xdp_prog;
	unsigned int count;
};

enum netdev_cmd {
	NETDEV_UP = 1,
	NETDEV_DOWN = 2,
	NETDEV_REBOOT = 3,
	NETDEV_CHANGE = 4,
	NETDEV_REGISTER = 5,
	NETDEV_UNREGISTER = 6,
	NETDEV_CHANGEMTU = 7,
	NETDEV_CHANGEADDR = 8,
	NETDEV_PRE_CHANGEADDR = 9,
	NETDEV_GOING_DOWN = 10,
	NETDEV_CHANGENAME = 11,
	NETDEV_FEAT_CHANGE = 12,
	NETDEV_BONDING_FAILOVER = 13,
	NETDEV_PRE_UP = 14,
	NETDEV_PRE_TYPE_CHANGE = 15,
	NETDEV_POST_TYPE_CHANGE = 16,
	NETDEV_POST_INIT = 17,
	NETDEV_RELEASE = 18,
	NETDEV_NOTIFY_PEERS = 19,
	NETDEV_JOIN = 20,
	NETDEV_CHANGEUPPER = 21,
	NETDEV_RESEND_IGMP = 22,
	NETDEV_PRECHANGEMTU = 23,
	NETDEV_CHANGEINFODATA = 24,
	NETDEV_BONDING_INFO = 25,
	NETDEV_PRECHANGEUPPER = 26,
	NETDEV_CHANGELOWERSTATE = 27,
	NETDEV_UDP_TUNNEL_PUSH_INFO = 28,
	NETDEV_UDP_TUNNEL_DROP_INFO = 29,
	NETDEV_CHANGE_TX_QUEUE_LEN = 30,
	NETDEV_CVLAN_FILTER_PUSH_INFO = 31,
	NETDEV_CVLAN_FILTER_DROP_INFO = 32,
	NETDEV_SVLAN_FILTER_PUSH_INFO = 33,
	NETDEV_SVLAN_FILTER_DROP_INFO = 34,
	NETDEV_OFFLOAD_XSTATS_ENABLE = 35,
	NETDEV_OFFLOAD_XSTATS_DISABLE = 36,
	NETDEV_OFFLOAD_XSTATS_REPORT_USED = 37,
	NETDEV_OFFLOAD_XSTATS_REPORT_DELTA = 38,
};

struct netdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
};

struct bpf_nh_params {
	u32 nh_family;
	union {
		u32 ipv4_nh;
		struct in6_addr ipv6_nh;
	};
};

struct bpf_redirect_info {
	u32 flags;
	u32 tgt_index;
	void *tgt_value;
	struct bpf_map *map;
	u32 map_id;
	enum bpf_map_type map_type;
	u32 kern_flags;
	struct bpf_nh_params nh;
};

struct bpf_dtab;

struct bpf_dtab_netdev {
	struct net_device *dev;
	struct hlist_node index_hlist;
	struct bpf_dtab *dtab;
	struct bpf_prog *xdp_prog;
	struct callback_head rcu;
	unsigned int idx;
	struct bpf_devmap_val val;
};

struct bpf_dtab {
	struct bpf_map map;
	struct bpf_dtab_netdev **netdev_map;
	struct list_head list;
	struct hlist_head *dev_index_head;
	spinlock_t index_lock;
	unsigned int items;
	u32 n_buckets;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_cpumap_val {
	__u32 qsize;
	union {
		int fd;
		__u32 id;
	} bpf_prog;
};

struct bpf_cpu_map_entry;

struct xdp_bulk_queue {
	void *q[8];
	struct list_head flush_node;
	struct bpf_cpu_map_entry *obj;
	unsigned int count;
};

struct bpf_cpu_map;

struct bpf_cpu_map_entry {
	u32 cpu;
	int map_id;
	struct xdp_bulk_queue *bulkq;
	struct bpf_cpu_map *cmap;
	struct ptr_ring *queue;
	struct task_struct *kthread;
	struct bpf_cpumap_val value;
	struct bpf_prog *prog;
	atomic_t refcnt;
	struct callback_head rcu;
	struct work_struct kthread_stop_wq;
};

struct bpf_cpu_map {
	struct bpf_map map;
	struct bpf_cpu_map_entry **cpu_map;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_prog_offload_ops {
	int (*insn_hook)(struct bpf_verifier_env *, int, int);
	int (*finalize)(struct bpf_verifier_env *);
	int (*replace_insn)(struct bpf_verifier_env *, u32, struct bpf_insn *);
	int (*remove_insns)(struct bpf_verifier_env *, u32, u32);
	int (*prepare)(struct bpf_prog *);
	int (*translate)(struct bpf_prog *);
	void (*destroy)(struct bpf_prog *);
};

struct bpf_offload_dev {
	const struct bpf_prog_offload_ops *ops;
	struct list_head netdevs;
	void *priv;
};

struct bpf_offload_netdev {
	struct rhash_head l;
	struct net_device *netdev;
	struct bpf_offload_dev *offdev;
	struct list_head progs;
	struct list_head maps;
	struct list_head offdev_netdevs;
};

struct ns_get_path_bpf_prog_args {
	struct bpf_prog *prog;
	struct bpf_prog_info *info;
};

struct ns_get_path_bpf_map_args {
	struct bpf_offloaded_map *offmap;
	struct bpf_map_info *info;
};

struct pernet_operations {
	struct list_head list;
	int (*init)(struct net *);
	void (*pre_exit)(struct net *);
	void (*exit)(struct net *);
	void (*exit_batch)(struct list_head *);
	unsigned int *id;
	size_t size;
};

struct bpf_netns_link {
	struct bpf_link link;
	enum bpf_attach_type type;
	enum netns_bpf_attach_type netns_type;
	struct net *net;
	struct list_head node;
	int: 32;
};

enum bpf_stack_build_id_status {
	BPF_STACK_BUILD_ID_EMPTY = 0,
	BPF_STACK_BUILD_ID_VALID = 1,
	BPF_STACK_BUILD_ID_IP = 2,
};

struct bpf_stack_build_id {
	__s32 status;
	unsigned char build_id[20];
	union {
		__u64 offset;
		__u64 ip;
	};
};

enum {
	BPF_F_SKIP_FIELD_MASK = 255,
	BPF_F_USER_STACK = 256,
	BPF_F_FAST_STACK_CMP = 512,
	BPF_F_REUSE_STACKID = 1024,
	BPF_F_USER_BUILD_ID = 2048,
};

enum perf_callchain_context {
	PERF_CONTEXT_HV = 4294967264,
	PERF_CONTEXT_KERNEL = 4294967168,
	PERF_CONTEXT_USER = 4294966784,
	PERF_CONTEXT_GUEST = 4294965248,
	PERF_CONTEXT_GUEST_KERNEL = 4294965120,
	PERF_CONTEXT_GUEST_USER = 4294964736,
	PERF_CONTEXT_MAX = 4294963201,
};

struct stack_map_bucket {
	struct pcpu_freelist_node fnode;
	u32 hash;
	u32 nr;
	int: 32;
	u64 data[0];
};

struct bpf_stack_map {
	struct bpf_map map;
	void *elems;
	struct pcpu_freelist freelist;
	u32 n_buckets;
	struct stack_map_bucket *buckets[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef u64 (*btf_bpf_get_stackid)(struct pt_regs *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stackid_pe)(struct bpf_perf_event_data_kern *, struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_stack)(struct pt_regs *, void *, u32, u64);

typedef u64 (*btf_bpf_get_task_stack)(struct task_struct *, void *, u32, u64);

typedef u64 (*btf_bpf_get_stack_pe)(struct bpf_perf_event_data_kern *, void *, u32, u64);

struct bpf_iter__cgroup {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct cgroup *cgroup;
	};
};

struct cgroup_iter_priv {
	struct cgroup_subsys_state *start_css;
	bool visited_all;
	bool terminate;
	int order;
};

enum {
	BPF_F_SYSCTL_BASE_NAME = 1,
};

struct bpf_cg_run_ctx {
	struct bpf_run_ctx run_ctx;
	const struct bpf_prog_array_item *prog_item;
	int retval;
};

struct __kernel_sockaddr_storage {
	union {
		struct {
			__kernel_sa_family_t ss_family;
			char __data[126];
		};
		void *__align;
	};
};

struct qdisc_skb_cb {
	struct {
		unsigned int pkt_len;
		u16 slave_dev_queue_mapping;
		u16 tc_classid;
	};
	unsigned char data[20];
};

struct bpf_skb_data_end {
	struct qdisc_skb_cb qdisc_cb;
	void *data_meta;
	void *data_end;
};

struct bpf_sockopt_buf {
	u8 data[32];
};

enum {
	TCPF_ESTABLISHED = 2,
	TCPF_SYN_SENT = 4,
	TCPF_SYN_RECV = 8,
	TCPF_FIN_WAIT1 = 16,
	TCPF_FIN_WAIT2 = 32,
	TCPF_TIME_WAIT = 64,
	TCPF_CLOSE = 128,
	TCPF_CLOSE_WAIT = 256,
	TCPF_LAST_ACK = 512,
	TCPF_LISTEN = 1024,
	TCPF_CLOSING = 2048,
	TCPF_NEW_SYN_RECV = 4096,
};

struct bpf_cgroup_link {
	struct bpf_link link;
	struct cgroup *cgroup;
	enum bpf_attach_type type;
};

struct bpf_prog_list {
	struct hlist_node node;
	struct bpf_prog *prog;
	struct bpf_cgroup_link *link;
	struct bpf_cgroup_storage *storage[2];
};

typedef u64 (*btf_bpf_get_local_storage)(struct bpf_map *, u64);

typedef u64 (*btf_bpf_get_retval)();

typedef u64 (*btf_bpf_set_retval)(int);

typedef u64 (*btf_bpf_sysctl_get_name)(struct bpf_sysctl_kern *, char *, size_t, u64);

typedef u64 (*btf_bpf_sysctl_get_current_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_get_new_value)(struct bpf_sysctl_kern *, char *, size_t);

typedef u64 (*btf_bpf_sysctl_set_new_value)(struct bpf_sysctl_kern *, const char *, size_t);

typedef u64 (*btf_bpf_get_netns_cookie_sockopt)(struct bpf_sockopt_kern *);

enum sock_type {
	SOCK_STREAM = 1,
	SOCK_DGRAM = 2,
	SOCK_RAW = 3,
	SOCK_RDM = 4,
	SOCK_SEQPACKET = 5,
	SOCK_DCCP = 6,
	SOCK_PACKET = 10,
};

enum sock_flags {
	SOCK_DEAD = 0,
	SOCK_DONE = 1,
	SOCK_URGINLINE = 2,
	SOCK_KEEPOPEN = 3,
	SOCK_LINGER = 4,
	SOCK_DESTROY = 5,
	SOCK_BROADCAST = 6,
	SOCK_TIMESTAMP = 7,
	SOCK_ZAPPED = 8,
	SOCK_USE_WRITE_QUEUE = 9,
	SOCK_DBG = 10,
	SOCK_RCVTSTAMP = 11,
	SOCK_RCVTSTAMPNS = 12,
	SOCK_LOCALROUTE = 13,
	SOCK_MEMALLOC = 14,
	SOCK_TIMESTAMPING_RX_SOFTWARE = 15,
	SOCK_FASYNC = 16,
	SOCK_RXQ_OVFL = 17,
	SOCK_ZEROCOPY = 18,
	SOCK_WIFI_STATUS = 19,
	SOCK_NOFCS = 20,
	SOCK_FILTER_LOCKED = 21,
	SOCK_SELECT_ERR_QUEUE = 22,
	SOCK_RCU_FREE = 23,
	SOCK_TXTIME = 24,
	SOCK_XDP = 25,
	SOCK_TSTAMP_NEW = 26,
	SOCK_RCVMARK = 27,
};

struct reuseport_array {
	struct bpf_map map;
	struct sock *ptrs[0];
};

struct bpf_dummy_ops_state {
	int val;
};

struct bpf_dummy_ops {
	int (*test_1)(struct bpf_dummy_ops_state *);
	int (*test_2)(struct bpf_dummy_ops_state *, int, short unsigned int, char, long unsigned int);
};

enum bpf_struct_ops_state {
	BPF_STRUCT_OPS_STATE_INIT = 0,
	BPF_STRUCT_OPS_STATE_INUSE = 1,
	BPF_STRUCT_OPS_STATE_TOBEFREE = 2,
};

struct bpf_struct_ops_value {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	char data[0];
};

struct bpf_struct_ops_map {
	struct bpf_map map;
	struct callback_head rcu;
	const struct bpf_struct_ops *st_ops;
	struct mutex lock;
	struct bpf_link **links;
	void *image;
	struct bpf_struct_ops_value *uvalue;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct bpf_struct_ops_value kvalue;
};

struct bpf_struct_ops_bpf_dummy_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct bpf_dummy_ops data;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_struct_ops_tcp_congestion_ops {
	refcount_t refcnt;
	enum bpf_struct_ops_state state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct tcp_congestion_ops data;
};

enum {
	BPF_STRUCT_OPS_TYPE_bpf_dummy_ops = 0,
	BPF_STRUCT_OPS_TYPE_tcp_congestion_ops = 1,
	__NR_BPF_STRUCT_OPS_TYPE = 2,
};

struct bpf_map_desc {
	int map_fd;
	__u32 max_entries;
	__u64 initial_value;
};

struct bpf_prog_desc {
	int prog_fd;
};

enum {
	BPF_SKEL_KERNEL = 1,
};

struct bpf_loader_ctx {
	__u32 sz;
	__u32 flags;
	__u32 log_level;
	__u32 log_size;
	__u64 log_buf;
};

struct bpf_load_and_run_opts {
	struct bpf_loader_ctx *ctx;
	const void *data;
	const void *insns;
	__u32 data_sz;
	__u32 insns_sz;
	const char *errstr;
};

struct iterators_bpf__rodata {};

struct iterators_bpf {
	struct bpf_loader_ctx ctx;
	struct {
		struct bpf_map_desc rodata;
	} maps;
	struct {
		struct bpf_prog_desc dump_bpf_map;
		struct bpf_prog_desc dump_bpf_prog;
	} progs;
	struct {
		int dump_bpf_map_fd;
		int dump_bpf_prog_fd;
	} links;
	struct iterators_bpf__rodata *rodata;
	int: 32;
};

enum perf_branch_sample_type {
	PERF_SAMPLE_BRANCH_USER = 1,
	PERF_SAMPLE_BRANCH_KERNEL = 2,
	PERF_SAMPLE_BRANCH_HV = 4,
	PERF_SAMPLE_BRANCH_ANY = 8,
	PERF_SAMPLE_BRANCH_ANY_CALL = 16,
	PERF_SAMPLE_BRANCH_ANY_RETURN = 32,
	PERF_SAMPLE_BRANCH_IND_CALL = 64,
	PERF_SAMPLE_BRANCH_ABORT_TX = 128,
	PERF_SAMPLE_BRANCH_IN_TX = 256,
	PERF_SAMPLE_BRANCH_NO_TX = 512,
	PERF_SAMPLE_BRANCH_COND = 1024,
	PERF_SAMPLE_BRANCH_CALL_STACK = 2048,
	PERF_SAMPLE_BRANCH_IND_JUMP = 4096,
	PERF_SAMPLE_BRANCH_CALL = 8192,
	PERF_SAMPLE_BRANCH_NO_FLAGS = 16384,
	PERF_SAMPLE_BRANCH_NO_CYCLES = 32768,
	PERF_SAMPLE_BRANCH_TYPE_SAVE = 65536,
	PERF_SAMPLE_BRANCH_HW_INDEX = 131072,
	PERF_SAMPLE_BRANCH_PRIV_SAVE = 262144,
	PERF_SAMPLE_BRANCH_MAX = 524288,
};

enum perf_event_read_format {
	PERF_FORMAT_TOTAL_TIME_ENABLED = 1,
	PERF_FORMAT_TOTAL_TIME_RUNNING = 2,
	PERF_FORMAT_ID = 4,
	PERF_FORMAT_GROUP = 8,
	PERF_FORMAT_LOST = 16,
	PERF_FORMAT_MAX = 32,
};

enum perf_event_ioc_flags {
	PERF_IOC_FLAG_GROUP = 1,
};

struct perf_event_mmap_page {
	__u32 version;
	__u32 compat_version;
	__u32 lock;
	__u32 index;
	__s64 offset;
	__u64 time_enabled;
	__u64 time_running;
	union {
		__u64 capabilities;
		struct {
			__u64 cap_bit0: 1;
			__u64 cap_bit0_is_deprecated: 1;
			__u64 cap_user_rdpmc: 1;
			__u64 cap_user_time: 1;
			__u64 cap_user_time_zero: 1;
			__u64 cap_user_time_short: 1;
			__u64 cap_____res: 58;
		};
	};
	__u16 pmc_width;
	__u16 time_shift;
	__u32 time_mult;
	__u64 time_offset;
	__u64 time_zero;
	__u32 size;
	__u32 __reserved_1;
	__u64 time_cycles;
	__u64 time_mask;
	__u8 __reserved[928];
	__u64 data_head;
	__u64 data_tail;
	__u64 data_offset;
	__u64 data_size;
	__u64 aux_head;
	__u64 aux_tail;
	__u64 aux_offset;
	__u64 aux_size;
};

struct perf_event_header {
	__u32 type;
	__u16 misc;
	__u16 size;
};

struct perf_ns_link_info {
	__u64 dev;
	__u64 ino;
};

enum {
	NET_NS_INDEX = 0,
	UTS_NS_INDEX = 1,
	IPC_NS_INDEX = 2,
	PID_NS_INDEX = 3,
	USER_NS_INDEX = 4,
	MNT_NS_INDEX = 5,
	CGROUP_NS_INDEX = 6,
	NR_NAMESPACES = 7,
};

enum perf_event_type {
	PERF_RECORD_MMAP = 1,
	PERF_RECORD_LOST = 2,
	PERF_RECORD_COMM = 3,
	PERF_RECORD_EXIT = 4,
	PERF_RECORD_THROTTLE = 5,
	PERF_RECORD_UNTHROTTLE = 6,
	PERF_RECORD_FORK = 7,
	PERF_RECORD_READ = 8,
	PERF_RECORD_SAMPLE = 9,
	PERF_RECORD_MMAP2 = 10,
	PERF_RECORD_AUX = 11,
	PERF_RECORD_ITRACE_START = 12,
	PERF_RECORD_LOST_SAMPLES = 13,
	PERF_RECORD_SWITCH = 14,
	PERF_RECORD_SWITCH_CPU_WIDE = 15,
	PERF_RECORD_NAMESPACES = 16,
	PERF_RECORD_KSYMBOL = 17,
	PERF_RECORD_BPF_EVENT = 18,
	PERF_RECORD_CGROUP = 19,
	PERF_RECORD_TEXT_POKE = 20,
	PERF_RECORD_AUX_OUTPUT_HW_ID = 21,
	PERF_RECORD_MAX = 22,
};

enum perf_addr_filter_action_t {
	PERF_ADDR_FILTER_ACTION_STOP = 0,
	PERF_ADDR_FILTER_ACTION_START = 1,
	PERF_ADDR_FILTER_ACTION_FILTER = 2,
};

struct perf_addr_filter {
	struct list_head entry;
	struct path path;
	long unsigned int offset;
	long unsigned int size;
	enum perf_addr_filter_action_t action;
};

struct swevent_hlist {
	struct hlist_head heads[256];
	struct callback_head callback_head;
};

struct pmu_event_list {
	raw_spinlock_t lock;
	struct list_head list;
};

struct perf_buffer {
	refcount_t refcount;
	struct callback_head callback_head;
	struct work_struct work;
	int page_order;
	int nr_pages;
	int overwrite;
	int paused;
	atomic_t poll;
	local_t head;
	unsigned int nest;
	local_t events;
	local_t wakeup;
	local_t lost;
	long int watermark;
	long int aux_watermark;
	spinlock_t event_lock;
	struct list_head event_list;
	atomic_t mmap_count;
	long unsigned int mmap_locked;
	struct user_struct *mmap_user;
	long int aux_head;
	unsigned int aux_nest;
	long int aux_wakeup;
	long unsigned int aux_pgoff;
	int aux_nr_pages;
	int aux_overwrite;
	atomic_t aux_mmap_count;
	long unsigned int aux_mmap_locked;
	void (*free_aux)(void *);
	refcount_t aux_refcount;
	int aux_in_sampling;
	void **aux_pages;
	void *aux_priv;
	struct perf_event_mmap_page *user_page;
	void *data_pages[0];
};

struct match_token {
	int token;
	const char *pattern;
};

enum {
	MAX_OPT_ARGS = 3,
};

typedef struct {
	char *from;
	char *to;
} substring_t;

struct min_heap {
	void *data;
	int nr;
	int size;
};

struct min_heap_callbacks {
	int elem_size;
	bool (*less)(const void *, const void *);
	void (*swp)(void *, void *);
};

typedef int (*remote_function_f)(void *);

struct remote_function_call {
	struct task_struct *p;
	remote_function_f func;
	void *info;
	int ret;
};

typedef void (*event_f)(struct perf_event *, struct perf_cpu_context *, struct perf_event_context *, void *);

struct event_function_struct {
	struct perf_event *event;
	event_f func;
	void *data;
};

enum event_type_t {
	EVENT_FLEXIBLE = 1,
	EVENT_PINNED = 2,
	EVENT_TIME = 4,
	EVENT_CPU = 8,
	EVENT_ALL = 3,
};

struct __group_key {
	int cpu;
	struct cgroup *cgroup;
};

struct stop_event_data {
	struct perf_event *event;
	unsigned int restart;
};

struct perf_read_data {
	struct perf_event *event;
	bool group;
	int ret;
};

struct perf_read_event {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

typedef void perf_iterate_f(struct perf_event *, void *);

struct remote_output {
	struct perf_buffer *rb;
	int err;
};

struct perf_task_event {
	struct task_struct *task;
	struct perf_event_context *task_ctx;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 ppid;
		u32 tid;
		u32 ptid;
		u64 time;
	} event_id;
};

struct perf_comm_event {
	struct task_struct *task;
	char *comm;
	int comm_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
	} event_id;
};

struct perf_namespaces_event {
	struct task_struct *task;
	int: 32;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 nr_namespaces;
		struct perf_ns_link_info link_info[7];
	} event_id;
};

struct perf_mmap_event {
	struct vm_area_struct *vma;
	const char *file_name;
	int file_size;
	int maj;
	int min;
	int: 32;
	u64 ino;
	u64 ino_generation;
	u32 prot;
	u32 flags;
	u8 build_id[20];
	u32 build_id_size;
	struct {
		struct perf_event_header header;
		u32 pid;
		u32 tid;
		u64 start;
		u64 len;
		u64 pgoff;
	} event_id;
};

struct perf_switch_event {
	struct task_struct *task;
	struct task_struct *next_prev;
	struct {
		struct perf_event_header header;
		u32 next_prev_pid;
		u32 next_prev_tid;
	} event_id;
};

struct perf_ksymbol_event {
	const char *name;
	int name_len;
	struct {
		struct perf_event_header header;
		u64 addr;
		u32 len;
		u16 ksym_type;
		u16 flags;
	} event_id;
};

struct perf_bpf_event {
	struct bpf_prog *prog;
	struct {
		struct perf_event_header header;
		u16 type;
		u16 flags;
		u32 id;
		u8 tag[8];
	} event_id;
};

struct perf_text_poke_event {
	const void *old_bytes;
	const void *new_bytes;
	size_t pad;
	u16 old_len;
	u16 new_len;
	struct {
		struct perf_event_header header;
		u64 addr;
	} event_id;
};

struct swevent_htable {
	struct swevent_hlist *swevent_hlist;
	struct mutex hlist_mutex;
	int hlist_refcount;
	int recursion[4];
};

enum perf_probe_config {
	PERF_PROBE_CONFIG_IS_RETPROBE = 1,
	PERF_UPROBE_REF_CTR_OFFSET_BITS = 32,
	PERF_UPROBE_REF_CTR_OFFSET_SHIFT = 32,
};

enum {
	IF_ACT_NONE = 4294967295,
	IF_ACT_FILTER = 0,
	IF_ACT_START = 1,
	IF_ACT_STOP = 2,
	IF_SRC_FILE = 3,
	IF_SRC_KERNEL = 4,
	IF_SRC_FILEADDR = 5,
	IF_SRC_KERNELADDR = 6,
};

enum {
	IF_STATE_ACTION = 0,
	IF_STATE_SOURCE = 1,
	IF_STATE_END = 2,
};

struct perf_aux_event {
	struct perf_event_header header;
	u64 hw_id;
};

struct perf_aux_event___2 {
	struct perf_event_header header;
	u32 pid;
	u32 tid;
};

struct perf_aux_event___3 {
	struct perf_event_header header;
	u64 offset;
	u64 size;
	u64 flags;
};

struct callchain_cpus_entries {
	struct callback_head callback_head;
	struct perf_callchain_entry *cpu_entries[0];
};

struct rhltable {
	struct rhashtable ht;
};

struct bp_slots_histogram {
	atomic_t *count;
};

struct bp_cpuinfo {
	unsigned int cpu_pinned;
	struct bp_slots_histogram tsk_pinned;
};

struct uprobe {
	struct rb_node rb_node;
	refcount_t ref;
	struct rw_semaphore register_rwsem;
	struct rw_semaphore consumer_rwsem;
	struct list_head pending_list;
	struct uprobe_consumer *consumers;
	struct inode *inode;
	loff_t offset;
	loff_t ref_ctr_offset;
	long unsigned int flags;
	struct arch_uprobe arch;
	int: 32;
};

enum rp_check {
	RP_CHECK_CALL = 0,
	RP_CHECK_CHAIN_CALL = 1,
	RP_CHECK_RET = 2,
};

struct xol_area {
	wait_queue_head_t wq;
	atomic_t slot_count;
	long unsigned int *bitmap;
	struct vm_special_mapping xol_mapping;
	struct page *pages[2];
	long unsigned int vaddr;
};

typedef long unsigned int vm_flags_t;

struct compact_control;

struct capture_control {
	struct compact_control *cc;
	struct page *page;
};

struct page_vma_mapped_walk {
	long unsigned int pfn;
	long unsigned int nr_pages;
	long unsigned int pgoff;
	struct vm_area_struct *vma;
	long unsigned int address;
	pmd_t *pmd;
	pte_t *pte;
	spinlock_t *ptl;
	unsigned int flags;
};

struct mmu_notifier_range {
	long unsigned int start;
	long unsigned int end;
};

struct compact_control {
	struct list_head freepages;
	struct list_head migratepages;
	unsigned int nr_freepages;
	unsigned int nr_migratepages;
	long unsigned int free_pfn;
	long unsigned int migrate_pfn;
	long unsigned int fast_start_pfn;
	struct zone *zone;
	long unsigned int total_migrate_scanned;
	long unsigned int total_free_scanned;
	short unsigned int fast_search_fail;
	short int search_order;
	const gfp_t gfp_mask;
	int order;
	int migratetype;
	const unsigned int alloc_flags;
	const int highest_zoneidx;
	enum migrate_mode mode;
	bool ignore_skip_hint;
	bool no_set_skip_hint;
	bool ignore_block_suitable;
	bool direct_compaction;
	bool proactive_compaction;
	bool whole_zone;
	bool contended;
	bool rescan;
	bool alloc_contig;
};

struct delayed_uprobe {
	struct list_head list;
	struct uprobe *uprobe;
	struct mm_struct *mm;
};

struct __uprobe_key {
	struct inode *inode;
	int: 32;
	loff_t offset;
};

struct map_info {
	struct map_info *next;
	struct mm_struct *mm;
	long unsigned int vaddr;
};

enum rseq_cpu_id_state {
	RSEQ_CPU_ID_UNINITIALIZED = 4294967295,
	RSEQ_CPU_ID_REGISTRATION_FAILED = 4294967294,
};

enum rseq_flags {
	RSEQ_FLAG_UNREGISTER = 1,
};

enum rseq_cs_flags {
	RSEQ_CS_FLAG_NO_RESTART_ON_PREEMPT = 1,
	RSEQ_CS_FLAG_NO_RESTART_ON_SIGNAL = 2,
	RSEQ_CS_FLAG_NO_RESTART_ON_MIGRATE = 4,
};

struct rseq_cs {
	__u32 version;
	__u32 flags;
	__u64 start_ip;
	__u64 post_commit_offset;
	__u64 abort_ip;
};

struct trace_event_raw_rseq_update {
	struct trace_entry ent;
	s32 cpu_id;
	char __data[0];
};

struct trace_event_raw_rseq_ip_fixup {
	struct trace_entry ent;
	long unsigned int regs_ip;
	long unsigned int start_ip;
	long unsigned int post_commit_offset;
	long unsigned int abort_ip;
	char __data[0];
};

struct trace_event_data_offsets_rseq_update {};

struct trace_event_data_offsets_rseq_ip_fixup {};

typedef void (*btf_trace_rseq_update)(void *, struct task_struct *);

typedef void (*btf_trace_rseq_ip_fixup)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef struct {
	long unsigned int val;
} swp_entry_t;

typedef struct pglist_data pg_data_t;

typedef void (*xa_update_node_t)(struct xa_node *);

struct xa_state {
	struct xarray *xa;
	long unsigned int xa_index;
	unsigned char xa_shift;
	unsigned char xa_sibs;
	unsigned char xa_offset;
	unsigned char xa_pad;
	struct xa_node *xa_node;
	struct xa_node *xa_alloc;
	xa_update_node_t xa_update;
	struct list_lru *xa_lru;
};

enum migrate_reason {
	MR_COMPACTION = 0,
	MR_MEMORY_FAILURE = 1,
	MR_MEMORY_HOTPLUG = 2,
	MR_SYSCALL = 3,
	MR_MEMPOLICY_MBIND = 4,
	MR_NUMA_MISPLACED = 5,
	MR_CONTIG_RANGE = 6,
	MR_LONGTERM_PIN = 7,
	MR_DEMOTION = 8,
	MR_TYPES = 9,
};

enum positive_aop_returns {
	AOP_WRITEPAGE_ACTIVATE = 524288,
	AOP_TRUNCATED_PAGE = 524289,
};

struct vm_event_state {
	long unsigned int event[68];
};

enum mapping_flags {
	AS_EIO = 0,
	AS_ENOSPC = 1,
	AS_MM_ALL_LOCKS = 2,
	AS_UNEVICTABLE = 3,
	AS_EXITING = 4,
	AS_NO_WRITEBACK_TAGS = 5,
	AS_LARGE_FOLIO_SUPPORT = 6,
};

typedef int filler_t(struct file *, struct folio *);

struct wait_page_key {
	struct folio *folio;
	int bit_nr;
	int page_match;
};

enum iter_type {
	ITER_IOVEC = 0,
	ITER_KVEC = 1,
	ITER_BVEC = 2,
	ITER_PIPE = 3,
	ITER_XARRAY = 4,
	ITER_DISCARD = 5,
	ITER_UBUF = 6,
};

struct pagevec {
	unsigned char nr;
	bool percpu_pvec_drained;
	struct page *pages[15];
};

struct folio_batch {
	unsigned char nr;
	bool percpu_pvec_drained;
	struct folio *folios[15];
};

struct trace_event_raw_mm_filemap_op_page_cache {
	struct trace_entry ent;
	long unsigned int pfn;
	long unsigned int i_ino;
	long unsigned int index;
	dev_t s_dev;
	unsigned char order;
	char __data[0];
};

struct trace_event_raw_filemap_set_wb_err {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t errseq;
	char __data[0];
};

struct trace_event_raw_file_check_and_advance_wb_err {
	struct trace_entry ent;
	struct file *file;
	long unsigned int i_ino;
	dev_t s_dev;
	errseq_t old;
	errseq_t new;
	char __data[0];
};

struct trace_event_data_offsets_mm_filemap_op_page_cache {};

struct trace_event_data_offsets_filemap_set_wb_err {};

struct trace_event_data_offsets_file_check_and_advance_wb_err {};

typedef void (*btf_trace_mm_filemap_delete_from_page_cache)(void *, struct folio *);

typedef void (*btf_trace_mm_filemap_add_to_page_cache)(void *, struct folio *);

typedef void (*btf_trace_filemap_set_wb_err)(void *, struct address_space *, errseq_t);

typedef void (*btf_trace_file_check_and_advance_wb_err)(void *, struct file *, errseq_t);

enum behavior {
	EXCLUSIVE = 0,
	SHARED = 1,
	DROP = 2,
};

struct reciprocal_value {
	u32 m;
	u8 sh1;
	u8 sh2;
};

struct kmem_cache_order_objects {
	unsigned int x;
};

struct kmem_cache_cpu;

struct kmem_cache_node;

struct kmem_cache {
	struct kmem_cache_cpu *cpu_slab;
	slab_flags_t flags;
	long unsigned int min_partial;
	unsigned int size;
	unsigned int object_size;
	struct reciprocal_value reciprocal_size;
	unsigned int offset;
	unsigned int cpu_partial;
	unsigned int cpu_partial_slabs;
	struct kmem_cache_order_objects oo;
	struct kmem_cache_order_objects min;
	gfp_t allocflags;
	int refcount;
	void (*ctor)(void *);
	unsigned int inuse;
	unsigned int align;
	unsigned int red_left_pad;
	const char *name;
	struct list_head list;
	struct kobject kobj;
	unsigned int useroffset;
	unsigned int usersize;
	struct kmem_cache_node *node[1];
};

struct slab {
	long unsigned int __page_flags;
	union {
		struct list_head slab_list;
		struct callback_head callback_head;
		struct {
			struct slab *next;
			int slabs;
		};
	};
	struct kmem_cache *slab_cache;
	void *freelist;
	union {
		long unsigned int counters;
		struct {
			unsigned int inuse: 16;
			unsigned int objects: 15;
			unsigned int frozen: 1;
		};
	};
	unsigned int __unused;
	atomic_t __page_refcount;
	long unsigned int memcg_data;
};

struct kmem_cache_cpu {
	void **freelist;
	long unsigned int tid;
	struct slab *slab;
	struct slab *partial;
	local_lock_t lock;
};

struct kmem_cache_node {
	spinlock_t list_lock;
	long unsigned int nr_partial;
	struct list_head partial;
};

enum oom_constraint {
	CONSTRAINT_NONE = 0,
	CONSTRAINT_CPUSET = 1,
	CONSTRAINT_MEMORY_POLICY = 2,
	CONSTRAINT_MEMCG = 3,
};

struct oom_control {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct mem_cgroup *memcg;
	const gfp_t gfp_mask;
	const int order;
	long unsigned int totalpages;
	struct task_struct *chosen;
	long int chosen_points;
	enum oom_constraint constraint;
};

struct mmu_gather_batch {
	struct mmu_gather_batch *next;
	unsigned int nr;
	unsigned int max;
	struct page *pages[0];
};

struct mmu_gather {
	struct mm_struct *mm;
	long unsigned int start;
	long unsigned int end;
	unsigned int fullmm: 1;
	unsigned int need_flush_all: 1;
	unsigned int freed_tables: 1;
	unsigned int cleared_ptes: 1;
	unsigned int cleared_pmds: 1;
	unsigned int cleared_puds: 1;
	unsigned int cleared_p4ds: 1;
	unsigned int vma_exec: 1;
	unsigned int vma_huge: 1;
	unsigned int vma_pfn: 1;
	unsigned int batch_count;
	struct mmu_gather_batch *active;
	struct mmu_gather_batch local;
	struct page *__pages[8];
};

enum compact_priority {
	COMPACT_PRIO_SYNC_FULL = 0,
	MIN_COMPACT_PRIORITY = 0,
	COMPACT_PRIO_SYNC_LIGHT = 1,
	MIN_COMPACT_COSTLY_PRIORITY = 1,
	DEF_COMPACT_PRIORITY = 1,
	COMPACT_PRIO_ASYNC = 2,
	INIT_COMPACT_PRIORITY = 2,
};

enum compact_result {
	COMPACT_NOT_SUITABLE_ZONE = 0,
	COMPACT_SKIPPED = 1,
	COMPACT_DEFERRED = 2,
	COMPACT_NO_SUITABLE_PAGE = 3,
	COMPACT_CONTINUE = 4,
	COMPACT_COMPLETE = 5,
	COMPACT_PARTIAL_SKIPPED = 6,
	COMPACT_CONTENDED = 7,
	COMPACT_SUCCESS = 8,
};

struct trace_event_raw_oom_score_adj_update {
	struct trace_entry ent;
	pid_t pid;
	char comm[16];
	short int oom_score_adj;
	char __data[0];
};

struct trace_event_raw_reclaim_retry_zone {
	struct trace_entry ent;
	int node;
	int zone_idx;
	int order;
	long unsigned int reclaimable;
	long unsigned int available;
	long unsigned int min_wmark;
	int no_progress_loops;
	bool wmark_check;
	char __data[0];
};

struct trace_event_raw_mark_victim {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_wake_reaper {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_start_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_finish_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_skip_task_reaping {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_compact_retry {
	struct trace_entry ent;
	int order;
	int priority;
	int result;
	int retries;
	int max_retries;
	bool ret;
	char __data[0];
};

struct trace_event_data_offsets_oom_score_adj_update {};

struct trace_event_data_offsets_reclaim_retry_zone {};

struct trace_event_data_offsets_mark_victim {};

struct trace_event_data_offsets_wake_reaper {};

struct trace_event_data_offsets_start_task_reaping {};

struct trace_event_data_offsets_finish_task_reaping {};

struct trace_event_data_offsets_skip_task_reaping {};

struct trace_event_data_offsets_compact_retry {};

typedef void (*btf_trace_oom_score_adj_update)(void *, struct task_struct *);

typedef void (*btf_trace_reclaim_retry_zone)(void *, struct zoneref *, int, long unsigned int, long unsigned int, long unsigned int, int, bool);

typedef void (*btf_trace_mark_victim)(void *, int);

typedef void (*btf_trace_wake_reaper)(void *, int);

typedef void (*btf_trace_start_task_reaping)(void *, int);

typedef void (*btf_trace_finish_task_reaping)(void *, int);

typedef void (*btf_trace_skip_task_reaping)(void *, int);

typedef void (*btf_trace_compact_retry)(void *, int, enum compact_priority, enum compact_result, int, int, bool);

enum {
	XA_CHECK_SCHED = 4096,
};

struct fprop_global {
	struct percpu_counter events;
	unsigned int period;
	seqcount_t sequence;
};

enum wb_state {
	WB_registered = 0,
	WB_writeback_running = 1,
	WB_has_dirty_io = 2,
	WB_start_all = 3,
};

struct wb_lock_cookie {
	bool locked;
	long unsigned int flags;
};

struct wb_domain {
	spinlock_t lock;
	int: 32;
	struct fprop_global completions;
	struct timer_list period_timer;
	long unsigned int period_time;
	long unsigned int dirty_limit_tstamp;
	long unsigned int dirty_limit;
};

typedef int (*writepage_t)(struct page *, struct writeback_control *, void *);

struct dirty_throttle_control {
	struct bdi_writeback *wb;
	struct fprop_local_percpu *wb_completions;
	long unsigned int avail;
	long unsigned int dirty;
	long unsigned int thresh;
	long unsigned int bg_thresh;
	long unsigned int wb_dirty;
	long unsigned int wb_thresh;
	long unsigned int wb_bg_thresh;
	long unsigned int pos_ratio;
};

enum page_memcg_data_flags {
	MEMCG_DATA_OBJCGS = 1,
	MEMCG_DATA_KMEM = 2,
	__NR_MEMCG_DATA_FLAGS = 4,
};

struct trace_event_raw_mm_lru_insertion {
	struct trace_entry ent;
	struct folio *folio;
	long unsigned int pfn;
	enum lru_list lru;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_mm_lru_activate {
	struct trace_entry ent;
	struct folio *folio;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_data_offsets_mm_lru_insertion {};

struct trace_event_data_offsets_mm_lru_activate {};

typedef void (*btf_trace_mm_lru_insertion)(void *, struct folio *);

typedef void (*btf_trace_mm_lru_activate)(void *, struct folio *);

struct lru_rotate {
	local_lock_t lock;
	struct folio_batch fbatch;
};

struct cpu_fbatches {
	local_lock_t lock;
	struct folio_batch lru_add;
	struct folio_batch lru_deactivate_file;
	struct folio_batch lru_deactivate;
	struct folio_batch lru_lazyfree;
	struct folio_batch activate;
};

typedef void (*move_fn_t)(struct lruvec *, struct folio *);

enum lruvec_flags {
	LRUVEC_CONGESTED = 0,
};

typedef unsigned int isolate_mode_t;

enum pgdat_flags {
	PGDAT_DIRTY = 0,
	PGDAT_WRITEBACK = 1,
	PGDAT_RECLAIM_LOCKED = 2,
};

enum zone_flags {
	ZONE_BOOSTED_WATERMARK = 0,
	ZONE_RECLAIM_ACTIVE = 1,
};

struct reclaim_stat {
	unsigned int nr_dirty;
	unsigned int nr_unqueued_dirty;
	unsigned int nr_congested;
	unsigned int nr_writeback;
	unsigned int nr_immediate;
	unsigned int nr_pageout;
	unsigned int nr_activate[2];
	unsigned int nr_ref_keep;
	unsigned int nr_unmap_fail;
	unsigned int nr_lazyfree_fail;
};

enum {
	SWP_USED = 1,
	SWP_WRITEOK = 2,
	SWP_DISCARDABLE = 4,
	SWP_DISCARDING = 8,
	SWP_SOLIDSTATE = 16,
	SWP_CONTINUED = 32,
	SWP_BLKDEV = 64,
	SWP_ACTIVATED = 128,
	SWP_FS_OPS = 256,
	SWP_AREA_DISCARD = 512,
	SWP_PAGE_DISCARD = 1024,
	SWP_STABLE_WRITES = 2048,
	SWP_SYNCHRONOUS_IO = 4096,
	SWP_SCANNING = 16384,
};

enum ttu_flags {
	TTU_SPLIT_HUGE_PMD = 4,
	TTU_IGNORE_MLOCK = 8,
	TTU_SYNC = 16,
	TTU_IGNORE_HWPOISON = 32,
	TTU_BATCH_FLUSH = 64,
	TTU_RMAP_LOCKED = 128,
};

struct migration_target_control {
	int nid;
	nodemask_t *nmask;
	gfp_t gfp_mask;
};

struct trace_event_raw_mm_vmscan_kswapd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_kswapd_wake {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_wakeup_kswapd {
	struct trace_entry ent;
	int nid;
	int zid;
	int order;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_begin_template {
	struct trace_entry ent;
	int order;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_direct_reclaim_end_template {
	struct trace_entry ent;
	long unsigned int nr_reclaimed;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_start {
	struct trace_entry ent;
	struct shrinker *shr;
	void *shrink;
	int nid;
	long int nr_objects_to_shrink;
	long unsigned int gfp_flags;
	long unsigned int cache_items;
	long long unsigned int delta;
	long unsigned int total_scan;
	int priority;
	char __data[0];
};

struct trace_event_raw_mm_shrink_slab_end {
	struct trace_entry ent;
	struct shrinker *shr;
	int nid;
	void *shrink;
	long int unused_scan;
	long int new_scan;
	int retval;
	long int total_scan;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_isolate {
	struct trace_entry ent;
	int highest_zoneidx;
	int order;
	long unsigned int nr_requested;
	long unsigned int nr_scanned;
	long unsigned int nr_skipped;
	long unsigned int nr_taken;
	unsigned int isolate_mode;
	int lru;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_write_folio {
	struct trace_entry ent;
	long unsigned int pfn;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_inactive {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int nr_congested;
	long unsigned int nr_immediate;
	unsigned int nr_activate0;
	unsigned int nr_activate1;
	long unsigned int nr_ref_keep;
	long unsigned int nr_unmap_fail;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_lru_shrink_active {
	struct trace_entry ent;
	int nid;
	long unsigned int nr_taken;
	long unsigned int nr_active;
	long unsigned int nr_deactivated;
	long unsigned int nr_referenced;
	int priority;
	int reclaim_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_node_reclaim_begin {
	struct trace_entry ent;
	int nid;
	int order;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_mm_vmscan_throttled {
	struct trace_entry ent;
	int nid;
	int usec_timeout;
	int usec_delayed;
	int reason;
	char __data[0];
};

struct trace_event_data_offsets_mm_vmscan_kswapd_sleep {};

struct trace_event_data_offsets_mm_vmscan_kswapd_wake {};

struct trace_event_data_offsets_mm_vmscan_wakeup_kswapd {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_begin_template {};

struct trace_event_data_offsets_mm_vmscan_direct_reclaim_end_template {};

struct trace_event_data_offsets_mm_shrink_slab_start {};

struct trace_event_data_offsets_mm_shrink_slab_end {};

struct trace_event_data_offsets_mm_vmscan_lru_isolate {};

struct trace_event_data_offsets_mm_vmscan_write_folio {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_inactive {};

struct trace_event_data_offsets_mm_vmscan_lru_shrink_active {};

struct trace_event_data_offsets_mm_vmscan_node_reclaim_begin {};

struct trace_event_data_offsets_mm_vmscan_throttled {};

typedef void (*btf_trace_mm_vmscan_kswapd_sleep)(void *, int);

typedef void (*btf_trace_mm_vmscan_kswapd_wake)(void *, int, int, int);

typedef void (*btf_trace_mm_vmscan_wakeup_kswapd)(void *, int, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_begin)(void *, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_direct_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_memcg_softlimit_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_shrink_slab_start)(void *, struct shrinker *, struct shrink_control *, long int, long unsigned int, long long unsigned int, long unsigned int, int);

typedef void (*btf_trace_mm_shrink_slab_end)(void *, struct shrinker *, int, int, long int, long int, long int);

typedef void (*btf_trace_mm_vmscan_lru_isolate)(void *, int, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, isolate_mode_t, int);

typedef void (*btf_trace_mm_vmscan_write_folio)(void *, struct folio *);

typedef void (*btf_trace_mm_vmscan_lru_shrink_inactive)(void *, int, long unsigned int, long unsigned int, struct reclaim_stat *, int, int);

typedef void (*btf_trace_mm_vmscan_lru_shrink_active)(void *, int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, int, int);

typedef void (*btf_trace_mm_vmscan_node_reclaim_begin)(void *, int, int, gfp_t);

typedef void (*btf_trace_mm_vmscan_node_reclaim_end)(void *, long unsigned int);

typedef void (*btf_trace_mm_vmscan_throttled)(void *, int, int, int, int);

struct scan_control {
	long unsigned int nr_to_reclaim;
	nodemask_t *nodemask;
	struct mem_cgroup *target_mem_cgroup;
	long unsigned int anon_cost;
	long unsigned int file_cost;
	unsigned int may_deactivate: 2;
	unsigned int force_deactivate: 1;
	unsigned int skipped_deactivate: 1;
	unsigned int may_writepage: 1;
	unsigned int may_unmap: 1;
	unsigned int may_swap: 1;
	unsigned int proactive: 1;
	unsigned int memcg_low_reclaim: 1;
	unsigned int memcg_low_skipped: 1;
	unsigned int hibernation_mode: 1;
	unsigned int compaction_ready: 1;
	unsigned int cache_trim_mode: 1;
	unsigned int file_is_tiny: 1;
	unsigned int no_demotion: 1;
	s8 order;
	s8 priority;
	s8 reclaim_idx;
	gfp_t gfp_mask;
	long unsigned int nr_scanned;
	long unsigned int nr_reclaimed;
	struct {
		unsigned int dirty;
		unsigned int unqueued_dirty;
		unsigned int congested;
		unsigned int writeback;
		unsigned int immediate;
		unsigned int file_taken;
		unsigned int taken;
	} nr;
	struct reclaim_state reclaim_state;
};

typedef enum {
	PAGE_KEEP = 0,
	PAGE_ACTIVATE = 1,
	PAGE_SUCCESS = 2,
	PAGE_CLEAN = 3,
} pageout_t;

enum folio_references {
	FOLIOREF_RECLAIM = 0,
	FOLIOREF_RECLAIM_CLEAN = 1,
	FOLIOREF_KEEP = 2,
	FOLIOREF_ACTIVATE = 3,
};

enum scan_balance {
	SCAN_EQUAL = 0,
	SCAN_FRACT = 1,
	SCAN_ANON = 2,
	SCAN_FILE = 3,
};

struct fileattr {
	u32 flags;
	u32 fsx_xflags;
	u32 fsx_extsize;
	u32 fsx_nextents;
	u32 fsx_projid;
	u32 fsx_cowextsize;
	bool flags_valid: 1;
	bool fsx_valid: 1;
};

struct kstatfs {
	long int f_type;
	long int f_bsize;
	u64 f_blocks;
	u64 f_bfree;
	u64 f_bavail;
	u64 f_files;
	u64 f_ffree;
	__kernel_fsid_t f_fsid;
	long int f_namelen;
	long int f_frsize;
	long int f_flags;
	long int f_spare[4];
	int: 32;
};

struct xattr;

typedef int (*initxattrs)(struct inode *, const struct xattr *, void *);

struct xattr {
	const char *name;
	void *value;
	size_t value_len;
};

struct constant_table {
	const char *name;
	int value;
};

struct simple_xattrs {
	struct list_head head;
	spinlock_t lock;
};

struct simple_xattr {
	struct list_head list;
	char *name;
	size_t size;
	char value[0];
};

enum fid_type {
	FILEID_ROOT = 0,
	FILEID_INO32_GEN = 1,
	FILEID_INO32_GEN_PARENT = 2,
	FILEID_BTRFS_WITHOUT_PARENT = 77,
	FILEID_BTRFS_WITH_PARENT = 78,
	FILEID_BTRFS_WITH_PARENT_ROOT = 79,
	FILEID_UDF_WITHOUT_PARENT = 81,
	FILEID_UDF_WITH_PARENT = 82,
	FILEID_NILFS_WITHOUT_PARENT = 97,
	FILEID_NILFS_WITH_PARENT = 98,
	FILEID_FAT_WITHOUT_PARENT = 113,
	FILEID_FAT_WITH_PARENT = 114,
	FILEID_LUSTRE = 151,
	FILEID_KERNFS = 254,
	FILEID_INVALID = 255,
};

struct fid {
	union {
		struct {
			u32 ino;
			u32 gen;
			u32 parent_ino;
			u32 parent_gen;
		} i32;
		struct {
			u32 block;
			u16 partref;
			u16 parent_partref;
			u32 generation;
			u32 parent_block;
			u32 parent_generation;
		} udf;
		__u32 raw[0];
	};
};

struct shared_policy {};

struct shmem_inode_info {
	spinlock_t lock;
	unsigned int seals;
	long unsigned int flags;
	long unsigned int alloced;
	long unsigned int swapped;
	long unsigned int fallocend;
	struct list_head shrinklist;
	struct list_head swaplist;
	struct shared_policy policy;
	struct simple_xattrs xattrs;
	atomic_t stop_eviction;
	struct timespec64 i_crtime;
	unsigned int fsflags;
	int: 32;
	struct inode vfs_inode;
};

struct shmem_sb_info {
	long unsigned int max_blocks;
	int: 32;
	struct percpu_counter used_blocks;
	long unsigned int max_inodes;
	long unsigned int free_inodes;
	raw_spinlock_t stat_lock;
	umode_t mode;
	unsigned char huge;
	kuid_t uid;
	kgid_t gid;
	bool full_inums;
	ino_t next_ino;
	ino_t *ino_batch;
	struct mempolicy *mpol;
	spinlock_t shrinklist_lock;
	struct list_head shrinklist;
	long unsigned int shrinklist_len;
};

enum sgp_type {
	SGP_READ = 0,
	SGP_NOALLOC = 1,
	SGP_CACHE = 2,
	SGP_WRITE = 3,
	SGP_FALLOC = 4,
};

struct shmem_falloc {
	wait_queue_head_t *waitq;
	long unsigned int start;
	long unsigned int next;
	long unsigned int nr_falloced;
	long unsigned int nr_unswapped;
};

struct shmem_options {
	long long unsigned int blocks;
	long long unsigned int inodes;
	struct mempolicy *mpol;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	bool full_inums;
	int huge;
	int seen;
};

enum shmem_param {
	Opt_gid = 0,
	Opt_huge = 1,
	Opt_mode = 2,
	Opt_mpol = 3,
	Opt_nr_blocks = 4,
	Opt_nr_inodes = 5,
	Opt_size = 6,
	Opt_uid = 7,
	Opt_inode32 = 8,
	Opt_inode64 = 9,
};

enum writeback_stat_item {
	NR_DIRTY_THRESHOLD = 0,
	NR_DIRTY_BG_THRESHOLD = 1,
	NR_VM_WRITEBACK_STAT_ITEMS = 2,
};

struct contig_page_info {
	long unsigned int free_pages;
	long unsigned int free_blocks_total;
	long unsigned int free_blocks_suitable;
};

struct pcpu_group_info {
	int nr_units;
	long unsigned int base_offset;
	unsigned int *cpu_map;
};

struct pcpu_alloc_info {
	size_t static_size;
	size_t reserved_size;
	size_t dyn_size;
	size_t unit_size;
	size_t atom_size;
	size_t alloc_size;
	size_t __ai_size;
	int nr_groups;
	struct pcpu_group_info groups[0];
};

typedef int pcpu_fc_cpu_to_node_fn_t(int);

typedef int pcpu_fc_cpu_distance_fn_t(unsigned int, unsigned int);

enum memcg_stat_item {
	MEMCG_SWAP = 41,
	MEMCG_SOCK = 42,
	MEMCG_PERCPU_B = 43,
	MEMCG_VMALLOC = 44,
	MEMCG_KMEM = 45,
	MEMCG_ZSWAP_B = 46,
	MEMCG_ZSWAPPED = 47,
	MEMCG_NR_STAT = 48,
};

struct trace_event_raw_percpu_alloc_percpu {
	struct trace_entry ent;
	long unsigned int call_site;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	void *base_addr;
	int off;
	void *ptr;
	size_t bytes_alloc;
	long unsigned int gfp_flags;
	char __data[0];
};

struct trace_event_raw_percpu_free_percpu {
	struct trace_entry ent;
	void *base_addr;
	int off;
	void *ptr;
	char __data[0];
};

struct trace_event_raw_percpu_alloc_percpu_fail {
	struct trace_entry ent;
	bool reserved;
	bool is_atomic;
	size_t size;
	size_t align;
	char __data[0];
};

struct trace_event_raw_percpu_create_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_raw_percpu_destroy_chunk {
	struct trace_entry ent;
	void *base_addr;
	char __data[0];
};

struct trace_event_data_offsets_percpu_alloc_percpu {};

struct trace_event_data_offsets_percpu_free_percpu {};

struct trace_event_data_offsets_percpu_alloc_percpu_fail {};

struct trace_event_data_offsets_percpu_create_chunk {};

struct trace_event_data_offsets_percpu_destroy_chunk {};

typedef void (*btf_trace_percpu_alloc_percpu)(void *, long unsigned int, bool, bool, size_t, size_t, void *, int, void *, size_t, gfp_t);

typedef void (*btf_trace_percpu_free_percpu)(void *, void *, int, void *);

typedef void (*btf_trace_percpu_alloc_percpu_fail)(void *, bool, bool, size_t, size_t);

typedef void (*btf_trace_percpu_create_chunk)(void *, void *);

typedef void (*btf_trace_percpu_destroy_chunk)(void *, void *);

struct pcpu_block_md {
	int scan_hint;
	int scan_hint_start;
	int contig_hint;
	int contig_hint_start;
	int left_free;
	int right_free;
	int first_free;
	int nr_bits;
};

struct pcpu_chunk {
	struct list_head list;
	int free_bytes;
	struct pcpu_block_md chunk_md;
	void *base_addr;
	long unsigned int *alloc_map;
	long unsigned int *bound_map;
	struct pcpu_block_md *md_blocks;
	void *data;
	bool immutable;
	bool isolated;
	int start_offset;
	int end_offset;
	struct obj_cgroup **obj_cgroups;
	int nr_pages;
	int nr_populated;
	int nr_empty_pop_pages;
	long unsigned int populated[0];
};

enum slab_state {
	DOWN = 0,
	PARTIAL = 1,
	PARTIAL_NODE = 2,
	UP = 3,
	FULL = 4,
};

struct kmalloc_info_struct {
	const char *name[3];
	unsigned int size;
};

struct kmem_obj_info {
	void *kp_ptr;
	struct slab *kp_slab;
	void *kp_objp;
	long unsigned int kp_data_offset;
	struct kmem_cache *kp_slab_cache;
	void *kp_ret;
	void *kp_stack[16];
	void *kp_free_stack[16];
};

struct trace_event_raw_kmem_cache_alloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	long unsigned int gfp_flags;
	int node;
	bool accounted;
	char __data[0];
};

struct trace_event_raw_kmalloc {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	size_t bytes_req;
	size_t bytes_alloc;
	long unsigned int gfp_flags;
	int node;
	char __data[0];
};

struct trace_event_raw_kfree {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	char __data[0];
};

struct trace_event_raw_kmem_cache_free {
	struct trace_entry ent;
	long unsigned int call_site;
	const void *ptr;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mm_page_free {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	char __data[0];
};

struct trace_event_raw_mm_page_free_batched {
	struct trace_entry ent;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	long unsigned int gfp_flags;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	int percpu_refill;
	char __data[0];
};

struct trace_event_raw_mm_page_pcpu_drain {
	struct trace_entry ent;
	long unsigned int pfn;
	unsigned int order;
	int migratetype;
	char __data[0];
};

struct trace_event_raw_mm_page_alloc_extfrag {
	struct trace_entry ent;
	long unsigned int pfn;
	int alloc_order;
	int fallback_order;
	int alloc_migratetype;
	int fallback_migratetype;
	int change_ownership;
	char __data[0];
};

struct trace_event_raw_rss_stat {
	struct trace_entry ent;
	unsigned int mm_id;
	unsigned int curr;
	int member;
	long int size;
	char __data[0];
};

struct trace_event_data_offsets_kmem_cache_alloc {};

struct trace_event_data_offsets_kmalloc {};

struct trace_event_data_offsets_kfree {};

struct trace_event_data_offsets_kmem_cache_free {
	u32 name;
};

struct trace_event_data_offsets_mm_page_free {};

struct trace_event_data_offsets_mm_page_free_batched {};

struct trace_event_data_offsets_mm_page_alloc {};

struct trace_event_data_offsets_mm_page {};

struct trace_event_data_offsets_mm_page_pcpu_drain {};

struct trace_event_data_offsets_mm_page_alloc_extfrag {};

struct trace_event_data_offsets_rss_stat {};

typedef void (*btf_trace_kmem_cache_alloc)(void *, long unsigned int, const void *, struct kmem_cache *, gfp_t, int);

typedef void (*btf_trace_kmalloc)(void *, long unsigned int, const void *, size_t, size_t, gfp_t, int);

typedef void (*btf_trace_kfree)(void *, long unsigned int, const void *);

typedef void (*btf_trace_kmem_cache_free)(void *, long unsigned int, const void *, const struct kmem_cache *);

typedef void (*btf_trace_mm_page_free)(void *, struct page *, unsigned int);

typedef void (*btf_trace_mm_page_free_batched)(void *, struct page *);

typedef void (*btf_trace_mm_page_alloc)(void *, struct page *, unsigned int, gfp_t, int);

typedef void (*btf_trace_mm_page_alloc_zone_locked)(void *, struct page *, unsigned int, int, int);

typedef void (*btf_trace_mm_page_pcpu_drain)(void *, struct page *, unsigned int, int);

typedef void (*btf_trace_mm_page_alloc_extfrag)(void *, struct page *, int, int, int, int);

typedef void (*btf_trace_rss_stat)(void *, struct mm_struct *, int, long int);

enum pageblock_bits {
	PB_migrate = 0,
	PB_migrate_end = 2,
	PB_migrate_skip = 3,
	NR_PAGEBLOCK_BITS = 4,
};

struct movable_operations {
	bool (*isolate_page)(struct page *, isolate_mode_t);
	int (*migrate_page)(struct page *, struct page *, enum migrate_mode);
	void (*putback_page)(struct page *);
};

struct alloc_context {
	struct zonelist *zonelist;
	nodemask_t *nodemask;
	struct zoneref *preferred_zoneref;
	int migratetype;
	enum zone_type highest_zoneidx;
	bool spread_dirty_pages;
};

struct trace_event_raw_mm_compaction_isolate_template {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int nr_scanned;
	long unsigned int nr_taken;
	char __data[0];
};

struct trace_event_raw_mm_compaction_migratepages {
	struct trace_entry ent;
	long unsigned int nr_migrated;
	long unsigned int nr_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_begin {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	char __data[0];
};

struct trace_event_raw_mm_compaction_end {
	struct trace_entry ent;
	long unsigned int zone_start;
	long unsigned int migrate_pfn;
	long unsigned int free_pfn;
	long unsigned int zone_end;
	bool sync;
	int status;
	char __data[0];
};

struct trace_event_raw_mm_compaction_try_to_compact_pages {
	struct trace_entry ent;
	int order;
	long unsigned int gfp_mask;
	int prio;
	char __data[0];
};

struct trace_event_raw_mm_compaction_suitable_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	int ret;
	char __data[0];
};

struct trace_event_raw_mm_compaction_defer_template {
	struct trace_entry ent;
	int nid;
	enum zone_type idx;
	int order;
	unsigned int considered;
	unsigned int defer_shift;
	int order_failed;
	char __data[0];
};

struct trace_event_raw_mm_compaction_kcompactd_sleep {
	struct trace_entry ent;
	int nid;
	char __data[0];
};

struct trace_event_raw_kcompactd_wake_template {
	struct trace_entry ent;
	int nid;
	int order;
	enum zone_type highest_zoneidx;
	char __data[0];
};

struct trace_event_data_offsets_mm_compaction_isolate_template {};

struct trace_event_data_offsets_mm_compaction_migratepages {};

struct trace_event_data_offsets_mm_compaction_begin {};

struct trace_event_data_offsets_mm_compaction_end {};

struct trace_event_data_offsets_mm_compaction_try_to_compact_pages {};

struct trace_event_data_offsets_mm_compaction_suitable_template {};

struct trace_event_data_offsets_mm_compaction_defer_template {};

struct trace_event_data_offsets_mm_compaction_kcompactd_sleep {};

struct trace_event_data_offsets_kcompactd_wake_template {};

typedef void (*btf_trace_mm_compaction_isolate_migratepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_isolate_freepages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_mm_compaction_migratepages)(void *, struct compact_control *, unsigned int);

typedef void (*btf_trace_mm_compaction_begin)(void *, struct compact_control *, long unsigned int, long unsigned int, bool);

typedef void (*btf_trace_mm_compaction_end)(void *, struct compact_control *, long unsigned int, long unsigned int, bool, int);

typedef void (*btf_trace_mm_compaction_try_to_compact_pages)(void *, int, gfp_t, int);

typedef void (*btf_trace_mm_compaction_finished)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_suitable)(void *, struct zone *, int, int);

typedef void (*btf_trace_mm_compaction_deferred)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_compaction)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_defer_reset)(void *, struct zone *, int);

typedef void (*btf_trace_mm_compaction_kcompactd_sleep)(void *, int);

typedef void (*btf_trace_mm_compaction_wakeup_kcompactd)(void *, int, int, enum zone_type);

typedef void (*btf_trace_mm_compaction_kcompactd_wake)(void *, int, int, enum zone_type);

typedef enum {
	ISOLATE_ABORT = 0,
	ISOLATE_NONE = 1,
	ISOLATE_SUCCESS = 2,
} isolate_migrate_t;

struct anon_vma_chain {
	struct vm_area_struct *vma;
	struct anon_vma *anon_vma;
	struct list_head same_vma;
	struct rb_node rb;
	long unsigned int rb_subtree_last;
};

struct rb_augment_callbacks {
	void (*propagate)(struct rb_node *, struct rb_node *);
	void (*copy)(struct rb_node *, struct rb_node *);
	void (*rotate)(struct rb_node *, struct rb_node *);
};

enum lru_status {
	LRU_REMOVED = 0,
	LRU_REMOVED_RETRY = 1,
	LRU_ROTATE = 2,
	LRU_SKIP = 3,
	LRU_RETRY = 4,
};

struct list_lru_memcg {
	struct callback_head rcu;
	struct list_lru_one node[0];
};

typedef enum lru_status (*list_lru_walk_cb)(struct list_head *, struct list_lru_one *, spinlock_t *, void *);

struct list_lru_memcg_table {
	struct list_lru_memcg *mlru;
	struct mem_cgroup *memcg;
};

typedef struct {
	long unsigned int pd;
} hugepd_t;

struct follow_page_context {
	struct dev_pagemap *pgmap;
	unsigned int page_mask;
};

struct trace_event_raw_mmap_lock {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	char __data[0];
};

struct trace_event_raw_mmap_lock_acquire_returned {
	struct trace_entry ent;
	struct mm_struct *mm;
	u32 __data_loc_memcg_path;
	bool write;
	bool success;
	char __data[0];
};

struct trace_event_data_offsets_mmap_lock {
	u32 memcg_path;
};

struct trace_event_data_offsets_mmap_lock_acquire_returned {
	u32 memcg_path;
};

typedef void (*btf_trace_mmap_lock_start_locking)(void *, struct mm_struct *, const char *, bool);

typedef void (*btf_trace_mmap_lock_released)(void *, struct mm_struct *, const char *, bool);

typedef void (*btf_trace_mmap_lock_acquire_returned)(void *, struct mm_struct *, const char *, bool, bool);

struct memcg_path {
	local_lock_t lock;
	char *buf;
	local_t buf_idx;
};

struct page_address_map {
	struct page *page;
	void *virtual;
	struct list_head list;
};

struct page_address_slot {
	struct list_head lh;
	spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef struct {
	u64 val;
} pfn_t;

typedef unsigned int zap_flags_t;

typedef unsigned int pgtbl_mod_mask;

struct zap_details {
	struct folio *single_folio;
	bool even_cows;
	zap_flags_t zap_flags;
};

typedef int (*pte_fn_t)(pte_t *, long unsigned int, void *);

typedef long unsigned int pte_marker;

typedef int rmap_t;

struct mm_walk;

struct mm_walk_ops {
	int (*pgd_entry)(pgd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*p4d_entry)(p4d_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pud_entry)(pud_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pmd_entry)(pmd_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_entry)(pte_t *, long unsigned int, long unsigned int, struct mm_walk *);
	int (*pte_hole)(long unsigned int, long unsigned int, int, struct mm_walk *);
	int (*hugetlb_entry)(pte_t *, long unsigned int, long unsigned int, long unsigned int, struct mm_walk *);
	int (*test_walk)(long unsigned int, long unsigned int, struct mm_walk *);
	int (*pre_vma)(long unsigned int, long unsigned int, struct mm_walk *);
	void (*post_vma)(struct mm_walk *);
};

enum page_walk_action {
	ACTION_SUBTREE = 0,
	ACTION_CONTINUE = 1,
	ACTION_AGAIN = 2,
};

struct mm_walk {
	const struct mm_walk_ops *ops;
	struct mm_struct *mm;
	pgd_t *pgd;
	struct vm_area_struct *vma;
	enum page_walk_action action;
	bool no_vma;
	void *private;
};

struct mlock_pvec {
	local_lock_t lock;
	struct pagevec vec;
};

enum {
	HUGETLB_SHMFS_INODE = 1,
	HUGETLB_ANONHUGE_INODE = 2,
};

struct hstate {};

struct trace_event_raw_vm_unmapped_area {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int total_vm;
	long unsigned int flags;
	long unsigned int length;
	long unsigned int low_limit;
	long unsigned int high_limit;
	long unsigned int align_mask;
	long unsigned int align_offset;
	char __data[0];
};

struct trace_event_raw_vma_mas_szero {
	struct trace_entry ent;
	struct maple_tree *mt;
	long unsigned int start;
	long unsigned int end;
	char __data[0];
};

struct trace_event_raw_vma_store {
	struct trace_entry ent;
	struct maple_tree *mt;
	struct vm_area_struct *vma;
	long unsigned int vm_start;
	long unsigned int vm_end;
	char __data[0];
};

struct trace_event_raw_exit_mmap {
	struct trace_entry ent;
	struct mm_struct *mm;
	struct maple_tree *mt;
	char __data[0];
};

struct trace_event_data_offsets_vm_unmapped_area {};

struct trace_event_data_offsets_vma_mas_szero {};

struct trace_event_data_offsets_vma_store {};

struct trace_event_data_offsets_exit_mmap {};

typedef void (*btf_trace_vm_unmapped_area)(void *, long unsigned int, struct vm_unmapped_area_info *);

typedef void (*btf_trace_vma_mas_szero)(void *, struct maple_tree *, long unsigned int, long unsigned int);

typedef void (*btf_trace_vma_store)(void *, struct maple_tree *, struct vm_area_struct *);

typedef void (*btf_trace_exit_mmap)(void *, struct mm_struct *);

struct mmap_arg_struct {
	long unsigned int addr;
	long unsigned int len;
	long unsigned int prot;
	long unsigned int flags;
	long unsigned int fd;
	long unsigned int offset;
};

enum pgt_entry {
	NORMAL_PMD = 0,
	HPAGE_PMD = 1,
	NORMAL_PUD = 2,
	HPAGE_PUD = 3,
};

enum tlb_flush_reason {
	TLB_FLUSH_ON_TASK_SWITCH = 0,
	TLB_REMOTE_SHOOTDOWN = 1,
	TLB_LOCAL_SHOOTDOWN = 2,
	TLB_LOCAL_MM_SHOOTDOWN = 3,
	TLB_REMOTE_SEND_IPI = 4,
	NR_TLB_FLUSH_REASONS = 5,
};

struct rmap_walk_control {
	void *arg;
	bool try_lock;
	bool contended;
	bool (*rmap_one)(struct folio *, struct vm_area_struct *, long unsigned int, void *);
	int (*done)(struct folio *);
	struct anon_vma * (*anon_lock)(struct folio *, struct rmap_walk_control *);
	bool (*invalid_vma)(struct vm_area_struct *, void *);
};

struct trace_event_raw_tlb_flush {
	struct trace_entry ent;
	int reason;
	long unsigned int pages;
	char __data[0];
};

struct trace_event_data_offsets_tlb_flush {};

typedef void (*btf_trace_tlb_flush)(void *, int, long unsigned int);

struct trace_event_raw_mm_migrate_pages {
	struct trace_entry ent;
	long unsigned int succeeded;
	long unsigned int failed;
	long unsigned int thp_succeeded;
	long unsigned int thp_failed;
	long unsigned int thp_split;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_mm_migrate_pages_start {
	struct trace_entry ent;
	enum migrate_mode mode;
	int reason;
	char __data[0];
};

struct trace_event_raw_migration_pte {
	struct trace_entry ent;
	long unsigned int addr;
	long unsigned int pte;
	int order;
	char __data[0];
};

struct trace_event_data_offsets_mm_migrate_pages {};

struct trace_event_data_offsets_mm_migrate_pages_start {};

struct trace_event_data_offsets_migration_pte {};

typedef void (*btf_trace_mm_migrate_pages)(void *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, enum migrate_mode, int);

typedef void (*btf_trace_mm_migrate_pages_start)(void *, enum migrate_mode, int);

typedef void (*btf_trace_set_migration_pte)(void *, long unsigned int, long unsigned int, int);

typedef void (*btf_trace_remove_migration_pte)(void *, long unsigned int, long unsigned int, int);

struct folio_referenced_arg {
	int mapcount;
	int referenced;
	long unsigned int vm_flags;
	struct mem_cgroup *memcg;
};

struct vmap_area {
	long unsigned int va_start;
	long unsigned int va_end;
	struct rb_node rb_node;
	struct list_head list;
	union {
		long unsigned int subtree_max_size;
		struct vm_struct *vm;
	};
};

typedef unsigned int kasan_vmalloc_flags_t;

struct vfree_deferred {
	struct llist_head list;
	struct work_struct wq;
};

enum fit_type {
	NOTHING_FIT = 0,
	FL_FIT_TYPE = 1,
	LE_FIT_TYPE = 2,
	RE_FIT_TYPE = 3,
	NE_FIT_TYPE = 4,
};

struct vmap_block_queue {
	spinlock_t lock;
	struct list_head free;
};

struct vmap_block {
	spinlock_t lock;
	struct vmap_area *va;
	long unsigned int free;
	long unsigned int dirty;
	long unsigned int dirty_min;
	long unsigned int dirty_max;
	struct list_head free_list;
	struct callback_head callback_head;
	struct list_head purge;
};

struct va_format {
	const char *fmt;
	va_list *va;
};

struct page_frag_cache {
	void *va;
	__u16 offset;
	__u16 size;
	unsigned int pagecnt_bias;
	bool pfmemalloc;
};

enum meminit_context {
	MEMINIT_EARLY = 0,
	MEMINIT_HOTPLUG = 1,
};

typedef void compound_page_dtor(struct page *);

enum mminit_level {
	MMINIT_WARNING = 0,
	MMINIT_VERIFY = 1,
	MMINIT_TRACE = 2,
};

typedef int fpi_t;

struct madvise_walk_private {
	struct mmu_gather *tlb;
	bool pageout;
};

enum {
	BIO_NO_PAGE_REF = 0,
	BIO_CLONED = 1,
	BIO_BOUNCED = 2,
	BIO_QUIET = 3,
	BIO_CHAIN = 4,
	BIO_REFFED = 5,
	BIO_BPS_THROTTLED = 6,
	BIO_TRACE_COMPLETION = 7,
	BIO_CGROUP_ACCT = 8,
	BIO_QOS_THROTTLED = 9,
	BIO_QOS_MERGED = 10,
	BIO_REMAPPED = 11,
	BIO_ZONE_WRITE_LOCKED = 12,
	BIO_FLAG_LAST = 13,
};

struct swap_iocb {
	struct kiocb iocb;
	struct bio_vec bvec[32];
	int pages;
	int len;
};

struct vma_swap_readahead {
	short unsigned int win;
	short unsigned int offset;
	short unsigned int nr_pte;
	pte_t ptes[8];
};

enum {
	PERCPU_REF_INIT_ATOMIC = 1,
	PERCPU_REF_INIT_DEAD = 2,
	PERCPU_REF_ALLOW_REINIT = 4,
};

union swap_header {
	struct {
		char reserved[4086];
		char magic[10];
	} magic;
	struct {
		char bootbits[1024];
		__u32 version;
		__u32 last_page;
		__u32 nr_badpages;
		unsigned char sws_uuid[16];
		unsigned char sws_volume[16];
		__u32 padding[117];
		__u32 badpages[1];
	} info;
};

struct swap_extent {
	struct rb_node rb_node;
	long unsigned int start_page;
	long unsigned int nr_pages;
	int: 32;
	sector_t start_block;
};

struct swap_slots_cache {
	bool lock_initialized;
	struct mutex alloc_lock;
	swp_entry_t *slots;
	int nr;
	int cur;
	spinlock_t free_lock;
	swp_entry_t *slots_ret;
	int n_ret;
};

struct dma_pool {
	struct list_head page_list;
	spinlock_t lock;
	size_t size;
	struct device *dev;
	size_t allocation;
	size_t boundary;
	char name[32];
	struct list_head pools;
};

struct dma_page {
	struct list_head page_list;
	void *vaddr;
	dma_addr_t dma;
	unsigned int in_use;
	unsigned int offset;
};

enum stat_item {
	ALLOC_FASTPATH = 0,
	ALLOC_SLOWPATH = 1,
	FREE_FASTPATH = 2,
	FREE_SLOWPATH = 3,
	FREE_FROZEN = 4,
	FREE_ADD_PARTIAL = 5,
	FREE_REMOVE_PARTIAL = 6,
	ALLOC_FROM_PARTIAL = 7,
	ALLOC_SLAB = 8,
	ALLOC_REFILL = 9,
	ALLOC_NODE_MISMATCH = 10,
	FREE_SLAB = 11,
	CPUSLAB_FLUSH = 12,
	DEACTIVATE_FULL = 13,
	DEACTIVATE_EMPTY = 14,
	DEACTIVATE_TO_HEAD = 15,
	DEACTIVATE_TO_TAIL = 16,
	DEACTIVATE_REMOTE_FREES = 17,
	DEACTIVATE_BYPASS = 18,
	ORDER_FALLBACK = 19,
	CMPXCHG_DOUBLE_CPU_FAIL = 20,
	CMPXCHG_DOUBLE_FAIL = 21,
	CPU_PARTIAL_ALLOC = 22,
	CPU_PARTIAL_FREE = 23,
	CPU_PARTIAL_NODE = 24,
	CPU_PARTIAL_DRAIN = 25,
	NR_SLUB_STAT_ITEMS = 26,
};

struct partial_context {
	struct slab **slab;
	gfp_t flags;
	unsigned int orig_size;
};

struct track {
	long unsigned int addr;
	int cpu;
	int pid;
	long unsigned int when;
};

enum track_item {
	TRACK_ALLOC = 0,
	TRACK_FREE = 1,
};

struct slub_flush_work {
	struct work_struct work;
	struct kmem_cache *s;
	bool skip;
};

struct detached_freelist {
	struct slab *slab;
	void *tail;
	void *freelist;
	int cnt;
	struct kmem_cache *s;
};

enum slab_stat_type {
	SL_ALL = 0,
	SL_PARTIAL = 1,
	SL_CPU = 2,
	SL_OBJECTS = 3,
	SL_TOTAL = 4,
};

struct slab_attribute {
	struct attribute attr;
	ssize_t (*show)(struct kmem_cache *, char *);
	ssize_t (*store)(struct kmem_cache *, const char *, size_t);
};

struct saved_alias {
	struct kmem_cache *s;
	const char *name;
	struct saved_alias *next;
};

enum slab_modes {
	M_NONE = 0,
	M_PARTIAL = 1,
	M_FULL = 2,
	M_FREE = 3,
	M_FULL_NOLIST = 4,
};

struct buffer_head;

typedef void bh_end_io_t(struct buffer_head *, int);

struct buffer_head {
	long unsigned int b_state;
	struct buffer_head *b_this_page;
	struct page *b_page;
	int: 32;
	sector_t b_blocknr;
	size_t b_size;
	char *b_data;
	struct block_device *b_bdev;
	bh_end_io_t *b_end_io;
	void *b_private;
	struct list_head b_assoc_buffers;
	struct address_space *b_assoc_map;
	atomic_t b_count;
	spinlock_t b_uptodate_lock;
};

typedef struct page *new_page_t(struct page *, long unsigned int);

typedef void free_page_t(struct page *, long unsigned int);

enum bh_state_bits {
	BH_Uptodate = 0,
	BH_Dirty = 1,
	BH_Lock = 2,
	BH_Req = 3,
	BH_Mapped = 4,
	BH_New = 5,
	BH_Async_Read = 6,
	BH_Async_Write = 7,
	BH_Delay = 8,
	BH_Boundary = 9,
	BH_Write_EIO = 10,
	BH_Unwritten = 11,
	BH_Quiet = 12,
	BH_Meta = 13,
	BH_Prio = 14,
	BH_Defer_Completion = 15,
	BH_PrivateStart = 16,
};

struct hugepage_subpool;

struct mem_cgroup_reclaim_cookie {
	pg_data_t *pgdat;
	unsigned int generation;
};

enum mem_cgroup_events_target {
	MEM_CGROUP_TARGET_THRESH = 0,
	MEM_CGROUP_TARGET_SOFTLIMIT = 1,
	MEM_CGROUP_NTARGETS = 2,
};

struct memcg_vmstats {
	long int state[48];
	long unsigned int events[13];
	long int state_pending[48];
	long unsigned int events_pending[13];
};

struct memcg_vmstats_percpu {
	long int state[48];
	long unsigned int events[13];
	long int state_prev[48];
	long unsigned int events_prev[13];
	long unsigned int nr_page_events;
	long unsigned int targets[2];
};

struct mem_cgroup_tree_per_node {
	struct rb_root rb_root;
	struct rb_node *rb_rightmost;
	spinlock_t lock;
};

struct mem_cgroup_tree {
	struct mem_cgroup_tree_per_node *rb_tree_per_node[1];
};

struct mem_cgroup_eventfd_list {
	struct list_head list;
	struct eventfd_ctx *eventfd;
};

struct mem_cgroup_event {
	struct mem_cgroup *memcg;
	struct eventfd_ctx *eventfd;
	struct list_head list;
	int (*register_event)(struct mem_cgroup *, struct eventfd_ctx *, const char *);
	void (*unregister_event)(struct mem_cgroup *, struct eventfd_ctx *);
	poll_table pt;
	wait_queue_head_t *wqh;
	wait_queue_entry_t wait;
	struct work_struct remove;
};

struct move_charge_struct {
	spinlock_t lock;
	struct mm_struct *mm;
	struct mem_cgroup *from;
	struct mem_cgroup *to;
	long unsigned int flags;
	long unsigned int precharge;
	long unsigned int moved_charge;
	long unsigned int moved_swap;
	struct task_struct *moving_task;
	wait_queue_head_t waitq;
};

enum res_type {
	_MEM = 0,
	_MEMSWAP = 1,
	_KMEM = 2,
	_TCP = 3,
};

struct memory_stat {
	const char *name;
	unsigned int idx;
};

struct oom_wait_info {
	struct mem_cgroup *memcg;
	wait_queue_entry_t wait;
};

struct memcg_stock_pcp {
	local_lock_t stock_lock;
	struct mem_cgroup *cached;
	unsigned int nr_pages;
	struct obj_cgroup *cached_objcg;
	struct pglist_data *cached_pgdat;
	unsigned int nr_bytes;
	int nr_slab_reclaimable_b;
	int nr_slab_unreclaimable_b;
	struct work_struct work;
	long unsigned int flags;
};

enum {
	RES_USAGE = 0,
	RES_LIMIT = 1,
	RES_MAX_USAGE = 2,
	RES_FAILCNT = 3,
	RES_SOFT_LIMIT = 4,
};

union mc_target {
	struct page *page;
	swp_entry_t ent;
};

enum mc_target_type {
	MC_TARGET_NONE = 0,
	MC_TARGET_PAGE = 1,
	MC_TARGET_SWAP = 2,
	MC_TARGET_DEVICE = 3,
};

struct uncharge_gather {
	struct mem_cgroup *memcg;
	long unsigned int nr_memory;
	long unsigned int pgpgout;
	long unsigned int nr_kmem;
	int nid;
};

enum vmpressure_levels {
	VMPRESSURE_LOW = 0,
	VMPRESSURE_MEDIUM = 1,
	VMPRESSURE_CRITICAL = 2,
	VMPRESSURE_NUM_LEVELS = 3,
};

enum vmpressure_modes {
	VMPRESSURE_NO_PASSTHROUGH = 0,
	VMPRESSURE_HIERARCHY = 1,
	VMPRESSURE_LOCAL = 2,
	VMPRESSURE_NUM_MODES = 3,
};

struct vmpressure_event {
	struct eventfd_ctx *efd;
	enum vmpressure_levels level;
	enum vmpressure_modes mode;
	struct list_head node;
};

struct swap_cgroup_ctrl {
	struct page **map;
	long unsigned int length;
	spinlock_t lock;
};

struct swap_cgroup {
	short unsigned int id;
};

struct trace_event_raw_test_pages_isolated {
	struct trace_entry ent;
	long unsigned int start_pfn;
	long unsigned int end_pfn;
	long unsigned int fin_pfn;
	char __data[0];
};

struct trace_event_data_offsets_test_pages_isolated {};

typedef void (*btf_trace_test_pages_isolated)(void *, long unsigned int, long unsigned int, long unsigned int);

struct cma {
	long unsigned int base_pfn;
	long unsigned int count;
	long unsigned int *bitmap;
	unsigned int order_per_bit;
	spinlock_t lock;
	char name[64];
	bool reserve_pages_on_error;
};

struct trace_event_raw_cma_alloc_class {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int pfn;
	const struct page *page;
	long unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_raw_cma_release {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int pfn;
	const struct page *page;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_cma_alloc_start {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int count;
	unsigned int align;
	char __data[0];
};

struct trace_event_data_offsets_cma_alloc_class {
	u32 name;
};

struct trace_event_data_offsets_cma_release {
	u32 name;
};

struct trace_event_data_offsets_cma_alloc_start {
	u32 name;
};

typedef void (*btf_trace_cma_release)(void *, const char *, long unsigned int, const struct page *, long unsigned int);

typedef void (*btf_trace_cma_alloc_start)(void *, const char *, long unsigned int, unsigned int);

typedef void (*btf_trace_cma_alloc_finish)(void *, const char *, long unsigned int, const struct page *, long unsigned int, unsigned int);

typedef void (*btf_trace_cma_alloc_busy_retry)(void *, const char *, long unsigned int, const struct page *, long unsigned int, unsigned int);

struct open_how {
	__u64 flags;
	__u64 mode;
	__u64 resolve;
};

enum fsnotify_data_type {
	FSNOTIFY_EVENT_NONE = 0,
	FSNOTIFY_EVENT_PATH = 1,
	FSNOTIFY_EVENT_INODE = 2,
	FSNOTIFY_EVENT_DENTRY = 3,
	FSNOTIFY_EVENT_ERROR = 4,
};

enum hash_algo {
	HASH_ALGO_MD4 = 0,
	HASH_ALGO_MD5 = 1,
	HASH_ALGO_SHA1 = 2,
	HASH_ALGO_RIPE_MD_160 = 3,
	HASH_ALGO_SHA256 = 4,
	HASH_ALGO_SHA384 = 5,
	HASH_ALGO_SHA512 = 6,
	HASH_ALGO_SHA224 = 7,
	HASH_ALGO_RIPE_MD_128 = 8,
	HASH_ALGO_RIPE_MD_256 = 9,
	HASH_ALGO_RIPE_MD_320 = 10,
	HASH_ALGO_WP_256 = 11,
	HASH_ALGO_WP_384 = 12,
	HASH_ALGO_WP_512 = 13,
	HASH_ALGO_TGR_128 = 14,
	HASH_ALGO_TGR_160 = 15,
	HASH_ALGO_TGR_192 = 16,
	HASH_ALGO_SM3_256 = 17,
	HASH_ALGO_STREEBOG_256 = 18,
	HASH_ALGO_STREEBOG_512 = 19,
	HASH_ALGO__LAST = 20,
};

struct open_flags {
	int open_flag;
	umode_t mode;
	int acc_mode;
	int intent;
	int lookup_flags;
};

typedef __kernel_long_t __kernel_off_t;

typedef __kernel_off_t off_t;

typedef __kernel_rwf_t rwf_t;

struct files_stat_struct {
	long unsigned int nr_files;
	long unsigned int nr_free_files;
	long unsigned int max_files;
};

enum vfs_get_super_keying {
	vfs_get_single_super = 0,
	vfs_get_single_reconf_super = 1,
	vfs_get_keyed_super = 2,
	vfs_get_independent_super = 3,
};

struct kobj_map;

struct char_device_struct {
	struct char_device_struct *next;
	unsigned int major;
	unsigned int baseminor;
	int minorct;
	char name[64];
	struct cdev *cdev;
};

struct stat {
	long unsigned int st_dev;
	long unsigned int st_ino;
	short unsigned int st_mode;
	short unsigned int st_nlink;
	short unsigned int st_uid;
	short unsigned int st_gid;
	long unsigned int st_rdev;
	long unsigned int st_size;
	long unsigned int st_blksize;
	long unsigned int st_blocks;
	long unsigned int st_atime;
	long unsigned int st_atime_nsec;
	long unsigned int st_mtime;
	long unsigned int st_mtime_nsec;
	long unsigned int st_ctime;
	long unsigned int st_ctime_nsec;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct stat64 {
	long long unsigned int st_dev;
	unsigned char __pad0[4];
	long unsigned int __st_ino;
	unsigned int st_mode;
	unsigned int st_nlink;
	long unsigned int st_uid;
	long unsigned int st_gid;
	long long unsigned int st_rdev;
	unsigned char __pad3[4];
	int: 32;
	long long int st_size;
	long unsigned int st_blksize;
	int: 32;
	long long unsigned int st_blocks;
	long unsigned int st_atime;
	long unsigned int st_atime_nsec;
	long unsigned int st_mtime;
	long unsigned int st_mtime_nsec;
	long unsigned int st_ctime;
	long unsigned int st_ctime_nsec;
	long long unsigned int st_ino;
};

struct statx_timestamp {
	__s64 tv_sec;
	__u32 tv_nsec;
	__s32 __reserved;
};

struct statx {
	__u32 stx_mask;
	__u32 stx_blksize;
	__u64 stx_attributes;
	__u32 stx_nlink;
	__u32 stx_uid;
	__u32 stx_gid;
	__u16 stx_mode;
	__u16 __spare0[1];
	__u64 stx_ino;
	__u64 stx_size;
	__u64 stx_blocks;
	__u64 stx_attributes_mask;
	struct statx_timestamp stx_atime;
	struct statx_timestamp stx_btime;
	struct statx_timestamp stx_ctime;
	struct statx_timestamp stx_mtime;
	__u32 stx_rdev_major;
	__u32 stx_rdev_minor;
	__u32 stx_dev_major;
	__u32 stx_dev_minor;
	__u64 stx_mnt_id;
	__u32 stx_dio_mem_align;
	__u32 stx_dio_offset_align;
	__u64 __spare3[12];
};

struct mount;

struct mnt_namespace {
	struct ns_common ns;
	struct mount *root;
	struct list_head list;
	spinlock_t ns_lock;
	struct user_namespace *user_ns;
	struct ucounts *ucounts;
	u64 seq;
	wait_queue_head_t poll;
	int: 32;
	u64 event;
	unsigned int mounts;
	unsigned int pending_mounts;
};

struct mnt_pcp;

struct mountpoint;

struct mount {
	struct hlist_node mnt_hash;
	struct mount *mnt_parent;
	struct dentry *mnt_mountpoint;
	struct vfsmount mnt;
	union {
		struct callback_head mnt_rcu;
		struct llist_node mnt_llist;
	};
	struct mnt_pcp *mnt_pcp;
	struct list_head mnt_mounts;
	struct list_head mnt_child;
	struct list_head mnt_instance;
	const char *mnt_devname;
	struct list_head mnt_list;
	struct list_head mnt_expire;
	struct list_head mnt_share;
	struct list_head mnt_slave_list;
	struct list_head mnt_slave;
	struct mount *mnt_master;
	struct mnt_namespace *mnt_ns;
	struct mountpoint *mnt_mp;
	union {
		struct hlist_node mnt_mp_list;
		struct hlist_node mnt_umount;
	};
	struct list_head mnt_umounting;
	struct fsnotify_mark_connector *mnt_fsnotify_marks;
	__u32 mnt_fsnotify_mask;
	int mnt_id;
	int mnt_group_id;
	int mnt_expiry_mark;
	struct hlist_head mnt_pins;
	struct hlist_head mnt_stuck_children;
};

struct mnt_pcp {
	int mnt_count;
	int mnt_writers;
};

struct mountpoint {
	struct hlist_node m_hash;
	struct dentry *m_dentry;
	struct hlist_head m_list;
	int m_count;
};

typedef short unsigned int ushort;

struct user_arg_ptr {
	union {
		const char * const *native;
	} ptr;
};

enum inode_i_mutex_lock_class {
	I_MUTEX_NORMAL = 0,
	I_MUTEX_PARENT = 1,
	I_MUTEX_CHILD = 2,
	I_MUTEX_XATTR = 3,
	I_MUTEX_NONDIR2 = 4,
	I_MUTEX_PARENT2 = 5,
};

struct pseudo_fs_context {
	const struct super_operations *ops;
	const struct xattr_handler **xattr;
	const struct dentry_operations *dops;
	long unsigned int magic;
};

struct name_snapshot {
	struct qstr name;
	unsigned char inline_name[36];
	int: 32;
};

struct saved {
	struct path link;
	struct delayed_call done;
	const char *name;
	unsigned int seq;
};

struct nameidata {
	struct path path;
	struct qstr last;
	struct path root;
	struct inode *inode;
	unsigned int flags;
	unsigned int state;
	unsigned int seq;
	unsigned int next_seq;
	unsigned int m_seq;
	unsigned int r_seq;
	int last_type;
	unsigned int depth;
	int total_link_count;
	struct saved *stack;
	struct saved internal[2];
	struct filename *name;
	struct nameidata *saved;
	unsigned int root_seq;
	int dfd;
	kuid_t dir_uid;
	umode_t dir_mode;
	int: 16;
	int: 32;
};

struct renamedata {
	struct user_namespace *old_mnt_userns;
	struct inode *old_dir;
	struct dentry *old_dentry;
	struct user_namespace *new_mnt_userns;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct inode **delegated_inode;
	unsigned int flags;
};

enum {
	LAST_NORM = 0,
	LAST_ROOT = 1,
	LAST_DOT = 2,
	LAST_DOTDOT = 3,
};

enum {
	WALK_TRAILING = 1,
	WALK_MORE = 2,
	WALK_NOFOLLOW = 4,
};

struct word_at_a_time {
	const long unsigned int one_bits;
	const long unsigned int high_bits;
};

struct f_owner_ex {
	int type;
	__kernel_pid_t pid;
};

struct flock {
	short int l_type;
	short int l_whence;
	__kernel_off_t l_start;
	__kernel_off_t l_len;
	__kernel_pid_t l_pid;
};

struct flock64 {
	short int l_type;
	short int l_whence;
	int: 32;
	__kernel_loff_t l_start;
	__kernel_loff_t l_len;
	__kernel_pid_t l_pid;
	int: 32;
};

enum rw_hint {
	WRITE_LIFE_NOT_SET = 0,
	WRITE_LIFE_NONE = 1,
	WRITE_LIFE_SHORT = 2,
	WRITE_LIFE_MEDIUM = 3,
	WRITE_LIFE_LONG = 4,
	WRITE_LIFE_EXTREME = 5,
};

struct file_clone_range {
	__s64 src_fd;
	__u64 src_offset;
	__u64 src_length;
	__u64 dest_offset;
};

struct file_dedupe_range_info {
	__s64 dest_fd;
	__u64 dest_offset;
	__u64 bytes_deduped;
	__s32 status;
	__u32 reserved;
};

struct file_dedupe_range {
	__u64 src_offset;
	__u64 src_length;
	__u16 dest_count;
	__u16 reserved1;
	__u32 reserved2;
	struct file_dedupe_range_info info[0];
};

struct fsxattr {
	__u32 fsx_xflags;
	__u32 fsx_extsize;
	__u32 fsx_nextents;
	__u32 fsx_projid;
	__u32 fsx_cowextsize;
	unsigned char fsx_pad[8];
};

struct fiemap_extent;

struct fiemap_extent_info {
	unsigned int fi_flags;
	unsigned int fi_extents_mapped;
	unsigned int fi_extents_max;
	struct fiemap_extent *fi_extents_start;
};

struct space_resv {
	__s16 l_type;
	__s16 l_whence;
	int: 32;
	__s64 l_start;
	__s64 l_len;
	__s32 l_sysid;
	__u32 l_pid;
	__s32 l_pad[4];
};

struct fiemap_extent {
	__u64 fe_logical;
	__u64 fe_physical;
	__u64 fe_length;
	__u64 fe_reserved64[2];
	__u32 fe_flags;
	__u32 fe_reserved[3];
};

struct fiemap {
	__u64 fm_start;
	__u64 fm_length;
	__u32 fm_flags;
	__u32 fm_mapped_extents;
	__u32 fm_extent_count;
	__u32 fm_reserved;
	struct fiemap_extent fm_extents[0];
};

struct linux_dirent64 {
	u64 d_ino;
	s64 d_off;
	short unsigned int d_reclen;
	unsigned char d_type;
	char d_name[0];
	int: 8;
	int: 32;
};

struct linux_dirent {
	long unsigned int d_ino;
	long unsigned int d_off;
	short unsigned int d_reclen;
	char d_name[1];
};

struct getdents_callback {
	struct dir_context ctx;
	struct linux_dirent *current_dir;
	int prev_reclen;
	int count;
	int error;
};

struct getdents_callback64 {
	struct dir_context ctx;
	struct linux_dirent64 *current_dir;
	int prev_reclen;
	int count;
	int error;
};

typedef struct {
	long unsigned int fds_bits[32];
} __kernel_fd_set;

typedef __kernel_fd_set fd_set;

struct poll_table_entry {
	struct file *filp;
	__poll_t key;
	wait_queue_entry_t wait;
	wait_queue_head_t *wait_address;
};

struct poll_table_page;

struct poll_wqueues {
	poll_table pt;
	struct poll_table_page *table;
	struct task_struct *polling_task;
	int triggered;
	int error;
	int inline_index;
	struct poll_table_entry inline_entries[18];
};

struct poll_table_page {
	struct poll_table_page *next;
	struct poll_table_entry *entry;
	struct poll_table_entry entries[0];
};

enum poll_time_type {
	PT_TIMEVAL = 0,
	PT_OLD_TIMEVAL = 1,
	PT_TIMESPEC = 2,
	PT_OLD_TIMESPEC = 3,
};

typedef struct {
	long unsigned int *in;
	long unsigned int *out;
	long unsigned int *ex;
	long unsigned int *res_in;
	long unsigned int *res_out;
	long unsigned int *res_ex;
} fd_set_bits;

struct sigset_argpack {
	sigset_t *p;
	size_t size;
};

struct sel_arg_struct {
	long unsigned int n;
	fd_set *inp;
	fd_set *outp;
	fd_set *exp;
	struct __kernel_old_timeval *tvp;
};

struct poll_list {
	struct poll_list *next;
	int len;
	struct pollfd entries[0];
};

enum dentry_d_lock_class {
	DENTRY_D_LOCK_NORMAL = 0,
	DENTRY_D_LOCK_NESTED = 1,
};

struct dentry_stat_t {
	long int nr_dentry;
	long int nr_unused;
	long int age_limit;
	long int want_pages;
	long int nr_negative;
	long int dummy;
};

struct external_name {
	union {
		atomic_t count;
		struct callback_head head;
	} u;
	unsigned char name[0];
};

enum d_walk_ret {
	D_WALK_CONTINUE = 0,
	D_WALK_QUIT = 1,
	D_WALK_NORETRY = 2,
	D_WALK_SKIP = 3,
};

struct check_mount {
	struct vfsmount *mnt;
	unsigned int mounted;
};

struct select_data {
	struct dentry *start;
	union {
		long int found;
		struct dentry *victim;
	};
	struct list_head dispose;
};

struct inodes_stat_t {
	long int nr_inodes;
	long int nr_unused;
	long int dummy[5];
};

enum file_time_flags {
	S_ATIME = 1,
	S_MTIME = 2,
	S_CTIME = 4,
	S_VERSION = 8,
};

struct mount_attr {
	__u64 attr_set;
	__u64 attr_clr;
	__u64 propagation;
	__u64 userns_fd;
};

struct proc_mounts {
	struct mnt_namespace *ns;
	struct path root;
	int (*show)(struct seq_file *, struct vfsmount *);
	struct mount cursor;
};

struct mount_kattr {
	unsigned int attr_set;
	unsigned int attr_clr;
	unsigned int propagation;
	unsigned int lookup_flags;
	bool recurse;
	struct user_namespace *mnt_userns;
};

enum umount_tree_flags {
	UMOUNT_SYNC = 1,
	UMOUNT_PROPAGATE = 2,
	UMOUNT_CONNECTED = 4,
};

struct xattr_name {
	char name[256];
};

struct xattr_ctx {
	union {
		const void *cvalue;
		void *value;
	};
	void *kvalue;
	size_t size;
	struct xattr_name *kname;
	unsigned int flags;
};

struct simple_transaction_argresp {
	ssize_t size;
	char data[0];
};

enum utf8_normalization {
	UTF8_NFDI = 0,
	UTF8_NFDICF = 1,
	UTF8_NMAX = 2,
};

struct simple_attr {
	int (*get)(void *, u64 *);
	int (*set)(void *, u64);
	char get_buf[24];
	char set_buf[24];
	void *data;
	const char *fmt;
	struct mutex mutex;
};

struct wb_completion {
	atomic_t cnt;
	wait_queue_head_t *waitq;
};

struct wb_writeback_work {
	long int nr_pages;
	struct super_block *sb;
	enum writeback_sync_modes sync_mode;
	unsigned int tagged_writepages: 1;
	unsigned int for_kupdate: 1;
	unsigned int range_cyclic: 1;
	unsigned int for_background: 1;
	unsigned int for_sync: 1;
	unsigned int auto_free: 1;
	enum wb_reason reason;
	struct list_head list;
	struct wb_completion *done;
};

struct trace_event_raw_writeback_folio_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_writeback_dirty_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_writeback_write_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	int sync_mode;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_work_class {
	struct trace_entry ent;
	char name[32];
	long int nr_pages;
	dev_t sb_dev;
	int sync_mode;
	int for_kupdate;
	int range_cyclic;
	int for_background;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_pages_written {
	struct trace_entry ent;
	long int pages;
	char __data[0];
};

struct trace_event_raw_writeback_class {
	struct trace_entry ent;
	char name[32];
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_bdi_register {
	struct trace_entry ent;
	char name[32];
	char __data[0];
};

struct trace_event_raw_wbc_class {
	struct trace_entry ent;
	char name[32];
	long int nr_to_write;
	long int pages_skipped;
	int sync_mode;
	int for_kupdate;
	int for_background;
	int for_reclaim;
	int range_cyclic;
	long int range_start;
	long int range_end;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_queue_io {
	struct trace_entry ent;
	char name[32];
	long unsigned int older;
	long int age;
	int moved;
	int reason;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_global_dirty_state {
	struct trace_entry ent;
	long unsigned int nr_dirty;
	long unsigned int nr_writeback;
	long unsigned int background_thresh;
	long unsigned int dirty_thresh;
	long unsigned int dirty_limit;
	long unsigned int nr_dirtied;
	long unsigned int nr_written;
	char __data[0];
};

struct trace_event_raw_bdi_dirty_ratelimit {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int write_bw;
	long unsigned int avg_write_bw;
	long unsigned int dirty_rate;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	long unsigned int balanced_dirty_ratelimit;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_balance_dirty_pages {
	struct trace_entry ent;
	char bdi[32];
	long unsigned int limit;
	long unsigned int setpoint;
	long unsigned int dirty;
	long unsigned int bdi_setpoint;
	long unsigned int bdi_dirty;
	long unsigned int dirty_ratelimit;
	long unsigned int task_ratelimit;
	unsigned int dirtied;
	unsigned int dirtied_pause;
	long unsigned int paused;
	long int pause;
	long unsigned int period;
	long int think;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_sb_inodes_requeue {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_single_inode_template {
	struct trace_entry ent;
	char name[32];
	ino_t ino;
	long unsigned int state;
	long unsigned int dirtied_when;
	long unsigned int writeback_index;
	long int nr_to_write;
	long unsigned int wrote;
	ino_t cgroup_ino;
	char __data[0];
};

struct trace_event_raw_writeback_inode_template {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int state;
	__u16 mode;
	long unsigned int dirtied_when;
	char __data[0];
};

struct trace_event_data_offsets_writeback_folio_template {};

struct trace_event_data_offsets_writeback_dirty_inode_template {};

struct trace_event_data_offsets_writeback_write_inode_template {};

struct trace_event_data_offsets_writeback_work_class {};

struct trace_event_data_offsets_writeback_pages_written {};

struct trace_event_data_offsets_writeback_class {};

struct trace_event_data_offsets_writeback_bdi_register {};

struct trace_event_data_offsets_wbc_class {};

struct trace_event_data_offsets_writeback_queue_io {};

struct trace_event_data_offsets_global_dirty_state {};

struct trace_event_data_offsets_bdi_dirty_ratelimit {};

struct trace_event_data_offsets_balance_dirty_pages {};

struct trace_event_data_offsets_writeback_sb_inodes_requeue {};

struct trace_event_data_offsets_writeback_single_inode_template {};

struct trace_event_data_offsets_writeback_inode_template {};

typedef void (*btf_trace_writeback_dirty_folio)(void *, struct folio *, struct address_space *);

typedef void (*btf_trace_folio_wait_writeback)(void *, struct folio *, struct address_space *);

typedef void (*btf_trace_writeback_mark_inode_dirty)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode_start)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_dirty_inode)(void *, struct inode *, int);

typedef void (*btf_trace_writeback_write_inode_start)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_write_inode)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_writeback_queue)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_exec)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_start)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_written)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_wait)(void *, struct bdi_writeback *, struct wb_writeback_work *);

typedef void (*btf_trace_writeback_pages_written)(void *, long int);

typedef void (*btf_trace_writeback_wake_background)(void *, struct bdi_writeback *);

typedef void (*btf_trace_writeback_bdi_register)(void *, struct backing_dev_info *);

typedef void (*btf_trace_wbc_writepage)(void *, struct writeback_control *, struct backing_dev_info *);

typedef void (*btf_trace_writeback_queue_io)(void *, struct bdi_writeback *, struct wb_writeback_work *, long unsigned int, int);

typedef void (*btf_trace_global_dirty_state)(void *, long unsigned int, long unsigned int);

typedef void (*btf_trace_bdi_dirty_ratelimit)(void *, struct bdi_writeback *, long unsigned int, long unsigned int);

typedef void (*btf_trace_balance_dirty_pages)(void *, struct bdi_writeback *, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long int, long unsigned int);

typedef void (*btf_trace_writeback_sb_inodes_requeue)(void *, struct inode *);

typedef void (*btf_trace_writeback_single_inode_start)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_single_inode)(void *, struct inode *, struct writeback_control *, long unsigned int);

typedef void (*btf_trace_writeback_lazytime)(void *, struct inode *);

typedef void (*btf_trace_writeback_lazytime_iput)(void *, struct inode *);

typedef void (*btf_trace_writeback_dirty_inode_enqueue)(void *, struct inode *);

typedef void (*btf_trace_sb_mark_inode_writeback)(void *, struct inode *);

typedef void (*btf_trace_sb_clear_inode_writeback)(void *, struct inode *);

struct splice_desc {
	size_t total_len;
	unsigned int len;
	unsigned int flags;
	union {
		void *userptr;
		struct file *file;
		void *data;
	} u;
	loff_t pos;
	loff_t *opos;
	size_t num_spliced;
	bool need_wakeup;
	int: 24;
	int: 32;
};

typedef int splice_actor(struct pipe_inode_info *, struct pipe_buffer *, struct splice_desc *);

typedef int splice_direct_actor(struct pipe_inode_info *, struct splice_desc *);

struct old_utimbuf32 {
	old_time32_t actime;
	old_time32_t modtime;
};

struct prepend_buffer {
	char *buf;
	int len;
};

typedef int __kernel_daddr_t;

struct ustat {
	__kernel_daddr_t f_tfree;
	long unsigned int f_tinode;
	char f_fname[6];
	char f_fpack[6];
};

struct statfs {
	__u32 f_type;
	__u32 f_bsize;
	__u32 f_blocks;
	__u32 f_bfree;
	__u32 f_bavail;
	__u32 f_files;
	__u32 f_ffree;
	__kernel_fsid_t f_fsid;
	__u32 f_namelen;
	__u32 f_frsize;
	__u32 f_flags;
	__u32 f_spare[4];
};

struct statfs64 {
	__u32 f_type;
	__u32 f_bsize;
	__u64 f_blocks;
	__u64 f_bfree;
	__u64 f_bavail;
	__u64 f_files;
	__u64 f_ffree;
	__kernel_fsid_t f_fsid;
	__u32 f_namelen;
	__u32 f_frsize;
	__u32 f_flags;
	__u32 f_spare[4];
};

struct fs_pin {
	wait_queue_head_t wait;
	int done;
	struct hlist_node s_list;
	struct hlist_node m_list;
	void (*kill)(struct fs_pin *);
};

typedef struct ns_common *ns_get_path_helper_t(void *);

struct ns_get_path_task_args {
	const struct proc_ns_operations *ns_ops;
	struct task_struct *task;
};

enum legacy_fs_param {
	LEGACY_FS_UNSET_PARAMS = 0,
	LEGACY_FS_MONOLITHIC_PARAMS = 1,
	LEGACY_FS_INDIVIDUAL_PARAMS = 2,
};

struct legacy_fs_context {
	char *legacy_data;
	size_t data_size;
	enum legacy_fs_param param_type;
};

enum fsconfig_command {
	FSCONFIG_SET_FLAG = 0,
	FSCONFIG_SET_STRING = 1,
	FSCONFIG_SET_BINARY = 2,
	FSCONFIG_SET_PATH = 3,
	FSCONFIG_SET_PATH_EMPTY = 4,
	FSCONFIG_SET_FD = 5,
	FSCONFIG_CMD_CREATE = 6,
	FSCONFIG_CMD_RECONFIGURE = 7,
};

struct iomap_ops;

struct io_cq {
	struct request_queue *q;
	struct io_context *ioc;
	union {
		struct list_head q_node;
		struct kmem_cache *__rcu_icq_cache;
	};
	union {
		struct hlist_node ioc_node;
		struct callback_head __rcu_head;
	};
	unsigned int flags;
};

typedef int get_block_t(struct inode *, sector_t, struct buffer_head *, int);

typedef __u32 blk_mq_req_flags_t;

struct sbitmap_word {
	long unsigned int word;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int cleared;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sbitmap {
	unsigned int depth;
	unsigned int shift;
	unsigned int map_nr;
	bool round_robin;
	struct sbitmap_word *map;
	unsigned int *alloc_hint;
};

struct sbq_wait_state {
	atomic_t wait_cnt;
	wait_queue_head_t wait;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sbitmap_queue {
	struct sbitmap sb;
	unsigned int wake_batch;
	atomic_t wake_index;
	struct sbq_wait_state *ws;
	atomic_t ws_active;
	unsigned int min_shallow_depth;
};

typedef __u32 req_flags_t;

enum mq_rq_state {
	MQ_RQ_IDLE = 0,
	MQ_RQ_IN_FLIGHT = 1,
	MQ_RQ_COMPLETE = 2,
};

enum rq_end_io_ret {
	RQ_END_IO_NONE = 0,
	RQ_END_IO_FREE = 1,
};

typedef enum rq_end_io_ret rq_end_io_fn(struct request *, blk_status_t);

struct request {
	struct request_queue *q;
	struct blk_mq_ctx *mq_ctx;
	struct blk_mq_hw_ctx *mq_hctx;
	blk_opf_t cmd_flags;
	req_flags_t rq_flags;
	int tag;
	int internal_tag;
	unsigned int timeout;
	unsigned int __data_len;
	int: 32;
	sector_t __sector;
	struct bio *bio;
	struct bio *biotail;
	union {
		struct list_head queuelist;
		struct request *rq_next;
	};
	struct block_device *part;
	int: 32;
	u64 start_time_ns;
	u64 io_start_time_ns;
	short unsigned int stats_sectors;
	short unsigned int nr_phys_segments;
	short unsigned int write_hint;
	short unsigned int ioprio;
	enum mq_rq_state state;
	atomic_t ref;
	long unsigned int deadline;
	union {
		struct hlist_node hash;
		struct llist_node ipi_list;
	};
	union {
		struct rb_node rb_node;
		struct bio_vec special_vec;
		void *completion_data;
	};
	union {
		struct {
			struct io_cq *icq;
			void *priv[2];
		} elv;
		struct {
			unsigned int seq;
			struct list_head list;
			rq_end_io_fn *saved_end_io;
		} flush;
	};
	union {
		struct __call_single_data csd;
		u64 fifo_time;
	};
	rq_end_io_fn *end_io;
	void *end_io_data;
};

struct blk_mq_tags {
	unsigned int nr_tags;
	unsigned int nr_reserved_tags;
	atomic_t active_queues;
	struct sbitmap_queue bitmap_tags;
	struct sbitmap_queue breserved_tags;
	struct request **rqs;
	struct request **static_rqs;
	struct list_head page_list;
	spinlock_t lock;
};

struct blk_mq_queue_map {
	unsigned int *mq_map;
	unsigned int nr_queues;
	unsigned int queue_offset;
};

struct blk_mq_tag_set {
	struct blk_mq_queue_map map[3];
	unsigned int nr_maps;
	const struct blk_mq_ops *ops;
	unsigned int nr_hw_queues;
	unsigned int queue_depth;
	unsigned int reserved_tags;
	unsigned int cmd_size;
	int numa_node;
	unsigned int timeout;
	unsigned int flags;
	void *driver_data;
	struct blk_mq_tags **tags;
	struct blk_mq_tags *shared_tags;
	struct mutex tag_list_lock;
	struct list_head tag_list;
};

struct dax_device;

struct iomap_page_ops;

struct iomap {
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	struct block_device *bdev;
	struct dax_device *dax_dev;
	void *inline_data;
	void *private;
	const struct iomap_page_ops *page_ops;
};

struct iomap_page_ops {
	int (*page_prepare)(struct inode *, loff_t, unsigned int);
	void (*page_done)(struct inode *, loff_t, unsigned int, struct page *);
};

struct blk_mq_hw_ctx {
	struct {
		spinlock_t lock;
		struct list_head dispatch;
		long unsigned int state;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct delayed_work run_work;
	cpumask_var_t cpumask;
	int next_cpu;
	int next_cpu_batch;
	long unsigned int flags;
	void *sched_data;
	struct request_queue *queue;
	struct blk_flush_queue *fq;
	void *driver_data;
	struct sbitmap ctx_map;
	struct blk_mq_ctx *dispatch_from;
	unsigned int dispatch_busy;
	short unsigned int type;
	short unsigned int nr_ctx;
	struct blk_mq_ctx **ctxs;
	spinlock_t dispatch_wait_lock;
	wait_queue_entry_t dispatch_wait;
	atomic_t wait_index;
	struct blk_mq_tags *tags;
	struct blk_mq_tags *sched_tags;
	long unsigned int queued;
	long unsigned int run;
	unsigned int numa_node;
	unsigned int queue_num;
	atomic_t nr_active;
	struct hlist_node cpuhp_online;
	struct hlist_node cpuhp_dead;
	struct kobject kobj;
	struct dentry *debugfs_dir;
	struct dentry *sched_debugfs_dir;
	struct list_head hctx_list;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum hctx_type {
	HCTX_TYPE_DEFAULT = 0,
	HCTX_TYPE_READ = 1,
	HCTX_TYPE_POLL = 2,
	HCTX_MAX_TYPES = 3,
};

struct blk_mq_queue_data {
	struct request *rq;
	bool last;
};

enum blktrace_act {
	__BLK_TA_QUEUE = 1,
	__BLK_TA_BACKMERGE = 2,
	__BLK_TA_FRONTMERGE = 3,
	__BLK_TA_GETRQ = 4,
	__BLK_TA_SLEEPRQ = 5,
	__BLK_TA_REQUEUE = 6,
	__BLK_TA_ISSUE = 7,
	__BLK_TA_COMPLETE = 8,
	__BLK_TA_PLUG = 9,
	__BLK_TA_UNPLUG_IO = 10,
	__BLK_TA_UNPLUG_TIMER = 11,
	__BLK_TA_INSERT = 12,
	__BLK_TA_SPLIT = 13,
	__BLK_TA_BOUNCE = 14,
	__BLK_TA_REMAP = 15,
	__BLK_TA_ABORT = 16,
	__BLK_TA_DRV_DATA = 17,
	__BLK_TA_CGROUP = 256,
};

struct decrypt_bh_ctx {
	struct work_struct work;
	struct buffer_head *bh;
};

struct bh_lru {
	struct buffer_head *bhs[16];
};

struct bh_accounting {
	int nr;
	int ratelimit;
};

typedef int dio_iodone_t(struct kiocb *, loff_t, ssize_t, void *);

typedef void dio_submit_t(struct bio *, struct inode *, loff_t);

enum {
	DIO_LOCKING = 1,
	DIO_SKIP_HOLES = 2,
};

struct dio_submit {
	struct bio *bio;
	unsigned int blkbits;
	unsigned int blkfactor;
	unsigned int start_zero_done;
	int pages_in_io;
	int: 32;
	sector_t block_in_file;
	unsigned int blocks_available;
	int reap_counter;
	sector_t final_block_in_request;
	int boundary;
	get_block_t *get_block;
	dio_submit_t *submit_io;
	int: 32;
	loff_t logical_offset_in_bio;
	sector_t final_block_in_bio;
	sector_t next_block_for_io;
	struct page *cur_page;
	unsigned int cur_page_offset;
	unsigned int cur_page_len;
	int: 32;
	sector_t cur_page_block;
	loff_t cur_page_fs_offset;
	struct iov_iter *iter;
	unsigned int head;
	unsigned int tail;
	size_t from;
	size_t to;
	int: 32;
};

struct dio {
	int flags;
	blk_opf_t opf;
	struct gendisk *bio_disk;
	struct inode *inode;
	loff_t i_size;
	dio_iodone_t *end_io;
	void *private;
	spinlock_t bio_lock;
	int page_errors;
	int is_async;
	bool defer_completion;
	bool should_dirty;
	int io_error;
	long unsigned int refcount;
	struct bio *bio_list;
	struct task_struct *waiter;
	struct kiocb *iocb;
	ssize_t result;
	union {
		struct page *pages[64];
		struct work_struct complete_work;
	};
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bvec_iter_all {
	struct bio_vec bv;
	int idx;
	unsigned int done;
};

struct mpage_readpage_args {
	struct bio *bio;
	struct folio *folio;
	unsigned int nr_pages;
	bool is_readahead;
	sector_t last_block_in_bio;
	struct buffer_head map_bh;
	long unsigned int first_logical_block;
	get_block_t *get_block;
};

struct mpage_data {
	struct bio *bio;
	int: 32;
	sector_t last_block_in_bio;
	get_block_t *get_block;
	int: 32;
};

typedef u32 nlink_t;

typedef int (*proc_write_t)(struct file *, char *, size_t);

struct proc_dir_entry {
	atomic_t in_use;
	refcount_t refcnt;
	struct list_head pde_openers;
	spinlock_t pde_unload_lock;
	struct completion *pde_unload_completion;
	const struct inode_operations *proc_iops;
	union {
		const struct proc_ops *proc_ops;
		const struct file_operations *proc_dir_ops;
	};
	const struct dentry_operations *proc_dops;
	union {
		const struct seq_operations *seq_ops;
		int (*single_show)(struct seq_file *, void *);
	};
	proc_write_t write;
	void *data;
	unsigned int state_size;
	unsigned int low_ino;
	nlink_t nlink;
	kuid_t uid;
	kgid_t gid;
	int: 32;
	loff_t size;
	struct proc_dir_entry *parent;
	struct rb_root subdir;
	struct rb_node subdir_node;
	char *name;
	umode_t mode;
	u8 flags;
	u8 namelen;
	char inline_name[0];
	int: 32;
};

union proc_op {
	int (*proc_get_link)(struct dentry *, struct path *);
	int (*proc_show)(struct seq_file *, struct pid_namespace *, struct pid *, struct task_struct *);
	const char *lsm;
};

struct proc_inode {
	struct pid *pid;
	unsigned int fd;
	union proc_op op;
	struct proc_dir_entry *pde;
	struct ctl_table_header *sysctl;
	struct ctl_table *sysctl_entry;
	struct hlist_node sibling_inodes;
	const struct proc_ns_operations *ns_ops;
	int: 32;
	struct inode vfs_inode;
};

struct proc_fs_opts {
	int flag;
	const char *str;
};

struct fsnotify_group;

struct fsnotify_iter_info;

struct fsnotify_mark;

struct fsnotify_event;

struct fsnotify_ops {
	int (*handle_event)(struct fsnotify_group *, u32, const void *, int, struct inode *, const struct qstr *, u32, struct fsnotify_iter_info *);
	int (*handle_inode_event)(struct fsnotify_mark *, u32, struct inode *, struct inode *, const struct qstr *, u32);
	void (*free_group_priv)(struct fsnotify_group *);
	void (*freeing_mark)(struct fsnotify_mark *, struct fsnotify_group *);
	void (*free_event)(struct fsnotify_group *, struct fsnotify_event *);
	void (*free_mark)(struct fsnotify_mark *);
};

struct inotify_group_private_data {
	spinlock_t idr_lock;
	struct idr idr;
	struct ucounts *ucounts;
};

struct fsnotify_group {
	const struct fsnotify_ops *ops;
	refcount_t refcnt;
	spinlock_t notification_lock;
	struct list_head notification_list;
	wait_queue_head_t notification_waitq;
	unsigned int q_len;
	unsigned int max_events;
	unsigned int priority;
	bool shutdown;
	int flags;
	unsigned int owner_flags;
	struct mutex mark_mutex;
	atomic_t user_waits;
	struct list_head marks_list;
	struct fasync_struct *fsn_fa;
	struct fsnotify_event *overflow_event;
	struct mem_cgroup *memcg;
	union {
		void *private;
		struct inotify_group_private_data inotify_data;
	};
};

struct fsnotify_iter_info {
	struct fsnotify_mark *marks[5];
	struct fsnotify_group *current_group;
	unsigned int report_mask;
	int srcu_idx;
};

struct fsnotify_mark {
	__u32 mask;
	refcount_t refcnt;
	struct fsnotify_group *group;
	struct list_head g_list;
	spinlock_t lock;
	struct hlist_node obj_list;
	struct fsnotify_mark_connector *connector;
	__u32 ignore_mask;
	unsigned int flags;
};

struct fsnotify_event {
	struct list_head list;
};

struct fs_error_report {
	int error;
	struct inode *inode;
	struct super_block *sb;
};

enum fsnotify_obj_type {
	FSNOTIFY_OBJ_TYPE_ANY = 4294967295,
	FSNOTIFY_OBJ_TYPE_INODE = 0,
	FSNOTIFY_OBJ_TYPE_VFSMOUNT = 1,
	FSNOTIFY_OBJ_TYPE_SB = 2,
	FSNOTIFY_OBJ_TYPE_COUNT = 3,
	FSNOTIFY_OBJ_TYPE_DETACHED = 3,
};

struct file_handle {
	__u32 handle_bytes;
	int handle_type;
	unsigned char f_handle[0];
};

struct inotify_inode_mark {
	struct fsnotify_mark fsn_mark;
	int wd;
};

struct dnotify_struct {
	struct dnotify_struct *dn_next;
	__u32 dn_mask;
	int dn_fd;
	struct file *dn_filp;
	fl_owner_t dn_owner;
};

struct dnotify_mark {
	struct fsnotify_mark fsn_mark;
	struct dnotify_struct *dn;
};

struct inotify_event_info {
	struct fsnotify_event fse;
	u32 mask;
	int wd;
	u32 sync_cookie;
	int name_len;
	char name[0];
};

struct inotify_event {
	__s32 wd;
	__u32 mask;
	__u32 cookie;
	__u32 len;
	char name[0];
};

struct epoll_event {
	__poll_t events;
	int: 32;
	__u64 data;
};

struct epoll_filefd {
	struct file *file;
	int fd;
};

struct epitem;

struct eppoll_entry {
	struct eppoll_entry *next;
	struct epitem *base;
	wait_queue_entry_t wait;
	wait_queue_head_t *whead;
};

struct eventpoll;

struct epitem {
	union {
		struct rb_node rbn;
		struct callback_head rcu;
	};
	struct list_head rdllink;
	struct epitem *next;
	struct epoll_filefd ffd;
	struct eppoll_entry *pwqlist;
	struct eventpoll *ep;
	struct hlist_node fllink;
	struct wakeup_source *ws;
	int: 32;
	struct epoll_event event;
};

struct eventpoll {
	struct mutex mtx;
	wait_queue_head_t wq;
	wait_queue_head_t poll_wait;
	struct list_head rdllist;
	rwlock_t lock;
	struct rb_root_cached rbr;
	struct epitem *ovflist;
	struct wakeup_source *ws;
	struct user_struct *user;
	struct file *file;
	u64 gen;
	struct hlist_head refs;
	unsigned int napi_id;
};

struct ep_pqueue {
	poll_table pt;
	struct epitem *epi;
};

struct epitems_head {
	struct hlist_head epitems;
	struct epitems_head *next;
};

struct signalfd_siginfo {
	__u32 ssi_signo;
	__s32 ssi_errno;
	__s32 ssi_code;
	__u32 ssi_pid;
	__u32 ssi_uid;
	__s32 ssi_fd;
	__u32 ssi_tid;
	__u32 ssi_band;
	__u32 ssi_overrun;
	__u32 ssi_trapno;
	__s32 ssi_status;
	__s32 ssi_int;
	__u64 ssi_ptr;
	__u64 ssi_utime;
	__u64 ssi_stime;
	__u64 ssi_addr;
	__u16 ssi_addr_lsb;
	__u16 __pad2;
	__s32 ssi_syscall;
	__u64 ssi_call_addr;
	__u32 ssi_arch;
	__u8 __pad[28];
};

struct signalfd_ctx {
	sigset_t sigmask;
};

struct timerfd_ctx {
	union {
		struct hrtimer tmr;
		struct alarm alarm;
	} t;
	ktime_t tintv;
	ktime_t moffs;
	wait_queue_head_t wqh;
	int: 32;
	u64 ticks;
	int clockid;
	short unsigned int expired;
	short unsigned int settime_flags;
	struct callback_head rcu;
	struct list_head clist;
	spinlock_t cancel_lock;
	bool might_cancel;
};

struct eventfd_ctx {
	struct kref kref;
	wait_queue_head_t wqh;
	__u64 count;
	unsigned int flags;
	int id;
};

struct kioctx;

struct kioctx_table {
	struct callback_head rcu;
	unsigned int nr;
	struct kioctx *table[0];
};

typedef __kernel_ulong_t aio_context_t;

enum {
	IOCB_CMD_PREAD = 0,
	IOCB_CMD_PWRITE = 1,
	IOCB_CMD_FSYNC = 2,
	IOCB_CMD_FDSYNC = 3,
	IOCB_CMD_POLL = 5,
	IOCB_CMD_NOOP = 6,
	IOCB_CMD_PREADV = 7,
	IOCB_CMD_PWRITEV = 8,
};

struct io_event {
	__u64 data;
	__u64 obj;
	__s64 res;
	__s64 res2;
};

struct iocb {
	__u64 aio_data;
	__u32 aio_key;
	__kernel_rwf_t aio_rw_flags;
	__u16 aio_lio_opcode;
	__s16 aio_reqprio;
	__u32 aio_fildes;
	__u64 aio_buf;
	__u64 aio_nbytes;
	__s64 aio_offset;
	__u64 aio_reserved2;
	__u32 aio_flags;
	__u32 aio_resfd;
};

typedef int kiocb_cancel_fn(struct kiocb *);

struct aio_ring {
	unsigned int id;
	unsigned int nr;
	unsigned int head;
	unsigned int tail;
	unsigned int magic;
	unsigned int compat_features;
	unsigned int incompat_features;
	unsigned int header_length;
	struct io_event io_events[0];
};

struct kioctx_cpu;

struct ctx_rq_wait;

struct kioctx {
	struct percpu_ref users;
	atomic_t dead;
	struct percpu_ref reqs;
	long unsigned int user_id;
	struct kioctx_cpu *cpu;
	unsigned int req_batch;
	unsigned int max_reqs;
	unsigned int nr_events;
	long unsigned int mmap_base;
	long unsigned int mmap_size;
	struct page **ring_pages;
	long int nr_pages;
	struct rcu_work free_rwork;
	struct ctx_rq_wait *rq_wait;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct {
		atomic_t reqs_available;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		spinlock_t ctx_lock;
		struct list_head active_reqs;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		struct mutex ring_lock;
		wait_queue_head_t wait;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct {
		unsigned int tail;
		unsigned int completed_events;
		spinlock_t completion_lock;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	struct page *internal_pages[8];
	struct file *aio_ring_file;
	unsigned int id;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct kioctx_cpu {
	unsigned int reqs_available;
};

struct ctx_rq_wait {
	struct completion comp;
	atomic_t count;
};

struct fsync_iocb {
	struct file *file;
	struct work_struct work;
	bool datasync;
	struct cred *creds;
};

struct poll_iocb {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	bool cancelled;
	bool work_scheduled;
	bool work_need_resched;
	struct wait_queue_entry wait;
	struct work_struct work;
};

struct aio_kiocb {
	union {
		struct file *ki_filp;
		struct kiocb rw;
		struct fsync_iocb fsync;
		struct poll_iocb poll;
	};
	struct kioctx *ki_ctx;
	kiocb_cancel_fn *ki_cancel;
	struct io_event ki_res;
	struct list_head ki_list;
	refcount_t ki_refcnt;
	struct eventfd_ctx *ki_eventfd;
};

struct aio_poll_table {
	struct poll_table_struct pt;
	struct aio_kiocb *iocb;
	bool queued;
	int error;
};

struct __aio_sigset {
	const sigset_t *sigmask;
	size_t sigsetsize;
};

struct trace_event_raw_locks_get_lock_context {
	struct trace_entry ent;
	long unsigned int i_ino;
	dev_t s_dev;
	unsigned char type;
	struct file_lock_context *ctx;
	char __data[0];
};

struct trace_event_raw_filelock_lock {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_pid;
	unsigned int fl_flags;
	unsigned char fl_type;
	loff_t fl_start;
	loff_t fl_end;
	int ret;
	char __data[0];
	int: 32;
};

struct trace_event_raw_filelock_lease {
	struct trace_entry ent;
	struct file_lock *fl;
	long unsigned int i_ino;
	dev_t s_dev;
	struct file_lock *fl_blocker;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	long unsigned int fl_break_time;
	long unsigned int fl_downgrade_time;
	char __data[0];
};

struct trace_event_raw_generic_add_lease {
	struct trace_entry ent;
	long unsigned int i_ino;
	int wcount;
	int rcount;
	int icount;
	dev_t s_dev;
	fl_owner_t fl_owner;
	unsigned int fl_flags;
	unsigned char fl_type;
	char __data[0];
};

struct trace_event_raw_leases_conflict {
	struct trace_entry ent;
	void *lease;
	void *breaker;
	unsigned int l_fl_flags;
	unsigned int b_fl_flags;
	unsigned char l_fl_type;
	unsigned char b_fl_type;
	bool conflict;
	char __data[0];
};

struct trace_event_data_offsets_locks_get_lock_context {};

struct trace_event_data_offsets_filelock_lock {};

struct trace_event_data_offsets_filelock_lease {};

struct trace_event_data_offsets_generic_add_lease {};

struct trace_event_data_offsets_leases_conflict {};

typedef void (*btf_trace_locks_get_lock_context)(void *, struct inode *, int, struct file_lock_context *);

typedef void (*btf_trace_posix_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_fcntl_setlk)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_locks_remove_posix)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_flock_lock_inode)(void *, struct inode *, struct file_lock *, int);

typedef void (*btf_trace_break_lease_noblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_block)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_break_lease_unblock)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_delete_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_time_out_leases)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_generic_add_lease)(void *, struct inode *, struct file_lock *);

typedef void (*btf_trace_leases_conflict)(void *, bool, struct file_lock *, struct file_lock *);

struct file_lock_list_struct {
	spinlock_t lock;
	struct hlist_head hlist;
};

struct locks_iterator {
	int li_cpu;
	int: 32;
	loff_t li_pos;
};

struct elf32_phdr {
	Elf32_Word p_type;
	Elf32_Off p_offset;
	Elf32_Addr p_vaddr;
	Elf32_Addr p_paddr;
	Elf32_Word p_filesz;
	Elf32_Word p_memsz;
	Elf32_Word p_flags;
	Elf32_Word p_align;
};

struct elf_prpsinfo {
	char pr_state;
	char pr_sname;
	char pr_zomb;
	char pr_nice;
	long unsigned int pr_flag;
	__kernel_uid_t pr_uid;
	__kernel_gid_t pr_gid;
	pid_t pr_pid;
	pid_t pr_ppid;
	pid_t pr_pgrp;
	pid_t pr_sid;
	char pr_fname[16];
	char pr_psargs[80];
};

struct arch_elf_state {};

struct memelfnote {
	const char *name;
	int type;
	unsigned int datasz;
	void *data;
};

struct elf_thread_core_info {
	struct elf_thread_core_info *next;
	struct task_struct *task;
	struct elf_prstatus prstatus;
	struct memelfnote notes[0];
};

struct elf_note_info {
	struct elf_thread_core_info *thread;
	struct memelfnote psinfo;
	struct memelfnote signote;
	struct memelfnote auxv;
	struct memelfnote files;
	siginfo_t csigdata;
	size_t size;
	int thread_notes;
};

struct mb_cache_entry {
	struct list_head e_list;
	struct hlist_bl_node e_hash_list;
	atomic_t e_refcnt;
	u32 e_key;
	u32 e_referenced: 1;
	u32 e_reusable: 1;
	int: 30;
	int: 32;
	u64 e_value;
};

struct mb_cache {
	struct hlist_bl_head *c_hash;
	int c_bucket_bits;
	long unsigned int c_max_entries;
	spinlock_t c_list_lock;
	struct list_head c_list;
	long unsigned int c_entry_count;
	struct shrinker c_shrink;
	struct work_struct c_shrink_work;
};

struct posix_acl_xattr_entry {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
};

struct posix_acl_xattr_header {
	__le32 a_version;
};

struct xdr_buf {
	struct kvec head[1];
	struct kvec tail[1];
	struct bio_vec *bvec;
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int flags;
	unsigned int buflen;
	unsigned int len;
};

struct xdr_array2_desc;

typedef int (*xdr_xcode_elem_t)(struct xdr_array2_desc *, void *);

struct xdr_array2_desc {
	unsigned int elem_size;
	unsigned int array_len;
	unsigned int array_maxlen;
	xdr_xcode_elem_t xcode;
};

struct rpc_rqst;

struct xdr_stream {
	__be32 *p;
	struct xdr_buf *buf;
	__be32 *end;
	struct kvec *iov;
	struct kvec scratch;
	struct page **page_ptr;
	unsigned int nwords;
	struct rpc_rqst *rqst;
};

struct nfsacl_encode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
	int typeflag;
	kuid_t uid;
	kgid_t gid;
};

struct nfsacl_simple_acl {
	struct posix_acl acl;
	struct posix_acl_entry ace[4];
};

struct nfsacl_decode_desc {
	struct xdr_array2_desc desc;
	unsigned int count;
	struct posix_acl *acl;
};

struct lock_manager {
	struct list_head list;
	bool block_opens;
};

struct net_generic {
	union {
		struct {
			unsigned int len;
			struct callback_head rcu;
		} s;
		struct {
			struct {			} __empty_ptr;
			void *ptr[0];
		};
	};
};

struct rpc_timer {
	struct list_head list;
	long unsigned int expires;
	struct delayed_work dwork;
};

struct rpc_wait_queue {
	spinlock_t lock;
	struct list_head tasks[4];
	unsigned char maxpriority;
	unsigned char priority;
	unsigned char nr;
	short unsigned int qlen;
	struct rpc_timer timer_list;
	const char *name;
};

struct nfs_seqid_counter {
	ktime_t create_time;
	int owner_id;
	int flags;
	u32 counter;
	spinlock_t lock;
	struct list_head list;
	struct rpc_wait_queue wait;
};

struct nfs4_stateid_struct {
	union {
		char data[16];
		struct {
			__be32 seqid;
			char other[12];
		};
	};
	enum {
		NFS4_INVALID_STATEID_TYPE = 0,
		NFS4_SPECIAL_STATEID_TYPE = 1,
		NFS4_OPEN_STATEID_TYPE = 2,
		NFS4_LOCK_STATEID_TYPE = 3,
		NFS4_DELEGATION_STATEID_TYPE = 4,
		NFS4_LAYOUT_STATEID_TYPE = 5,
		NFS4_PNFS_DS_STATEID_TYPE = 6,
		NFS4_REVOKED_STATEID_TYPE = 7,
	} type;
};

typedef struct nfs4_stateid_struct nfs4_stateid;

struct nfs4_state;

struct nfs4_lock_state {
	struct list_head ls_locks;
	struct nfs4_state *ls_state;
	long unsigned int ls_flags;
	struct nfs_seqid_counter ls_seqid;
	nfs4_stateid ls_stateid;
	refcount_t ls_count;
	fl_owner_t ls_owner;
	int: 32;
};

struct xdr_netobj {
	unsigned int len;
	u8 *data;
};

struct rpc_xprt;

struct rpc_task;

struct rpc_cred;

struct rpc_rqst {
	struct rpc_xprt *rq_xprt;
	struct xdr_buf rq_snd_buf;
	struct xdr_buf rq_rcv_buf;
	struct rpc_task *rq_task;
	struct rpc_cred *rq_cred;
	__be32 rq_xid;
	int rq_cong;
	u32 rq_seqno;
	int rq_enc_pages_num;
	struct page **rq_enc_pages;
	void (*rq_release_snd_buf)(struct rpc_rqst *);
	union {
		struct list_head rq_list;
		struct rb_node rq_recv;
	};
	struct list_head rq_xmit;
	struct list_head rq_xmit2;
	void *rq_buffer;
	size_t rq_callsize;
	void *rq_rbuffer;
	size_t rq_rcvsize;
	size_t rq_xmit_bytes_sent;
	size_t rq_reply_bytes_recvd;
	struct xdr_buf rq_private_buf;
	long unsigned int rq_majortimeo;
	long unsigned int rq_minortimeo;
	long unsigned int rq_timeout;
	ktime_t rq_rtt;
	unsigned int rq_retries;
	unsigned int rq_connect_cookie;
	atomic_t rq_pin;
	u32 rq_bytes_sent;
	ktime_t rq_xtime;
	int rq_ntrans;
	struct list_head rq_bc_list;
	long unsigned int rq_bc_pa_state;
	struct list_head rq_bc_pa_list;
};

typedef void (*kxdreproc_t)(struct rpc_rqst *, struct xdr_stream *, const void *);

typedef int (*kxdrdproc_t)(struct rpc_rqst *, struct xdr_stream *, void *);

struct rpc_procinfo;

struct rpc_message {
	const struct rpc_procinfo *rpc_proc;
	void *rpc_argp;
	void *rpc_resp;
	const struct cred *rpc_cred;
};

struct rpc_procinfo {
	u32 p_proc;
	kxdreproc_t p_encode;
	kxdrdproc_t p_decode;
	unsigned int p_arglen;
	unsigned int p_replen;
	unsigned int p_timer;
	u32 p_statidx;
	const char *p_name;
};

struct rpc_wait {
	struct list_head list;
	struct list_head links;
	struct list_head timer_list;
};

struct rpc_call_ops;

struct rpc_clnt;

struct rpc_task {
	atomic_t tk_count;
	int tk_status;
	struct list_head tk_task;
	void (*tk_callback)(struct rpc_task *);
	void (*tk_action)(struct rpc_task *);
	long unsigned int tk_timeout;
	long unsigned int tk_runstate;
	struct rpc_wait_queue *tk_waitqueue;
	union {
		struct work_struct tk_work;
		struct rpc_wait tk_wait;
	} u;
	struct rpc_message tk_msg;
	void *tk_calldata;
	const struct rpc_call_ops *tk_ops;
	struct rpc_clnt *tk_client;
	struct rpc_xprt *tk_xprt;
	struct rpc_cred *tk_op_cred;
	struct rpc_rqst *tk_rqstp;
	struct workqueue_struct *tk_workqueue;
	ktime_t tk_start;
	pid_t tk_owner;
	int tk_rpc_status;
	short unsigned int tk_flags;
	short unsigned int tk_timeouts;
	short unsigned int tk_pid;
	unsigned char tk_priority: 2;
	unsigned char tk_garb_retry: 2;
	unsigned char tk_cred_retry: 2;
	unsigned char tk_rebind_retry: 2;
};

struct rpc_call_ops {
	void (*rpc_call_prepare)(struct rpc_task *, void *);
	void (*rpc_call_done)(struct rpc_task *, void *);
	void (*rpc_count_stats)(struct rpc_task *, void *);
	void (*rpc_release)(void *);
};

struct rpc_pipe_dir_head {
	struct list_head pdh_entries;
	struct dentry *pdh_dentry;
};

struct rpc_rtt {
	long unsigned int timeo;
	long unsigned int srtt[5];
	long unsigned int sdrtt[5];
	int ntimeouts[5];
};

struct rpc_timeout {
	long unsigned int to_initval;
	long unsigned int to_maxval;
	long unsigned int to_increment;
	unsigned int to_retries;
	unsigned char to_exponential;
};

struct rpc_xprt_switch;

struct rpc_xprt_iter_ops;

struct rpc_xprt_iter {
	struct rpc_xprt_switch *xpi_xpswitch;
	struct rpc_xprt *xpi_cursor;
	const struct rpc_xprt_iter_ops *xpi_ops;
};

struct rpc_auth;

struct rpc_stat;

struct rpc_iostats;

struct rpc_program;

struct rpc_sysfs_client;

struct rpc_clnt {
	refcount_t cl_count;
	unsigned int cl_clid;
	struct list_head cl_clients;
	struct list_head cl_tasks;
	atomic_t cl_pid;
	spinlock_t cl_lock;
	struct rpc_xprt *cl_xprt;
	const struct rpc_procinfo *cl_procinfo;
	u32 cl_prog;
	u32 cl_vers;
	u32 cl_maxproc;
	struct rpc_auth *cl_auth;
	struct rpc_stat *cl_stats;
	struct rpc_iostats *cl_metrics;
	unsigned int cl_softrtry: 1;
	unsigned int cl_softerr: 1;
	unsigned int cl_discrtry: 1;
	unsigned int cl_noretranstimeo: 1;
	unsigned int cl_autobind: 1;
	unsigned int cl_chatty: 1;
	struct rpc_rtt *cl_rtt;
	const struct rpc_timeout *cl_timeout;
	atomic_t cl_swapper;
	int cl_nodelen;
	char cl_nodename[65];
	struct rpc_pipe_dir_head cl_pipedir_objects;
	struct rpc_clnt *cl_parent;
	struct rpc_rtt cl_rtt_default;
	struct rpc_timeout cl_timeout_default;
	const struct rpc_program *cl_program;
	const char *cl_principal;
	struct rpc_sysfs_client *cl_sysfs;
	union {
		struct rpc_xprt_iter cl_xpi;
		struct work_struct cl_work;
	};
	const struct cred *cl_cred;
	unsigned int cl_max_connect;
};

struct rpc_xprt_ops;

struct svc_xprt;

struct svc_serv;

struct xprt_class;

struct rpc_sysfs_xprt;

struct rpc_xprt {
	struct kref kref;
	const struct rpc_xprt_ops *ops;
	unsigned int id;
	const struct rpc_timeout *timeout;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	int prot;
	long unsigned int cong;
	long unsigned int cwnd;
	size_t max_payload;
	struct rpc_wait_queue binding;
	struct rpc_wait_queue sending;
	struct rpc_wait_queue pending;
	struct rpc_wait_queue backlog;
	struct list_head free;
	unsigned int max_reqs;
	unsigned int min_reqs;
	unsigned int num_reqs;
	long unsigned int state;
	unsigned char resvport: 1;
	unsigned char reuseport: 1;
	atomic_t swapper;
	unsigned int bind_index;
	struct list_head xprt_switch;
	long unsigned int bind_timeout;
	long unsigned int reestablish_timeout;
	unsigned int connect_cookie;
	struct work_struct task_cleanup;
	struct timer_list timer;
	long unsigned int last_used;
	long unsigned int idle_timeout;
	long unsigned int connect_timeout;
	long unsigned int max_reconnect_timeout;
	atomic_long_t queuelen;
	spinlock_t transport_lock;
	spinlock_t reserve_lock;
	spinlock_t queue_lock;
	u32 xid;
	struct rpc_task *snd_task;
	struct list_head xmit_queue;
	atomic_long_t xmit_queuelen;
	struct svc_xprt *bc_xprt;
	struct svc_serv *bc_serv;
	unsigned int bc_alloc_max;
	unsigned int bc_alloc_count;
	atomic_t bc_slot_count;
	spinlock_t bc_pa_lock;
	struct list_head bc_pa_list;
	struct rb_root recv_queue;
	struct {
		long unsigned int bind_count;
		long unsigned int connect_count;
		long unsigned int connect_start;
		long unsigned int connect_time;
		long unsigned int sends;
		long unsigned int recvs;
		long unsigned int bad_xids;
		long unsigned int max_slots;
		long long unsigned int req_u;
		long long unsigned int bklog_u;
		long long unsigned int sending_u;
		long long unsigned int pending_u;
	} stat;
	struct net *xprt_net;
	netns_tracker ns_tracker;
	const char *servername;
	const char *address_strings[6];
	struct callback_head rcu;
	const struct xprt_class *xprt_class;
	struct rpc_sysfs_xprt *xprt_sysfs;
	bool main;
	int: 24;
	int: 32;
};

struct rpc_credops;

struct rpc_cred {
	struct hlist_node cr_hash;
	struct list_head cr_lru;
	struct callback_head cr_rcu;
	struct rpc_auth *cr_auth;
	const struct rpc_credops *cr_ops;
	long unsigned int cr_expire;
	long unsigned int cr_flags;
	refcount_t cr_count;
	const struct cred *cr_cred;
};

typedef u32 rpc_authflavor_t;

struct auth_cred {
	const struct cred *cred;
	const char *principal;
};

struct rpc_authops;

struct rpc_cred_cache;

struct rpc_auth {
	unsigned int au_cslack;
	unsigned int au_rslack;
	unsigned int au_verfsize;
	unsigned int au_ralign;
	long unsigned int au_flags;
	const struct rpc_authops *au_ops;
	rpc_authflavor_t au_flavor;
	refcount_t au_count;
	struct rpc_cred_cache *au_credcache;
};

struct rpc_credops {
	const char *cr_name;
	int (*cr_init)(struct rpc_auth *, struct rpc_cred *);
	void (*crdestroy)(struct rpc_cred *);
	int (*crmatch)(struct auth_cred *, struct rpc_cred *, int);
	int (*crmarshal)(struct rpc_task *, struct xdr_stream *);
	int (*crrefresh)(struct rpc_task *);
	int (*crvalidate)(struct rpc_task *, struct xdr_stream *);
	int (*crwrap_req)(struct rpc_task *, struct xdr_stream *);
	int (*crunwrap_resp)(struct rpc_task *, struct xdr_stream *);
	int (*crkey_timeout)(struct rpc_cred *);
	char * (*crstringify_acceptor)(struct rpc_cred *);
	bool (*crneed_reencode)(struct rpc_task *);
};

struct rpc_auth_create_args;

struct rpcsec_gss_info;

struct rpc_authops {
	struct module *owner;
	rpc_authflavor_t au_flavor;
	char *au_name;
	struct rpc_auth * (*create)(const struct rpc_auth_create_args *, struct rpc_clnt *);
	void (*destroy)(struct rpc_auth *);
	int (*hash_cred)(struct auth_cred *, unsigned int);
	struct rpc_cred * (*lookup_cred)(struct rpc_auth *, struct auth_cred *, int);
	struct rpc_cred * (*crcreate)(struct rpc_auth *, struct auth_cred *, int, gfp_t);
	rpc_authflavor_t (*info2flavor)(struct rpcsec_gss_info *);
	int (*flavor2info)(rpc_authflavor_t, struct rpcsec_gss_info *);
	int (*key_timeout)(struct rpc_auth *, struct rpc_cred *);
};

struct rpc_auth_create_args {
	rpc_authflavor_t pseudoflavor;
	const char *target_name;
};

struct rpcsec_gss_oid {
	unsigned int len;
	u8 data[32];
};

struct rpcsec_gss_info {
	struct rpcsec_gss_oid oid;
	u32 qop;
	u32 service;
};

struct rpc_xprt_ops {
	void (*set_buffer_size)(struct rpc_xprt *, size_t, size_t);
	int (*reserve_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*release_xprt)(struct rpc_xprt *, struct rpc_task *);
	void (*alloc_slot)(struct rpc_xprt *, struct rpc_task *);
	void (*free_slot)(struct rpc_xprt *, struct rpc_rqst *);
	void (*rpcbind)(struct rpc_task *);
	void (*set_port)(struct rpc_xprt *, short unsigned int);
	void (*connect)(struct rpc_xprt *, struct rpc_task *);
	int (*get_srcaddr)(struct rpc_xprt *, char *, size_t);
	short unsigned int (*get_srcport)(struct rpc_xprt *);
	int (*buf_alloc)(struct rpc_task *);
	void (*buf_free)(struct rpc_task *);
	int (*prepare_request)(struct rpc_rqst *, struct xdr_buf *);
	int (*send_request)(struct rpc_rqst *);
	void (*wait_for_reply_request)(struct rpc_task *);
	void (*timer)(struct rpc_xprt *, struct rpc_task *);
	void (*release_request)(struct rpc_task *);
	void (*close)(struct rpc_xprt *);
	void (*destroy)(struct rpc_xprt *);
	void (*set_connect_timeout)(struct rpc_xprt *, long unsigned int, long unsigned int);
	void (*print_stats)(struct rpc_xprt *, struct seq_file *);
	int (*enable_swap)(struct rpc_xprt *);
	void (*disable_swap)(struct rpc_xprt *);
	void (*inject_disconnect)(struct rpc_xprt *);
	int (*bc_setup)(struct rpc_xprt *, unsigned int);
	size_t (*bc_maxpayload)(struct rpc_xprt *);
	unsigned int (*bc_num_slots)(struct rpc_xprt *);
	void (*bc_free_rqst)(struct rpc_rqst *);
	void (*bc_destroy)(struct rpc_xprt *, unsigned int);
};

struct svc_program;

struct svc_stat;

struct svc_pool;

struct svc_serv {
	struct svc_program *sv_program;
	struct svc_stat *sv_stats;
	spinlock_t sv_lock;
	struct kref sv_refcnt;
	unsigned int sv_nrthreads;
	unsigned int sv_maxconn;
	unsigned int sv_max_payload;
	unsigned int sv_max_mesg;
	unsigned int sv_xdrsize;
	struct list_head sv_permsocks;
	struct list_head sv_tempsocks;
	int sv_tmpcnt;
	struct timer_list sv_temptimer;
	char *sv_name;
	unsigned int sv_nrpools;
	struct svc_pool *sv_pools;
	int (*sv_threadfn)(void *);
	struct list_head sv_cb_list;
	spinlock_t sv_cb_lock;
	wait_queue_head_t sv_cb_waitq;
	bool sv_bc_enabled;
};

struct xprt_create;

struct xprt_class {
	struct list_head list;
	int ident;
	struct rpc_xprt * (*setup)(struct xprt_create *);
	struct module *owner;
	char name[32];
	const char *netid[0];
};

struct xprt_create {
	int ident;
	struct net *net;
	struct sockaddr *srcaddr;
	struct sockaddr *dstaddr;
	size_t addrlen;
	const char *servername;
	struct svc_xprt *bc_xprt;
	struct rpc_xprt_switch *bc_xps;
	unsigned int flags;
};

struct rpc_sysfs_xprt_switch;

struct rpc_xprt_switch {
	spinlock_t xps_lock;
	struct kref xps_kref;
	unsigned int xps_id;
	unsigned int xps_nxprts;
	unsigned int xps_nactive;
	unsigned int xps_nunique_destaddr_xprts;
	atomic_long_t xps_queuelen;
	struct list_head xps_xprt_list;
	struct net *xps_net;
	const struct rpc_xprt_iter_ops *xps_iter_ops;
	struct rpc_sysfs_xprt_switch *xps_sysfs;
	struct callback_head xps_rcu;
};

struct rpc_stat {
	const struct rpc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int netreconn;
	unsigned int rpccnt;
	unsigned int rpcretrans;
	unsigned int rpcauthrefresh;
	unsigned int rpcgarbage;
};

struct rpc_version;

struct rpc_program {
	const char *name;
	u32 number;
	unsigned int nrvers;
	const struct rpc_version **version;
	struct rpc_stat *stats;
	const char *pipe_dir_name;
};

struct svc_stat {
	struct svc_program *program;
	unsigned int netcnt;
	unsigned int netudpcnt;
	unsigned int nettcpcnt;
	unsigned int nettcpconn;
	unsigned int rpccnt;
	unsigned int rpcbadfmt;
	unsigned int rpcbadauth;
	unsigned int rpcbadclnt;
};

struct svc_version;

struct svc_rqst;

struct svc_process_info;

struct svc_program {
	struct svc_program *pg_next;
	u32 pg_prog;
	unsigned int pg_lovers;
	unsigned int pg_hivers;
	unsigned int pg_nvers;
	const struct svc_version **pg_vers;
	char *pg_name;
	char *pg_class;
	struct svc_stat *pg_stats;
	int (*pg_authenticate)(struct svc_rqst *);
	__be32 (*pg_init_request)(struct svc_rqst *, const struct svc_program *, struct svc_process_info *);
	int (*pg_rpcbind_set)(struct net *, const struct svc_program *, u32, int, short unsigned int, short unsigned int);
};

struct rpc_xprt_iter_ops {
	void (*xpi_rewind)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_xprt)(struct rpc_xprt_iter *);
	struct rpc_xprt * (*xpi_next)(struct rpc_xprt_iter *);
};

struct rpc_version {
	u32 number;
	unsigned int nrprocs;
	const struct rpc_procinfo *procs;
	unsigned int *counts;
};

struct nfs_fh {
	short unsigned int size;
	unsigned char data[128];
};

enum nfs3_stable_how {
	NFS_UNSTABLE = 0,
	NFS_DATA_SYNC = 1,
	NFS_FILE_SYNC = 2,
	NFS_INVALID_STABLE_HOW = 4294967295,
};

struct nfs4_label {
	uint32_t lfs;
	uint32_t pi;
	u32 len;
	char *label;
};

typedef struct {
	char data[8];
} nfs4_verifier;

enum nfs4_change_attr_type {
	NFS4_CHANGE_TYPE_IS_MONOTONIC_INCR = 0,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER = 1,
	NFS4_CHANGE_TYPE_IS_VERSION_COUNTER_NOPNFS = 2,
	NFS4_CHANGE_TYPE_IS_TIME_METADATA = 3,
	NFS4_CHANGE_TYPE_IS_UNDEFINED = 4,
};

struct gss_api_mech;

struct gss_ctx {
	struct gss_api_mech *mech_type;
	void *internal_ctx_id;
	unsigned int slack;
	unsigned int align;
};

struct gss_api_ops;

struct pf_desc;

struct gss_api_mech {
	struct list_head gm_list;
	struct module *gm_owner;
	struct rpcsec_gss_oid gm_oid;
	char *gm_name;
	const struct gss_api_ops *gm_ops;
	int gm_pf_num;
	struct pf_desc *gm_pfs;
	const char *gm_upcall_enctypes;
};

struct auth_domain;

struct pf_desc {
	u32 pseudoflavor;
	u32 qop;
	u32 service;
	char *name;
	char *auth_domain_name;
	struct auth_domain *domain;
	bool datatouch;
};

struct auth_ops;

struct auth_domain {
	struct kref ref;
	struct hlist_node hash;
	char *name;
	struct auth_ops *flavour;
	struct callback_head callback_head;
};

struct gss_api_ops {
	int (*gss_import_sec_context)(const void *, size_t, struct gss_ctx *, time64_t *, gfp_t);
	u32 (*gss_get_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_verify_mic)(struct gss_ctx *, struct xdr_buf *, struct xdr_netobj *);
	u32 (*gss_wrap)(struct gss_ctx *, int, struct xdr_buf *, struct page **);
	u32 (*gss_unwrap)(struct gss_ctx *, int, int, struct xdr_buf *);
	void (*gss_delete_sec_context)(void *);
};

struct nfs4_string {
	unsigned int len;
	char *data;
};

struct nfs_fsid {
	uint64_t major;
	uint64_t minor;
};

struct nfs4_threshold {
	__u32 bm;
	__u32 l_type;
	__u64 rd_sz;
	__u64 wr_sz;
	__u64 rd_io_sz;
	__u64 wr_io_sz;
};

struct nfs_fattr {
	unsigned int valid;
	umode_t mode;
	__u32 nlink;
	kuid_t uid;
	kgid_t gid;
	dev_t rdev;
	__u64 size;
	union {
		struct {
			__u32 blocksize;
			__u32 blocks;
		} nfs2;
		struct {
			__u64 used;
		} nfs3;
	} du;
	struct nfs_fsid fsid;
	__u64 fileid;
	__u64 mounted_on_fileid;
	struct timespec64 atime;
	struct timespec64 mtime;
	struct timespec64 ctime;
	__u64 change_attr;
	__u64 pre_change_attr;
	__u64 pre_size;
	struct timespec64 pre_mtime;
	struct timespec64 pre_ctime;
	long unsigned int time_start;
	long unsigned int gencount;
	struct nfs4_string *owner_name;
	struct nfs4_string *group_name;
	struct nfs4_threshold *mdsthreshold;
	struct nfs4_label *label;
};

struct nfs_fsinfo {
	struct nfs_fattr *fattr;
	__u32 rtmax;
	__u32 rtpref;
	__u32 rtmult;
	__u32 wtmax;
	__u32 wtpref;
	__u32 wtmult;
	__u32 dtpref;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	__u32 lease_time;
	__u32 nlayouttypes;
	__u32 layouttype[8];
	__u32 blksize;
	__u32 clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	__u32 xattr_support;
};

struct nfs_fsstat {
	struct nfs_fattr *fattr;
	int: 32;
	__u64 tbytes;
	__u64 fbytes;
	__u64 abytes;
	__u64 tfiles;
	__u64 ffiles;
	__u64 afiles;
};

struct nfs_pathconf {
	struct nfs_fattr *fattr;
	__u32 max_link;
	__u32 max_namelen;
};

struct nfs4_change_info {
	u32 atomic;
	int: 32;
	u64 before;
	u64 after;
};

struct nfs4_slot;

struct nfs4_sequence_args {
	struct nfs4_slot *sa_slot;
	u8 sa_cache_this: 1;
	u8 sa_privileged: 1;
};

struct nfs4_sequence_res {
	struct nfs4_slot *sr_slot;
	long unsigned int sr_timestamp;
	int sr_status;
	u32 sr_status_flags;
	u32 sr_highest_slotid;
	u32 sr_target_highest_slotid;
};

struct nfs_open_context;

struct nfs_lock_context {
	refcount_t count;
	struct list_head list;
	struct nfs_open_context *open_context;
	fl_owner_t lockowner;
	atomic_t io_count;
	struct callback_head callback_head;
};

struct nfs_open_context {
	struct nfs_lock_context lock_context;
	fl_owner_t flock_owner;
	struct dentry *dentry;
	const struct cred *cred;
	struct rpc_cred *ll_cred;
	struct nfs4_state *state;
	fmode_t mode;
	long unsigned int flags;
	int error;
	struct list_head list;
	struct nfs4_threshold *mdsthreshold;
	struct callback_head callback_head;
};

struct nlm_host;

struct nfs_auth_info {
	unsigned int flavor_len;
	rpc_authflavor_t flavors[12];
};

struct nfs_client;

struct nfs_iostats;

struct pnfs_layoutdriver_type;

struct nfs_server {
	struct nfs_client *nfs_client;
	struct list_head client_link;
	struct list_head master_link;
	struct rpc_clnt *client;
	struct rpc_clnt *client_acl;
	struct nlm_host *nlm_host;
	struct nfs_iostats *io_stats;
	atomic_long_t writeback;
	unsigned int write_congested;
	unsigned int flags;
	unsigned int fattr_valid;
	unsigned int caps;
	unsigned int rsize;
	unsigned int rpages;
	unsigned int wsize;
	unsigned int wpages;
	unsigned int wtmult;
	unsigned int dtsize;
	short unsigned int port;
	unsigned int bsize;
	unsigned int gxasize;
	unsigned int sxasize;
	unsigned int lxasize;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namelen;
	unsigned int options;
	unsigned int clone_blksize;
	enum nfs4_change_attr_type change_attr_type;
	int: 32;
	struct nfs_fsid fsid;
	__u64 maxfilesize;
	struct timespec64 time_delta;
	long unsigned int mount_time;
	struct super_block *super;
	dev_t s_dev;
	struct nfs_auth_info auth_info;
	u32 pnfs_blksize;
	u32 attr_bitmask[3];
	u32 attr_bitmask_nl[3];
	u32 exclcreat_bitmask[3];
	u32 cache_consistency_bitmask[3];
	u32 acl_bitmask;
	u32 fh_expire_type;
	struct pnfs_layoutdriver_type *pnfs_curr_ld;
	struct rpc_wait_queue roc_rpcwaitq;
	void *pnfs_ld_data;
	struct rb_root state_owners;
	struct ida openowner_id;
	struct ida lockowner_id;
	struct list_head state_owners_lru;
	struct list_head layouts;
	struct list_head delegations;
	struct list_head ss_copies;
	long unsigned int mig_gen;
	long unsigned int mig_status;
	void (*destroy)(struct nfs_server *);
	atomic_t active;
	struct __kernel_sockaddr_storage mountd_address;
	size_t mountd_addrlen;
	u32 mountd_version;
	short unsigned int mountd_port;
	short unsigned int mountd_protocol;
	struct rpc_wait_queue uoc_rpcwaitq;
	unsigned int read_hdrsize;
	const struct cred *cred;
	bool has_sec_mnt_opts;
};

struct nfs_rpc_ops;

struct nfs_subversion;

struct idmap;

struct nfs4_minor_version_ops;

struct nfs4_slot_table;

struct nfs4_session;

struct nfs41_server_owner;

struct nfs41_server_scope;

struct nfs41_impl_id;

struct nfs_client {
	refcount_t cl_count;
	atomic_t cl_mds_count;
	int cl_cons_state;
	long unsigned int cl_res_state;
	long unsigned int cl_flags;
	struct __kernel_sockaddr_storage cl_addr;
	size_t cl_addrlen;
	char *cl_hostname;
	char *cl_acceptor;
	struct list_head cl_share_link;
	struct list_head cl_superblocks;
	struct rpc_clnt *cl_rpcclient;
	const struct nfs_rpc_ops *rpc_ops;
	int cl_proto;
	struct nfs_subversion *cl_nfs_mod;
	u32 cl_minorversion;
	unsigned int cl_nconnect;
	unsigned int cl_max_connect;
	const char *cl_principal;
	struct list_head cl_ds_clients;
	u64 cl_clientid;
	nfs4_verifier cl_confirm;
	long unsigned int cl_state;
	spinlock_t cl_lock;
	long unsigned int cl_lease_time;
	long unsigned int cl_last_renewal;
	struct delayed_work cl_renewd;
	struct rpc_wait_queue cl_rpcwaitq;
	struct idmap *cl_idmap;
	const char *cl_owner_id;
	u32 cl_cb_ident;
	const struct nfs4_minor_version_ops *cl_mvops;
	long unsigned int cl_mig_gen;
	struct nfs4_slot_table *cl_slot_tbl;
	u32 cl_seqid;
	u32 cl_exchange_flags;
	struct nfs4_session *cl_session;
	bool cl_preserve_clid;
	struct nfs41_server_owner *cl_serverowner;
	struct nfs41_server_scope *cl_serverscope;
	struct nfs41_impl_id *cl_implid;
	long unsigned int cl_sp4_flags;
	wait_queue_head_t cl_lock_waitq;
	char cl_ipaddr[48];
	struct net *cl_net;
	struct list_head pending_cb_stateids;
	int: 32;
};

struct nfs_seqid {
	struct nfs_seqid_counter *sequence;
	struct list_head list;
	struct rpc_task *task;
};

struct nfs_write_verifier {
	char data[8];
};

struct nfs_writeverf {
	struct nfs_write_verifier verifier;
	enum nfs3_stable_how committed;
};

struct nfs_pgio_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct nfs_open_context *context;
	struct nfs_lock_context *lock_context;
	nfs4_stateid stateid;
	__u64 offset;
	__u32 count;
	unsigned int pgbase;
	struct page **pages;
	union {
		unsigned int replen;
		struct {
			const u32 *bitmask;
			u32 bitmask_store[3];
			enum nfs3_stable_how stable;
		};
	};
};

struct nfs_pgio_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	int: 32;
	__u64 count;
	__u32 op_status;
	union {
		struct {
			unsigned int replen;
			int eof;
		};
		struct {
			struct nfs_writeverf *verf;
			const struct nfs_server *server;
		};
	};
	int: 32;
};

struct nfs_commitargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	int: 32;
	__u64 offset;
	__u32 count;
	const u32 *bitmask;
};

struct nfs_commitres {
	struct nfs4_sequence_res seq_res;
	__u32 op_status;
	struct nfs_fattr *fattr;
	struct nfs_writeverf *verf;
	const struct nfs_server *server;
};

struct nfs_removeargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	int: 32;
	struct qstr name;
};

struct nfs_removeres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	struct nfs_fattr *dir_attr;
	struct nfs4_change_info cinfo;
};

struct nfs_renameargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *old_dir;
	const struct nfs_fh *new_dir;
	const struct qstr *old_name;
	const struct qstr *new_name;
};

struct nfs_renameres {
	struct nfs4_sequence_res seq_res;
	struct nfs_server *server;
	int: 32;
	struct nfs4_change_info old_cinfo;
	struct nfs_fattr *old_fattr;
	int: 32;
	struct nfs4_change_info new_cinfo;
	struct nfs_fattr *new_fattr;
	int: 32;
};

struct nfs_entry {
	__u64 ino;
	__u64 cookie;
	const char *name;
	unsigned int len;
	int eof;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	unsigned char d_type;
	struct nfs_server *server;
	int: 32;
};

struct nfs_readdir_arg {
	struct dentry *dentry;
	const struct cred *cred;
	__be32 *verf;
	int: 32;
	u64 cookie;
	struct page **pages;
	unsigned int page_len;
	bool plus;
	int: 24;
	int: 32;
};

struct nfs_readdir_res {
	__be32 *verf;
};

struct nfs4_pathname {
	unsigned int ncomponents;
	struct nfs4_string components[512];
};

struct nfs4_fs_location {
	unsigned int nservers;
	struct nfs4_string servers[10];
	struct nfs4_pathname rootpath;
};

struct nfs4_fs_locations {
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
	struct nfs4_pathname fs_path;
	int nlocations;
	struct nfs4_fs_location locations[10];
};

struct nfstime4 {
	u64 seconds;
	u32 nseconds;
	int: 32;
};

struct pnfs_commit_ops;

struct pnfs_ds_commit_info {
	struct list_head commits;
	unsigned int nwritten;
	unsigned int ncommitting;
	const struct pnfs_commit_ops *ops;
};

struct pnfs_layout_segment;

struct nfs_commit_info;

struct nfs_page;

struct pnfs_commit_ops {
	void (*setup_ds_info)(struct pnfs_ds_commit_info *, struct pnfs_layout_segment *);
	void (*release_ds_info)(struct pnfs_ds_commit_info *, struct inode *);
	int (*commit_pagelist)(struct inode *, struct list_head *, int, struct nfs_commit_info *);
	void (*mark_request_commit)(struct nfs_page *, struct pnfs_layout_segment *, struct nfs_commit_info *, u32);
	void (*clear_request_commit)(struct nfs_page *, struct nfs_commit_info *);
	int (*scan_commit_lists)(struct nfs_commit_info *, int);
	void (*recover_commit_reqs)(struct list_head *, struct nfs_commit_info *);
	struct nfs_page * (*search_commit_reqs)(struct nfs_commit_info *, struct page *);
};

struct nfs41_server_owner {
	uint64_t minor_id;
	uint32_t major_id_sz;
	char major_id[1024];
	int: 32;
};

struct nfs41_server_scope {
	uint32_t server_scope_sz;
	char server_scope[1024];
};

struct nfs41_impl_id {
	char domain[1025];
	char name[1025];
	int: 16;
	int: 32;
	struct nfstime4 date;
};

struct nfs_page_array {
	struct page **pagevec;
	unsigned int npages;
	struct page *page_array[8];
};

struct nfs_pgio_completion_ops;

struct nfs_rw_ops;

struct nfs_io_completion;

struct nfs_direct_req;

struct nfs_pgio_header {
	struct inode *inode;
	const struct cred *cred;
	struct list_head pages;
	struct nfs_page *req;
	struct nfs_writeverf verf;
	fmode_t rw_mode;
	struct pnfs_layout_segment *lseg;
	loff_t io_start;
	const struct rpc_call_ops *mds_ops;
	void (*release)(struct nfs_pgio_header *);
	const struct nfs_pgio_completion_ops *completion_ops;
	const struct nfs_rw_ops *rw_ops;
	struct nfs_io_completion *io_completion;
	struct nfs_direct_req *dreq;
	int pnfs_error;
	int error;
	unsigned int good_bytes;
	long unsigned int flags;
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct nfs_pgio_args args;
	struct nfs_pgio_res res;
	long unsigned int timestamp;
	int (*pgio_done_cb)(struct rpc_task *, struct nfs_pgio_header *);
	__u64 mds_offset;
	struct nfs_page_array page_array;
	struct nfs_client *ds_clp;
	u32 ds_commit_idx;
	u32 pgio_mirror_idx;
	int: 32;
};

struct nfs_pgio_completion_ops {
	void (*error_cleanup)(struct list_head *, int);
	void (*init_hdr)(struct nfs_pgio_header *);
	void (*completion)(struct nfs_pgio_header *);
	void (*reschedule_io)(struct nfs_pgio_header *);
};

struct rpc_task_setup;

struct nfs_rw_ops {
	struct nfs_pgio_header * (*rw_alloc_header)();
	void (*rw_free_header)(struct nfs_pgio_header *);
	int (*rw_done)(struct rpc_task *, struct nfs_pgio_header *, struct inode *);
	void (*rw_result)(struct rpc_task *, struct nfs_pgio_header *);
	void (*rw_initiate)(struct nfs_pgio_header *, struct rpc_message *, const struct nfs_rpc_ops *, struct rpc_task_setup *, int);
};

struct nfs_mds_commit_info {
	atomic_t rpcs_out;
	atomic_long_t ncommit;
	struct list_head list;
};

struct nfs_commit_data;

struct nfs_commit_completion_ops {
	void (*completion)(struct nfs_commit_data *);
	void (*resched_write)(struct nfs_commit_info *, struct nfs_page *);
};

struct nfs_commit_data {
	struct rpc_task task;
	struct inode *inode;
	const struct cred *cred;
	struct nfs_fattr fattr;
	struct nfs_writeverf verf;
	struct list_head pages;
	struct list_head list;
	struct nfs_direct_req *dreq;
	struct nfs_commitargs args;
	struct nfs_commitres res;
	struct nfs_open_context *context;
	struct pnfs_layout_segment *lseg;
	struct nfs_client *ds_clp;
	int ds_commit_index;
	loff_t lwb;
	const struct rpc_call_ops *mds_ops;
	const struct nfs_commit_completion_ops *completion_ops;
	int (*commit_done_cb)(struct rpc_task *, struct nfs_commit_data *);
	long unsigned int flags;
};

struct nfs_commit_info {
	struct inode *inode;
	struct nfs_mds_commit_info *mds;
	struct pnfs_ds_commit_info *ds;
	struct nfs_direct_req *dreq;
	const struct nfs_commit_completion_ops *completion_ops;
};

struct nfs_unlinkdata {
	struct nfs_removeargs args;
	struct nfs_removeres res;
	struct dentry *dentry;
	wait_queue_head_t wq;
	const struct cred *cred;
	int: 32;
	struct nfs_fattr dir_attr;
	long int timeout;
	int: 32;
};

struct nfs_renamedata {
	struct nfs_renameargs args;
	struct nfs_renameres res;
	struct rpc_task task;
	const struct cred *cred;
	struct inode *old_dir;
	struct dentry *old_dentry;
	int: 32;
	struct nfs_fattr old_fattr;
	struct inode *new_dir;
	struct dentry *new_dentry;
	struct nfs_fattr new_fattr;
	void (*complete)(struct rpc_task *, struct nfs_renamedata *);
	long int timeout;
	bool cancelled;
	int: 24;
	int: 32;
};

struct nlmclnt_operations;

struct nfs_access_entry;

struct nfs_client_initdata;

struct nfs_rpc_ops {
	u32 version;
	const struct dentry_operations *dentry_ops;
	const struct inode_operations *dir_inode_ops;
	const struct inode_operations *file_inode_ops;
	const struct file_operations *file_ops;
	const struct nlmclnt_operations *nlmclnt_ops;
	int (*getroot)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*submount)(struct fs_context *, struct nfs_server *);
	int (*try_get_tree)(struct fs_context *);
	int (*getattr)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, struct inode *);
	int (*setattr)(struct dentry *, struct nfs_fattr *, struct iattr *);
	int (*lookup)(struct inode *, struct dentry *, struct nfs_fh *, struct nfs_fattr *);
	int (*lookupp)(struct inode *, struct nfs_fh *, struct nfs_fattr *);
	int (*access)(struct inode *, struct nfs_access_entry *, const struct cred *);
	int (*readlink)(struct inode *, struct page *, unsigned int, unsigned int);
	int (*create)(struct inode *, struct dentry *, struct iattr *, int);
	int (*remove)(struct inode *, struct dentry *);
	void (*unlink_setup)(struct rpc_message *, struct dentry *, struct inode *);
	void (*unlink_rpc_prepare)(struct rpc_task *, struct nfs_unlinkdata *);
	int (*unlink_done)(struct rpc_task *, struct inode *);
	void (*rename_setup)(struct rpc_message *, struct dentry *, struct dentry *);
	void (*rename_rpc_prepare)(struct rpc_task *, struct nfs_renamedata *);
	int (*rename_done)(struct rpc_task *, struct inode *, struct inode *);
	int (*link)(struct inode *, struct inode *, const struct qstr *);
	int (*symlink)(struct inode *, struct dentry *, struct page *, unsigned int, struct iattr *);
	int (*mkdir)(struct inode *, struct dentry *, struct iattr *);
	int (*rmdir)(struct inode *, const struct qstr *);
	int (*readdir)(struct nfs_readdir_arg *, struct nfs_readdir_res *);
	int (*mknod)(struct inode *, struct dentry *, struct iattr *, dev_t);
	int (*statfs)(struct nfs_server *, struct nfs_fh *, struct nfs_fsstat *);
	int (*fsinfo)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	int (*pathconf)(struct nfs_server *, struct nfs_fh *, struct nfs_pathconf *);
	int (*set_capabilities)(struct nfs_server *, struct nfs_fh *);
	int (*decode_dirent)(struct xdr_stream *, struct nfs_entry *, bool);
	int (*pgio_rpc_prepare)(struct rpc_task *, struct nfs_pgio_header *);
	void (*read_setup)(struct nfs_pgio_header *, struct rpc_message *);
	int (*read_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*write_setup)(struct nfs_pgio_header *, struct rpc_message *, struct rpc_clnt **);
	int (*write_done)(struct rpc_task *, struct nfs_pgio_header *);
	void (*commit_setup)(struct nfs_commit_data *, struct rpc_message *, struct rpc_clnt **);
	void (*commit_rpc_prepare)(struct rpc_task *, struct nfs_commit_data *);
	int (*commit_done)(struct rpc_task *, struct nfs_commit_data *);
	int (*lock)(struct file *, int, struct file_lock *);
	int (*lock_check_bounds)(const struct file_lock *);
	void (*clear_acl_cache)(struct inode *);
	void (*close_context)(struct nfs_open_context *, int);
	struct inode * (*open_context)(struct inode *, struct nfs_open_context *, int, struct iattr *, int *);
	int (*have_delegation)(struct inode *, fmode_t);
	struct nfs_client * (*alloc_client)(const struct nfs_client_initdata *);
	struct nfs_client * (*init_client)(struct nfs_client *, const struct nfs_client_initdata *);
	void (*free_client)(struct nfs_client *);
	struct nfs_server * (*create_server)(struct fs_context *);
	struct nfs_server * (*clone_server)(struct nfs_server *, struct nfs_fh *, struct nfs_fattr *, rpc_authflavor_t);
	int (*discover_trunking)(struct nfs_server *, struct nfs_fh *);
	void (*enable_swap)(struct inode *);
	void (*disable_swap)(struct inode *);
};

struct nlmclnt_operations {
	void (*nlmclnt_alloc_call)(void *);
	bool (*nlmclnt_unlock_prepare)(struct rpc_task *, void *);
	void (*nlmclnt_release_call)(void *);
};

struct nfs_access_entry {
	struct rb_node rb_node;
	struct list_head lru;
	kuid_t fsuid;
	kgid_t fsgid;
	struct group_info *group_info;
	__u32 mask;
	struct callback_head callback_head;
};

struct nfs_client_initdata {
	long unsigned int init_flags;
	const char *hostname;
	const struct __kernel_sockaddr_storage *addr;
	const char *nodename;
	const char *ip_addr;
	size_t addrlen;
	struct nfs_subversion *nfs_mod;
	int proto;
	u32 minorversion;
	unsigned int nconnect;
	unsigned int max_connect;
	struct net *net;
	const struct rpc_timeout *timeparms;
	const struct cred *cred;
};

struct nfs4_state_recovery_ops;

struct nfs4_state_maintenance_ops;

struct nfs4_mig_recovery_ops;

struct nfs4_minor_version_ops {
	u32 minor_version;
	unsigned int init_caps;
	int (*init_client)(struct nfs_client *);
	void (*shutdown_client)(struct nfs_client *);
	bool (*match_stateid)(const nfs4_stateid *, const nfs4_stateid *);
	int (*find_root_sec)(struct nfs_server *, struct nfs_fh *, struct nfs_fsinfo *);
	void (*free_lock_state)(struct nfs_server *, struct nfs4_lock_state *);
	int (*test_and_free_expired)(struct nfs_server *, nfs4_stateid *, const struct cred *);
	struct nfs_seqid * (*alloc_seqid)(struct nfs_seqid_counter *, gfp_t);
	void (*session_trunk)(struct rpc_clnt *, struct rpc_xprt *, void *);
	const struct rpc_call_ops *call_sync_ops;
	const struct nfs4_state_recovery_ops *reboot_recovery_ops;
	const struct nfs4_state_recovery_ops *nograce_recovery_ops;
	const struct nfs4_state_maintenance_ops *state_renewal_ops;
	const struct nfs4_mig_recovery_ops *mig_recovery_ops;
};

struct nfs4_state_owner;

struct nfs4_state {
	struct list_head open_states;
	struct list_head inode_states;
	struct list_head lock_states;
	struct nfs4_state_owner *owner;
	struct inode *inode;
	long unsigned int flags;
	spinlock_t state_lock;
	seqlock_t seqlock;
	nfs4_stateid stateid;
	nfs4_stateid open_stateid;
	unsigned int n_rdonly;
	unsigned int n_wronly;
	unsigned int n_rdwr;
	fmode_t state;
	refcount_t count;
	wait_queue_head_t waitq;
	struct callback_head callback_head;
};

struct cache_head {
	struct hlist_node cache_list;
	time64_t expiry_time;
	time64_t last_refresh;
	struct kref ref;
	long unsigned int flags;
};

struct cache_deferred_req;

struct cache_req {
	struct cache_deferred_req * (*defer)(struct cache_req *);
	long unsigned int thread_wait;
};

struct cache_deferred_req {
	struct hlist_node hash;
	struct list_head recent;
	struct cache_head *item;
	void *owner;
	void (*revisit)(struct cache_deferred_req *, int);
};

struct svc_cred {
	kuid_t cr_uid;
	kgid_t cr_gid;
	struct group_info *cr_group_info;
	u32 cr_flavor;
	char *cr_raw_principal;
	char *cr_principal;
	char *cr_targ_princ;
	struct gss_api_mech *cr_gss_mech;
};

struct auth_ops {
	char *name;
	struct module *owner;
	int flavour;
	int (*accept)(struct svc_rqst *);
	int (*release)(struct svc_rqst *);
	void (*domain_release)(struct auth_domain *);
	int (*set_client)(struct svc_rqst *);
};

struct svc_cacherep;

struct svc_procedure;

struct svc_deferred_req;

struct svc_rqst {
	struct list_head rq_all;
	struct callback_head rq_rcu_head;
	struct svc_xprt *rq_xprt;
	struct __kernel_sockaddr_storage rq_addr;
	size_t rq_addrlen;
	struct __kernel_sockaddr_storage rq_daddr;
	size_t rq_daddrlen;
	struct svc_serv *rq_server;
	struct svc_pool *rq_pool;
	const struct svc_procedure *rq_procinfo;
	struct auth_ops *rq_authop;
	struct svc_cred rq_cred;
	void *rq_xprt_ctxt;
	struct svc_deferred_req *rq_deferred;
	struct xdr_buf rq_arg;
	struct xdr_stream rq_arg_stream;
	struct xdr_stream rq_res_stream;
	struct page *rq_scratch_page;
	struct xdr_buf rq_res;
	struct page *rq_pages[260];
	struct page **rq_respages;
	struct page **rq_next_page;
	struct page **rq_page_end;
	struct pagevec rq_pvec;
	struct kvec rq_vec[259];
	struct bio_vec rq_bvec[259];
	__be32 rq_xid;
	u32 rq_prog;
	u32 rq_vers;
	u32 rq_proc;
	u32 rq_prot;
	int rq_cachetype;
	long unsigned int rq_flags;
	int: 32;
	ktime_t rq_qtime;
	void *rq_argp;
	void *rq_resp;
	void *rq_auth_data;
	__be32 rq_auth_stat;
	int rq_auth_slack;
	int rq_reserved;
	ktime_t rq_stime;
	struct cache_req rq_chandle;
	struct auth_domain *rq_client;
	struct auth_domain *rq_gssclient;
	struct svc_cacherep *rq_cacherep;
	struct task_struct *rq_task;
	spinlock_t rq_lock;
	struct net *rq_bc_net;
	void **rq_lease_breaker;
	int: 32;
};

struct svc_pool_stats {
	atomic_long_t packets;
	long unsigned int sockets_queued;
	atomic_long_t threads_woken;
	atomic_long_t threads_timedout;
};

struct svc_pool {
	unsigned int sp_id;
	spinlock_t sp_lock;
	struct list_head sp_sockets;
	unsigned int sp_nrthreads;
	struct list_head sp_all_threads;
	struct svc_pool_stats sp_stats;
	long unsigned int sp_flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct svc_procedure {
	__be32 (*pc_func)(struct svc_rqst *);
	bool (*pc_decode)(struct svc_rqst *, struct xdr_stream *);
	bool (*pc_encode)(struct svc_rqst *, struct xdr_stream *);
	void (*pc_release)(struct svc_rqst *);
	unsigned int pc_argsize;
	unsigned int pc_argzero;
	unsigned int pc_ressize;
	unsigned int pc_cachetype;
	unsigned int pc_xdrressize;
	const char *pc_name;
};

struct svc_deferred_req {
	u32 prot;
	struct svc_xprt *xprt;
	struct __kernel_sockaddr_storage addr;
	size_t addrlen;
	struct __kernel_sockaddr_storage daddr;
	size_t daddrlen;
	void *xprt_ctxt;
	struct cache_deferred_req handle;
	int argslen;
	__be32 args[0];
};

struct svc_process_info {
	union {
		int (*dispatch)(struct svc_rqst *, __be32 *);
		struct {
			unsigned int lovers;
			unsigned int hivers;
		} mismatch;
	};
};

struct svc_version {
	u32 vs_vers;
	u32 vs_nproc;
	const struct svc_procedure *vs_proc;
	unsigned int *vs_count;
	u32 vs_xdrsize;
	bool vs_hidden;
	bool vs_rpcb_optnl;
	bool vs_need_cong_ctrl;
	int (*vs_dispatch)(struct svc_rqst *, __be32 *);
};

struct nfs4_ssc_client_ops;

struct nfs_ssc_client_ops;

struct nfs_ssc_client_ops_tbl {
	const struct nfs4_ssc_client_ops *ssc_nfs4_ops;
	const struct nfs_ssc_client_ops *ssc_nfs_ops;
};

struct nfs4_ssc_client_ops {
	struct file * (*sco_open)(struct vfsmount *, struct nfs_fh *, nfs4_stateid *);
	void (*sco_close)(struct file *);
};

struct nfs_ssc_client_ops {
	void (*sco_sb_deactive)(struct super_block *);
};

struct nfs4_state_recovery_ops {
	int owner_flag_bit;
	int state_flag_bit;
	int (*recover_open)(struct nfs4_state_owner *, struct nfs4_state *);
	int (*recover_lock)(struct nfs4_state *, struct file_lock *);
	int (*establish_clid)(struct nfs_client *, const struct cred *);
	int (*reclaim_complete)(struct nfs_client *, const struct cred *);
	int (*detect_trunking)(struct nfs_client *, struct nfs_client **, const struct cred *);
};

struct nfs4_state_maintenance_ops {
	int (*sched_state_renewal)(struct nfs_client *, const struct cred *, unsigned int);
	const struct cred * (*get_state_renewal_cred)(struct nfs_client *);
	int (*renew_lease)(struct nfs_client *, const struct cred *);
};

struct nfs4_mig_recovery_ops {
	int (*get_locations)(struct nfs_server *, struct nfs_fh *, struct nfs4_fs_locations *, struct page *, const struct cred *);
	int (*fsid_present)(struct inode *, const struct cred *);
};

struct nfs4_state_owner {
	struct nfs_server *so_server;
	struct list_head so_lru;
	long unsigned int so_expires;
	struct rb_node so_server_node;
	const struct cred *so_cred;
	spinlock_t so_lock;
	atomic_t so_count;
	long unsigned int so_flags;
	struct list_head so_states;
	int: 32;
	struct nfs_seqid_counter so_seqid;
	seqcount_spinlock_t so_reclaim_seqcount;
	struct mutex so_delegreturn_mutex;
};

struct core_name {
	char *corename;
	int used;
	int size;
};

struct iomap_iter {
	struct inode *inode;
	int: 32;
	loff_t pos;
	u64 len;
	s64 processed;
	unsigned int flags;
	int: 32;
	struct iomap iomap;
	struct iomap srcmap;
	void *private;
	int: 32;
};

struct trace_event_raw_iomap_readpage_class {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	int nr_pages;
	char __data[0];
	int: 32;
};

struct trace_event_raw_iomap_range_class {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	loff_t size;
	loff_t offset;
	u64 length;
	char __data[0];
};

struct trace_event_raw_iomap_class {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	u64 addr;
	loff_t offset;
	u64 length;
	u16 type;
	u16 flags;
	dev_t bdev;
	char __data[0];
};

struct trace_event_raw_iomap_iter {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	loff_t pos;
	u64 length;
	unsigned int flags;
	const void *ops;
	long unsigned int caller;
	char __data[0];
	int: 32;
};

struct trace_event_data_offsets_iomap_readpage_class {};

struct trace_event_data_offsets_iomap_range_class {};

struct trace_event_data_offsets_iomap_class {};

struct trace_event_data_offsets_iomap_iter {};

typedef void (*btf_trace_iomap_readpage)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_readahead)(void *, struct inode *, int);

typedef void (*btf_trace_iomap_writepage)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_release_folio)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_invalidate_folio)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_dio_invalidate_fail)(void *, struct inode *, loff_t, u64);

typedef void (*btf_trace_iomap_iter_dstmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_iter_srcmap)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_writepage_map)(void *, struct inode *, struct iomap *);

typedef void (*btf_trace_iomap_iter)(void *, struct iomap_iter *, const void *, long unsigned int);

struct iomap_ops {
	int (*iomap_begin)(struct inode *, loff_t, loff_t, unsigned int, struct iomap *, struct iomap *);
	int (*iomap_end)(struct inode *, loff_t, loff_t, ssize_t, unsigned int, struct iomap *);
};

struct folio_iter {
	struct folio *folio;
	size_t offset;
	size_t length;
	struct folio *_next;
	size_t _seg_count;
	int _i;
};

enum {
	BIOSET_NEED_BVECS = 1,
	BIOSET_NEED_RESCUER = 2,
	BIOSET_PERCPU_CACHE = 4,
};

struct iomap_ioend {
	struct list_head io_list;
	u16 io_type;
	u16 io_flags;
	u32 io_folios;
	struct inode *io_inode;
	size_t io_size;
	loff_t io_offset;
	sector_t io_sector;
	struct bio *io_bio;
	struct bio io_inline_bio;
	int: 32;
};

struct iomap_writepage_ctx;

struct iomap_writeback_ops {
	int (*map_blocks)(struct iomap_writepage_ctx *, struct inode *, loff_t);
	int (*prepare_ioend)(struct iomap_ioend *, int);
	void (*discard_folio)(struct folio *, loff_t);
};

struct iomap_writepage_ctx {
	struct iomap iomap;
	struct iomap_ioend *ioend;
	const struct iomap_writeback_ops *ops;
};

struct iomap_page {
	atomic_t read_bytes_pending;
	atomic_t write_bytes_pending;
	spinlock_t uptodate_lock;
	long unsigned int uptodate[0];
};

struct iomap_readpage_ctx {
	struct folio *cur_folio;
	bool cur_folio_in_bio;
	struct bio *bio;
	struct readahead_control *rac;
};

struct iomap_dio_ops {
	int (*end_io)(struct kiocb *, ssize_t, int, unsigned int);
	void (*submit_io)(const struct iomap_iter *, struct bio *, loff_t);
	struct bio_set *bio_set;
};

struct iomap_dio {
	struct kiocb *iocb;
	const struct iomap_dio_ops *dops;
	loff_t i_size;
	loff_t size;
	atomic_t ref;
	unsigned int flags;
	int error;
	size_t done_before;
	bool wait_for_completion;
	union {
		struct {
			struct iov_iter *iter;
			struct task_struct *waiter;
			struct bio *poll_bio;
		} submit;
		struct {
			struct work_struct work;
		} aio;
	};
	int: 32;
};

struct iomap_swapfile_info {
	struct iomap iomap;
	struct swap_info_struct *sis;
	int: 32;
	uint64_t lowest_ppage;
	uint64_t highest_ppage;
	long unsigned int nr_pages;
	int nr_extents;
	struct file *file;
	int: 32;
};

enum {
	QIF_BLIMITS_B = 0,
	QIF_SPACE_B = 1,
	QIF_ILIMITS_B = 2,
	QIF_INODES_B = 3,
	QIF_BTIME_B = 4,
	QIF_ITIME_B = 5,
};

typedef __kernel_uid32_t qid_t;

enum {
	DQF_INFO_DIRTY_B = 17,
};

struct dqstats {
	long unsigned int stat[8];
	struct percpu_counter counter[8];
};

enum {
	_DQUOT_USAGE_ENABLED = 0,
	_DQUOT_LIMITS_ENABLED = 1,
	_DQUOT_SUSPENDED = 2,
	_DQUOT_STATE_FLAGS = 3,
};

struct quota_module_name {
	int qm_fmt_id;
	char *qm_mod_name;
};

struct dquot_warn {
	struct super_block *w_sb;
	struct kqid w_dq_id;
	short int w_type;
};

struct fs_disk_quota {
	__s8 d_version;
	__s8 d_flags;
	__u16 d_fieldmask;
	__u32 d_id;
	__u64 d_blk_hardlimit;
	__u64 d_blk_softlimit;
	__u64 d_ino_hardlimit;
	__u64 d_ino_softlimit;
	__u64 d_bcount;
	__u64 d_icount;
	__s32 d_itimer;
	__s32 d_btimer;
	__u16 d_iwarns;
	__u16 d_bwarns;
	__s8 d_itimer_hi;
	__s8 d_btimer_hi;
	__s8 d_rtbtimer_hi;
	__s8 d_padding2;
	__u64 d_rtb_hardlimit;
	__u64 d_rtb_softlimit;
	__u64 d_rtbcount;
	__s32 d_rtbtimer;
	__u16 d_rtbwarns;
	__s16 d_padding3;
	char d_padding4[8];
};

struct fs_qfilestat {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
	int: 32;
};

typedef struct fs_qfilestat fs_qfilestat_t;

struct fs_quota_stat {
	__s8 qs_version;
	__u16 qs_flags;
	__s8 qs_pad;
	fs_qfilestat_t qs_uquota;
	fs_qfilestat_t qs_gquota;
	__u32 qs_incoredqs;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
	int: 32;
};

struct fs_qfilestatv {
	__u64 qfs_ino;
	__u64 qfs_nblks;
	__u32 qfs_nextents;
	__u32 qfs_pad;
};

struct fs_quota_statv {
	__s8 qs_version;
	__u8 qs_pad1;
	__u16 qs_flags;
	__u32 qs_incoredqs;
	struct fs_qfilestatv qs_uquota;
	struct fs_qfilestatv qs_gquota;
	struct fs_qfilestatv qs_pquota;
	__s32 qs_btimelimit;
	__s32 qs_itimelimit;
	__s32 qs_rtbtimelimit;
	__u16 qs_bwarnlimit;
	__u16 qs_iwarnlimit;
	__u16 qs_rtbwarnlimit;
	__u16 qs_pad3;
	__u32 qs_pad4;
	__u64 qs_pad2[7];
};

struct if_dqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
	int: 32;
};

struct if_nextdqblk {
	__u64 dqb_bhardlimit;
	__u64 dqb_bsoftlimit;
	__u64 dqb_curspace;
	__u64 dqb_ihardlimit;
	__u64 dqb_isoftlimit;
	__u64 dqb_curinodes;
	__u64 dqb_btime;
	__u64 dqb_itime;
	__u32 dqb_valid;
	__u32 dqb_id;
};

struct if_dqinfo {
	__u64 dqi_bgrace;
	__u64 dqi_igrace;
	__u32 dqi_flags;
	__u32 dqi_valid;
};

typedef u32 compat_uint_t;

typedef u64 compat_u64;

struct compat_if_dqblk {
	compat_u64 dqb_bhardlimit;
	compat_u64 dqb_bsoftlimit;
	compat_u64 dqb_curspace;
	compat_u64 dqb_ihardlimit;
	compat_u64 dqb_isoftlimit;
	compat_u64 dqb_curinodes;
	compat_u64 dqb_btime;
	compat_u64 dqb_itime;
	compat_uint_t dqb_valid;
	int: 32;
};

enum {
	QUOTA_NL_C_UNSPEC = 0,
	QUOTA_NL_C_WARNING = 1,
	__QUOTA_NL_C_MAX = 2,
};

enum {
	QUOTA_NL_A_UNSPEC = 0,
	QUOTA_NL_A_QTYPE = 1,
	QUOTA_NL_A_EXCESS_ID = 2,
	QUOTA_NL_A_WARNING = 3,
	QUOTA_NL_A_DEV_MAJOR = 4,
	QUOTA_NL_A_DEV_MINOR = 5,
	QUOTA_NL_A_CAUSED_ID = 6,
	QUOTA_NL_A_PAD = 7,
	__QUOTA_NL_A_MAX = 8,
};

struct scm_creds {
	u32 pid;
	kuid_t uid;
	kgid_t gid;
};

struct netlink_skb_parms {
	struct scm_creds creds;
	__u32 portid;
	__u32 dst_group;
	__u32 flags;
	struct sock *sk;
	bool nsid_is_set;
	int nsid;
};

struct genlmsghdr {
	__u8 cmd;
	__u8 version;
	__u16 reserved;
};

struct genl_multicast_group {
	char name[16];
	u8 flags;
};

struct genl_ops;

struct genl_info;

struct genl_small_ops;

struct genl_family {
	int id;
	unsigned int hdrsize;
	char name[16];
	unsigned int version;
	unsigned int maxattr;
	unsigned int mcgrp_offset;
	u8 netnsok: 1;
	u8 parallel_ops: 1;
	u8 n_ops;
	u8 n_small_ops;
	u8 n_mcgrps;
	u8 resv_start_op;
	const struct nla_policy *policy;
	int (*pre_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	void (*post_doit)(const struct genl_ops *, struct sk_buff *, struct genl_info *);
	const struct genl_ops *ops;
	const struct genl_small_ops *small_ops;
	const struct genl_multicast_group *mcgrps;
	struct module *module;
};

struct genl_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*start)(struct netlink_callback *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	const struct nla_policy *policy;
	unsigned int maxattr;
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct genl_info {
	u32 snd_seq;
	u32 snd_portid;
	struct nlmsghdr *nlhdr;
	struct genlmsghdr *genlhdr;
	void *userhdr;
	struct nlattr **attrs;
	possible_net_t _net;
	void *user_ptr[2];
	struct netlink_ext_ack *extack;
};

struct genl_small_ops {
	int (*doit)(struct sk_buff *, struct genl_info *);
	int (*dumpit)(struct sk_buff *, struct netlink_callback *);
	u8 cmd;
	u8 internal_flags;
	u8 flags;
	u8 validate;
};

struct proc_maps_private {
	struct inode *inode;
	struct task_struct *task;
	struct mm_struct *mm;
	struct vma_iterator iter;
};

struct mem_size_stats {
	long unsigned int resident;
	long unsigned int shared_clean;
	long unsigned int shared_dirty;
	long unsigned int private_clean;
	long unsigned int private_dirty;
	long unsigned int referenced;
	long unsigned int anonymous;
	long unsigned int lazyfree;
	long unsigned int anonymous_thp;
	long unsigned int shmem_thp;
	long unsigned int file_thp;
	long unsigned int swap;
	long unsigned int shared_hugetlb;
	long unsigned int private_hugetlb;
	u64 pss;
	u64 pss_anon;
	u64 pss_file;
	u64 pss_shmem;
	u64 pss_dirty;
	u64 pss_locked;
	u64 swap_pss;
};

enum clear_refs_types {
	CLEAR_REFS_ALL = 1,
	CLEAR_REFS_ANON = 2,
	CLEAR_REFS_MAPPED = 3,
	CLEAR_REFS_SOFT_DIRTY = 4,
	CLEAR_REFS_MM_HIWATER_RSS = 5,
	CLEAR_REFS_LAST = 6,
};

struct clear_refs_private {
	enum clear_refs_types type;
};

typedef struct {
	u64 pme;
} pagemap_entry_t;

struct pagemapread {
	int pos;
	int len;
	pagemap_entry_t *buffer;
	bool show_pfn;
};

struct pde_opener {
	struct list_head lh;
	struct file *file;
	bool closing;
	struct completion *c;
};

enum {
	BIAS = 2147483648,
};

struct proc_fs_context {
	struct pid_namespace *pid_ns;
	unsigned int mask;
	enum proc_hidepid hidepid;
	int gid;
	enum proc_pidonly pidonly;
};

enum proc_param {
	Opt_gid___2 = 0,
	Opt_hidepid = 1,
	Opt_subset = 2,
};

struct genradix_root;

struct __genradix {
	struct genradix_root *root;
};

struct syscall_info {
	__u64 sp;
	struct seccomp_data data;
};

enum resctrl_conf_type {
	CDP_NONE = 0,
	CDP_CODE = 1,
	CDP_DATA = 2,
};

typedef struct dentry *instantiate_t(struct dentry *, struct task_struct *, const void *);

struct pid_entry {
	const char *name;
	unsigned int len;
	umode_t mode;
	const struct inode_operations *iop;
	const struct file_operations *fop;
	union proc_op op;
};

struct limit_names {
	const char *name;
	const char *unit;
};

struct map_files_info {
	long unsigned int start;
	long unsigned int end;
	fmode_t mode;
};

struct tgid_iter {
	unsigned int tgid;
	struct task_struct *task;
};

struct fd_data {
	fmode_t mode;
	unsigned int fd;
};

struct sysctl_alias {
	const char *kernel_param;
	const char *sysctl_param;
};

struct seq_net_private {
	struct net *net;
	netns_tracker ns_tracker;
};

struct bpf_iter_aux_info;

struct kernfs_global_locks {
	struct mutex open_file_mutex[16];
};

struct kernfs_root {
	struct kernfs_node *kn;
	unsigned int flags;
	struct idr ino_idr;
	u32 last_id_lowbits;
	u32 id_highbits;
	struct kernfs_syscall_ops *syscall_ops;
	struct list_head supers;
	wait_queue_head_t deactivate_waitq;
	struct rw_semaphore kernfs_rwsem;
};

struct kernfs_iattrs {
	kuid_t ia_uid;
	kgid_t ia_gid;
	struct timespec64 ia_atime;
	struct timespec64 ia_mtime;
	struct timespec64 ia_ctime;
	struct simple_xattrs xattrs;
	atomic_t nr_user_xattrs;
	atomic_t user_xattr_size;
	int: 32;
};

struct kernfs_super_info {
	struct super_block *sb;
	struct kernfs_root *root;
	const void *ns;
	struct list_head node;
};

enum kernfs_node_flag {
	KERNFS_ACTIVATED = 16,
	KERNFS_NS = 32,
	KERNFS_HAS_SEQ_SHOW = 64,
	KERNFS_HAS_MMAP = 128,
	KERNFS_LOCKDEP = 256,
	KERNFS_HIDDEN = 512,
	KERNFS_SUICIDAL = 1024,
	KERNFS_SUICIDED = 2048,
	KERNFS_EMPTY_DIR = 4096,
	KERNFS_HAS_RELEASE = 8192,
	KERNFS_REMOVING = 16384,
};

struct kernfs_open_node {
	struct callback_head callback_head;
	atomic_t event;
	wait_queue_head_t poll;
	struct list_head files;
	unsigned int nr_mmapped;
	unsigned int nr_to_release;
};

struct config_group;

struct config_item_type;

struct config_item {
	char *ci_name;
	char ci_namebuf[20];
	struct kref ci_kref;
	struct list_head ci_entry;
	struct config_item *ci_parent;
	struct config_group *ci_group;
	const struct config_item_type *ci_type;
	struct dentry *ci_dentry;
};

struct configfs_subsystem;

struct config_group {
	struct config_item cg_item;
	struct list_head cg_children;
	struct configfs_subsystem *cg_subsys;
	struct list_head default_groups;
	struct list_head group_entry;
};

struct configfs_item_operations;

struct configfs_group_operations;

struct configfs_attribute;

struct configfs_bin_attribute;

struct config_item_type {
	struct module *ct_owner;
	struct configfs_item_operations *ct_item_ops;
	struct configfs_group_operations *ct_group_ops;
	struct configfs_attribute **ct_attrs;
	struct configfs_bin_attribute **ct_bin_attrs;
};

struct configfs_item_operations {
	void (*release)(struct config_item *);
	int (*allow_link)(struct config_item *, struct config_item *);
	void (*drop_link)(struct config_item *, struct config_item *);
};

struct configfs_group_operations {
	struct config_item * (*make_item)(struct config_group *, const char *);
	struct config_group * (*make_group)(struct config_group *, const char *);
	int (*commit_item)(struct config_item *);
	void (*disconnect_notify)(struct config_group *, struct config_item *);
	void (*drop_item)(struct config_group *, struct config_item *);
};

struct configfs_attribute {
	const char *ca_name;
	struct module *ca_owner;
	umode_t ca_mode;
	ssize_t (*show)(struct config_item *, char *);
	ssize_t (*store)(struct config_item *, const char *, size_t);
};

struct configfs_bin_attribute {
	struct configfs_attribute cb_attr;
	void *cb_private;
	size_t cb_max_size;
	ssize_t (*read)(struct config_item *, void *, size_t);
	ssize_t (*write)(struct config_item *, const void *, size_t);
};

struct configfs_subsystem {
	struct config_group su_group;
	struct mutex su_mutex;
};

struct configfs_fragment {
	atomic_t frag_count;
	struct rw_semaphore frag_sem;
	bool frag_dead;
};

struct configfs_dirent {
	atomic_t s_count;
	int s_dependent_count;
	struct list_head s_sibling;
	struct list_head s_children;
	int s_links;
	void *s_element;
	int s_type;
	umode_t s_mode;
	struct dentry *s_dentry;
	struct iattr *s_iattr;
	struct configfs_fragment *s_frag;
};

struct configfs_buffer {
	size_t count;
	int: 32;
	loff_t pos;
	char *page;
	struct configfs_item_operations *ops;
	struct mutex mutex;
	int needs_read_fill;
	bool read_in_progress;
	bool write_in_progress;
	char *bin_buffer;
	int bin_buffer_size;
	int cb_max_size;
	struct config_item *item;
	struct module *owner;
	union {
		struct configfs_attribute *attr;
		struct configfs_bin_attribute *bin_attr;
	};
	int: 32;
};

struct pts_mount_opts {
	int setuid;
	int setgid;
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	umode_t ptmxmode;
	int reserve;
	int max;
};

enum {
	Opt_uid___2 = 0,
	Opt_gid___3 = 1,
	Opt_mode___2 = 2,
	Opt_ptmxmode = 3,
	Opt_newinstance = 4,
	Opt_max = 5,
	Opt_err = 6,
};

struct pts_fs_info {
	struct ida allocated_ptys;
	struct pts_mount_opts mount_opts;
	struct super_block *sb;
	struct dentry *ptmx_dentry;
};

typedef u16 uint16_t;

typedef unsigned int tid_t;

struct transaction_chp_stats_s {
	long unsigned int cs_chp_time;
	__u32 cs_forced_to_close;
	__u32 cs_written;
	__u32 cs_dropped;
};

struct journal_s;

typedef struct journal_s journal_t;

struct journal_head;

struct transaction_s;

typedef struct transaction_s transaction_t;

struct transaction_s {
	journal_t *t_journal;
	tid_t t_tid;
	enum {
		T_RUNNING = 0,
		T_LOCKED = 1,
		T_SWITCH = 2,
		T_FLUSH = 3,
		T_COMMIT = 4,
		T_COMMIT_DFLUSH = 5,
		T_COMMIT_JFLUSH = 6,
		T_COMMIT_CALLBACK = 7,
		T_FINISHED = 8,
	} t_state;
	long unsigned int t_log_start;
	int t_nr_buffers;
	struct journal_head *t_reserved_list;
	struct journal_head *t_buffers;
	struct journal_head *t_forget;
	struct journal_head *t_checkpoint_list;
	struct journal_head *t_checkpoint_io_list;
	struct journal_head *t_shadow_list;
	struct list_head t_inode_list;
	spinlock_t t_handle_lock;
	long unsigned int t_max_wait;
	long unsigned int t_start;
	long unsigned int t_requested;
	struct transaction_chp_stats_s t_chp_stats;
	atomic_t t_updates;
	atomic_t t_outstanding_credits;
	atomic_t t_outstanding_revokes;
	atomic_t t_handle_count;
	transaction_t *t_cpnext;
	transaction_t *t_cpprev;
	long unsigned int t_expires;
	ktime_t t_start_time;
	unsigned int t_synchronous_commit: 1;
	int t_need_data_flush;
	struct list_head t_private_list;
};

struct jbd2_buffer_trigger_type;

struct journal_head {
	struct buffer_head *b_bh;
	spinlock_t b_state_lock;
	int b_jcount;
	unsigned int b_jlist;
	unsigned int b_modified;
	char *b_frozen_data;
	char *b_committed_data;
	transaction_t *b_transaction;
	transaction_t *b_next_transaction;
	struct journal_head *b_tnext;
	struct journal_head *b_tprev;
	transaction_t *b_cp_transaction;
	struct journal_head *b_cpnext;
	struct journal_head *b_cpprev;
	struct jbd2_buffer_trigger_type *b_triggers;
	struct jbd2_buffer_trigger_type *b_frozen_triggers;
};

struct jbd2_buffer_trigger_type {
	void (*t_frozen)(struct jbd2_buffer_trigger_type *, struct buffer_head *, void *, size_t);
	void (*t_abort)(struct jbd2_buffer_trigger_type *, struct buffer_head *);
};

struct hw_bound_key_info {
	uint8_t flags;
	uint8_t reserved;
	uint16_t key_sz;
};

struct crypto_alg;

struct crypto_tfm {
	u32 crt_flags;
	unsigned int is_hbk;
	struct hw_bound_key_info hbk_info;
	int node;
	void (*exit)(struct crypto_tfm *);
	struct crypto_alg *__crt_alg;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__crt_ctx[0];
};

struct cipher_alg {
	unsigned int cia_min_keysize;
	unsigned int cia_max_keysize;
	int (*cia_setkey)(struct crypto_tfm *, const u8 *, unsigned int);
	void (*cia_encrypt)(struct crypto_tfm *, u8 *, const u8 *);
	void (*cia_decrypt)(struct crypto_tfm *, u8 *, const u8 *);
};

struct compress_alg {
	int (*coa_compress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
	int (*coa_decompress)(struct crypto_tfm *, const u8 *, unsigned int, u8 *, unsigned int *);
};

struct crypto_type;

struct crypto_alg {
	struct list_head cra_list;
	struct list_head cra_users;
	u32 cra_flags;
	unsigned int cra_blocksize;
	unsigned int cra_ctxsize;
	unsigned int cra_alignmask;
	int cra_priority;
	refcount_t cra_refcnt;
	char cra_name[128];
	char cra_driver_name[128];
	const struct crypto_type *cra_type;
	union {
		struct cipher_alg cipher;
		struct compress_alg compress;
	} cra_u;
	int (*cra_init)(struct crypto_tfm *);
	void (*cra_exit)(struct crypto_tfm *);
	void (*cra_destroy)(struct crypto_alg *);
	struct module *cra_module;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct crypto_instance;

struct crypto_type {
	unsigned int (*ctxsize)(struct crypto_alg *, u32, u32);
	unsigned int (*extsize)(struct crypto_alg *);
	int (*init)(struct crypto_tfm *, u32, u32);
	int (*init_tfm)(struct crypto_tfm *);
	void (*show)(struct seq_file *, struct crypto_alg *);
	int (*report)(struct sk_buff *, struct crypto_alg *);
	void (*free)(struct crypto_instance *);
	unsigned int type;
	unsigned int maskclear;
	unsigned int maskset;
	unsigned int tfmsize;
};

struct crypto_shash {
	unsigned int descsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct jbd2_journal_handle;

typedef struct jbd2_journal_handle handle_t;

struct jbd2_journal_handle {
	union {
		transaction_t *h_transaction;
		journal_t *h_journal;
	};
	handle_t *h_rsv_handle;
	int h_total_credits;
	int h_revoke_credits;
	int h_revoke_credits_requested;
	int h_ref;
	int h_err;
	unsigned int h_sync: 1;
	unsigned int h_jdata: 1;
	unsigned int h_reserved: 1;
	unsigned int h_aborted: 1;
	unsigned int h_type: 8;
	unsigned int h_line_no: 16;
	long unsigned int h_start_jiffies;
	unsigned int h_requested_credits;
	unsigned int saved_alloc_context;
};

struct transaction_run_stats_s {
	long unsigned int rs_wait;
	long unsigned int rs_request_delay;
	long unsigned int rs_running;
	long unsigned int rs_locked;
	long unsigned int rs_flushing;
	long unsigned int rs_logging;
	__u32 rs_handle_count;
	__u32 rs_blocks;
	__u32 rs_blocks_logged;
};

struct transaction_stats_s {
	long unsigned int ts_tid;
	long unsigned int ts_requested;
	struct transaction_run_stats_s run;
};

enum passtype {
	PASS_SCAN = 0,
	PASS_REVOKE = 1,
	PASS_REPLAY = 2,
};

struct journal_superblock_s;

typedef struct journal_superblock_s journal_superblock_t;

struct jbd2_revoke_table_s;

struct jbd2_inode;

struct journal_s {
	long unsigned int j_flags;
	long unsigned int j_atomic_flags;
	int j_errno;
	struct mutex j_abort_mutex;
	struct buffer_head *j_sb_buffer;
	journal_superblock_t *j_superblock;
	int j_format_version;
	rwlock_t j_state_lock;
	int j_barrier_count;
	struct mutex j_barrier;
	transaction_t *j_running_transaction;
	transaction_t *j_committing_transaction;
	transaction_t *j_checkpoint_transactions;
	wait_queue_head_t j_wait_transaction_locked;
	wait_queue_head_t j_wait_done_commit;
	wait_queue_head_t j_wait_commit;
	wait_queue_head_t j_wait_updates;
	wait_queue_head_t j_wait_reserved;
	wait_queue_head_t j_fc_wait;
	struct mutex j_checkpoint_mutex;
	struct buffer_head *j_chkpt_bhs[64];
	struct shrinker j_shrinker;
	int: 32;
	struct percpu_counter j_checkpoint_jh_count;
	transaction_t *j_shrink_transaction;
	long unsigned int j_head;
	long unsigned int j_tail;
	long unsigned int j_free;
	long unsigned int j_first;
	long unsigned int j_last;
	long unsigned int j_fc_first;
	long unsigned int j_fc_off;
	long unsigned int j_fc_last;
	struct block_device *j_dev;
	int j_blocksize;
	int: 32;
	long long unsigned int j_blk_offset;
	char j_devname[56];
	struct block_device *j_fs_dev;
	unsigned int j_total_len;
	atomic_t j_reserved_credits;
	spinlock_t j_list_lock;
	struct inode *j_inode;
	tid_t j_tail_sequence;
	tid_t j_transaction_sequence;
	tid_t j_commit_sequence;
	tid_t j_commit_request;
	__u8 j_uuid[16];
	struct task_struct *j_task;
	int j_max_transaction_buffers;
	int j_revoke_records_per_block;
	long unsigned int j_commit_interval;
	struct timer_list j_commit_timer;
	spinlock_t j_revoke_lock;
	struct jbd2_revoke_table_s *j_revoke;
	struct jbd2_revoke_table_s *j_revoke_table[2];
	struct buffer_head **j_wbuf;
	struct buffer_head **j_fc_wbuf;
	int j_wbufsize;
	int j_fc_wbufsize;
	pid_t j_last_sync_writer;
	int: 32;
	u64 j_average_commit_time;
	u32 j_min_batch_time;
	u32 j_max_batch_time;
	void (*j_commit_callback)(journal_t *, transaction_t *);
	int (*j_submit_inode_data_buffers)(struct jbd2_inode *);
	int (*j_finish_inode_data_buffers)(struct jbd2_inode *);
	spinlock_t j_history_lock;
	struct proc_dir_entry *j_proc_entry;
	struct transaction_stats_s j_stats;
	unsigned int j_failed_commit;
	void *j_private;
	struct crypto_shash *j_chksum_driver;
	__u32 j_csum_seed;
	void (*j_fc_cleanup_callback)(struct journal_s *, int, tid_t);
	int (*j_fc_replay_callback)(struct journal_s *, struct buffer_head *, enum passtype, int, tid_t);
};

struct journal_header_s {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
};

typedef struct journal_header_s journal_header_t;

struct journal_superblock_s {
	journal_header_t s_header;
	__be32 s_blocksize;
	__be32 s_maxlen;
	__be32 s_first;
	__be32 s_sequence;
	__be32 s_start;
	__be32 s_errno;
	__be32 s_feature_compat;
	__be32 s_feature_incompat;
	__be32 s_feature_ro_compat;
	__u8 s_uuid[16];
	__be32 s_nr_users;
	__be32 s_dynsuper;
	__be32 s_max_transaction;
	__be32 s_max_trans_data;
	__u8 s_checksum_type;
	__u8 s_padding2[3];
	__be32 s_num_fc_blks;
	__u32 s_padding[41];
	__be32 s_checksum;
	__u8 s_users[768];
};

enum jbd_state_bits {
	BH_JBD = 16,
	BH_JWrite = 17,
	BH_Freed = 18,
	BH_Revoked = 19,
	BH_RevokeValid = 20,
	BH_JBDDirty = 21,
	BH_JournalHead = 22,
	BH_Shadow = 23,
	BH_Verified = 24,
	BH_JBDPrivateStart = 25,
};

struct jbd2_inode {
	transaction_t *i_transaction;
	transaction_t *i_next_transaction;
	struct list_head i_list;
	struct inode *i_vfs_inode;
	long unsigned int i_flags;
	loff_t i_dirty_start;
	loff_t i_dirty_end;
};

struct bgl_lock {
	spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct blockgroup_lock {
	struct bgl_lock locks[16];
};

struct fscrypt_dummy_policy {};

typedef int ext4_grpblk_t;

typedef long long unsigned int ext4_fsblk_t;

typedef __u32 ext4_lblk_t;

typedef unsigned int ext4_group_t;

struct ext4_allocation_request {
	struct inode *inode;
	unsigned int len;
	ext4_lblk_t logical;
	ext4_lblk_t lleft;
	ext4_lblk_t lright;
	int: 32;
	ext4_fsblk_t goal;
	ext4_fsblk_t pleft;
	ext4_fsblk_t pright;
	unsigned int flags;
	int: 32;
};

struct ext4_system_blocks {
	struct rb_root root;
	struct callback_head rcu;
};

struct ext4_group_desc {
	__le32 bg_block_bitmap_lo;
	__le32 bg_inode_bitmap_lo;
	__le32 bg_inode_table_lo;
	__le16 bg_free_blocks_count_lo;
	__le16 bg_free_inodes_count_lo;
	__le16 bg_used_dirs_count_lo;
	__le16 bg_flags;
	__le32 bg_exclude_bitmap_lo;
	__le16 bg_block_bitmap_csum_lo;
	__le16 bg_inode_bitmap_csum_lo;
	__le16 bg_itable_unused_lo;
	__le16 bg_checksum;
	__le32 bg_block_bitmap_hi;
	__le32 bg_inode_bitmap_hi;
	__le32 bg_inode_table_hi;
	__le16 bg_free_blocks_count_hi;
	__le16 bg_free_inodes_count_hi;
	__le16 bg_used_dirs_count_hi;
	__le16 bg_itable_unused_hi;
	__le32 bg_exclude_bitmap_hi;
	__le16 bg_block_bitmap_csum_hi;
	__le16 bg_inode_bitmap_csum_hi;
	__u32 bg_reserved;
};

struct flex_groups {
	atomic64_t free_clusters;
	atomic_t free_inodes;
	atomic_t used_dirs;
};

struct extent_status {
	struct rb_node rb_node;
	ext4_lblk_t es_lblk;
	ext4_lblk_t es_len;
	int: 32;
	ext4_fsblk_t es_pblk;
};

struct ext4_es_tree {
	struct rb_root root;
	struct extent_status *cache_es;
};

struct ext4_es_stats {
	long unsigned int es_stats_shrunk;
	int: 32;
	struct percpu_counter es_stats_cache_hits;
	struct percpu_counter es_stats_cache_misses;
	u64 es_stats_scan_time;
	u64 es_stats_max_scan_time;
	struct percpu_counter es_stats_all_cnt;
	struct percpu_counter es_stats_shk_cnt;
};

struct ext4_pending_tree {
	struct rb_root root;
};

struct ext4_fc_stats {
	unsigned int fc_ineligible_reason_count[9];
	long unsigned int fc_num_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_failed_commits;
	long unsigned int fc_skipped_commits;
	long unsigned int fc_numblks;
	u64 s_fc_avg_commit_time;
};

struct ext4_fc_alloc_region {
	ext4_lblk_t lblk;
	int: 32;
	ext4_fsblk_t pblk;
	int ino;
	int len;
};

struct ext4_fc_replay_state {
	int fc_replay_num_tags;
	int fc_replay_expected_off;
	int fc_current_pass;
	int fc_cur_tag;
	int fc_crc;
	struct ext4_fc_alloc_region *fc_regions;
	int fc_regions_size;
	int fc_regions_used;
	int fc_regions_valid;
	int *fc_modified_inodes;
	int fc_modified_inodes_used;
	int fc_modified_inodes_size;
};

struct ext4_inode_info {
	__le32 i_data[15];
	__u32 i_dtime;
	ext4_fsblk_t i_file_acl;
	ext4_group_t i_block_group;
	ext4_lblk_t i_dir_start_lookup;
	long unsigned int i_state_flags;
	long unsigned int i_flags;
	struct rw_semaphore xattr_sem;
	union {
		struct list_head i_orphan;
		unsigned int i_orphan_idx;
	};
	struct list_head i_fc_dilist;
	struct list_head i_fc_list;
	ext4_lblk_t i_fc_lblk_start;
	ext4_lblk_t i_fc_lblk_len;
	atomic_t i_fc_updates;
	wait_queue_head_t i_fc_wait;
	struct mutex i_fc_lock;
	int: 32;
	loff_t i_disksize;
	struct rw_semaphore i_data_sem;
	struct inode vfs_inode;
	struct jbd2_inode *jinode;
	spinlock_t i_raw_lock;
	struct timespec64 i_crtime;
	atomic_t i_prealloc_active;
	struct list_head i_prealloc_list;
	spinlock_t i_prealloc_lock;
	struct ext4_es_tree i_es_tree;
	rwlock_t i_es_lock;
	struct list_head i_es_list;
	unsigned int i_es_all_nr;
	unsigned int i_es_shk_nr;
	ext4_lblk_t i_es_shrink_lblk;
	ext4_group_t i_last_alloc_group;
	unsigned int i_reserved_data_blocks;
	struct ext4_pending_tree i_pending_tree;
	__u16 i_extra_isize;
	u16 i_inline_off;
	u16 i_inline_size;
	int: 16;
	int: 32;
	qsize_t i_reserved_quota;
	spinlock_t i_completed_io_lock;
	struct list_head i_rsv_conversion_list;
	struct work_struct i_rsv_conversion_work;
	atomic_t i_unwritten;
	spinlock_t i_block_reservation_lock;
	tid_t i_sync_tid;
	tid_t i_datasync_tid;
	struct dquot *i_dquot[3];
	__u32 i_csum_seed;
	kprojid_t i_projid;
};

struct ext4_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count_lo;
	__le32 s_r_blocks_count_lo;
	__le32 s_free_blocks_count_lo;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_cluster_size;
	__le32 s_blocks_per_group;
	__le32 s_clusters_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__le16 s_reserved_gdt_blocks;
	__u8 s_journal_uuid[16];
	__le32 s_journal_inum;
	__le32 s_journal_dev;
	__le32 s_last_orphan;
	__le32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_jnl_backup_type;
	__le16 s_desc_size;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__le32 s_mkfs_time;
	__le32 s_jnl_blocks[17];
	__le32 s_blocks_count_hi;
	__le32 s_r_blocks_count_hi;
	__le32 s_free_blocks_count_hi;
	__le16 s_min_extra_isize;
	__le16 s_want_extra_isize;
	__le32 s_flags;
	__le16 s_raid_stride;
	__le16 s_mmp_update_interval;
	__le64 s_mmp_block;
	__le32 s_raid_stripe_width;
	__u8 s_log_groups_per_flex;
	__u8 s_checksum_type;
	__u8 s_encryption_level;
	__u8 s_reserved_pad;
	__le64 s_kbytes_written;
	__le32 s_snapshot_inum;
	__le32 s_snapshot_id;
	__le64 s_snapshot_r_blocks_count;
	__le32 s_snapshot_list;
	__le32 s_error_count;
	__le32 s_first_error_time;
	__le32 s_first_error_ino;
	__le64 s_first_error_block;
	__u8 s_first_error_func[32];
	__le32 s_first_error_line;
	__le32 s_last_error_time;
	__le32 s_last_error_ino;
	__le32 s_last_error_line;
	__le64 s_last_error_block;
	__u8 s_last_error_func[32];
	__u8 s_mount_opts[64];
	__le32 s_usr_quota_inum;
	__le32 s_grp_quota_inum;
	__le32 s_overhead_clusters;
	__le32 s_backup_bgs[2];
	__u8 s_encrypt_algos[4];
	__u8 s_encrypt_pw_salt[16];
	__le32 s_lpf_ino;
	__le32 s_prj_quota_inum;
	__le32 s_checksum_seed;
	__u8 s_wtime_hi;
	__u8 s_mtime_hi;
	__u8 s_mkfs_time_hi;
	__u8 s_lastcheck_hi;
	__u8 s_first_error_time_hi;
	__u8 s_last_error_time_hi;
	__u8 s_first_error_errcode;
	__u8 s_last_error_errcode;
	__le16 s_encoding;
	__le16 s_encoding_flags;
	__le32 s_orphan_file_inum;
	__le32 s_reserved[94];
	__le32 s_checksum;
};

struct ext4_journal_trigger {
	struct jbd2_buffer_trigger_type tr_triggers;
	struct super_block *sb;
};

struct ext4_orphan_block {
	atomic_t ob_free_entries;
	struct buffer_head *ob_bh;
};

struct ext4_orphan_info {
	int of_blocks;
	__u32 of_csum_seed;
	struct ext4_orphan_block *of_binfo;
};

struct mb_cache;

struct ext4_group_info;

struct ext4_locality_group;

struct ext4_li_request;

struct ext4_sb_info {
	long unsigned int s_desc_size;
	long unsigned int s_inodes_per_block;
	long unsigned int s_blocks_per_group;
	long unsigned int s_clusters_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	ext4_group_t s_groups_count;
	ext4_group_t s_blockfile_groups;
	long unsigned int s_overhead;
	unsigned int s_cluster_ratio;
	unsigned int s_cluster_bits;
	int: 32;
	loff_t s_bitmap_maxbytes;
	struct buffer_head *s_sbh;
	struct ext4_super_block *s_es;
	struct buffer_head **s_group_desc;
	unsigned int s_mount_opt;
	unsigned int s_mount_opt2;
	long unsigned int s_mount_flags;
	unsigned int s_def_mount_opt;
	int: 32;
	ext4_fsblk_t s_sb_block;
	atomic64_t s_resv_clusters;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	unsigned int s_inode_readahead_blks;
	unsigned int s_inode_goal;
	u32 s_hash_seed[4];
	int s_def_hash_version;
	int s_hash_unsigned;
	int: 32;
	struct percpu_counter s_freeclusters_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct percpu_counter s_dirtyclusters_counter;
	struct percpu_counter s_sra_exceeded_retry_limit;
	struct blockgroup_lock *s_blockgroup_lock;
	struct proc_dir_entry *s_proc;
	struct kobject s_kobj;
	struct completion s_kobj_unregister;
	struct super_block *s_sb;
	struct buffer_head *s_mmp_bh;
	struct journal_s *s_journal;
	long unsigned int s_ext4_flags;
	struct mutex s_orphan_lock;
	struct list_head s_orphan;
	struct ext4_orphan_info s_orphan_info;
	long unsigned int s_commit_interval;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	struct block_device *s_journal_bdev;
	char *s_qf_names[3];
	int s_jquota_fmt;
	unsigned int s_want_extra_isize;
	struct ext4_system_blocks *s_system_blks;
	struct ext4_group_info ***s_group_info;
	struct inode *s_buddy_cache;
	spinlock_t s_md_lock;
	short unsigned int *s_mb_offsets;
	unsigned int *s_mb_maxs;
	unsigned int s_group_info_size;
	unsigned int s_mb_free_pending;
	struct list_head s_freed_data_list;
	struct list_head s_discard_list;
	struct work_struct s_discard_work;
	atomic_t s_retry_alloc_pending;
	struct list_head *s_mb_avg_fragment_size;
	rwlock_t *s_mb_avg_fragment_size_locks;
	struct list_head *s_mb_largest_free_orders;
	rwlock_t *s_mb_largest_free_orders_locks;
	long unsigned int s_stripe;
	unsigned int s_mb_max_linear_groups;
	unsigned int s_mb_stream_request;
	unsigned int s_mb_max_to_scan;
	unsigned int s_mb_min_to_scan;
	unsigned int s_mb_stats;
	unsigned int s_mb_order2_reqs;
	unsigned int s_mb_group_prealloc;
	unsigned int s_mb_max_inode_prealloc;
	unsigned int s_max_dir_size_kb;
	long unsigned int s_mb_last_group;
	long unsigned int s_mb_last_start;
	unsigned int s_mb_prefetch;
	unsigned int s_mb_prefetch_limit;
	atomic_t s_bal_reqs;
	atomic_t s_bal_success;
	atomic_t s_bal_allocated;
	atomic_t s_bal_ex_scanned;
	atomic_t s_bal_groups_scanned;
	atomic_t s_bal_goals;
	atomic_t s_bal_breaks;
	atomic_t s_bal_2orders;
	atomic_t s_bal_cr0_bad_suggestions;
	atomic_t s_bal_cr1_bad_suggestions;
	int: 32;
	atomic64_t s_bal_cX_groups_considered[4];
	atomic64_t s_bal_cX_hits[4];
	atomic64_t s_bal_cX_failed[4];
	atomic_t s_mb_buddies_generated;
	int: 32;
	atomic64_t s_mb_generation_time;
	atomic_t s_mb_lost_chunks;
	atomic_t s_mb_preallocated;
	atomic_t s_mb_discarded;
	atomic_t s_lock_busy;
	struct ext4_locality_group *s_locality_groups;
	long unsigned int s_sectors_written_start;
	u64 s_kbytes_written;
	unsigned int s_extent_max_zeroout_kb;
	unsigned int s_log_groups_per_flex;
	struct flex_groups **s_flex_groups;
	ext4_group_t s_flex_groups_allocated;
	struct workqueue_struct *rsv_conversion_wq;
	struct timer_list s_err_report;
	struct ext4_li_request *s_li_request;
	unsigned int s_li_wait_mult;
	struct task_struct *s_mmp_tsk;
	long unsigned int s_last_trim_minblks;
	struct crypto_shash *s_chksum_driver;
	__u32 s_csum_seed;
	struct shrinker s_es_shrinker;
	struct list_head s_es_list;
	long int s_es_nr_inode;
	struct ext4_es_stats s_es_stats;
	struct mb_cache *s_ea_block_cache;
	struct mb_cache *s_ea_inode_cache;
	spinlock_t s_es_lock;
	struct ext4_journal_trigger s_journal_triggers[1];
	struct ratelimit_state s_err_ratelimit_state;
	struct ratelimit_state s_warning_ratelimit_state;
	struct ratelimit_state s_msg_ratelimit_state;
	atomic_t s_warning_count;
	atomic_t s_msg_count;
	struct fscrypt_dummy_policy s_dummy_enc_policy;
	struct percpu_rw_semaphore s_writepages_rwsem;
	struct dax_device *s_daxdev;
	int: 32;
	u64 s_dax_part_off;
	errseq_t s_bdev_wb_err;
	spinlock_t s_bdev_wb_lock;
	spinlock_t s_error_lock;
	int s_add_error_count;
	int s_first_error_code;
	__u32 s_first_error_line;
	__u32 s_first_error_ino;
	int: 32;
	__u64 s_first_error_block;
	const char *s_first_error_func;
	int: 32;
	time64_t s_first_error_time;
	int s_last_error_code;
	__u32 s_last_error_line;
	__u32 s_last_error_ino;
	int: 32;
	__u64 s_last_error_block;
	const char *s_last_error_func;
	int: 32;
	time64_t s_last_error_time;
	struct work_struct s_error_work;
	atomic_t s_fc_subtid;
	struct list_head s_fc_q[2];
	struct list_head s_fc_dentry_q[2];
	unsigned int s_fc_bytes;
	spinlock_t s_fc_lock;
	struct buffer_head *s_fc_bh;
	struct ext4_fc_stats s_fc_stats;
	tid_t s_fc_ineligible_tid;
	struct ext4_fc_replay_state s_fc_replay_state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ext4_group_info {
	long unsigned int bb_state;
	struct rb_root bb_free_root;
	ext4_grpblk_t bb_first_free;
	ext4_grpblk_t bb_free;
	ext4_grpblk_t bb_fragments;
	int bb_avg_fragment_size_order;
	ext4_grpblk_t bb_largest_free_order;
	ext4_group_t bb_group;
	struct list_head bb_prealloc_list;
	struct rw_semaphore alloc_sem;
	struct list_head bb_avg_fragment_size_node;
	struct list_head bb_largest_free_order_node;
	ext4_grpblk_t bb_counters[0];
};

struct ext4_locality_group {
	struct mutex lg_mutex;
	struct list_head lg_prealloc_list[10];
	spinlock_t lg_prealloc_lock;
};

enum ext4_li_mode {
	EXT4_LI_MODE_PREFETCH_BBITMAP = 0,
	EXT4_LI_MODE_ITABLE = 1,
};

struct ext4_li_request {
	struct super_block *lr_super;
	enum ext4_li_mode lr_mode;
	ext4_group_t lr_first_not_zeroed;
	ext4_group_t lr_next_group;
	struct list_head lr_request;
	long unsigned int lr_next_sched;
	long unsigned int lr_timeout;
};

struct shash_desc {
	struct crypto_shash *tfm;
	int: 32;
	void *__ctx[0];
};

struct ext4_map_blocks {
	ext4_fsblk_t m_pblk;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	unsigned int m_flags;
	int: 32;
};

struct ext4_system_zone {
	struct rb_node node;
	int: 32;
	ext4_fsblk_t start_blk;
	unsigned int count;
	u32 ino;
};

struct fscrypt_str {
	unsigned char *name;
	u32 len;
};

enum {
	EXT4_INODE_SECRM = 0,
	EXT4_INODE_UNRM = 1,
	EXT4_INODE_COMPR = 2,
	EXT4_INODE_SYNC = 3,
	EXT4_INODE_IMMUTABLE = 4,
	EXT4_INODE_APPEND = 5,
	EXT4_INODE_NODUMP = 6,
	EXT4_INODE_NOATIME = 7,
	EXT4_INODE_DIRTY = 8,
	EXT4_INODE_COMPRBLK = 9,
	EXT4_INODE_NOCOMPR = 10,
	EXT4_INODE_ENCRYPT = 11,
	EXT4_INODE_INDEX = 12,
	EXT4_INODE_IMAGIC = 13,
	EXT4_INODE_JOURNAL_DATA = 14,
	EXT4_INODE_NOTAIL = 15,
	EXT4_INODE_DIRSYNC = 16,
	EXT4_INODE_TOPDIR = 17,
	EXT4_INODE_HUGE_FILE = 18,
	EXT4_INODE_EXTENTS = 19,
	EXT4_INODE_VERITY = 20,
	EXT4_INODE_EA_INODE = 21,
	EXT4_INODE_DAX = 25,
	EXT4_INODE_INLINE_DATA = 28,
	EXT4_INODE_PROJINHERIT = 29,
	EXT4_INODE_CASEFOLD = 30,
	EXT4_INODE_RESERVED = 31,
};

enum {
	EXT4_FC_REASON_XATTR = 0,
	EXT4_FC_REASON_CROSS_RENAME = 1,
	EXT4_FC_REASON_JOURNAL_FLAG_CHANGE = 2,
	EXT4_FC_REASON_NOMEM = 3,
	EXT4_FC_REASON_SWAP_BOOT = 4,
	EXT4_FC_REASON_RESIZE = 5,
	EXT4_FC_REASON_RENAME_DIR = 6,
	EXT4_FC_REASON_FALLOC_RANGE = 7,
	EXT4_FC_REASON_INODE_JOURNAL_DATA = 8,
	EXT4_FC_REASON_MAX = 9,
};

enum ext4_journal_trigger_type {
	EXT4_JTR_ORPHAN_FILE = 0,
	EXT4_JTR_NONE = 1,
};

struct ext4_dir_entry_hash {
	__le32 hash;
	__le32 minor_hash;
};

struct ext4_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[255];
};

struct fname;

struct dir_private_info {
	struct rb_root root;
	struct rb_node *curr_node;
	struct fname *extra_fname;
	int: 32;
	loff_t last_pos;
	__u32 curr_hash;
	__u32 curr_minor_hash;
	__u32 next_hash;
	int: 32;
};

struct fname {
	__u32 hash;
	__u32 minor_hash;
	struct rb_node rb_hash;
	struct fname *next;
	__u32 inode;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

enum SHIFT_DIRECTION {
	SHIFT_LEFT = 0,
	SHIFT_RIGHT = 1,
};

struct ext4_io_end_vec {
	struct list_head list;
	loff_t offset;
	ssize_t size;
	int: 32;
};

struct ext4_io_end {
	struct list_head list;
	handle_t *handle;
	struct inode *inode;
	struct bio *bio;
	unsigned int flag;
	refcount_t count;
	struct list_head list_vec;
};

typedef struct ext4_io_end ext4_io_end_t;

enum {
	ES_WRITTEN_B = 0,
	ES_UNWRITTEN_B = 1,
	ES_DELAYED_B = 2,
	ES_HOLE_B = 3,
	ES_REFERENCED_B = 4,
	ES_FLAGS = 5,
};

enum {
	EXT4_STATE_JDATA = 0,
	EXT4_STATE_NEW = 1,
	EXT4_STATE_XATTR = 2,
	EXT4_STATE_NO_EXPAND = 3,
	EXT4_STATE_DA_ALLOC_CLOSE = 4,
	EXT4_STATE_EXT_MIGRATE = 5,
	EXT4_STATE_NEWENTRY = 6,
	EXT4_STATE_MAY_INLINE_DATA = 7,
	EXT4_STATE_EXT_PRECACHED = 8,
	EXT4_STATE_LUSTRE_EA_INODE = 9,
	EXT4_STATE_VERITY_IN_PROGRESS = 10,
	EXT4_STATE_FC_COMMITTING = 11,
	EXT4_STATE_ORPHAN_FILE = 12,
};

struct ext4_iloc {
	struct buffer_head *bh;
	long unsigned int offset;
	ext4_group_t block_group;
};

struct ext4_extent_tail {
	__le32 et_checksum;
};

struct ext4_extent {
	__le32 ee_block;
	__le16 ee_len;
	__le16 ee_start_hi;
	__le32 ee_start_lo;
};

struct ext4_extent_idx {
	__le32 ei_block;
	__le32 ei_leaf_lo;
	__le16 ei_leaf_hi;
	__u16 ei_unused;
};

struct ext4_extent_header {
	__le16 eh_magic;
	__le16 eh_entries;
	__le16 eh_max;
	__le16 eh_depth;
	__le32 eh_generation;
};

struct ext4_ext_path {
	ext4_fsblk_t p_block;
	__u16 p_depth;
	__u16 p_maxdepth;
	struct ext4_extent *p_ext;
	struct ext4_extent_idx *p_idx;
	struct ext4_extent_header *p_hdr;
	struct buffer_head *p_bh;
	int: 32;
};

struct partial_cluster {
	ext4_fsblk_t pclu;
	ext4_lblk_t lblk;
	enum {
		initial = 0,
		tofree = 1,
		nofree = 2,
	} state;
};

struct pending_reservation {
	struct rb_node rb_node;
	ext4_lblk_t lclu;
};

struct rsvd_count {
	int ndelonly;
	bool first_do_lblk_found;
	ext4_lblk_t first_do_lblk;
	ext4_lblk_t last_do_lblk;
	struct extent_status *left_es;
	bool partial;
	ext4_lblk_t lclu;
};

enum {
	EXT4_MF_MNTDIR_SAMPLED = 0,
	EXT4_MF_FS_ABORTED = 1,
	EXT4_MF_FC_INELIGIBLE = 2,
};

struct fsmap {
	__u32 fmr_device;
	__u32 fmr_flags;
	__u64 fmr_physical;
	__u64 fmr_owner;
	__u64 fmr_offset;
	__u64 fmr_length;
	__u64 fmr_reserved[3];
};

struct ext4_fsmap {
	struct list_head fmr_list;
	dev_t fmr_device;
	uint32_t fmr_flags;
	uint64_t fmr_physical;
	uint64_t fmr_owner;
	uint64_t fmr_length;
};

struct ext4_fsmap_head {
	uint32_t fmh_iflags;
	uint32_t fmh_oflags;
	unsigned int fmh_count;
	unsigned int fmh_entries;
	struct ext4_fsmap fmh_keys[2];
};

typedef int (*ext4_fsmap_format_t)(struct ext4_fsmap *, void *);

struct ext4_getfsmap_info {
	struct ext4_fsmap_head *gfi_head;
	ext4_fsmap_format_t gfi_formatter;
	void *gfi_format_arg;
	int: 32;
	ext4_fsblk_t gfi_next_fsblk;
	u32 gfi_dev;
	ext4_group_t gfi_agno;
	struct ext4_fsmap gfi_low;
	struct ext4_fsmap gfi_high;
	struct ext4_fsmap gfi_lastfree;
	struct list_head gfi_meta_list;
	bool gfi_last;
	int: 24;
	int: 32;
};

struct ext4_getfsmap_dev {
	int (*gfd_fn)(struct super_block *, struct ext4_fsmap *, struct ext4_getfsmap_info *);
	u32 gfd_dev;
};

struct dx_hash_info {
	u32 hash;
	u32 minor_hash;
	int hash_version;
	u32 *seed;
};

struct fscrypt_info;

typedef short unsigned int __kernel_mode_t;

typedef __kernel_mode_t mode_t;

struct ext4_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size_lo;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks_lo;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_version;
		} linux1;
		struct {
			__u32 h_i_translator;
		} hurd1;
		struct {
			__u32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl_lo;
	__le32 i_size_high;
	__le32 i_obso_faddr;
	union {
		struct {
			__le16 l_i_blocks_high;
			__le16 l_i_file_acl_high;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__le16 l_i_checksum_lo;
			__le16 l_i_reserved;
		} linux2;
		struct {
			__le16 h_i_reserved1;
			__u16 h_i_mode_high;
			__u16 h_i_uid_high;
			__u16 h_i_gid_high;
			__u32 h_i_author;
		} hurd2;
		struct {
			__le16 h_i_reserved1;
			__le16 m_i_file_acl_high;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
	__le16 i_extra_isize;
	__le16 i_checksum_hi;
	__le32 i_ctime_extra;
	__le32 i_mtime_extra;
	__le32 i_atime_extra;
	__le32 i_crtime;
	__le32 i_crtime_extra;
	__le32 i_version_hi;
	__le32 i_projid;
};

struct orlov_stats {
	__u64 free_clusters;
	__u32 free_inodes;
	__u32 used_dirs;
};

typedef struct {
	__le32 *p;
	__le32 key;
	struct buffer_head *bh;
} Indirect;

struct ext4_filename {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	struct dx_hash_info hinfo;
};

struct ext4_xattr_ibody_header {
	__le32 h_magic;
};

struct ext4_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_inum;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

struct ext4_xattr_info {
	const char *name;
	const void *value;
	size_t value_len;
	int name_index;
	int in_inode;
};

struct ext4_xattr_search {
	struct ext4_xattr_entry *first;
	void *base;
	void *end;
	struct ext4_xattr_entry *here;
	int not_found;
};

struct ext4_xattr_ibody_find {
	struct ext4_xattr_search s;
	struct ext4_iloc iloc;
};

typedef short unsigned int __kernel_uid16_t;

typedef short unsigned int __kernel_gid16_t;

typedef __kernel_uid16_t uid16_t;

typedef __kernel_gid16_t gid16_t;

struct ext4_io_submit {
	struct writeback_control *io_wbc;
	struct bio *io_bio;
	ext4_io_end_t *io_end;
	int: 32;
	sector_t io_next_block;
};

typedef enum {
	EXT4_IGET_NORMAL = 0,
	EXT4_IGET_SPECIAL = 1,
	EXT4_IGET_HANDLE = 2,
} ext4_iget_flags;

struct ext4_xattr_inode_array {
	unsigned int count;
	struct inode *inodes[0];
};

struct mpage_da_data {
	struct inode *inode;
	struct writeback_control *wbc;
	long unsigned int first_page;
	long unsigned int next_page;
	long unsigned int last_page;
	int: 32;
	struct ext4_map_blocks map;
	struct ext4_io_submit io_submit;
	unsigned int do_map: 1;
	unsigned int scanned_until_end: 1;
	int: 30;
	int: 32;
};

struct fsverity_info;

struct fstrim_range {
	__u64 start;
	__u64 len;
	__u64 minlen;
};

struct ext4_new_group_input {
	__u32 group;
	int: 32;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 unused;
};

struct ext4_new_group_data {
	__u32 group;
	int: 32;
	__u64 block_bitmap;
	__u64 inode_bitmap;
	__u64 inode_table;
	__u32 blocks_count;
	__u16 reserved_blocks;
	__u16 mdata_blocks;
	__u32 free_clusters_count;
	int: 32;
};

struct fsuuid {
	__u32 fsu_len;
	__u32 fsu_flags;
	__u8 fsu_uuid[0];
};

struct move_extent {
	__u32 reserved;
	__u32 donor_fd;
	__u64 orig_start;
	__u64 donor_start;
	__u64 len;
	__u64 moved_len;
};

struct fsmap_head {
	__u32 fmh_iflags;
	__u32 fmh_oflags;
	__u32 fmh_count;
	__u32 fmh_entries;
	__u64 fmh_reserved[6];
	struct fsmap fmh_keys[2];
	struct fsmap fmh_recs[0];
};

typedef void ext4_update_sb_callback(struct ext4_super_block *, const void *);

struct getfsmap_info {
	struct super_block *gi_sb;
	struct fsmap_head *gi_data;
	unsigned int gi_idx;
	__u32 gi_last_flags;
};

typedef long unsigned int cycles_t;

enum blk_default_limits {
	BLK_MAX_SEGMENTS = 128,
	BLK_SAFE_MAX_SECTORS = 255,
	BLK_DEF_MAX_SECTORS = 2560,
	BLK_MAX_SEGMENT_SIZE = 65536,
	BLK_SEG_BOUNDARY_MASK = 4294967295,
};

struct ext4_free_data {
	struct list_head efd_list;
	struct rb_node efd_node;
	ext4_group_t efd_group;
	ext4_grpblk_t efd_start_cluster;
	ext4_grpblk_t efd_count;
	tid_t efd_tid;
};

struct ext4_prealloc_space {
	struct list_head pa_inode_list;
	struct list_head pa_group_list;
	union {
		struct list_head pa_tmp_list;
		struct callback_head pa_rcu;
	} u;
	spinlock_t pa_lock;
	atomic_t pa_count;
	unsigned int pa_deleted;
	int: 32;
	ext4_fsblk_t pa_pstart;
	ext4_lblk_t pa_lstart;
	ext4_grpblk_t pa_len;
	ext4_grpblk_t pa_free;
	short unsigned int pa_type;
	spinlock_t *pa_obj_lock;
	struct inode *pa_inode;
};

enum {
	MB_INODE_PA = 0,
	MB_GROUP_PA = 1,
};

struct ext4_free_extent {
	ext4_lblk_t fe_logical;
	ext4_grpblk_t fe_start;
	ext4_group_t fe_group;
	ext4_grpblk_t fe_len;
};

struct ext4_allocation_context {
	struct inode *ac_inode;
	struct super_block *ac_sb;
	struct ext4_free_extent ac_o_ex;
	struct ext4_free_extent ac_g_ex;
	struct ext4_free_extent ac_b_ex;
	struct ext4_free_extent ac_f_ex;
	__u32 ac_groups_considered;
	__u32 ac_flags;
	__u16 ac_groups_scanned;
	__u16 ac_groups_linear_remaining;
	__u16 ac_found;
	__u16 ac_tail;
	__u16 ac_buddy;
	__u8 ac_status;
	__u8 ac_criteria;
	__u8 ac_2order;
	__u8 ac_op;
	struct page *ac_bitmap_page;
	struct page *ac_buddy_page;
	struct ext4_prealloc_space *ac_pa;
	struct ext4_locality_group *ac_lg;
};

struct ext4_buddy {
	struct page *bd_buddy_page;
	void *bd_buddy;
	struct page *bd_bitmap_page;
	void *bd_bitmap;
	struct ext4_group_info *bd_info;
	struct super_block *bd_sb;
	__u16 bd_blkbits;
	ext4_group_t bd_group;
};

typedef int (*ext4_mballoc_query_range_fn)(struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t, void *);

struct sg {
	struct ext4_group_info info;
	ext4_grpblk_t counters[18];
};

struct migrate_struct {
	ext4_lblk_t first_block;
	ext4_lblk_t last_block;
	ext4_lblk_t curr_block;
	int: 32;
	ext4_fsblk_t first_pblock;
	ext4_fsblk_t last_pblock;
};

struct mmp_struct {
	__le32 mmp_magic;
	__le32 mmp_seq;
	__le64 mmp_time;
	char mmp_nodename[64];
	char mmp_bdevname[32];
	__le16 mmp_check_interval;
	__le16 mmp_pad1;
	__le32 mmp_pad2[226];
	__le32 mmp_checksum;
};

struct fscrypt_name {
	const struct qstr *usr_fname;
	struct fscrypt_str disk_name;
	u32 hash;
	u32 minor_hash;
	struct fscrypt_str crypto_buf;
	bool is_nokey_name;
};

struct ext4_dir_entry {
	__le32 inode;
	__le16 rec_len;
	__le16 name_len;
	char name[255];
};

struct ext4_dir_entry_tail {
	__le32 det_reserved_zero1;
	__le16 det_rec_len;
	__u8 det_reserved_zero2;
	__u8 det_reserved_ft;
	__le32 det_checksum;
};

typedef enum {
	EITHER = 0,
	INDEX = 1,
	DIRENT = 2,
	DIRENT_HTREE = 3,
} dirblock_type_t;

struct fake_dirent {
	__le32 inode;
	__le16 rec_len;
	u8 name_len;
	u8 file_type;
};

struct dx_countlimit {
	__le16 limit;
	__le16 count;
};

struct dx_entry {
	__le32 hash;
	__le32 block;
};

struct dx_root_info {
	__le32 reserved_zero;
	u8 hash_version;
	u8 info_length;
	u8 indirect_levels;
	u8 unused_flags;
};

struct dx_root {
	struct fake_dirent dot;
	char dot_name[4];
	struct fake_dirent dotdot;
	char dotdot_name[4];
	struct dx_root_info info;
	struct dx_entry entries[0];
};

struct dx_node {
	struct fake_dirent fake;
	struct dx_entry entries[0];
};

struct dx_frame {
	struct buffer_head *bh;
	struct dx_entry *entries;
	struct dx_entry *at;
};

struct dx_map_entry {
	u32 hash;
	u16 offs;
	u16 size;
};

struct dx_tail {
	u32 dt_reserved;
	__le32 dt_checksum;
};

struct ext4_renament {
	struct inode *dir;
	struct dentry *dentry;
	struct inode *inode;
	bool is_dir;
	int dir_nlink_delta;
	struct buffer_head *bh;
	struct ext4_dir_entry_2 *de;
	int inlined;
	struct buffer_head *dir_bh;
	struct ext4_dir_entry_2 *parent_de;
	int dir_inlined;
};

enum bio_post_read_step {
	STEP_INITIAL = 0,
	STEP_DECRYPT = 1,
	STEP_VERITY = 2,
	STEP_MAX = 3,
};

struct bio_post_read_ctx {
	struct bio *bio;
	struct work_struct work;
	unsigned int cur_step;
	unsigned int enabled_steps;
};

enum {
	BLOCK_BITMAP = 0,
	INODE_BITMAP = 1,
	INODE_TABLE = 2,
	GROUP_TABLE_COUNT = 3,
};

struct ext4_rcu_ptr {
	struct callback_head rcu;
	void *ptr;
};

struct ext4_new_flex_group_data {
	struct ext4_new_group_data *groups;
	__u16 *bg_flags;
	ext4_group_t count;
};

enum {
	IOPRIO_CLASS_NONE = 0,
	IOPRIO_CLASS_RT = 1,
	IOPRIO_CLASS_BE = 2,
	IOPRIO_CLASS_IDLE = 3,
};

struct disk_stats {
	u64 nsecs[4];
	long unsigned int sectors[4];
	long unsigned int ios[4];
	long unsigned int merges[4];
	long unsigned int io_ticks;
	local_t in_flight[2];
	int: 32;
};

enum stat_group {
	STAT_READ = 0,
	STAT_WRITE = 1,
	STAT_DISCARD = 2,
	STAT_FLUSH = 3,
	NR_STAT_GROUPS = 4,
};

struct dax_holder_operations {
	int (*notify_failure)(struct dax_device *, u64, u64, int);
};

enum {
	I_DATA_SEM_NORMAL = 0,
	I_DATA_SEM_OTHER = 1,
	I_DATA_SEM_QUOTA = 2,
};

struct ext4_lazy_init {
	long unsigned int li_state;
	struct list_head li_request_list;
	struct mutex li_list_mtx;
};

struct ext4_journal_cb_entry {
	struct list_head jce_list;
	void (*jce_func)(struct super_block *, struct ext4_journal_cb_entry *, int);
};

struct trace_event_raw_ext4_other_inode_update_time {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t orig_ino;
	uid_t uid;
	gid_t gid;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_free_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	uid_t uid;
	gid_t gid;
	__u64 blocks;
	__u16 mode;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4_request_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_allocate_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t dir;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_evict_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int nlink;
	char __data[0];
};

struct trace_event_raw_ext4_drop_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int drop;
	char __data[0];
};

struct trace_event_raw_ext4_nfs_commit_metadata {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_mark_inode_dirty {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int ip;
	char __data[0];
};

struct trace_event_raw_ext4_begin_ordered_truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_ext4__write_begin {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4__write_end {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int len;
	unsigned int copied;
	char __data[0];
};

struct trace_event_raw_ext4_writepages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long int nr_to_write;
	long int pages_skipped;
	loff_t range_start;
	loff_t range_end;
	long unsigned int writeback_index;
	int sync_mode;
	char for_kupdate;
	char range_cyclic;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4_da_write_pages {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int first_page;
	long int nr_to_write;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_write_pages_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 lblk;
	__u32 len;
	__u32 flags;
	char __data[0];
};

struct trace_event_raw_ext4_writepages_result {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	int pages_written;
	long int pages_skipped;
	long unsigned int writeback_index;
	int sync_mode;
	char __data[0];
};

struct trace_event_raw_ext4__page_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	char __data[0];
};

struct trace_event_raw_ext4_invalidate_folio_op {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	long unsigned int index;
	size_t offset;
	size_t length;
	char __data[0];
};

struct trace_event_raw_ext4_discard_blocks {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	__u64 blk;
	__u64 count;
	char __data[0];
};

struct trace_event_raw_ext4__mb_new_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 pa_pstart;
	__u64 pa_lstart;
	__u32 pa_len;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_mb_release_inode_pa {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	__u32 count;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_mb_release_group_pa {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	__u64 pa_pstart;
	__u32 pa_len;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	unsigned int needed;
	char __data[0];
};

struct trace_event_raw_ext4_mb_discard_preallocations {
	struct trace_entry ent;
	dev_t dev;
	int needed;
	char __data[0];
};

struct trace_event_raw_ext4_request_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_allocate_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	unsigned int len;
	__u32 logical;
	__u32 lleft;
	__u32 lright;
	__u64 goal;
	__u64 pleft;
	__u64 pright;
	unsigned int flags;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_free_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	long unsigned int count;
	int flags;
	__u16 mode;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4_sync_file_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int datasync;
	char __data[0];
};

struct trace_event_raw_ext4_sync_file_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_sync_fs {
	struct trace_entry ent;
	dev_t dev;
	int wait;
	char __data[0];
};

struct trace_event_raw_ext4_alloc_da_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int data_blocks;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_alloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 goal_logical;
	int goal_start;
	__u32 goal_group;
	int goal_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	__u16 found;
	__u16 groups;
	__u16 buddy;
	__u16 flags;
	__u16 tail;
	__u8 cr;
	char __data[0];
};

struct trace_event_raw_ext4_mballoc_prealloc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u32 orig_logical;
	int orig_start;
	__u32 orig_group;
	int orig_len;
	__u32 result_logical;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4__mballoc {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int result_start;
	__u32 result_group;
	int result_len;
	char __data[0];
};

struct trace_event_raw_ext4_forget {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 block;
	int is_metadata;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_update_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int used_blocks;
	int reserved_data_blocks;
	int quota_claim;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_reserve_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
};

struct trace_event_raw_ext4_da_release_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 i_blocks;
	int freed_blocks;
	int reserved_data_blocks;
	__u16 mode;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4__bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_read_block_bitmap_load {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	bool prefetch;
	char __data[0];
};

struct trace_event_raw_ext4__fallocate_mode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	int mode;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_fallocate_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t pos;
	unsigned int blocks;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ino_t parent;
	int: 32;
	loff_t size;
	char __data[0];
};

struct trace_event_raw_ext4_unlink_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4__truncate {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	__u64 blocks;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_convert_to_initialized_fastpath {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t m_lblk;
	unsigned int m_len;
	ext4_lblk_t u_lblk;
	unsigned int u_len;
	ext4_fsblk_t u_pblk;
	ext4_lblk_t i_lblk;
	unsigned int i_len;
	ext4_fsblk_t i_pblk;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4__map_blocks_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	unsigned int flags;
	int: 32;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	unsigned int len;
	unsigned int mflags;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_load_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	char __data[0];
	int: 32;
};

struct trace_event_raw_ext4_load_inode {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	int rsv_blocks;
	int revoke_creds;
	char __data[0];
};

struct trace_event_raw_ext4_journal_start_reserved {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int ip;
	int blocks;
	char __data[0];
};

struct trace_event_raw_ext4__trim {
	struct trace_entry ent;
	int dev_major;
	int dev_minor;
	__u32 group;
	int start;
	int len;
	char __data[0];
};

struct trace_event_raw_ext4_ext_handle_unwritten_extents {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	int flags;
	ext4_lblk_t lblk;
	ext4_fsblk_t pblk;
	unsigned int len;
	unsigned int allocated;
	ext4_fsblk_t newblk;
	char __data[0];
};

struct trace_event_raw_ext4_get_implied_cluster_alloc_exit {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	ext4_lblk_t lblk;
	int: 32;
	ext4_fsblk_t pblk;
	unsigned int len;
	int ret;
	char __data[0];
};

struct trace_event_raw_ext4_ext_show_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	ext4_lblk_t lblk;
	short unsigned int len;
	char __data[0];
};

struct trace_event_raw_ext4_remove_blocks {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t from;
	ext4_lblk_t to;
	ext4_fsblk_t ee_pblk;
	ext4_lblk_t ee_lblk;
	short unsigned int ee_len;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_leaf {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t ee_lblk;
	ext4_fsblk_t ee_pblk;
	short int ee_len;
	int: 16;
	int: 32;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	char __data[0];
};

struct trace_event_raw_ext4_ext_rm_idx {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_fsblk_t pblk;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	char __data[0];
};

struct trace_event_raw_ext4_ext_remove_space_done {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t start;
	ext4_lblk_t end;
	int depth;
	int: 32;
	ext4_fsblk_t pc_pclu;
	ext4_lblk_t pc_lblk;
	int pc_state;
	short unsigned int eh_entries;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4__es_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_ext4_es_remove_extent {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t lblk;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_find_extent_range_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	char __data[0];
	int: 24;
	int: 32;
};

struct trace_event_raw_ext4_es_lookup_extent_enter {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	char __data[0];
};

struct trace_event_raw_ext4_es_lookup_extent_exit {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	int found;
	char __data[0];
};

struct trace_event_raw_ext4__es_shrink_enter {
	struct trace_entry ent;
	dev_t dev;
	int nr_to_scan;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	int cache_cnt;
	char __data[0];
};

struct trace_event_raw_ext4_collapse_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_insert_range {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	loff_t offset;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_ext4_es_shrink {
	struct trace_entry ent;
	dev_t dev;
	int nr_shrunk;
	long long unsigned int scan_time;
	int nr_skipped;
	int retried;
	char __data[0];
};

struct trace_event_raw_ext4_es_insert_delayed_block {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	ext4_lblk_t lblk;
	ext4_lblk_t len;
	ext4_fsblk_t pblk;
	char status;
	bool allocated;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_ext4_fsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u32 agno;
	int: 32;
	u64 bno;
	u64 len;
	u64 owner;
	char __data[0];
};

struct trace_event_raw_ext4_getfsmap_class {
	struct trace_entry ent;
	dev_t dev;
	dev_t keydev;
	u64 block;
	u64 len;
	u64 owner;
	u64 flags;
	char __data[0];
};

struct trace_event_raw_ext4_shutdown {
	struct trace_entry ent;
	dev_t dev;
	unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ext4_error {
	struct trace_entry ent;
	dev_t dev;
	const char *function;
	unsigned int line;
	char __data[0];
};

struct trace_event_raw_ext4_prefetch_bitmaps {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	__u32 next;
	__u32 ios;
	char __data[0];
};

struct trace_event_raw_ext4_lazy_itable_init {
	struct trace_entry ent;
	dev_t dev;
	__u32 group;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay_scan {
	struct trace_entry ent;
	dev_t dev;
	int error;
	int off;
	char __data[0];
};

struct trace_event_raw_ext4_fc_replay {
	struct trace_entry ent;
	dev_t dev;
	int tag;
	int ino;
	int priv1;
	int priv2;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_start {
	struct trace_entry ent;
	dev_t dev;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_commit_stop {
	struct trace_entry ent;
	dev_t dev;
	int nblks;
	int reason;
	int num_fc;
	int num_fc_ineligible;
	int nblks_agg;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_fc_stats {
	struct trace_entry ent;
	dev_t dev;
	unsigned int fc_ineligible_rc[9];
	long unsigned int fc_commits;
	long unsigned int fc_ineligible_commits;
	long unsigned int fc_numblks;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_dentry {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_inode {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_track_range {
	struct trace_entry ent;
	dev_t dev;
	tid_t t_tid;
	ino_t i_ino;
	tid_t i_sync_tid;
	long int start;
	long int end;
	int error;
	char __data[0];
};

struct trace_event_raw_ext4_fc_cleanup {
	struct trace_entry ent;
	dev_t dev;
	int j_fc_off;
	int full;
	tid_t tid;
	char __data[0];
};

struct trace_event_raw_ext4_update_sb {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	ext4_fsblk_t fsblk;
	unsigned int flags;
	char __data[0];
	int: 32;
};

struct trace_event_data_offsets_ext4_other_inode_update_time {};

struct trace_event_data_offsets_ext4_free_inode {};

struct trace_event_data_offsets_ext4_request_inode {};

struct trace_event_data_offsets_ext4_allocate_inode {};

struct trace_event_data_offsets_ext4_evict_inode {};

struct trace_event_data_offsets_ext4_drop_inode {};

struct trace_event_data_offsets_ext4_nfs_commit_metadata {};

struct trace_event_data_offsets_ext4_mark_inode_dirty {};

struct trace_event_data_offsets_ext4_begin_ordered_truncate {};

struct trace_event_data_offsets_ext4__write_begin {};

struct trace_event_data_offsets_ext4__write_end {};

struct trace_event_data_offsets_ext4_writepages {};

struct trace_event_data_offsets_ext4_da_write_pages {};

struct trace_event_data_offsets_ext4_da_write_pages_extent {};

struct trace_event_data_offsets_ext4_writepages_result {};

struct trace_event_data_offsets_ext4__page_op {};

struct trace_event_data_offsets_ext4_invalidate_folio_op {};

struct trace_event_data_offsets_ext4_discard_blocks {};

struct trace_event_data_offsets_ext4__mb_new_pa {};

struct trace_event_data_offsets_ext4_mb_release_inode_pa {};

struct trace_event_data_offsets_ext4_mb_release_group_pa {};

struct trace_event_data_offsets_ext4_discard_preallocations {};

struct trace_event_data_offsets_ext4_mb_discard_preallocations {};

struct trace_event_data_offsets_ext4_request_blocks {};

struct trace_event_data_offsets_ext4_allocate_blocks {};

struct trace_event_data_offsets_ext4_free_blocks {};

struct trace_event_data_offsets_ext4_sync_file_enter {};

struct trace_event_data_offsets_ext4_sync_file_exit {};

struct trace_event_data_offsets_ext4_sync_fs {};

struct trace_event_data_offsets_ext4_alloc_da_blocks {};

struct trace_event_data_offsets_ext4_mballoc_alloc {};

struct trace_event_data_offsets_ext4_mballoc_prealloc {};

struct trace_event_data_offsets_ext4__mballoc {};

struct trace_event_data_offsets_ext4_forget {};

struct trace_event_data_offsets_ext4_da_update_reserve_space {};

struct trace_event_data_offsets_ext4_da_reserve_space {};

struct trace_event_data_offsets_ext4_da_release_space {};

struct trace_event_data_offsets_ext4__bitmap_load {};

struct trace_event_data_offsets_ext4_read_block_bitmap_load {};

struct trace_event_data_offsets_ext4__fallocate_mode {};

struct trace_event_data_offsets_ext4_fallocate_exit {};

struct trace_event_data_offsets_ext4_unlink_enter {};

struct trace_event_data_offsets_ext4_unlink_exit {};

struct trace_event_data_offsets_ext4__truncate {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_enter {};

struct trace_event_data_offsets_ext4_ext_convert_to_initialized_fastpath {};

struct trace_event_data_offsets_ext4__map_blocks_enter {};

struct trace_event_data_offsets_ext4__map_blocks_exit {};

struct trace_event_data_offsets_ext4_ext_load_extent {};

struct trace_event_data_offsets_ext4_load_inode {};

struct trace_event_data_offsets_ext4_journal_start {};

struct trace_event_data_offsets_ext4_journal_start_reserved {};

struct trace_event_data_offsets_ext4__trim {};

struct trace_event_data_offsets_ext4_ext_handle_unwritten_extents {};

struct trace_event_data_offsets_ext4_get_implied_cluster_alloc_exit {};

struct trace_event_data_offsets_ext4_ext_show_extent {};

struct trace_event_data_offsets_ext4_remove_blocks {};

struct trace_event_data_offsets_ext4_ext_rm_leaf {};

struct trace_event_data_offsets_ext4_ext_rm_idx {};

struct trace_event_data_offsets_ext4_ext_remove_space {};

struct trace_event_data_offsets_ext4_ext_remove_space_done {};

struct trace_event_data_offsets_ext4__es_extent {};

struct trace_event_data_offsets_ext4_es_remove_extent {};

struct trace_event_data_offsets_ext4_es_find_extent_range_enter {};

struct trace_event_data_offsets_ext4_es_find_extent_range_exit {};

struct trace_event_data_offsets_ext4_es_lookup_extent_enter {};

struct trace_event_data_offsets_ext4_es_lookup_extent_exit {};

struct trace_event_data_offsets_ext4__es_shrink_enter {};

struct trace_event_data_offsets_ext4_es_shrink_scan_exit {};

struct trace_event_data_offsets_ext4_collapse_range {};

struct trace_event_data_offsets_ext4_insert_range {};

struct trace_event_data_offsets_ext4_es_shrink {};

struct trace_event_data_offsets_ext4_es_insert_delayed_block {};

struct trace_event_data_offsets_ext4_fsmap_class {};

struct trace_event_data_offsets_ext4_getfsmap_class {};

struct trace_event_data_offsets_ext4_shutdown {};

struct trace_event_data_offsets_ext4_error {};

struct trace_event_data_offsets_ext4_prefetch_bitmaps {};

struct trace_event_data_offsets_ext4_lazy_itable_init {};

struct trace_event_data_offsets_ext4_fc_replay_scan {};

struct trace_event_data_offsets_ext4_fc_replay {};

struct trace_event_data_offsets_ext4_fc_commit_start {};

struct trace_event_data_offsets_ext4_fc_commit_stop {};

struct trace_event_data_offsets_ext4_fc_stats {};

struct trace_event_data_offsets_ext4_fc_track_dentry {};

struct trace_event_data_offsets_ext4_fc_track_inode {};

struct trace_event_data_offsets_ext4_fc_track_range {};

struct trace_event_data_offsets_ext4_fc_cleanup {};

struct trace_event_data_offsets_ext4_update_sb {};

typedef void (*btf_trace_ext4_other_inode_update_time)(void *, struct inode *, ino_t);

typedef void (*btf_trace_ext4_free_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_request_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_allocate_inode)(void *, struct inode *, struct inode *, int);

typedef void (*btf_trace_ext4_evict_inode)(void *, struct inode *);

typedef void (*btf_trace_ext4_drop_inode)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_nfs_commit_metadata)(void *, struct inode *);

typedef void (*btf_trace_ext4_mark_inode_dirty)(void *, struct inode *, long unsigned int);

typedef void (*btf_trace_ext4_begin_ordered_truncate)(void *, struct inode *, loff_t);

typedef void (*btf_trace_ext4_write_begin)(void *, struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_ext4_da_write_begin)(void *, struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_ext4_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_journalled_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_da_write_end)(void *, struct inode *, loff_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_writepages)(void *, struct inode *, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages)(void *, struct inode *, long unsigned int, struct writeback_control *);

typedef void (*btf_trace_ext4_da_write_pages_extent)(void *, struct inode *, struct ext4_map_blocks *);

typedef void (*btf_trace_ext4_writepages_result)(void *, struct inode *, struct writeback_control *, int, int);

typedef void (*btf_trace_ext4_writepage)(void *, struct page *);

typedef void (*btf_trace_ext4_readpage)(void *, struct page *);

typedef void (*btf_trace_ext4_releasepage)(void *, struct page *);

typedef void (*btf_trace_ext4_invalidate_folio)(void *, struct folio *, size_t, size_t);

typedef void (*btf_trace_ext4_journalled_invalidate_folio)(void *, struct folio *, size_t, size_t);

typedef void (*btf_trace_ext4_discard_blocks)(void *, struct super_block *, long long unsigned int, long long unsigned int);

typedef void (*btf_trace_ext4_mb_new_inode_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_new_group_pa)(void *, struct ext4_allocation_context *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_mb_release_inode_pa)(void *, struct ext4_prealloc_space *, long long unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_release_group_pa)(void *, struct super_block *, struct ext4_prealloc_space *);

typedef void (*btf_trace_ext4_discard_preallocations)(void *, struct inode *, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_mb_discard_preallocations)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_request_blocks)(void *, struct ext4_allocation_request *);

typedef void (*btf_trace_ext4_allocate_blocks)(void *, struct ext4_allocation_request *, long long unsigned int);

typedef void (*btf_trace_ext4_free_blocks)(void *, struct inode *, __u64, long unsigned int, int);

typedef void (*btf_trace_ext4_sync_file_enter)(void *, struct file *, int);

typedef void (*btf_trace_ext4_sync_file_exit)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_sync_fs)(void *, struct super_block *, int);

typedef void (*btf_trace_ext4_alloc_da_blocks)(void *, struct inode *);

typedef void (*btf_trace_ext4_mballoc_alloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_prealloc)(void *, struct ext4_allocation_context *);

typedef void (*btf_trace_ext4_mballoc_discard)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_mballoc_free)(void *, struct super_block *, struct inode *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_forget)(void *, struct inode *, int, __u64);

typedef void (*btf_trace_ext4_da_update_reserve_space)(void *, struct inode *, int, int);

typedef void (*btf_trace_ext4_da_reserve_space)(void *, struct inode *);

typedef void (*btf_trace_ext4_da_release_space)(void *, struct inode *, int);

typedef void (*btf_trace_ext4_mb_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_mb_buddy_bitmap_load)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_load_inode_bitmap)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_read_block_bitmap_load)(void *, struct super_block *, long unsigned int, bool);

typedef void (*btf_trace_ext4_fallocate_enter)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_punch_hole)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_zero_range)(void *, struct inode *, loff_t, loff_t, int);

typedef void (*btf_trace_ext4_fallocate_exit)(void *, struct inode *, loff_t, unsigned int, int);

typedef void (*btf_trace_ext4_unlink_enter)(void *, struct inode *, struct dentry *);

typedef void (*btf_trace_ext4_unlink_exit)(void *, struct dentry *, int);

typedef void (*btf_trace_ext4_truncate_enter)(void *, struct inode *);

typedef void (*btf_trace_ext4_truncate_exit)(void *, struct inode *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_enter)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_convert_to_initialized_fastpath)(void *, struct inode *, struct ext4_map_blocks *, struct ext4_extent *, struct ext4_extent *);

typedef void (*btf_trace_ext4_ext_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ind_map_blocks_enter)(void *, struct inode *, ext4_lblk_t, unsigned int, unsigned int);

typedef void (*btf_trace_ext4_ext_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ind_map_blocks_exit)(void *, struct inode *, unsigned int, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_load_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t);

typedef void (*btf_trace_ext4_load_inode)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_journal_start)(void *, struct super_block *, int, int, int, long unsigned int);

typedef void (*btf_trace_ext4_journal_start_reserved)(void *, struct super_block *, int, long unsigned int);

typedef void (*btf_trace_ext4_trim_extent)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_trim_all_free)(void *, struct super_block *, ext4_group_t, ext4_grpblk_t, ext4_grpblk_t);

typedef void (*btf_trace_ext4_ext_handle_unwritten_extents)(void *, struct inode *, struct ext4_map_blocks *, int, unsigned int, ext4_fsblk_t);

typedef void (*btf_trace_ext4_get_implied_cluster_alloc_exit)(void *, struct super_block *, struct ext4_map_blocks *, int);

typedef void (*btf_trace_ext4_ext_show_extent)(void *, struct inode *, ext4_lblk_t, ext4_fsblk_t, short unsigned int);

typedef void (*btf_trace_ext4_remove_blocks)(void *, struct inode *, struct ext4_extent *, ext4_lblk_t, ext4_fsblk_t, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_leaf)(void *, struct inode *, ext4_lblk_t, struct ext4_extent *, struct partial_cluster *);

typedef void (*btf_trace_ext4_ext_rm_idx)(void *, struct inode *, ext4_fsblk_t);

typedef void (*btf_trace_ext4_ext_remove_space)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int);

typedef void (*btf_trace_ext4_ext_remove_space_done)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t, int, struct partial_cluster *, __le16);

typedef void (*btf_trace_ext4_es_insert_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_cache_extent)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_remove_extent)(void *, struct inode *, ext4_lblk_t, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_find_extent_range_exit)(void *, struct inode *, struct extent_status *);

typedef void (*btf_trace_ext4_es_lookup_extent_enter)(void *, struct inode *, ext4_lblk_t);

typedef void (*btf_trace_ext4_es_lookup_extent_exit)(void *, struct inode *, struct extent_status *, int);

typedef void (*btf_trace_ext4_es_shrink_count)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_enter)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_es_shrink_scan_exit)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_collapse_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_insert_range)(void *, struct inode *, loff_t, loff_t);

typedef void (*btf_trace_ext4_es_shrink)(void *, struct super_block *, int, u64, int, int);

typedef void (*btf_trace_ext4_es_insert_delayed_block)(void *, struct inode *, struct extent_status *, bool);

typedef void (*btf_trace_ext4_fsmap_low_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_high_key)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_fsmap_mapping)(void *, struct super_block *, u32, u32, u64, u64, u64);

typedef void (*btf_trace_ext4_getfsmap_low_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_high_key)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_getfsmap_mapping)(void *, struct super_block *, struct ext4_fsmap *);

typedef void (*btf_trace_ext4_shutdown)(void *, struct super_block *, long unsigned int);

typedef void (*btf_trace_ext4_error)(void *, struct super_block *, const char *, unsigned int);

typedef void (*btf_trace_ext4_prefetch_bitmaps)(void *, struct super_block *, ext4_group_t, ext4_group_t, unsigned int);

typedef void (*btf_trace_ext4_lazy_itable_init)(void *, struct super_block *, ext4_group_t);

typedef void (*btf_trace_ext4_fc_replay_scan)(void *, struct super_block *, int, int);

typedef void (*btf_trace_ext4_fc_replay)(void *, struct super_block *, int, int, int, int);

typedef void (*btf_trace_ext4_fc_commit_start)(void *, struct super_block *, tid_t);

typedef void (*btf_trace_ext4_fc_commit_stop)(void *, struct super_block *, int, int, tid_t);

typedef void (*btf_trace_ext4_fc_stats)(void *, struct super_block *);

typedef void (*btf_trace_ext4_fc_track_create)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_link)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_unlink)(void *, handle_t *, struct inode *, struct dentry *, int);

typedef void (*btf_trace_ext4_fc_track_inode)(void *, handle_t *, struct inode *, int);

typedef void (*btf_trace_ext4_fc_track_range)(void *, handle_t *, struct inode *, long int, long int, int);

typedef void (*btf_trace_ext4_fc_cleanup)(void *, journal_t *, int, tid_t);

typedef void (*btf_trace_ext4_update_sb)(void *, struct super_block *, ext4_fsblk_t, unsigned int);

struct ext4_err_translation {
	int code;
	int errno;
};

enum {
	Opt_bsd_df = 0,
	Opt_minix_df = 1,
	Opt_grpid = 2,
	Opt_nogrpid = 3,
	Opt_resgid = 4,
	Opt_resuid = 5,
	Opt_sb = 6,
	Opt_nouid32 = 7,
	Opt_debug = 8,
	Opt_removed = 9,
	Opt_user_xattr = 10,
	Opt_acl = 11,
	Opt_auto_da_alloc = 12,
	Opt_noauto_da_alloc = 13,
	Opt_noload = 14,
	Opt_commit = 15,
	Opt_min_batch_time = 16,
	Opt_max_batch_time = 17,
	Opt_journal_dev = 18,
	Opt_journal_path = 19,
	Opt_journal_checksum = 20,
	Opt_journal_async_commit = 21,
	Opt_abort = 22,
	Opt_data_journal = 23,
	Opt_data_ordered = 24,
	Opt_data_writeback = 25,
	Opt_data_err_abort = 26,
	Opt_data_err_ignore = 27,
	Opt_test_dummy_encryption = 28,
	Opt_inlinecrypt = 29,
	Opt_usrjquota = 30,
	Opt_grpjquota = 31,
	Opt_quota = 32,
	Opt_noquota = 33,
	Opt_barrier = 34,
	Opt_nobarrier = 35,
	Opt_err___2 = 36,
	Opt_usrquota = 37,
	Opt_grpquota = 38,
	Opt_prjquota = 39,
	Opt_dax = 40,
	Opt_dax_always = 41,
	Opt_dax_inode = 42,
	Opt_dax_never = 43,
	Opt_stripe = 44,
	Opt_delalloc = 45,
	Opt_nodelalloc = 46,
	Opt_warn_on_error = 47,
	Opt_nowarn_on_error = 48,
	Opt_mblk_io_submit = 49,
	Opt_debug_want_extra_isize = 50,
	Opt_nomblk_io_submit = 51,
	Opt_block_validity = 52,
	Opt_noblock_validity = 53,
	Opt_inode_readahead_blks = 54,
	Opt_journal_ioprio = 55,
	Opt_dioread_nolock = 56,
	Opt_dioread_lock = 57,
	Opt_discard = 58,
	Opt_nodiscard = 59,
	Opt_init_itable = 60,
	Opt_noinit_itable = 61,
	Opt_max_dir_size_kb = 62,
	Opt_nojournal_checksum = 63,
	Opt_nombcache = 64,
	Opt_no_prefetch_block_bitmaps = 65,
	Opt_mb_optimize_scan = 66,
	Opt_errors = 67,
	Opt_data = 68,
	Opt_data_err = 69,
	Opt_jqfmt = 70,
	Opt_dax_type = 71,
};

struct mount_opts {
	int token;
	int mount_opt;
	int flags;
};

struct ext4_fs_context {
	char *s_qf_names[3];
	struct fscrypt_dummy_policy dummy_enc_policy;
	int s_jquota_fmt;
	short unsigned int qname_spec;
	long unsigned int vals_s_flags;
	long unsigned int mask_s_flags;
	long unsigned int journal_devnum;
	long unsigned int s_commit_interval;
	long unsigned int s_stripe;
	unsigned int s_inode_readahead_blks;
	unsigned int s_want_extra_isize;
	unsigned int s_li_wait_mult;
	unsigned int s_max_dir_size_kb;
	unsigned int journal_ioprio;
	unsigned int vals_s_mount_opt;
	unsigned int mask_s_mount_opt;
	unsigned int vals_s_mount_opt2;
	unsigned int mask_s_mount_opt2;
	long unsigned int vals_s_mount_flags;
	long unsigned int mask_s_mount_flags;
	unsigned int opt_flags;
	unsigned int spec;
	u32 s_max_batch_time;
	u32 s_min_batch_time;
	kuid_t s_resuid;
	kgid_t s_resgid;
	int: 32;
	ext4_fsblk_t s_sb_block;
};

struct ext4_mount_options {
	long unsigned int s_mount_opt;
	long unsigned int s_mount_opt2;
	kuid_t s_resuid;
	kgid_t s_resgid;
	long unsigned int s_commit_interval;
	u32 s_min_batch_time;
	u32 s_max_batch_time;
	int s_jquota_fmt;
	char *s_qf_names[3];
};

enum {
	attr_noop = 0,
	attr_delayed_allocation_blocks = 1,
	attr_session_write_kbytes = 2,
	attr_lifetime_write_kbytes = 3,
	attr_reserved_clusters = 4,
	attr_sra_exceeded_retry_limit = 5,
	attr_inode_readahead = 6,
	attr_trigger_test_error = 7,
	attr_first_error_time = 8,
	attr_last_error_time = 9,
	attr_feature = 10,
	attr_pointer_ui = 11,
	attr_pointer_ul = 12,
	attr_pointer_u64 = 13,
	attr_pointer_u8 = 14,
	attr_pointer_string = 15,
	attr_pointer_atomic = 16,
	attr_journal_task = 17,
};

enum {
	ptr_explicit = 0,
	ptr_ext4_sb_info_offset = 1,
	ptr_ext4_super_block_offset = 2,
};

struct ext4_attr {
	struct attribute attr;
	short int attr_id;
	short int attr_ptr;
	short unsigned int attr_size;
	union {
		int offset;
		void *explicit_ptr;
	} u;
};

struct ext4_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__le32 h_checksum;
	__u32 h_reserved[3];
};

struct ext4_xattr_block_find {
	struct ext4_xattr_search s;
	struct buffer_head *bh;
};

struct ext4_fc_tl {
	__le16 fc_tag;
	__le16 fc_len;
};

struct ext4_fc_head {
	__le32 fc_features;
	__le32 fc_tid;
};

struct ext4_fc_add_range {
	__le32 fc_ino;
	__u8 fc_ex[12];
};

struct ext4_fc_del_range {
	__le32 fc_ino;
	__le32 fc_lblk;
	__le32 fc_len;
};

struct ext4_fc_dentry_info {
	__le32 fc_parent_ino;
	__le32 fc_ino;
	__u8 fc_dname[0];
};

struct ext4_fc_inode {
	__le32 fc_ino;
	__u8 fc_raw_inode[0];
};

struct ext4_fc_tail {
	__le32 fc_tid;
	__le32 fc_crc;
};

enum {
	EXT4_FC_STATUS_OK = 0,
	EXT4_FC_STATUS_INELIGIBLE = 1,
	EXT4_FC_STATUS_SKIPPED = 2,
	EXT4_FC_STATUS_FAILED = 3,
};

struct ext4_fc_dentry_update {
	int fcd_op;
	int fcd_parent;
	int fcd_ino;
	int: 32;
	struct qstr fcd_name;
	unsigned char fcd_iname[36];
	struct list_head fcd_list;
	struct list_head fcd_dilist;
	int: 32;
};

struct __track_dentry_update_args {
	struct dentry *dentry;
	int op;
};

struct __track_range_args {
	ext4_lblk_t start;
	ext4_lblk_t end;
};

struct dentry_info_args {
	int parent_ino;
	int dname_len;
	int ino;
	int inode_len;
	char *dname;
};

struct ext4_orphan_block_tail {
	__le32 ob_magic;
	__le32 ob_checksum;
};

typedef struct {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
} ext4_acl_entry;

typedef struct {
	__le32 a_version;
} ext4_acl_header;

typedef int ext2_grpblk_t;

typedef long unsigned int ext2_fsblk_t;

struct ext2_reserve_window {
	ext2_fsblk_t _rsv_start;
	ext2_fsblk_t _rsv_end;
};

struct ext2_reserve_window_node {
	struct rb_node rsv_node;
	__u32 rsv_goal_size;
	__u32 rsv_alloc_hit;
	struct ext2_reserve_window rsv_window;
};

struct ext2_block_alloc_info {
	struct ext2_reserve_window_node rsv_window_node;
	__u32 last_alloc_logical_block;
	ext2_fsblk_t last_alloc_physical_block;
};

struct ext2_super_block;

struct ext2_sb_info {
	long unsigned int s_frag_size;
	long unsigned int s_frags_per_block;
	long unsigned int s_inodes_per_block;
	long unsigned int s_frags_per_group;
	long unsigned int s_blocks_per_group;
	long unsigned int s_inodes_per_group;
	long unsigned int s_itb_per_group;
	long unsigned int s_gdb_count;
	long unsigned int s_desc_per_block;
	long unsigned int s_groups_count;
	long unsigned int s_overhead_last;
	long unsigned int s_blocks_last;
	struct buffer_head *s_sbh;
	struct ext2_super_block *s_es;
	struct buffer_head **s_group_desc;
	long unsigned int s_mount_opt;
	long unsigned int s_sb_block;
	kuid_t s_resuid;
	kgid_t s_resgid;
	short unsigned int s_mount_state;
	short unsigned int s_pad;
	int s_addr_per_block_bits;
	int s_desc_per_block_bits;
	int s_inode_size;
	int s_first_ino;
	spinlock_t s_next_gen_lock;
	u32 s_next_generation;
	long unsigned int s_dir_count;
	u8 *s_debts;
	struct percpu_counter s_freeblocks_counter;
	struct percpu_counter s_freeinodes_counter;
	struct percpu_counter s_dirs_counter;
	struct blockgroup_lock *s_blockgroup_lock;
	spinlock_t s_rsv_window_lock;
	struct rb_root s_rsv_window_root;
	struct ext2_reserve_window_node s_rsv_window_head;
	spinlock_t s_lock;
	struct mb_cache *s_ea_block_cache;
	struct dax_device *s_daxdev;
	int: 32;
	u64 s_dax_part_off;
};

struct ext2_super_block {
	__le32 s_inodes_count;
	__le32 s_blocks_count;
	__le32 s_r_blocks_count;
	__le32 s_free_blocks_count;
	__le32 s_free_inodes_count;
	__le32 s_first_data_block;
	__le32 s_log_block_size;
	__le32 s_log_frag_size;
	__le32 s_blocks_per_group;
	__le32 s_frags_per_group;
	__le32 s_inodes_per_group;
	__le32 s_mtime;
	__le32 s_wtime;
	__le16 s_mnt_count;
	__le16 s_max_mnt_count;
	__le16 s_magic;
	__le16 s_state;
	__le16 s_errors;
	__le16 s_minor_rev_level;
	__le32 s_lastcheck;
	__le32 s_checkinterval;
	__le32 s_creator_os;
	__le32 s_rev_level;
	__le16 s_def_resuid;
	__le16 s_def_resgid;
	__le32 s_first_ino;
	__le16 s_inode_size;
	__le16 s_block_group_nr;
	__le32 s_feature_compat;
	__le32 s_feature_incompat;
	__le32 s_feature_ro_compat;
	__u8 s_uuid[16];
	char s_volume_name[16];
	char s_last_mounted[64];
	__le32 s_algorithm_usage_bitmap;
	__u8 s_prealloc_blocks;
	__u8 s_prealloc_dir_blocks;
	__u16 s_padding1;
	__u8 s_journal_uuid[16];
	__u32 s_journal_inum;
	__u32 s_journal_dev;
	__u32 s_last_orphan;
	__u32 s_hash_seed[4];
	__u8 s_def_hash_version;
	__u8 s_reserved_char_pad;
	__u16 s_reserved_word_pad;
	__le32 s_default_mount_opts;
	__le32 s_first_meta_bg;
	__u32 s_reserved[190];
};

struct ext2_group_desc {
	__le32 bg_block_bitmap;
	__le32 bg_inode_bitmap;
	__le32 bg_inode_table;
	__le16 bg_free_blocks_count;
	__le16 bg_free_inodes_count;
	__le16 bg_used_dirs_count;
	__le16 bg_pad;
	__le32 bg_reserved[3];
};

struct ext2_inode_info {
	__le32 i_data[15];
	__u32 i_flags;
	__u32 i_faddr;
	__u8 i_frag_no;
	__u8 i_frag_size;
	__u16 i_state;
	__u32 i_file_acl;
	__u32 i_dir_acl;
	__u32 i_dtime;
	__u32 i_block_group;
	struct ext2_block_alloc_info *i_block_alloc_info;
	__u32 i_dir_start_lookup;
	struct rw_semaphore xattr_sem;
	rwlock_t i_meta_lock;
	struct mutex truncate_mutex;
	struct inode vfs_inode;
	struct list_head i_orphan;
	struct dquot *i_dquot[3];
	int: 32;
};

struct ext2_dir_entry_2 {
	__le32 inode;
	__le16 rec_len;
	__u8 name_len;
	__u8 file_type;
	char name[0];
};

typedef struct ext2_dir_entry_2 ext2_dirent;

struct ext2_inode {
	__le16 i_mode;
	__le16 i_uid;
	__le32 i_size;
	__le32 i_atime;
	__le32 i_ctime;
	__le32 i_mtime;
	__le32 i_dtime;
	__le16 i_gid;
	__le16 i_links_count;
	__le32 i_blocks;
	__le32 i_flags;
	union {
		struct {
			__le32 l_i_reserved1;
		} linux1;
		struct {
			__le32 h_i_translator;
		} hurd1;
		struct {
			__le32 m_i_reserved1;
		} masix1;
	} osd1;
	__le32 i_block[15];
	__le32 i_generation;
	__le32 i_file_acl;
	__le32 i_dir_acl;
	__le32 i_faddr;
	union {
		struct {
			__u8 l_i_frag;
			__u8 l_i_fsize;
			__u16 i_pad1;
			__le16 l_i_uid_high;
			__le16 l_i_gid_high;
			__u32 l_i_reserved2;
		} linux2;
		struct {
			__u8 h_i_frag;
			__u8 h_i_fsize;
			__le16 h_i_mode_high;
			__le16 h_i_uid_high;
			__le16 h_i_gid_high;
			__le32 h_i_author;
		} hurd2;
		struct {
			__u8 m_i_frag;
			__u8 m_i_fsize;
			__u16 m_pad1;
			__u32 m_i_reserved2[2];
		} masix2;
	} osd2;
};

struct ext2_mount_options {
	long unsigned int s_mount_opt;
	kuid_t s_resuid;
	kgid_t s_resgid;
};

enum {
	Opt_bsd_df___2 = 0,
	Opt_minix_df___2 = 1,
	Opt_grpid___2 = 2,
	Opt_nogrpid___2 = 3,
	Opt_resgid___2 = 4,
	Opt_resuid___2 = 5,
	Opt_sb___2 = 6,
	Opt_err_cont = 7,
	Opt_err_panic = 8,
	Opt_err_ro = 9,
	Opt_nouid32___2 = 10,
	Opt_debug___2 = 11,
	Opt_oldalloc = 12,
	Opt_orlov = 13,
	Opt_nobh = 14,
	Opt_user_xattr___2 = 15,
	Opt_nouser_xattr = 16,
	Opt_acl___2 = 17,
	Opt_noacl = 18,
	Opt_xip = 19,
	Opt_dax___2 = 20,
	Opt_ignore = 21,
	Opt_err___3 = 22,
	Opt_quota___2 = 23,
	Opt_usrquota___2 = 24,
	Opt_grpquota___2 = 25,
	Opt_reservation = 26,
	Opt_noreservation = 27,
};

struct ext2_xattr_header {
	__le32 h_magic;
	__le32 h_refcount;
	__le32 h_blocks;
	__le32 h_hash;
	__u32 h_reserved[4];
};

struct ext2_xattr_entry {
	__u8 e_name_len;
	__u8 e_name_index;
	__le16 e_value_offs;
	__le32 e_value_block;
	__le32 e_value_size;
	__le32 e_hash;
	char e_name[0];
};

typedef struct {
	__le16 e_tag;
	__le16 e_perm;
	__le32 e_id;
} ext2_acl_entry;

typedef struct {
	__le32 a_version;
} ext2_acl_header;

struct commit_header {
	__be32 h_magic;
	__be32 h_blocktype;
	__be32 h_sequence;
	unsigned char h_chksum_type;
	unsigned char h_chksum_size;
	unsigned char h_padding[2];
	__be32 h_chksum[8];
	__be64 h_commit_sec;
	__be32 h_commit_nsec;
	int: 32;
};

struct journal_block_tag3_s {
	__be32 t_blocknr;
	__be32 t_flags;
	__be32 t_blocknr_high;
	__be32 t_checksum;
};

typedef struct journal_block_tag3_s journal_block_tag3_t;

struct journal_block_tag_s {
	__be32 t_blocknr;
	__be16 t_checksum;
	__be16 t_flags;
	__be32 t_blocknr_high;
};

typedef struct journal_block_tag_s journal_block_tag_t;

struct jbd2_journal_block_tail {
	__be32 t_checksum;
};

struct jbd2_journal_revoke_header_s {
	journal_header_t r_header;
	__be32 r_count;
};

typedef struct jbd2_journal_revoke_header_s jbd2_journal_revoke_header_t;

struct recovery_info {
	tid_t start_transaction;
	tid_t end_transaction;
	int nr_replays;
	int nr_revokes;
	int nr_revoke_hits;
};

struct jbd2_revoke_table_s {
	int hash_size;
	int hash_shift;
	struct list_head *hash_table;
};

struct jbd2_revoke_record_s {
	struct list_head hash;
	tid_t sequence;
	int: 32;
	long long unsigned int blocknr;
};

struct trace_event_raw_jbd2_checkpoint {
	struct trace_entry ent;
	dev_t dev;
	int result;
	char __data[0];
};

struct trace_event_raw_jbd2_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	char __data[0];
};

struct trace_event_raw_jbd2_end_commit {
	struct trace_entry ent;
	dev_t dev;
	char sync_commit;
	int transaction;
	int head;
	char __data[0];
};

struct trace_event_raw_jbd2_submit_inode_data {
	struct trace_entry ent;
	dev_t dev;
	ino_t ino;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_start_class {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_extend {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int buffer_credits;
	int requested_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_handle_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	unsigned int type;
	unsigned int line_no;
	int interval;
	int sync;
	int requested_blocks;
	int dirtied_blocks;
	char __data[0];
};

struct trace_event_raw_jbd2_run_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int wait;
	long unsigned int request_delay;
	long unsigned int running;
	long unsigned int locked;
	long unsigned int flushing;
	long unsigned int logging;
	__u32 handle_count;
	__u32 blocks;
	__u32 blocks_logged;
	char __data[0];
};

struct trace_event_raw_jbd2_checkpoint_stats {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int tid;
	long unsigned int chp_time;
	__u32 forced_to_close;
	__u32 written;
	__u32 dropped;
	char __data[0];
};

struct trace_event_raw_jbd2_update_log_tail {
	struct trace_entry ent;
	dev_t dev;
	tid_t tail_sequence;
	tid_t first_tid;
	long unsigned int block_nr;
	long unsigned int freed;
	char __data[0];
};

struct trace_event_raw_jbd2_write_superblock {
	struct trace_entry ent;
	dev_t dev;
	blk_opf_t write_flags;
	char __data[0];
};

struct trace_event_raw_jbd2_lock_buffer_stall {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int stall_ms;
	char __data[0];
};

struct trace_event_raw_jbd2_journal_shrink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_scan_exit {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int nr_to_scan;
	long unsigned int nr_shrunk;
	long unsigned int count;
	char __data[0];
};

struct trace_event_raw_jbd2_shrink_checkpoint_list {
	struct trace_entry ent;
	dev_t dev;
	tid_t first_tid;
	tid_t tid;
	tid_t last_tid;
	long unsigned int nr_freed;
	long unsigned int nr_scanned;
	tid_t next_tid;
	char __data[0];
};

struct trace_event_data_offsets_jbd2_checkpoint {};

struct trace_event_data_offsets_jbd2_commit {};

struct trace_event_data_offsets_jbd2_end_commit {};

struct trace_event_data_offsets_jbd2_submit_inode_data {};

struct trace_event_data_offsets_jbd2_handle_start_class {};

struct trace_event_data_offsets_jbd2_handle_extend {};

struct trace_event_data_offsets_jbd2_handle_stats {};

struct trace_event_data_offsets_jbd2_run_stats {};

struct trace_event_data_offsets_jbd2_checkpoint_stats {};

struct trace_event_data_offsets_jbd2_update_log_tail {};

struct trace_event_data_offsets_jbd2_write_superblock {};

struct trace_event_data_offsets_jbd2_lock_buffer_stall {};

struct trace_event_data_offsets_jbd2_journal_shrink {};

struct trace_event_data_offsets_jbd2_shrink_scan_exit {};

struct trace_event_data_offsets_jbd2_shrink_checkpoint_list {};

typedef void (*btf_trace_jbd2_checkpoint)(void *, journal_t *, int);

typedef void (*btf_trace_jbd2_start_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_locking)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_flushing)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_commit_logging)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_drop_transaction)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_end_commit)(void *, journal_t *, transaction_t *);

typedef void (*btf_trace_jbd2_submit_inode_data)(void *, struct inode *);

typedef void (*btf_trace_jbd2_handle_start)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_restart)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int);

typedef void (*btf_trace_jbd2_handle_extend)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int);

typedef void (*btf_trace_jbd2_handle_stats)(void *, dev_t, long unsigned int, unsigned int, unsigned int, int, int, int, int);

typedef void (*btf_trace_jbd2_run_stats)(void *, dev_t, long unsigned int, struct transaction_run_stats_s *);

typedef void (*btf_trace_jbd2_checkpoint_stats)(void *, dev_t, long unsigned int, struct transaction_chp_stats_s *);

typedef void (*btf_trace_jbd2_update_log_tail)(void *, journal_t *, tid_t, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_write_superblock)(void *, journal_t *, blk_opf_t);

typedef void (*btf_trace_jbd2_lock_buffer_stall)(void *, dev_t, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_count)(void *, journal_t *, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_scan_enter)(void *, journal_t *, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_scan_exit)(void *, journal_t *, long unsigned int, long unsigned int, long unsigned int);

typedef void (*btf_trace_jbd2_shrink_checkpoint_list)(void *, journal_t *, tid_t, tid_t, tid_t, long unsigned int, long unsigned int, tid_t);

struct jbd2_stats_proc_session {
	journal_t *journal;
	struct transaction_stats_s *stats;
	int start;
	int max;
};

struct ramfs_mount_opts {
	umode_t mode;
};

struct ramfs_fs_info {
	struct ramfs_mount_opts mount_opts;
};

enum ramfs_param {
	Opt_mode___3 = 0,
};

typedef u16 wchar_t;

struct nls_table {
	const char *charset;
	const char *alias;
	int (*uni2char)(wchar_t, unsigned char *, int);
	int (*char2uni)(const unsigned char *, int, wchar_t *);
	const unsigned char *charset2lower;
	const unsigned char *charset2upper;
	struct module *owner;
	struct nls_table *next;
};

struct fat_mount_options {
	kuid_t fs_uid;
	kgid_t fs_gid;
	short unsigned int fs_fmask;
	short unsigned int fs_dmask;
	short unsigned int codepage;
	int time_offset;
	char *iocharset;
	short unsigned int shortname;
	unsigned char name_check;
	unsigned char errors;
	unsigned char nfs;
	short unsigned int allow_utime;
	unsigned int quiet: 1;
	unsigned int showexec: 1;
	unsigned int sys_immutable: 1;
	unsigned int dotsOK: 1;
	unsigned int isvfat: 1;
	unsigned int utf8: 1;
	unsigned int unicode_xlate: 1;
	unsigned int numtail: 1;
	unsigned int flush: 1;
	unsigned int nocase: 1;
	unsigned int usefree: 1;
	unsigned int tz_set: 1;
	unsigned int rodir: 1;
	unsigned int discard: 1;
	unsigned int dos1xfloppy: 1;
};

struct fatent_operations;

struct msdos_sb_info {
	short unsigned int sec_per_clus;
	short unsigned int cluster_bits;
	unsigned int cluster_size;
	unsigned char fats;
	unsigned char fat_bits;
	short unsigned int fat_start;
	long unsigned int fat_length;
	long unsigned int dir_start;
	short unsigned int dir_entries;
	long unsigned int data_start;
	long unsigned int max_cluster;
	long unsigned int root_cluster;
	long unsigned int fsinfo_sector;
	struct mutex fat_lock;
	struct mutex nfs_build_inode_lock;
	struct mutex s_lock;
	unsigned int prev_free;
	unsigned int free_clusters;
	unsigned int free_clus_valid;
	struct fat_mount_options options;
	struct nls_table *nls_disk;
	struct nls_table *nls_io;
	const void *dir_ops;
	int dir_per_block;
	int dir_per_block_bits;
	unsigned int vol_id;
	int fatent_shift;
	const struct fatent_operations *fatent_ops;
	struct inode *fat_inode;
	struct inode *fsinfo_inode;
	struct ratelimit_state ratelimit;
	spinlock_t inode_hash_lock;
	struct hlist_head inode_hashtable[256];
	spinlock_t dir_hash_lock;
	struct hlist_head dir_hashtable[256];
	unsigned int dirty;
	struct callback_head rcu;
};

struct fat_entry;

struct fatent_operations {
	void (*ent_blocknr)(struct super_block *, int, int *, sector_t *);
	void (*ent_set_ptr)(struct fat_entry *, int);
	int (*ent_bread)(struct super_block *, struct fat_entry *, int, sector_t);
	int (*ent_get)(struct fat_entry *);
	void (*ent_put)(struct fat_entry *, int);
	int (*ent_next)(struct fat_entry *);
};

struct msdos_inode_info {
	spinlock_t cache_lru_lock;
	struct list_head cache_lru;
	int nr_caches;
	unsigned int cache_valid_id;
	int: 32;
	loff_t mmu_private;
	int i_start;
	int i_logstart;
	int i_attrs;
	int: 32;
	loff_t i_pos;
	struct hlist_node i_fat_hash;
	struct hlist_node i_dir_hash;
	struct rw_semaphore truncate_lock;
	struct timespec64 i_crtime;
	struct inode vfs_inode;
};

struct fat_entry {
	int entry;
	union {
		u8 *ent12_p[2];
		__le16 *ent16_p;
		__le32 *ent32_p;
	} u;
	int nr_bhs;
	struct buffer_head *bhs[2];
	struct inode *fat_inode;
};

struct fat_cache {
	struct list_head cache_list;
	int nr_contig;
	int fcluster;
	int dcluster;
};

struct fat_cache_id {
	unsigned int id;
	int nr_contig;
	int fcluster;
	int dcluster;
};

enum utf16_endian {
	UTF16_HOST_ENDIAN = 0,
	UTF16_LITTLE_ENDIAN = 1,
	UTF16_BIG_ENDIAN = 2,
};

struct __fat_dirent {
	long int d_ino;
	__kernel_off_t d_off;
	short unsigned int d_reclen;
	char d_name[256];
};

struct msdos_dir_entry {
	__u8 name[11];
	__u8 attr;
	__u8 lcase;
	__u8 ctime_cs;
	__le16 ctime;
	__le16 cdate;
	__le16 adate;
	__le16 starthi;
	__le16 time;
	__le16 date;
	__le16 start;
	__le32 size;
};

struct msdos_dir_slot {
	__u8 id;
	__u8 name0_4[10];
	__u8 attr;
	__u8 reserved;
	__u8 alias_checksum;
	__u8 name5_10[12];
	__le16 start;
	__u8 name11_12[4];
};

struct fat_slot_info {
	loff_t i_pos;
	loff_t slot_off;
	int nr_slots;
	struct msdos_dir_entry *de;
	struct buffer_head *bh;
	int: 32;
};

typedef long long unsigned int llu;

enum {
	PARSE_INVALID = 1,
	PARSE_NOT_LONGNAME = 2,
	PARSE_EOF = 3,
};

struct fat_ioctl_filldir_callback {
	struct dir_context ctx;
	void *dirent;
	int result;
	const char *longname;
	int long_len;
	const char *shortname;
	int short_len;
};

struct fatent_ra {
	sector_t cur;
	sector_t limit;
	unsigned int ra_blocks;
	int: 32;
	sector_t ra_advance;
	sector_t ra_next;
	sector_t ra_limit;
};

struct fat_boot_sector {
	__u8 ignored[3];
	__u8 system_id[8];
	__u8 sector_size[2];
	__u8 sec_per_clus;
	__le16 reserved;
	__u8 fats;
	__u8 dir_entries[2];
	__u8 sectors[2];
	__u8 media;
	__le16 fat_length;
	__le16 secs_track;
	__le16 heads;
	__le32 hidden;
	__le32 total_sect;
	union {
		struct {
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat16;
		struct {
			__le32 length;
			__le16 flags;
			__u8 version[2];
			__le32 root_cluster;
			__le16 info_sector;
			__le16 backup_boot;
			__le16 reserved2[6];
			__u8 drive_number;
			__u8 state;
			__u8 signature;
			__u8 vol_id[4];
			__u8 vol_label[11];
			__u8 fs_type[8];
		} fat32;
	};
};

struct fat_boot_fsinfo {
	__le32 signature1;
	__le32 reserved1[120];
	__le32 signature2;
	__le32 free_clusters;
	__le32 next_cluster;
	__le32 reserved2[4];
};

struct fat_bios_param_block {
	u16 fat_sector_size;
	u8 fat_sec_per_clus;
	u16 fat_reserved;
	u8 fat_fats;
	u16 fat_dir_entries;
	u16 fat_sectors;
	u16 fat_fat_length;
	u32 fat_total_sect;
	u8 fat16_state;
	u32 fat16_vol_id;
	u32 fat32_length;
	u32 fat32_root_cluster;
	u16 fat32_info_sector;
	u8 fat32_state;
	u32 fat32_vol_id;
};

struct fat_floppy_defaults {
	unsigned int nr_sectors;
	unsigned int sec_per_clus;
	unsigned int dir_entries;
	unsigned int media;
	unsigned int fat_length;
};

enum {
	Opt_check_n = 0,
	Opt_check_r = 1,
	Opt_check_s = 2,
	Opt_uid___3 = 3,
	Opt_gid___4 = 4,
	Opt_umask = 5,
	Opt_dmask = 6,
	Opt_fmask = 7,
	Opt_allow_utime = 8,
	Opt_codepage = 9,
	Opt_usefree = 10,
	Opt_nocase = 11,
	Opt_quiet = 12,
	Opt_showexec = 13,
	Opt_debug___3 = 14,
	Opt_immutable = 15,
	Opt_dots = 16,
	Opt_nodots = 17,
	Opt_charset = 18,
	Opt_shortname_lower = 19,
	Opt_shortname_win95 = 20,
	Opt_shortname_winnt = 21,
	Opt_shortname_mixed = 22,
	Opt_utf8_no = 23,
	Opt_utf8_yes = 24,
	Opt_uni_xl_no = 25,
	Opt_uni_xl_yes = 26,
	Opt_nonumtail_no = 27,
	Opt_nonumtail_yes = 28,
	Opt_obsolete = 29,
	Opt_flush = 30,
	Opt_tz_utc = 31,
	Opt_rodir = 32,
	Opt_err_cont___2 = 33,
	Opt_err_panic___2 = 34,
	Opt_err_ro___2 = 35,
	Opt_discard___2 = 36,
	Opt_nfs = 37,
	Opt_time_offset = 38,
	Opt_nfs_stale_rw = 39,
	Opt_nfs_nostale_ro = 40,
	Opt_err___4 = 41,
	Opt_dos1xfloppy = 42,
};

struct fat_fid {
	u32 i_gen;
	u32 i_pos_low;
	u16 i_pos_hi;
	u16 parent_i_pos_hi;
	u32 parent_i_pos_low;
	u32 parent_i_gen;
};

struct shortname_info {
	unsigned char lower: 1;
	unsigned char upper: 1;
	unsigned char valid: 1;
};

struct in_addr {
	__be32 s_addr;
};

struct sockaddr_in {
	__kernel_sa_family_t sin_family;
	__be16 sin_port;
	struct in_addr sin_addr;
	unsigned char __pad[8];
};

struct sockaddr_in6 {
	short unsigned int sin6_family;
	__be16 sin6_port;
	__be32 sin6_flowinfo;
	struct in6_addr sin6_addr;
	__u32 sin6_scope_id;
};

enum rpc_auth_flavors {
	RPC_AUTH_NULL = 0,
	RPC_AUTH_UNIX = 1,
	RPC_AUTH_SHORT = 2,
	RPC_AUTH_DES = 3,
	RPC_AUTH_KRB = 4,
	RPC_AUTH_GSS = 6,
	RPC_AUTH_TLS = 7,
	RPC_AUTH_MAXFLAVOR = 8,
	RPC_AUTH_GSS_KRB5 = 390003,
	RPC_AUTH_GSS_KRB5I = 390004,
	RPC_AUTH_GSS_KRB5P = 390005,
	RPC_AUTH_GSS_LKEY = 390006,
	RPC_AUTH_GSS_LKEYI = 390007,
	RPC_AUTH_GSS_LKEYP = 390008,
	RPC_AUTH_GSS_SPKM = 390009,
	RPC_AUTH_GSS_SPKMI = 390010,
	RPC_AUTH_GSS_SPKMP = 390011,
};

struct rpc_task_setup {
	struct rpc_task *task;
	struct rpc_clnt *rpc_client;
	struct rpc_xprt *rpc_xprt;
	struct rpc_cred *rpc_op_cred;
	const struct rpc_message *rpc_message;
	const struct rpc_call_ops *callback_ops;
	void *callback_data;
	struct workqueue_struct *workqueue;
	short unsigned int flags;
	signed char priority;
};

enum xprt_transports {
	XPRT_TRANSPORT_UDP = 17,
	XPRT_TRANSPORT_TCP = 6,
	XPRT_TRANSPORT_BC_TCP = 2147483654,
	XPRT_TRANSPORT_RDMA = 256,
	XPRT_TRANSPORT_BC_RDMA = 2147483904,
	XPRT_TRANSPORT_LOCAL = 257,
};

struct svc_xprt_class;

struct svc_xprt_ops;

struct svc_xprt {
	struct svc_xprt_class *xpt_class;
	const struct svc_xprt_ops *xpt_ops;
	struct kref xpt_ref;
	struct list_head xpt_list;
	struct list_head xpt_ready;
	long unsigned int xpt_flags;
	struct svc_serv *xpt_server;
	atomic_t xpt_reserved;
	atomic_t xpt_nr_rqsts;
	struct mutex xpt_mutex;
	spinlock_t xpt_lock;
	void *xpt_auth_cache;
	struct list_head xpt_deferred;
	struct __kernel_sockaddr_storage xpt_local;
	size_t xpt_locallen;
	struct __kernel_sockaddr_storage xpt_remote;
	size_t xpt_remotelen;
	char xpt_remotebuf[58];
	struct list_head xpt_users;
	struct net *xpt_net;
	netns_tracker ns_tracker;
	const struct cred *xpt_cred;
	struct rpc_xprt *xpt_bc_xprt;
	struct rpc_xprt_switch *xpt_bc_xps;
};

struct rpc_pipe_msg {
	struct list_head list;
	void *data;
	size_t len;
	size_t copied;
	int errno;
};

struct rpc_pipe_ops {
	ssize_t (*upcall)(struct file *, struct rpc_pipe_msg *, char *, size_t);
	ssize_t (*downcall)(struct file *, const char *, size_t);
	void (*release_pipe)(struct inode *);
	int (*open_pipe)(struct inode *);
	void (*destroy_msg)(struct rpc_pipe_msg *);
};

struct rpc_pipe {
	struct list_head pipe;
	struct list_head in_upcall;
	struct list_head in_downcall;
	int pipelen;
	int nreaders;
	int nwriters;
	int flags;
	struct delayed_work queue_timeout;
	const struct rpc_pipe_ops *ops;
	spinlock_t lock;
	struct dentry *dentry;
};

struct rpc_iostats {
	spinlock_t om_lock;
	long unsigned int om_ops;
	long unsigned int om_ntrans;
	long unsigned int om_timeouts;
	long long unsigned int om_bytes_sent;
	long long unsigned int om_bytes_recv;
	ktime_t om_queue;
	ktime_t om_rtt;
	ktime_t om_execute;
	long unsigned int om_error_status;
	int: 32;
};

struct rpc_create_args {
	struct net *net;
	int protocol;
	struct sockaddr *address;
	size_t addrsize;
	struct sockaddr *saddress;
	const struct rpc_timeout *timeout;
	const char *servername;
	const char *nodename;
	const struct rpc_program *program;
	u32 prognumber;
	u32 version;
	rpc_authflavor_t authflavor;
	u32 nconnect;
	long unsigned int flags;
	char *client_name;
	struct svc_xprt *bc_xprt;
	const struct cred *cred;
	unsigned int max_connect;
};

enum pnfs_iomode {
	IOMODE_READ = 1,
	IOMODE_RW = 2,
	IOMODE_ANY = 3,
};

struct nfs4_deviceid {
	char data[16];
};

struct nfs4_xdr_opaque_data;

struct nfs4_xdr_opaque_ops {
	void (*encode)(struct xdr_stream *, const void *, const struct nfs4_xdr_opaque_data *);
	void (*free)(struct nfs4_xdr_opaque_data *);
};

struct nfs4_xdr_opaque_data {
	const struct nfs4_xdr_opaque_ops *ops;
	void *data;
};

struct nfs4_layoutdriver_data {
	struct page **pages;
	__u32 pglen;
	__u32 len;
};

struct pnfs_layout_range {
	u32 iomode;
	int: 32;
	u64 offset;
	u64 length;
};

struct nfs4_layoutget_res {
	struct nfs4_sequence_res seq_res;
	int status;
	__u32 return_on_close;
	struct pnfs_layout_range range;
	__u32 type;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data *layoutp;
	int: 32;
};

struct pnfs_layout_hdr {
	refcount_t plh_refcount;
	atomic_t plh_outstanding;
	struct list_head plh_layouts;
	struct list_head plh_bulk_destroy;
	struct list_head plh_segs;
	struct list_head plh_return_segs;
	long unsigned int plh_block_lgets;
	long unsigned int plh_retry_timestamp;
	long unsigned int plh_flags;
	nfs4_stateid plh_stateid;
	u32 plh_barrier;
	u32 plh_return_seq;
	enum pnfs_iomode plh_return_iomode;
	int: 32;
	loff_t plh_lwb;
	const struct cred *plh_lc_cred;
	struct inode *plh_inode;
	struct callback_head plh_rcu;
};

struct pnfs_device {
	struct nfs4_deviceid dev_id;
	unsigned int layout_type;
	unsigned int mincount;
	unsigned int maxcount;
	struct page **pages;
	unsigned int pgbase;
	unsigned int pglen;
	unsigned char nocache: 1;
};

struct nfs4_layoutcommit_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid stateid;
	int: 32;
	__u64 lastbytewritten;
	struct inode *inode;
	const u32 *bitmask;
	size_t layoutupdate_len;
	struct page *layoutupdate_page;
	struct page **layoutupdate_pages;
	__be32 *start_p;
};

struct nfs4_layoutcommit_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
	int status;
};

struct nfs4_layoutcommit_data {
	struct rpc_task task;
	struct nfs_fattr fattr;
	struct list_head lseg_list;
	const struct cred *cred;
	struct inode *inode;
	struct nfs4_layoutcommit_args args;
	struct nfs4_layoutcommit_res res;
	int: 32;
};

struct nfs4_layoutreturn_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_layout_hdr *layout;
	struct inode *inode;
	struct pnfs_layout_range range;
	nfs4_stateid stateid;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data *ld_private;
	int: 32;
};

struct nfs42_layoutstat_devinfo;

struct nfs42_layoutstat_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct inode *inode;
	nfs4_stateid stateid;
	int num_dev;
	struct nfs42_layoutstat_devinfo *devinfo;
};

struct nfs42_layoutstat_devinfo {
	struct nfs4_deviceid dev_id;
	__u64 offset;
	__u64 length;
	__u64 read_count;
	__u64 read_bytes;
	__u64 write_count;
	__u64 write_bytes;
	__u32 layout_type;
	struct nfs4_xdr_opaque_data ld_private;
	int: 32;
};

struct pnfs_layout_segment {
	struct list_head pls_list;
	struct list_head pls_lc_list;
	struct list_head pls_commits;
	struct pnfs_layout_range pls_range;
	refcount_t pls_refcount;
	u32 pls_seq;
	long unsigned int pls_flags;
	struct pnfs_layout_hdr *pls_layout;
};

struct nfs_page {
	struct list_head wb_list;
	struct page *wb_page;
	struct nfs_lock_context *wb_lock_context;
	long unsigned int wb_index;
	unsigned int wb_offset;
	unsigned int wb_pgbase;
	unsigned int wb_bytes;
	struct kref wb_kref;
	long unsigned int wb_flags;
	struct nfs_write_verifier wb_verf;
	struct nfs_page *wb_this_page;
	struct nfs_page *wb_head;
	short unsigned int wb_nio;
};

struct nfs_direct_req {
	struct kref kref;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	struct kiocb *iocb;
	struct inode *inode;
	atomic_t io_count;
	spinlock_t lock;
	int: 32;
	loff_t io_start;
	ssize_t count;
	ssize_t max_count;
	ssize_t bytes_left;
	ssize_t error;
	struct completion completion;
	struct nfs_mds_commit_info mds_cinfo;
	struct pnfs_ds_commit_info ds_cinfo;
	struct work_struct work;
	int flags;
};

struct nfs_subversion {
	struct module *owner;
	struct file_system_type *nfs_fs;
	const struct rpc_version *rpc_vers;
	const struct nfs_rpc_ops *rpc_ops;
	const struct super_operations *sops;
	const struct xattr_handler **xattr;
	struct list_head list;
};

struct nfs_iostats {
	long long unsigned int bytes[8];
	long unsigned int events[27];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum pnfs_try_status {
	PNFS_ATTEMPTED = 0,
	PNFS_NOT_ATTEMPTED = 1,
	PNFS_TRY_AGAIN = 2,
};

struct nfs_pageio_ops;

struct nfs4_deviceid_node;

struct pnfs_layoutdriver_type {
	struct list_head pnfs_tblid;
	const u32 id;
	const char *name;
	struct module *owner;
	unsigned int flags;
	unsigned int max_deviceinfo_size;
	unsigned int max_layoutget_response;
	int (*set_layoutdriver)(struct nfs_server *, const struct nfs_fh *);
	int (*clear_layoutdriver)(struct nfs_server *);
	struct pnfs_layout_hdr * (*alloc_layout_hdr)(struct inode *, gfp_t);
	void (*free_layout_hdr)(struct pnfs_layout_hdr *);
	struct pnfs_layout_segment * (*alloc_lseg)(struct pnfs_layout_hdr *, struct nfs4_layoutget_res *, gfp_t);
	void (*free_lseg)(struct pnfs_layout_segment *);
	void (*add_lseg)(struct pnfs_layout_hdr *, struct pnfs_layout_segment *, struct list_head *);
	void (*return_range)(struct pnfs_layout_hdr *, struct pnfs_layout_range *);
	const struct nfs_pageio_ops *pg_read_ops;
	const struct nfs_pageio_ops *pg_write_ops;
	struct pnfs_ds_commit_info * (*get_ds_info)(struct inode *);
	int (*sync)(struct inode *, bool);
	enum pnfs_try_status (*read_pagelist)(struct nfs_pgio_header *);
	enum pnfs_try_status (*write_pagelist)(struct nfs_pgio_header *, int);
	void (*free_deviceid_node)(struct nfs4_deviceid_node *);
	struct nfs4_deviceid_node * (*alloc_deviceid_node)(struct nfs_server *, struct pnfs_device *, gfp_t);
	int (*prepare_layoutreturn)(struct nfs4_layoutreturn_args *);
	void (*cleanup_layoutcommit)(struct nfs4_layoutcommit_data *);
	int (*prepare_layoutcommit)(struct nfs4_layoutcommit_args *);
	int (*prepare_layoutstats)(struct nfs42_layoutstat_args *);
	void (*cancel_io)(struct pnfs_layout_segment *);
};

struct nlmclnt_initdata {
	const char *hostname;
	const struct sockaddr *address;
	size_t addrlen;
	short unsigned int protocol;
	u32 nfs_version;
	int noresvport;
	struct net *net;
	const struct nlmclnt_operations *nlmclnt_ops;
	const struct cred *cred;
};

struct cache_detail {
	struct module *owner;
	int hash_size;
	struct hlist_head *hash_table;
	spinlock_t hash_lock;
	char *name;
	void (*cache_put)(struct kref *);
	int (*cache_upcall)(struct cache_detail *, struct cache_head *);
	void (*cache_request)(struct cache_detail *, struct cache_head *, char **, int *);
	int (*cache_parse)(struct cache_detail *, char *, int);
	int (*cache_show)(struct seq_file *, struct cache_detail *, struct cache_head *);
	void (*warn_no_listener)(struct cache_detail *, int);
	struct cache_head * (*alloc)();
	void (*flush)();
	int (*match)(struct cache_head *, struct cache_head *);
	void (*init)(struct cache_head *, struct cache_head *);
	void (*update)(struct cache_head *, struct cache_head *);
	time64_t flush_time;
	struct list_head others;
	time64_t nextcheck;
	int entries;
	struct list_head queue;
	atomic_t writers;
	time64_t last_close;
	time64_t last_warn;
	union {
		struct proc_dir_entry *procfs;
		struct dentry *pipefs;
	};
	struct net *net;
};

struct svc_xprt_ops {
	struct svc_xprt * (*xpo_create)(struct svc_serv *, struct net *, struct sockaddr *, int, int);
	struct svc_xprt * (*xpo_accept)(struct svc_xprt *);
	int (*xpo_has_wspace)(struct svc_xprt *);
	int (*xpo_recvfrom)(struct svc_rqst *);
	int (*xpo_sendto)(struct svc_rqst *);
	int (*xpo_result_payload)(struct svc_rqst *, unsigned int, unsigned int);
	void (*xpo_release_rqst)(struct svc_rqst *);
	void (*xpo_detach)(struct svc_xprt *);
	void (*xpo_free)(struct svc_xprt *);
	void (*xpo_secure_port)(struct svc_rqst *);
	void (*xpo_kill_temp_xprt)(struct svc_xprt *);
	void (*xpo_start_tls)(struct svc_xprt *);
};

struct svc_xprt_class {
	const char *xcl_name;
	struct module *xcl_owner;
	const struct svc_xprt_ops *xcl_ops;
	struct list_head xcl_list;
	u32 xcl_max_payload;
	int xcl_ident;
};

enum nfs_stat_bytecounters {
	NFSIOS_NORMALREADBYTES = 0,
	NFSIOS_NORMALWRITTENBYTES = 1,
	NFSIOS_DIRECTREADBYTES = 2,
	NFSIOS_DIRECTWRITTENBYTES = 3,
	NFSIOS_SERVERREADBYTES = 4,
	NFSIOS_SERVERWRITTENBYTES = 5,
	NFSIOS_READPAGES = 6,
	NFSIOS_WRITEPAGES = 7,
	__NFSIOS_BYTESMAX = 8,
};

enum nfs_stat_eventcounters {
	NFSIOS_INODEREVALIDATE = 0,
	NFSIOS_DENTRYREVALIDATE = 1,
	NFSIOS_DATAINVALIDATE = 2,
	NFSIOS_ATTRINVALIDATE = 3,
	NFSIOS_VFSOPEN = 4,
	NFSIOS_VFSLOOKUP = 5,
	NFSIOS_VFSACCESS = 6,
	NFSIOS_VFSUPDATEPAGE = 7,
	NFSIOS_VFSREADPAGE = 8,
	NFSIOS_VFSREADPAGES = 9,
	NFSIOS_VFSWRITEPAGE = 10,
	NFSIOS_VFSWRITEPAGES = 11,
	NFSIOS_VFSGETDENTS = 12,
	NFSIOS_VFSSETATTR = 13,
	NFSIOS_VFSFLUSH = 14,
	NFSIOS_VFSFSYNC = 15,
	NFSIOS_VFSLOCK = 16,
	NFSIOS_VFSRELEASE = 17,
	NFSIOS_CONGESTIONWAIT = 18,
	NFSIOS_SETATTRTRUNC = 19,
	NFSIOS_EXTENDWRITE = 20,
	NFSIOS_SILLYRENAME = 21,
	NFSIOS_SHORTREAD = 22,
	NFSIOS_SHORTWRITE = 23,
	NFSIOS_DELAY = 24,
	NFSIOS_PNFS_READ = 25,
	NFSIOS_PNFS_WRITE = 26,
	__NFSIOS_COUNTSMAX = 27,
};

struct nfs_pageio_descriptor;

struct nfs_pgio_mirror;

struct nfs_pageio_ops {
	void (*pg_init)(struct nfs_pageio_descriptor *, struct nfs_page *);
	size_t (*pg_test)(struct nfs_pageio_descriptor *, struct nfs_page *, struct nfs_page *);
	int (*pg_doio)(struct nfs_pageio_descriptor *);
	unsigned int (*pg_get_mirror_count)(struct nfs_pageio_descriptor *, struct nfs_page *);
	void (*pg_cleanup)(struct nfs_pageio_descriptor *);
	struct nfs_pgio_mirror * (*pg_get_mirror)(struct nfs_pageio_descriptor *, u32);
	u32 (*pg_set_mirror)(struct nfs_pageio_descriptor *, u32);
};

struct nfs_pgio_mirror {
	struct list_head pg_list;
	long unsigned int pg_bytes_written;
	size_t pg_count;
	size_t pg_bsize;
	unsigned int pg_base;
	unsigned char pg_recoalesce: 1;
};

struct nfs_pageio_descriptor {
	struct inode *pg_inode;
	const struct nfs_pageio_ops *pg_ops;
	const struct nfs_rw_ops *pg_rw_ops;
	int pg_ioflags;
	int pg_error;
	const struct rpc_call_ops *pg_rpc_callops;
	const struct nfs_pgio_completion_ops *pg_completion_ops;
	struct pnfs_layout_segment *pg_lseg;
	struct nfs_io_completion *pg_io_completion;
	struct nfs_direct_req *pg_dreq;
	unsigned int pg_bsize;
	u32 pg_mirror_count;
	struct nfs_pgio_mirror *pg_mirrors;
	struct nfs_pgio_mirror pg_mirrors_static[1];
	struct nfs_pgio_mirror *pg_mirrors_dynamic;
	u32 pg_mirror_idx;
	short unsigned int pg_maxretrans;
	unsigned char pg_moreio: 1;
};

struct nfs_clone_mount {
	struct super_block *sb;
	struct dentry *dentry;
	struct nfs_fattr *fattr;
	unsigned int inherited_bsize;
};

struct nfs_fs_context {
	bool internal;
	bool skip_reconfig_option_check;
	bool need_mount;
	bool sloppy;
	unsigned int flags;
	unsigned int rsize;
	unsigned int wsize;
	unsigned int timeo;
	unsigned int retrans;
	unsigned int acregmin;
	unsigned int acregmax;
	unsigned int acdirmin;
	unsigned int acdirmax;
	unsigned int namlen;
	unsigned int options;
	unsigned int bsize;
	struct nfs_auth_info auth_info;
	rpc_authflavor_t selected_flavor;
	char *client_address;
	unsigned int version;
	unsigned int minorversion;
	char *fscache_uniq;
	short unsigned int protofamily;
	short unsigned int mountfamily;
	bool has_sec_mnt_opts;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		u32 version;
		int port;
		short unsigned int protocol;
	} mount_server;
	struct {
		union {
			struct sockaddr address;
			struct __kernel_sockaddr_storage _address;
		};
		size_t addrlen;
		char *hostname;
		char *export_path;
		int port;
		short unsigned int protocol;
		short unsigned int nconnect;
		short unsigned int max_connect;
		short unsigned int export_path_len;
	} nfs_server;
	struct nfs_fh *mntfh;
	struct nfs_server *server;
	struct nfs_subversion *nfs_mod;
	struct nfs_clone_mount clone_data;
};

struct nfs4_deviceid_node {
	struct hlist_node node;
	struct hlist_node tmpnode;
	const struct pnfs_layoutdriver_type *ld;
	const struct nfs_client *nfs_client;
	long unsigned int flags;
	long unsigned int timestamp_unavailable;
	struct nfs4_deviceid deviceid;
	struct callback_head rcu;
	atomic_t ref;
};

struct bl_dev_msg {
	int32_t status;
	uint32_t major;
	uint32_t minor;
};

struct nfs_netns_client;

struct nfs_net {
	struct cache_detail *nfs_dns_resolve;
	struct rpc_pipe *bl_device_pipe;
	struct bl_dev_msg bl_mount_reply;
	wait_queue_head_t bl_wq;
	struct mutex bl_mutex;
	struct list_head nfs_client_list;
	struct list_head nfs_volume_list;
	struct idr cb_ident_idr;
	short unsigned int nfs_callback_tcpport;
	short unsigned int nfs_callback_tcpport6;
	int cb_users[3];
	struct nfs_netns_client *nfs_client;
	spinlock_t nfs_client_lock;
	ktime_t boot_time;
	struct proc_dir_entry *proc_nfsfs;
	int: 32;
};

struct nfs_netns_client {
	struct kobject kobject;
	struct net *net;
	const char *identifier;
};

struct nfs_open_dir_context {
	struct list_head list;
	atomic_t cache_hits;
	atomic_t cache_misses;
	long unsigned int attr_gencount;
	__be32 verf[2];
	int: 32;
	__u64 dir_cookie;
	__u64 last_cookie;
	long unsigned int page_index;
	unsigned int dtsize;
	bool force_clear;
	bool eof;
	struct callback_head callback_head;
	int: 32;
};

struct nfs4_cached_acl;

struct nfs_delegation;

struct nfs4_xattr_cache;

struct nfs_inode {
	__u64 fileid;
	struct nfs_fh fh;
	long unsigned int flags;
	long unsigned int cache_validity;
	long unsigned int read_cache_jiffies;
	long unsigned int attrtimeo;
	long unsigned int attrtimeo_timestamp;
	long unsigned int attr_gencount;
	struct rb_root access_cache;
	struct list_head access_cache_entry_lru;
	struct list_head access_cache_inode_lru;
	union {
		struct {
			long unsigned int cache_change_attribute;
			__be32 cookieverf[2];
			struct rw_semaphore rmdir_sem;
		};
		struct {
			atomic_long_t nrequests;
			atomic_long_t redirtied_pages;
			struct nfs_mds_commit_info commit_info;
			struct mutex commit_mutex;
		};
	};
	struct list_head open_files;
	struct nfs4_cached_acl *nfs4_acl;
	struct list_head open_states;
	struct nfs_delegation *delegation;
	struct rw_semaphore rwsem;
	struct pnfs_layout_hdr *layout;
	__u64 write_io;
	__u64 read_io;
	struct inode vfs_inode;
	struct nfs4_xattr_cache *xattr_cache;
	int: 32;
};

struct nfs_delegation {
	struct list_head super_list;
	const struct cred *cred;
	struct inode *inode;
	nfs4_stateid stateid;
	fmode_t type;
	long unsigned int pagemod_limit;
	int: 32;
	__u64 change_attr;
	long unsigned int flags;
	refcount_t refcount;
	spinlock_t lock;
	struct callback_head rcu;
	int: 32;
};

struct nfs_cache_array_entry {
	u64 cookie;
	u64 ino;
	const char *name;
	unsigned int name_len;
	unsigned char d_type;
	int: 24;
	int: 32;
};

struct nfs_cache_array {
	u64 change_attr;
	u64 last_cookie;
	unsigned int size;
	unsigned char page_full: 1;
	unsigned char page_is_eof: 1;
	unsigned char cookies_are_ordered: 1;
	struct nfs_cache_array_entry array[0];
};

struct nfs_readdir_descriptor {
	struct file *file;
	struct page *page;
	struct dir_context *ctx;
	long unsigned int page_index;
	long unsigned int page_index_max;
	int: 32;
	u64 dir_cookie;
	u64 last_cookie;
	loff_t current_index;
	__be32 verf[2];
	long unsigned int dir_verifier;
	long unsigned int timestamp;
	long unsigned int gencount;
	long unsigned int attr_gencount;
	unsigned int cache_entry_index;
	unsigned int buffer_fills;
	unsigned int dtsize;
	bool clear_cache;
	bool plus;
	bool eob;
	bool eof;
};

enum layoutdriver_policy_flags {
	PNFS_LAYOUTRET_ON_SETATTR = 1,
	PNFS_LAYOUTRET_ON_ERROR = 2,
	PNFS_READ_WHOLE_PAGE = 4,
	PNFS_LAYOUTGET_ON_OPEN = 8,
};

struct nfs_find_desc {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs4_sessionid {
	unsigned char data[16];
};

struct nfs4_channel_attrs {
	u32 max_rqst_sz;
	u32 max_resp_sz;
	u32 max_resp_sz_cached;
	u32 max_ops;
	u32 max_reqs;
};

struct nfs4_slot {
	struct nfs4_slot_table *table;
	struct nfs4_slot *next;
	long unsigned int generation;
	u32 slot_nr;
	u32 seq_nr;
	u32 seq_nr_last_acked;
	u32 seq_nr_highest_sent;
	unsigned int privileged: 1;
	unsigned int seq_done: 1;
};

struct nfs4_slot_table {
	struct nfs4_session *session;
	struct nfs4_slot *slots;
	long unsigned int used_slots[32];
	spinlock_t slot_tbl_lock;
	struct rpc_wait_queue slot_tbl_waitq;
	wait_queue_head_t slot_waitq;
	u32 max_slots;
	u32 max_slotid;
	u32 highest_used_slotid;
	u32 target_highest_slotid;
	u32 server_highest_slotid;
	s32 d_target_highest_slotid;
	s32 d2_target_highest_slotid;
	long unsigned int generation;
	struct completion complete;
	long unsigned int slot_tbl_state;
};

struct nfs4_session {
	struct nfs4_sessionid sess_id;
	u32 flags;
	long unsigned int session_state;
	u32 hash_alg;
	u32 ssv_len;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_slot_table fc_slot_table;
	struct nfs4_channel_attrs bc_attrs;
	struct nfs4_slot_table bc_slot_table;
	struct nfs_client *clp;
};

struct nfs_mount_request {
	struct __kernel_sockaddr_storage *sap;
	size_t salen;
	char *hostname;
	char *dirpath;
	u32 version;
	short unsigned int protocol;
	struct nfs_fh *fh;
	int noresvport;
	unsigned int *auth_flav_len;
	rpc_authflavor_t *auth_flavs;
	struct net *net;
};

struct proc_nfs_info {
	int flag;
	const char *str;
	const char *nostr;
};

struct pnfs_commit_bucket {
	struct list_head written;
	struct list_head committing;
	struct pnfs_layout_segment *lseg;
	struct nfs_writeverf direct_verf;
};

struct pnfs_commit_array {
	struct list_head cinfo_list;
	struct list_head lseg_list;
	struct pnfs_layout_segment *lseg;
	struct callback_head rcu;
	refcount_t refcount;
	unsigned int nbuckets;
	struct pnfs_commit_bucket buckets[0];
};

enum {
	NFS_IOHDR_ERROR = 0,
	NFS_IOHDR_EOF = 1,
	NFS_IOHDR_REDO = 2,
	NFS_IOHDR_STAT = 3,
	NFS_IOHDR_RESEND_PNFS = 4,
	NFS_IOHDR_RESEND_MDS = 5,
	NFS_IOHDR_UNSTABLE_WRITES = 6,
};

enum {
	PG_BUSY = 0,
	PG_MAPPED = 1,
	PG_CLEAN = 2,
	PG_COMMIT_TO_DS = 3,
	PG_INODE_REF = 4,
	PG_HEADLOCK = 5,
	PG_TEARDOWN = 6,
	PG_UNLOCKPAGE = 7,
	PG_UPTODATE = 8,
	PG_WB_END = 9,
	PG_REMOVE = 10,
	PG_CONTENDED1 = 11,
	PG_CONTENDED2 = 12,
};

struct nfs_readdesc {
	struct nfs_pageio_descriptor pgio;
	struct nfs_open_context *ctx;
};

struct nfs_io_completion {
	void (*complete)(void *);
	void *data;
	struct kref refcount;
};

enum {
	MOUNTPROC_NULL = 0,
	MOUNTPROC_MNT = 1,
	MOUNTPROC_DUMP = 2,
	MOUNTPROC_UMNT = 3,
	MOUNTPROC_UMNTALL = 4,
	MOUNTPROC_EXPORT = 5,
};

enum {
	MOUNTPROC3_NULL = 0,
	MOUNTPROC3_MNT = 1,
	MOUNTPROC3_DUMP = 2,
	MOUNTPROC3_UMNT = 3,
	MOUNTPROC3_UMNTALL = 4,
	MOUNTPROC3_EXPORT = 5,
};

enum mountstat {
	MNT_OK = 0,
	MNT_EPERM = 1,
	MNT_ENOENT = 2,
	MNT_EACCES = 13,
	MNT_EINVAL = 22,
};

enum mountstat3 {
	MNT3_OK = 0,
	MNT3ERR_PERM = 1,
	MNT3ERR_NOENT = 2,
	MNT3ERR_IO = 5,
	MNT3ERR_ACCES = 13,
	MNT3ERR_NOTDIR = 20,
	MNT3ERR_INVAL = 22,
	MNT3ERR_NAMETOOLONG = 63,
	MNT3ERR_NOTSUPP = 10004,
	MNT3ERR_SERVERFAULT = 10006,
};

struct mountres {
	int errno;
	struct nfs_fh *fh;
	unsigned int *auth_count;
	rpc_authflavor_t *auth_flavors;
};

enum nfs_stat {
	NFS_OK = 0,
	NFSERR_PERM = 1,
	NFSERR_NOENT = 2,
	NFSERR_IO = 5,
	NFSERR_NXIO = 6,
	NFSERR_EAGAIN = 11,
	NFSERR_ACCES = 13,
	NFSERR_EXIST = 17,
	NFSERR_XDEV = 18,
	NFSERR_NODEV = 19,
	NFSERR_NOTDIR = 20,
	NFSERR_ISDIR = 21,
	NFSERR_INVAL = 22,
	NFSERR_FBIG = 27,
	NFSERR_NOSPC = 28,
	NFSERR_ROFS = 30,
	NFSERR_MLINK = 31,
	NFSERR_OPNOTSUPP = 45,
	NFSERR_NAMETOOLONG = 63,
	NFSERR_NOTEMPTY = 66,
	NFSERR_DQUOT = 69,
	NFSERR_STALE = 70,
	NFSERR_REMOTE = 71,
	NFSERR_WFLUSH = 99,
	NFSERR_BADHANDLE = 10001,
	NFSERR_NOT_SYNC = 10002,
	NFSERR_BAD_COOKIE = 10003,
	NFSERR_NOTSUPP = 10004,
	NFSERR_TOOSMALL = 10005,
	NFSERR_SERVERFAULT = 10006,
	NFSERR_BADTYPE = 10007,
	NFSERR_JUKEBOX = 10008,
	NFSERR_SAME = 10009,
	NFSERR_DENIED = 10010,
	NFSERR_EXPIRED = 10011,
	NFSERR_LOCKED = 10012,
	NFSERR_GRACE = 10013,
	NFSERR_FHEXPIRED = 10014,
	NFSERR_SHARE_DENIED = 10015,
	NFSERR_WRONGSEC = 10016,
	NFSERR_CLID_INUSE = 10017,
	NFSERR_RESOURCE = 10018,
	NFSERR_MOVED = 10019,
	NFSERR_NOFILEHANDLE = 10020,
	NFSERR_MINOR_VERS_MISMATCH = 10021,
	NFSERR_STALE_CLIENTID = 10022,
	NFSERR_STALE_STATEID = 10023,
	NFSERR_OLD_STATEID = 10024,
	NFSERR_BAD_STATEID = 10025,
	NFSERR_BAD_SEQID = 10026,
	NFSERR_NOT_SAME = 10027,
	NFSERR_LOCK_RANGE = 10028,
	NFSERR_SYMLINK = 10029,
	NFSERR_RESTOREFH = 10030,
	NFSERR_LEASE_MOVED = 10031,
	NFSERR_ATTRNOTSUPP = 10032,
	NFSERR_NO_GRACE = 10033,
	NFSERR_RECLAIM_BAD = 10034,
	NFSERR_RECLAIM_CONFLICT = 10035,
	NFSERR_BAD_XDR = 10036,
	NFSERR_LOCKS_HELD = 10037,
	NFSERR_OPENMODE = 10038,
	NFSERR_BADOWNER = 10039,
	NFSERR_BADCHAR = 10040,
	NFSERR_BADNAME = 10041,
	NFSERR_BAD_RANGE = 10042,
	NFSERR_LOCK_NOTSUPP = 10043,
	NFSERR_OP_ILLEGAL = 10044,
	NFSERR_DEADLOCK = 10045,
	NFSERR_FILE_OPEN = 10046,
	NFSERR_ADMIN_REVOKED = 10047,
	NFSERR_CB_PATH_DOWN = 10048,
};

enum nfsstat4 {
	NFS4_OK = 0,
	NFS4ERR_PERM = 1,
	NFS4ERR_NOENT = 2,
	NFS4ERR_IO = 5,
	NFS4ERR_NXIO = 6,
	NFS4ERR_ACCESS = 13,
	NFS4ERR_EXIST = 17,
	NFS4ERR_XDEV = 18,
	NFS4ERR_NOTDIR = 20,
	NFS4ERR_ISDIR = 21,
	NFS4ERR_INVAL = 22,
	NFS4ERR_FBIG = 27,
	NFS4ERR_NOSPC = 28,
	NFS4ERR_ROFS = 30,
	NFS4ERR_MLINK = 31,
	NFS4ERR_NAMETOOLONG = 63,
	NFS4ERR_NOTEMPTY = 66,
	NFS4ERR_DQUOT = 69,
	NFS4ERR_STALE = 70,
	NFS4ERR_BADHANDLE = 10001,
	NFS4ERR_BAD_COOKIE = 10003,
	NFS4ERR_NOTSUPP = 10004,
	NFS4ERR_TOOSMALL = 10005,
	NFS4ERR_SERVERFAULT = 10006,
	NFS4ERR_BADTYPE = 10007,
	NFS4ERR_DELAY = 10008,
	NFS4ERR_SAME = 10009,
	NFS4ERR_DENIED = 10010,
	NFS4ERR_EXPIRED = 10011,
	NFS4ERR_LOCKED = 10012,
	NFS4ERR_GRACE = 10013,
	NFS4ERR_FHEXPIRED = 10014,
	NFS4ERR_SHARE_DENIED = 10015,
	NFS4ERR_WRONGSEC = 10016,
	NFS4ERR_CLID_INUSE = 10017,
	NFS4ERR_RESOURCE = 10018,
	NFS4ERR_MOVED = 10019,
	NFS4ERR_NOFILEHANDLE = 10020,
	NFS4ERR_MINOR_VERS_MISMATCH = 10021,
	NFS4ERR_STALE_CLIENTID = 10022,
	NFS4ERR_STALE_STATEID = 10023,
	NFS4ERR_OLD_STATEID = 10024,
	NFS4ERR_BAD_STATEID = 10025,
	NFS4ERR_BAD_SEQID = 10026,
	NFS4ERR_NOT_SAME = 10027,
	NFS4ERR_LOCK_RANGE = 10028,
	NFS4ERR_SYMLINK = 10029,
	NFS4ERR_RESTOREFH = 10030,
	NFS4ERR_LEASE_MOVED = 10031,
	NFS4ERR_ATTRNOTSUPP = 10032,
	NFS4ERR_NO_GRACE = 10033,
	NFS4ERR_RECLAIM_BAD = 10034,
	NFS4ERR_RECLAIM_CONFLICT = 10035,
	NFS4ERR_BADXDR = 10036,
	NFS4ERR_LOCKS_HELD = 10037,
	NFS4ERR_OPENMODE = 10038,
	NFS4ERR_BADOWNER = 10039,
	NFS4ERR_BADCHAR = 10040,
	NFS4ERR_BADNAME = 10041,
	NFS4ERR_BAD_RANGE = 10042,
	NFS4ERR_LOCK_NOTSUPP = 10043,
	NFS4ERR_OP_ILLEGAL = 10044,
	NFS4ERR_DEADLOCK = 10045,
	NFS4ERR_FILE_OPEN = 10046,
	NFS4ERR_ADMIN_REVOKED = 10047,
	NFS4ERR_CB_PATH_DOWN = 10048,
	NFS4ERR_BADIOMODE = 10049,
	NFS4ERR_BADLAYOUT = 10050,
	NFS4ERR_BAD_SESSION_DIGEST = 10051,
	NFS4ERR_BADSESSION = 10052,
	NFS4ERR_BADSLOT = 10053,
	NFS4ERR_COMPLETE_ALREADY = 10054,
	NFS4ERR_CONN_NOT_BOUND_TO_SESSION = 10055,
	NFS4ERR_DELEG_ALREADY_WANTED = 10056,
	NFS4ERR_BACK_CHAN_BUSY = 10057,
	NFS4ERR_LAYOUTTRYLATER = 10058,
	NFS4ERR_LAYOUTUNAVAILABLE = 10059,
	NFS4ERR_NOMATCHING_LAYOUT = 10060,
	NFS4ERR_RECALLCONFLICT = 10061,
	NFS4ERR_UNKNOWN_LAYOUTTYPE = 10062,
	NFS4ERR_SEQ_MISORDERED = 10063,
	NFS4ERR_SEQUENCE_POS = 10064,
	NFS4ERR_REQ_TOO_BIG = 10065,
	NFS4ERR_REP_TOO_BIG = 10066,
	NFS4ERR_REP_TOO_BIG_TO_CACHE = 10067,
	NFS4ERR_RETRY_UNCACHED_REP = 10068,
	NFS4ERR_UNSAFE_COMPOUND = 10069,
	NFS4ERR_TOO_MANY_OPS = 10070,
	NFS4ERR_OP_NOT_IN_SESSION = 10071,
	NFS4ERR_HASH_ALG_UNSUPP = 10072,
	NFS4ERR_CLIENTID_BUSY = 10074,
	NFS4ERR_PNFS_IO_HOLE = 10075,
	NFS4ERR_SEQ_FALSE_RETRY = 10076,
	NFS4ERR_BAD_HIGH_SLOT = 10077,
	NFS4ERR_DEADSESSION = 10078,
	NFS4ERR_ENCR_ALG_UNSUPP = 10079,
	NFS4ERR_PNFS_NO_LAYOUT = 10080,
	NFS4ERR_NOT_ONLY_OP = 10081,
	NFS4ERR_WRONG_CRED = 10082,
	NFS4ERR_WRONG_TYPE = 10083,
	NFS4ERR_DIRDELEG_UNAVAIL = 10084,
	NFS4ERR_REJECT_DELEG = 10085,
	NFS4ERR_RETURNCONFLICT = 10086,
	NFS4ERR_DELEG_REVOKED = 10087,
	NFS4ERR_PARTNER_NOTSUPP = 10088,
	NFS4ERR_PARTNER_NO_AUTH = 10089,
	NFS4ERR_UNION_NOTSUPP = 10090,
	NFS4ERR_OFFLOAD_DENIED = 10091,
	NFS4ERR_WRONG_LFS = 10092,
	NFS4ERR_BADLABEL = 10093,
	NFS4ERR_OFFLOAD_NO_REQS = 10094,
	NFS4ERR_NOXATTR = 10095,
	NFS4ERR_XATTR2BIG = 10096,
};

struct trace_event_raw_nfs_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char __data[0];
};

struct trace_event_raw_nfs_inode_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	char __data[0];
};

struct trace_event_raw_nfs_access_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	unsigned char type;
	u64 fileid;
	u64 version;
	loff_t size;
	long unsigned int nfsi_flags;
	long unsigned int cache_validity;
	unsigned int mask;
	unsigned int permitted;
	char __data[0];
};

struct trace_event_raw_nfs_update_size_class {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t cur_size;
	loff_t new_size;
	char __data[0];
};

struct trace_event_raw_nfs_inode_range_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t range_start;
	loff_t range_end;
	char __data[0];
};

struct trace_event_raw_nfs_readdir_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	char verifier[8];
	u64 cookie;
	long unsigned int index;
	unsigned int dtsize;
	char __data[0];
};

struct trace_event_raw_nfs_lookup_event {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_lookup_event_done {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	int: 32;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_atomic_open_enter {
	struct trace_entry ent;
	long unsigned int flags;
	long unsigned int fmode;
	dev_t dev;
	int: 32;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_atomic_open_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	long unsigned int fmode;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_create_enter {
	struct trace_entry ent;
	long unsigned int flags;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_create_exit {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	dev_t dev;
	int: 32;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_directory_event {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_directory_event_done {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_link_enter {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_link_exit {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_rename_event {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 old_dir;
	u64 new_dir;
	u32 __data_loc_old_name;
	u32 __data_loc_new_name;
	char __data[0];
};

struct trace_event_raw_nfs_rename_event_done {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 old_dir;
	u32 __data_loc_old_name;
	int: 32;
	u64 new_dir;
	u32 __data_loc_new_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_sillyrename_unlink {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_aop_readpage {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t offset;
	char __data[0];
};

struct trace_event_raw_nfs_aop_readpage_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	int ret;
	int: 32;
	u64 fileid;
	u64 version;
	loff_t offset;
	char __data[0];
};

struct trace_event_raw_nfs_aop_readahead {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u64 version;
	loff_t offset;
	unsigned int nr_pages;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_aop_readahead_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	int ret;
	int: 32;
	u64 fileid;
	u64 version;
	loff_t offset;
	unsigned int nr_pages;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_initiate_read {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_readpage_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_readpage_short {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	bool eof;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_fscache_page_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	char __data[0];
};

struct trace_event_raw_nfs_fscache_page_event_done {
	struct trace_entry ent;
	int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	loff_t offset;
	char __data[0];
};

struct trace_event_raw_nfs_pgio_error {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	loff_t pos;
	int error;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_initiate_write {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	long unsigned int stable;
	char __data[0];
};

struct trace_event_raw_nfs_writeback_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	int error;
	long unsigned int stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_page_error_class {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	unsigned int count;
	int error;
	char __data[0];
};

struct trace_event_raw_nfs_initiate_commit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 count;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs_commit_done {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	int error;
	long unsigned int stable;
	char verifier[8];
	char __data[0];
};

struct trace_event_raw_nfs_direct_req_class {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 fileid;
	u32 fhandle;
	int: 32;
	loff_t offset;
	ssize_t count;
	ssize_t bytes_left;
	ssize_t error;
	int flags;
	char __data[0];
};

struct trace_event_raw_nfs_fh_to_dentry {
	struct trace_entry ent;
	int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	char __data[0];
};

struct trace_event_raw_nfs_mount_assign {
	struct trace_entry ent;
	u32 __data_loc_option;
	u32 __data_loc_value;
	char __data[0];
};

struct trace_event_raw_nfs_mount_option {
	struct trace_entry ent;
	u32 __data_loc_option;
	char __data[0];
};

struct trace_event_raw_nfs_mount_path {
	struct trace_entry ent;
	u32 __data_loc_path;
	char __data[0];
};

struct trace_event_raw_nfs_xdr_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	long unsigned int error;
	u32 __data_loc_program;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_data_offsets_nfs_inode_event {};

struct trace_event_data_offsets_nfs_inode_event_done {};

struct trace_event_data_offsets_nfs_access_exit {};

struct trace_event_data_offsets_nfs_update_size_class {};

struct trace_event_data_offsets_nfs_inode_range_event {};

struct trace_event_data_offsets_nfs_readdir_event {};

struct trace_event_data_offsets_nfs_lookup_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_lookup_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_atomic_open_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_create_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event {
	u32 name;
};

struct trace_event_data_offsets_nfs_directory_event_done {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_enter {
	u32 name;
};

struct trace_event_data_offsets_nfs_link_exit {
	u32 name;
};

struct trace_event_data_offsets_nfs_rename_event {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_rename_event_done {
	u32 old_name;
	u32 new_name;
};

struct trace_event_data_offsets_nfs_sillyrename_unlink {
	u32 name;
};

struct trace_event_data_offsets_nfs_aop_readpage {};

struct trace_event_data_offsets_nfs_aop_readpage_done {};

struct trace_event_data_offsets_nfs_aop_readahead {};

struct trace_event_data_offsets_nfs_aop_readahead_done {};

struct trace_event_data_offsets_nfs_initiate_read {};

struct trace_event_data_offsets_nfs_readpage_done {};

struct trace_event_data_offsets_nfs_readpage_short {};

struct trace_event_data_offsets_nfs_fscache_page_event {};

struct trace_event_data_offsets_nfs_fscache_page_event_done {};

struct trace_event_data_offsets_nfs_pgio_error {};

struct trace_event_data_offsets_nfs_initiate_write {};

struct trace_event_data_offsets_nfs_writeback_done {};

struct trace_event_data_offsets_nfs_page_error_class {};

struct trace_event_data_offsets_nfs_initiate_commit {};

struct trace_event_data_offsets_nfs_commit_done {};

struct trace_event_data_offsets_nfs_direct_req_class {};

struct trace_event_data_offsets_nfs_fh_to_dentry {};

struct trace_event_data_offsets_nfs_mount_assign {
	u32 option;
	u32 value;
};

struct trace_event_data_offsets_nfs_mount_option {
	u32 option;
};

struct trace_event_data_offsets_nfs_mount_path {
	u32 path;
};

struct trace_event_data_offsets_nfs_xdr_event {
	u32 program;
	u32 procedure;
};

typedef void (*btf_trace_nfs_set_inode_stale)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_refresh_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_revalidate_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_revalidate_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_invalidate_mapping_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_invalidate_mapping_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_getattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_getattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_setattr_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_setattr_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_writeback_page_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_page_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_writeback_inode_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_writeback_inode_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_fsync_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_fsync_exit)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_access_enter)(void *, const struct inode *);

typedef void (*btf_trace_nfs_set_cache_invalid)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_readdir_force_readdirplus)(void *, const struct inode *);

typedef void (*btf_trace_nfs_readdir_cache_fill_done)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_readdir_uncached_done)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs_access_exit)(void *, const struct inode *, unsigned int, unsigned int, int);

typedef void (*btf_trace_nfs_size_truncate)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_wcc)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_update)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_size_grow)(void *, const struct inode *, loff_t);

typedef void (*btf_trace_nfs_readdir_invalidate_cache_range)(void *, const struct inode *, loff_t, loff_t);

typedef void (*btf_trace_nfs_readdir_cache_fill)(void *, const struct file *, const __be32 *, u64, long unsigned int, unsigned int);

typedef void (*btf_trace_nfs_readdir_uncached)(void *, const struct file *, const __be32 *, u64, long unsigned int, unsigned int);

typedef void (*btf_trace_nfs_lookup_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_lookup_revalidate_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_lookup_revalidate_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_readdir_lookup)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_readdir_lookup_revalidate_failed)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_readdir_lookup_revalidate)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_atomic_open_enter)(void *, const struct inode *, const struct nfs_open_context *, unsigned int);

typedef void (*btf_trace_nfs_atomic_open_exit)(void *, const struct inode *, const struct nfs_open_context *, unsigned int, int);

typedef void (*btf_trace_nfs_create_enter)(void *, const struct inode *, const struct dentry *, unsigned int);

typedef void (*btf_trace_nfs_create_exit)(void *, const struct inode *, const struct dentry *, unsigned int, int);

typedef void (*btf_trace_nfs_mknod_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mknod_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_mkdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_mkdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rmdir_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rmdir_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_remove_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_remove_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_unlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_unlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_symlink_enter)(void *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_symlink_exit)(void *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_link_enter)(void *, const struct inode *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_link_exit)(void *, const struct inode *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_rename_enter)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *);

typedef void (*btf_trace_nfs_rename_exit)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_rename)(void *, const struct inode *, const struct dentry *, const struct inode *, const struct dentry *, int);

typedef void (*btf_trace_nfs_sillyrename_unlink)(void *, const struct nfs_unlinkdata *, int);

typedef void (*btf_trace_nfs_aop_readpage)(void *, const struct inode *, struct page *);

typedef void (*btf_trace_nfs_aop_readpage_done)(void *, const struct inode *, struct page *, int);

typedef void (*btf_trace_nfs_aop_readahead)(void *, const struct inode *, loff_t, unsigned int);

typedef void (*btf_trace_nfs_aop_readahead_done)(void *, const struct inode *, unsigned int, int);

typedef void (*btf_trace_nfs_initiate_read)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_readpage_short)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_fscache_read_page)(void *, const struct inode *, struct page *);

typedef void (*btf_trace_nfs_fscache_read_page_exit)(void *, const struct inode *, struct page *, int);

typedef void (*btf_trace_nfs_fscache_write_page)(void *, const struct inode *, struct page *);

typedef void (*btf_trace_nfs_fscache_write_page_exit)(void *, const struct inode *, struct page *, int);

typedef void (*btf_trace_nfs_pgio_error)(void *, const struct nfs_pgio_header *, int, loff_t);

typedef void (*btf_trace_nfs_initiate_write)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_writeback_done)(void *, const struct rpc_task *, const struct nfs_pgio_header *);

typedef void (*btf_trace_nfs_write_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_comp_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_commit_error)(void *, const struct inode *, const struct nfs_page *, int);

typedef void (*btf_trace_nfs_initiate_commit)(void *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_commit_done)(void *, const struct rpc_task *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs_direct_commit_complete)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_resched_write)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_complete)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_completion)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_schedule_iovec)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_direct_write_reschedule_io)(void *, const struct nfs_direct_req *);

typedef void (*btf_trace_nfs_fh_to_dentry)(void *, const struct super_block *, const struct nfs_fh *, u64, int);

typedef void (*btf_trace_nfs_mount_assign)(void *, const char *, const char *);

typedef void (*btf_trace_nfs_mount_option)(void *, const struct fs_parameter *);

typedef void (*btf_trace_nfs_mount_path)(void *, const char *);

typedef void (*btf_trace_nfs_xdr_status)(void *, const struct xdr_stream *, int);

typedef void (*btf_trace_nfs_xdr_bad_filehandle)(void *, const struct xdr_stream *, int);

enum {
	FILEID_HIGH_OFF = 0,
	FILEID_LOW_OFF = 1,
	FILE_I_TYPE_OFF = 2,
	EMBED_FH_OFF = 3,
};

typedef s32 compat_int_t;

typedef u32 compat_uptr_t;

struct nfs2_fh {
	char data[32];
};

struct nfs3_fh {
	short unsigned int size;
	unsigned char data[64];
};

struct nfs_mount_data {
	int version;
	int fd;
	struct nfs2_fh old_root;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct sockaddr_in addr;
	char hostname[256];
	int namlen;
	unsigned int bsize;
	struct nfs3_fh root;
	int pseudoflavor;
	char context[257];
};

struct nfs_string {
	unsigned int len;
	const char *data;
};

struct nfs4_mount_data {
	int version;
	int flags;
	int rsize;
	int wsize;
	int timeo;
	int retrans;
	int acregmin;
	int acregmax;
	int acdirmin;
	int acdirmax;
	struct nfs_string client_addr;
	struct nfs_string mnt_path;
	struct nfs_string hostname;
	unsigned int host_addrlen;
	struct sockaddr *host_addr;
	int proto;
	int auth_flavourlen;
	int *auth_flavours;
};

enum nfs_param {
	Opt_ac = 0,
	Opt_acdirmax = 1,
	Opt_acdirmin = 2,
	Opt_acl___3 = 3,
	Opt_acregmax = 4,
	Opt_acregmin = 5,
	Opt_actimeo = 6,
	Opt_addr = 7,
	Opt_bg = 8,
	Opt_bsize = 9,
	Opt_clientaddr = 10,
	Opt_cto = 11,
	Opt_fg = 12,
	Opt_fscache = 13,
	Opt_fscache_flag = 14,
	Opt_hard = 15,
	Opt_intr = 16,
	Opt_local_lock = 17,
	Opt_lock = 18,
	Opt_lookupcache = 19,
	Opt_migration = 20,
	Opt_minorversion = 21,
	Opt_mountaddr = 22,
	Opt_mounthost = 23,
	Opt_mountport = 24,
	Opt_mountproto = 25,
	Opt_mountvers = 26,
	Opt_namelen = 27,
	Opt_nconnect = 28,
	Opt_max_connect = 29,
	Opt_port = 30,
	Opt_posix = 31,
	Opt_proto = 32,
	Opt_rdirplus = 33,
	Opt_rdma = 34,
	Opt_resvport = 35,
	Opt_retrans = 36,
	Opt_retry = 37,
	Opt_rsize = 38,
	Opt_sec = 39,
	Opt_sharecache = 40,
	Opt_sloppy = 41,
	Opt_soft = 42,
	Opt_softerr = 43,
	Opt_softreval = 44,
	Opt_source = 45,
	Opt_tcp = 46,
	Opt_timeo = 47,
	Opt_trunkdiscovery = 48,
	Opt_udp = 49,
	Opt_v = 50,
	Opt_vers = 51,
	Opt_wsize = 52,
	Opt_write = 53,
};

enum {
	Opt_local_lock_all = 0,
	Opt_local_lock_flock = 1,
	Opt_local_lock_none = 2,
	Opt_local_lock_posix = 3,
};

enum {
	Opt_lookupcache_all = 0,
	Opt_lookupcache_none = 1,
	Opt_lookupcache_positive = 2,
};

enum {
	Opt_write_lazy = 0,
	Opt_write_eager = 1,
	Opt_write_wait = 2,
};

enum {
	Opt_vers_2 = 0,
	Opt_vers_3 = 1,
	Opt_vers_4 = 2,
	Opt_vers_4_0 = 3,
	Opt_vers_4_1 = 4,
	Opt_vers_4_2 = 5,
};

enum {
	Opt_xprt_rdma = 0,
	Opt_xprt_rdma6 = 1,
	Opt_xprt_tcp = 2,
	Opt_xprt_tcp6 = 3,
	Opt_xprt_udp = 4,
	Opt_xprt_udp6 = 5,
	nr__Opt_xprt = 6,
};

enum {
	Opt_sec_krb5 = 0,
	Opt_sec_krb5i = 1,
	Opt_sec_krb5p = 2,
	Opt_sec_lkey = 3,
	Opt_sec_lkeyi = 4,
	Opt_sec_lkeyp = 5,
	Opt_sec_none = 6,
	Opt_sec_spkm = 7,
	Opt_sec_spkmi = 8,
	Opt_sec_spkmp = 9,
	Opt_sec_sys = 10,
	nr__Opt_sec = 11,
};

struct compat_nfs_string {
	compat_uint_t len;
	compat_uptr_t data;
};

struct compat_nfs4_mount_data_v1 {
	compat_int_t version;
	compat_int_t flags;
	compat_int_t rsize;
	compat_int_t wsize;
	compat_int_t timeo;
	compat_int_t retrans;
	compat_int_t acregmin;
	compat_int_t acregmax;
	compat_int_t acdirmin;
	compat_int_t acdirmax;
	struct compat_nfs_string client_addr;
	struct compat_nfs_string mnt_path;
	struct compat_nfs_string hostname;
	compat_uint_t host_addrlen;
	compat_uptr_t host_addr;
	compat_int_t proto;
	compat_int_t auth_flavourlen;
	compat_uptr_t auth_flavours;
};

struct nfs2_fsstat {
	__u32 tsize;
	__u32 bsize;
	__u32 blocks;
	__u32 bfree;
	__u32 bavail;
};

struct nfs_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
};

struct nfs_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs_readdirargs {
	struct nfs_fh *fh;
	__u32 cookie;
	unsigned int count;
	struct page **pages;
};

struct nfs_diropok {
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs_createdata {
	struct nfs_createargs arg;
	struct nfs_diropok res;
	struct nfs_fh fhandle;
	int: 16;
	int: 32;
	struct nfs_fattr fattr;
};

enum nfs_ftype {
	NFNON = 0,
	NFREG = 1,
	NFDIR = 2,
	NFBLK = 3,
	NFCHR = 4,
	NFLNK = 5,
	NFSOCK = 6,
	NFBAD = 7,
	NFFIFO = 8,
};

enum nfs2_ftype {
	NF2NON = 0,
	NF2REG = 1,
	NF2DIR = 2,
	NF2BLK = 3,
	NF2CHR = 4,
	NF2LNK = 5,
	NF2SOCK = 6,
	NF2BAD = 7,
	NF2FIFO = 8,
};

enum nfs3_createmode {
	NFS3_CREATE_UNCHECKED = 0,
	NFS3_CREATE_GUARDED = 1,
	NFS3_CREATE_EXCLUSIVE = 2,
};

enum nfs3_ftype {
	NF3NON = 0,
	NF3REG = 1,
	NF3DIR = 2,
	NF3BLK = 3,
	NF3CHR = 4,
	NF3LNK = 5,
	NF3SOCK = 6,
	NF3FIFO = 7,
	NF3BAD = 8,
};

struct nfs3_sattrargs {
	struct nfs_fh *fh;
	struct iattr *sattr;
	unsigned int guard;
	int: 32;
	struct timespec64 guardtime;
};

struct nfs3_diropargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
};

struct nfs3_accessargs {
	struct nfs_fh *fh;
	__u32 access;
};

struct nfs3_createargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
	enum nfs3_createmode createmode;
	__be32 verifier[2];
};

struct nfs3_mkdirargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	struct iattr *sattr;
};

struct nfs3_symlinkargs {
	struct nfs_fh *fromfh;
	const char *fromname;
	unsigned int fromlen;
	struct page **pages;
	unsigned int pathlen;
	struct iattr *sattr;
};

struct nfs3_mknodargs {
	struct nfs_fh *fh;
	const char *name;
	unsigned int len;
	enum nfs3_ftype type;
	struct iattr *sattr;
	dev_t rdev;
};

struct nfs3_linkargs {
	struct nfs_fh *fromfh;
	struct nfs_fh *tofh;
	const char *toname;
	unsigned int tolen;
};

struct nfs3_readdirargs {
	struct nfs_fh *fh;
	int: 32;
	__u64 cookie;
	__be32 verf[2];
	bool plus;
	unsigned int count;
	struct page **pages;
	int: 32;
};

struct nfs3_diropres {
	struct nfs_fattr *dir_attr;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
};

struct nfs3_accessres {
	struct nfs_fattr *fattr;
	__u32 access;
};

struct nfs3_readlinkargs {
	struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs3_linkres {
	struct nfs_fattr *dir_attr;
	struct nfs_fattr *fattr;
};

struct nfs3_readdirres {
	struct nfs_fattr *dir_attr;
	__be32 *verf;
	bool plus;
};

struct nfs3_createdata {
	struct rpc_message msg;
	union {
		struct nfs3_createargs create;
		struct nfs3_mkdirargs mkdir;
		struct nfs3_symlinkargs symlink;
		struct nfs3_mknodargs mknod;
	} arg;
	struct nfs3_diropres res;
	struct nfs_fh fh;
	int: 16;
	int: 32;
	struct nfs_fattr fattr;
	struct nfs_fattr dir_attr;
};

struct nfs3_getaclargs {
	struct nfs_fh *fh;
	int mask;
	struct page **pages;
};

struct nfs3_setaclargs {
	struct inode *inode;
	int mask;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
	size_t len;
	unsigned int npages;
	struct page **pages;
};

struct nfs3_getaclres {
	struct nfs_fattr *fattr;
	int mask;
	unsigned int acl_access_count;
	unsigned int acl_default_count;
	struct posix_acl *acl_access;
	struct posix_acl *acl_default;
};

struct rpc_add_xprt_test {
	void (*add_xprt_test)(struct rpc_clnt *, struct rpc_xprt *, void *);
	void *data;
};

enum nfs_ftype4 {
	NF4BAD = 0,
	NF4REG = 1,
	NF4DIR = 2,
	NF4BLK = 3,
	NF4CHR = 4,
	NF4LNK = 5,
	NF4SOCK = 6,
	NF4FIFO = 7,
	NF4ATTRDIR = 8,
	NF4NAMEDATTR = 9,
};

enum open_claim_type4 {
	NFS4_OPEN_CLAIM_NULL = 0,
	NFS4_OPEN_CLAIM_PREVIOUS = 1,
	NFS4_OPEN_CLAIM_DELEGATE_CUR = 2,
	NFS4_OPEN_CLAIM_DELEGATE_PREV = 3,
	NFS4_OPEN_CLAIM_FH = 4,
	NFS4_OPEN_CLAIM_DELEG_CUR_FH = 5,
	NFS4_OPEN_CLAIM_DELEG_PREV_FH = 6,
};

enum createmode4 {
	NFS4_CREATE_UNCHECKED = 0,
	NFS4_CREATE_GUARDED = 1,
	NFS4_CREATE_EXCLUSIVE = 2,
	NFS4_CREATE_EXCLUSIVE4_1 = 3,
};

enum {
	NFSPROC4_CLNT_NULL = 0,
	NFSPROC4_CLNT_READ = 1,
	NFSPROC4_CLNT_WRITE = 2,
	NFSPROC4_CLNT_COMMIT = 3,
	NFSPROC4_CLNT_OPEN = 4,
	NFSPROC4_CLNT_OPEN_CONFIRM = 5,
	NFSPROC4_CLNT_OPEN_NOATTR = 6,
	NFSPROC4_CLNT_OPEN_DOWNGRADE = 7,
	NFSPROC4_CLNT_CLOSE = 8,
	NFSPROC4_CLNT_SETATTR = 9,
	NFSPROC4_CLNT_FSINFO = 10,
	NFSPROC4_CLNT_RENEW = 11,
	NFSPROC4_CLNT_SETCLIENTID = 12,
	NFSPROC4_CLNT_SETCLIENTID_CONFIRM = 13,
	NFSPROC4_CLNT_LOCK = 14,
	NFSPROC4_CLNT_LOCKT = 15,
	NFSPROC4_CLNT_LOCKU = 16,
	NFSPROC4_CLNT_ACCESS = 17,
	NFSPROC4_CLNT_GETATTR = 18,
	NFSPROC4_CLNT_LOOKUP = 19,
	NFSPROC4_CLNT_LOOKUP_ROOT = 20,
	NFSPROC4_CLNT_REMOVE = 21,
	NFSPROC4_CLNT_RENAME = 22,
	NFSPROC4_CLNT_LINK = 23,
	NFSPROC4_CLNT_SYMLINK = 24,
	NFSPROC4_CLNT_CREATE = 25,
	NFSPROC4_CLNT_PATHCONF = 26,
	NFSPROC4_CLNT_STATFS = 27,
	NFSPROC4_CLNT_READLINK = 28,
	NFSPROC4_CLNT_READDIR = 29,
	NFSPROC4_CLNT_SERVER_CAPS = 30,
	NFSPROC4_CLNT_DELEGRETURN = 31,
	NFSPROC4_CLNT_GETACL = 32,
	NFSPROC4_CLNT_SETACL = 33,
	NFSPROC4_CLNT_FS_LOCATIONS = 34,
	NFSPROC4_CLNT_RELEASE_LOCKOWNER = 35,
	NFSPROC4_CLNT_SECINFO = 36,
	NFSPROC4_CLNT_FSID_PRESENT = 37,
	NFSPROC4_CLNT_EXCHANGE_ID = 38,
	NFSPROC4_CLNT_CREATE_SESSION = 39,
	NFSPROC4_CLNT_DESTROY_SESSION = 40,
	NFSPROC4_CLNT_SEQUENCE = 41,
	NFSPROC4_CLNT_GET_LEASE_TIME = 42,
	NFSPROC4_CLNT_RECLAIM_COMPLETE = 43,
	NFSPROC4_CLNT_LAYOUTGET = 44,
	NFSPROC4_CLNT_GETDEVICEINFO = 45,
	NFSPROC4_CLNT_LAYOUTCOMMIT = 46,
	NFSPROC4_CLNT_LAYOUTRETURN = 47,
	NFSPROC4_CLNT_SECINFO_NO_NAME = 48,
	NFSPROC4_CLNT_TEST_STATEID = 49,
	NFSPROC4_CLNT_FREE_STATEID = 50,
	NFSPROC4_CLNT_GETDEVICELIST = 51,
	NFSPROC4_CLNT_BIND_CONN_TO_SESSION = 52,
	NFSPROC4_CLNT_DESTROY_CLIENTID = 53,
	NFSPROC4_CLNT_SEEK = 54,
	NFSPROC4_CLNT_ALLOCATE = 55,
	NFSPROC4_CLNT_DEALLOCATE = 56,
	NFSPROC4_CLNT_LAYOUTSTATS = 57,
	NFSPROC4_CLNT_CLONE = 58,
	NFSPROC4_CLNT_COPY = 59,
	NFSPROC4_CLNT_OFFLOAD_CANCEL = 60,
	NFSPROC4_CLNT_LOOKUPP = 61,
	NFSPROC4_CLNT_LAYOUTERROR = 62,
	NFSPROC4_CLNT_COPY_NOTIFY = 63,
	NFSPROC4_CLNT_GETXATTR = 64,
	NFSPROC4_CLNT_SETXATTR = 65,
	NFSPROC4_CLNT_LISTXATTRS = 66,
	NFSPROC4_CLNT_REMOVEXATTR = 67,
	NFSPROC4_CLNT_READ_PLUS = 68,
};

enum state_protect_how4 {
	SP4_NONE = 0,
	SP4_MACH_CRED = 1,
	SP4_SSV = 2,
};

enum pnfs_notify_deviceid_type4 {
	NOTIFY_DEVICEID4_CHANGE = 2,
	NOTIFY_DEVICEID4_DELETE = 4,
};

struct nfs4_op_map {
	union {
		long unsigned int longs[3];
		u32 words[3];
	} u;
};

struct nfs4_get_lease_time_args {
	struct nfs4_sequence_args la_seq_args;
};

struct nfs4_get_lease_time_res {
	struct nfs4_sequence_res lr_seq_res;
	struct nfs_fsinfo *lr_fsinfo;
};

struct nfs4_layoutget_args {
	struct nfs4_sequence_args seq_args;
	__u32 type;
	int: 32;
	struct pnfs_layout_range range;
	__u64 minlength;
	__u32 maxcount;
	struct inode *inode;
	struct nfs_open_context *ctx;
	nfs4_stateid stateid;
	struct nfs4_layoutdriver_data layout;
	int: 32;
};

struct nfs4_layoutget {
	struct nfs4_layoutget_args args;
	struct nfs4_layoutget_res res;
	const struct cred *cred;
	struct pnfs_layout_hdr *lo;
	gfp_t gfp_flags;
	int: 32;
};

struct nfs4_getdeviceinfo_args {
	struct nfs4_sequence_args seq_args;
	struct pnfs_device *pdev;
	__u32 notify_types;
};

struct nfs4_getdeviceinfo_res {
	struct nfs4_sequence_res seq_res;
	struct pnfs_device *pdev;
	__u32 notification;
};

struct nfs4_layoutreturn_res {
	struct nfs4_sequence_res seq_res;
	u32 lrs_present;
	nfs4_stateid stateid;
};

struct nfs4_layoutreturn {
	struct nfs4_layoutreturn_args args;
	struct nfs4_layoutreturn_res res;
	const struct cred *cred;
	struct nfs_client *clp;
	struct inode *inode;
	int rpc_status;
	struct nfs4_xdr_opaque_data ld_private;
};

struct stateowner_id {
	__u64 create_time;
	__u32 uniquifier;
	int: 32;
};

struct nfs_openargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	struct nfs_seqid *seqid;
	int open_flags;
	fmode_t fmode;
	u32 share_access;
	u32 access;
	__u64 clientid;
	struct stateowner_id id;
	union {
		struct {
			struct iattr *attrs;
			nfs4_verifier verifier;
		};
		nfs4_stateid delegation;
		fmode_t delegation_type;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const u32 *bitmask;
	const u32 *open_bitmap;
	enum open_claim_type4 claim;
	enum createmode4 createmode;
	const struct nfs4_label *label;
	umode_t umask;
	struct nfs4_layoutget_args *lg_args;
};

struct nfs_openres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fh fh;
	struct nfs4_change_info cinfo;
	__u32 rflags;
	struct nfs_fattr *f_attr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	fmode_t delegation_type;
	nfs4_stateid delegation;
	long unsigned int pagemod_limit;
	__u32 do_recall;
	__u32 attrset[3];
	struct nfs4_string *owner;
	struct nfs4_string *group_owner;
	__u32 access_request;
	__u32 access_supported;
	__u32 access_result;
	struct nfs4_layoutget_res *lg_res;
	int: 32;
};

struct nfs_open_confirmargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	nfs4_stateid *stateid;
	struct nfs_seqid *seqid;
};

struct nfs_open_confirmres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs_closeargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
	fmode_t fmode;
	u32 share_access;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs_closeres {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_fattr *fattr;
	struct nfs_seqid *seqid;
	const struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

struct nfs_lowner {
	__u64 clientid;
	__u64 id;
	dev_t s_dev;
	int: 32;
};

struct nfs_lock_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *lock_seqid;
	nfs4_stateid lock_stateid;
	struct nfs_seqid *open_seqid;
	nfs4_stateid open_stateid;
	struct nfs_lowner lock_owner;
	unsigned char block: 1;
	unsigned char reclaim: 1;
	unsigned char new_lock: 1;
	unsigned char new_lock_owner: 1;
	int: 28;
	int: 32;
};

struct nfs_lock_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *lock_seqid;
	struct nfs_seqid *open_seqid;
};

struct nfs_locku_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_seqid *seqid;
	nfs4_stateid stateid;
};

struct nfs_locku_res {
	struct nfs4_sequence_res seq_res;
	nfs4_stateid stateid;
	struct nfs_seqid *seqid;
};

struct nfs_lockt_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	struct file_lock *fl;
	struct nfs_lowner lock_owner;
};

struct nfs_lockt_res {
	struct nfs4_sequence_res seq_res;
	struct file_lock *denied;
};

struct nfs_release_lockowner_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_lowner lock_owner;
};

struct nfs_release_lockowner_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_delegreturnargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fhandle;
	const nfs4_stateid *stateid;
	const u32 *bitmask;
	u32 bitmask_store[3];
	struct nfs4_layoutreturn_args *lr_args;
};

struct nfs4_delegreturnres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	struct nfs_server *server;
	struct nfs4_layoutreturn_res *lr_res;
	int lr_ret;
};

struct nfs_setattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	nfs4_stateid stateid;
	struct iattr *iap;
	const struct nfs_server *server;
	const u32 *bitmask;
	const struct nfs4_label *label;
};

enum nfs4_acl_type {
	NFS4ACL_NONE = 0,
	NFS4ACL_ACL = 1,
	NFS4ACL_DACL = 2,
	NFS4ACL_SACL = 3,
};

struct nfs_setaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_setaclres {
	struct nfs4_sequence_res seq_res;
};

struct nfs_getaclargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	struct page **acl_pages;
};

struct nfs_getaclres {
	struct nfs4_sequence_res seq_res;
	enum nfs4_acl_type acl_type;
	size_t acl_len;
	size_t acl_data_offset;
	int acl_flags;
	struct page *acl_scratch;
};

struct nfs_setattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs_fattr *fattr;
	const struct nfs_server *server;
};

typedef u64 clientid4;

struct nfs4_accessargs {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
	u32 access;
};

struct nfs4_accessres {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	u32 supported;
	u32 access;
};

struct nfs4_create_arg {
	struct nfs4_sequence_args seq_args;
	u32 ftype;
	union {
		struct {
			struct page **pages;
			unsigned int len;
		} symlink;
		struct {
			u32 specdata1;
			u32 specdata2;
		} device;
	} u;
	const struct qstr *name;
	const struct nfs_server *server;
	const struct iattr *attrs;
	const struct nfs_fh *dir_fh;
	const u32 *bitmask;
	const struct nfs4_label *label;
	umode_t umask;
};

struct nfs4_create_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fh *fh;
	struct nfs_fattr *fattr;
	int: 32;
	struct nfs4_change_info dir_cinfo;
};

struct nfs4_fsinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_fsinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsinfo *fsinfo;
};

struct nfs4_getattr_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_getattr_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
};

struct nfs4_link_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_link_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs4_change_info cinfo;
	struct nfs_fattr *dir_attr;
	int: 32;
};

struct nfs4_lookup_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
	const u32 *bitmask;
};

struct nfs4_lookup_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
};

struct nfs4_lookupp_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_lookupp_res {
	struct nfs4_sequence_res seq_res;
	const struct nfs_server *server;
	struct nfs_fattr *fattr;
	struct nfs_fh *fh;
};

struct nfs4_lookup_root_arg {
	struct nfs4_sequence_args seq_args;
	const u32 *bitmask;
};

struct nfs4_pathconf_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_pathconf_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_pathconf *pathconf;
};

struct nfs4_readdir_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	int: 32;
	u64 cookie;
	nfs4_verifier verifier;
	u32 count;
	struct page **pages;
	unsigned int pgbase;
	const u32 *bitmask;
	bool plus;
	int: 24;
	int: 32;
};

struct nfs4_readdir_res {
	struct nfs4_sequence_res seq_res;
	nfs4_verifier verifier;
	unsigned int pgbase;
};

struct nfs4_readlink {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	unsigned int pgbase;
	unsigned int pglen;
	struct page **pages;
};

struct nfs4_readlink_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs4_setclientid {
	const nfs4_verifier *sc_verifier;
	u32 sc_prog;
	unsigned int sc_netid_len;
	char sc_netid[6];
	unsigned int sc_uaddr_len;
	char sc_uaddr[58];
	struct nfs_client *sc_clnt;
	struct rpc_cred *sc_cred;
};

struct nfs4_setclientid_res {
	u64 clientid;
	nfs4_verifier confirm;
};

struct nfs4_statfs_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	const u32 *bitmask;
};

struct nfs4_statfs_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fsstat *fsstat;
};

struct nfs4_server_caps_arg {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fhandle;
	const u32 *bitmask;
};

struct nfs4_server_caps_res {
	struct nfs4_sequence_res seq_res;
	u32 attr_bitmask[3];
	u32 exclcreat_bitmask[3];
	u32 acl_bitmask;
	u32 has_links;
	u32 has_symlinks;
	u32 fh_expire_type;
	u32 case_insensitive;
	u32 case_preserving;
};

struct nfs4_fs_locations_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct nfs_fh *fh;
	const struct qstr *name;
	struct page *page;
	const u32 *bitmask;
	int: 32;
	clientid4 clientid;
	unsigned char migration: 1;
	unsigned char renew: 1;
	int: 30;
	int: 32;
};

struct nfs4_fs_locations_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_fs_locations *fs_locations;
	unsigned char migration: 1;
	unsigned char renew: 1;
};

struct nfs4_secinfo4 {
	u32 flavor;
	struct rpcsec_gss_info flavor_info;
};

struct nfs4_secinfo_flavors {
	unsigned int num_flavors;
	struct nfs4_secinfo4 flavors[0];
};

struct nfs4_secinfo_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *dir_fh;
	const struct qstr *name;
};

struct nfs4_secinfo_res {
	struct nfs4_sequence_res seq_res;
	struct nfs4_secinfo_flavors *flavors;
};

struct nfs4_fsid_present_arg {
	struct nfs4_sequence_args seq_args;
	const struct nfs_fh *fh;
	int: 32;
	clientid4 clientid;
	unsigned char renew: 1;
	int: 31;
	int: 32;
};

struct nfs4_fsid_present_res {
	struct nfs4_sequence_res seq_res;
	struct nfs_fh *fh;
	unsigned char renew: 1;
};

struct nfs41_state_protection {
	u32 how;
	struct nfs4_op_map enforce;
	struct nfs4_op_map allow;
};

struct nfs41_exchange_id_args {
	struct nfs_client *client;
	nfs4_verifier verifier;
	u32 flags;
	struct nfs41_state_protection state_protect;
};

struct nfs41_bind_conn_to_session_args {
	struct nfs_client *client;
	struct nfs4_sessionid sessionid;
	u32 dir;
	bool use_conn_in_rdma_mode;
	int retries;
};

struct nfs41_bind_conn_to_session_res {
	struct nfs4_sessionid sessionid;
	u32 dir;
	bool use_conn_in_rdma_mode;
};

struct nfs41_exchange_id_res {
	u64 clientid;
	u32 seqid;
	u32 flags;
	struct nfs41_server_owner *server_owner;
	struct nfs41_server_scope *server_scope;
	struct nfs41_impl_id *impl_id;
	struct nfs41_state_protection state_protect;
};

struct nfs41_create_session_args {
	struct nfs_client *client;
	int: 32;
	u64 clientid;
	uint32_t seqid;
	uint32_t flags;
	uint32_t cb_program;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_channel_attrs bc_attrs;
	int: 32;
};

struct nfs41_create_session_res {
	struct nfs4_sessionid sessionid;
	uint32_t seqid;
	uint32_t flags;
	struct nfs4_channel_attrs fc_attrs;
	struct nfs4_channel_attrs bc_attrs;
};

struct nfs41_reclaim_complete_args {
	struct nfs4_sequence_args seq_args;
	unsigned char one_fs: 1;
};

struct nfs41_reclaim_complete_res {
	struct nfs4_sequence_res seq_res;
};

struct nfs41_secinfo_no_name_args {
	struct nfs4_sequence_args seq_args;
	int style;
};

struct nfs41_test_stateid_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid *stateid;
};

struct nfs41_test_stateid_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
};

struct nfs41_free_stateid_args {
	struct nfs4_sequence_args seq_args;
	nfs4_stateid stateid;
};

struct nfs41_free_stateid_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
};

struct nfs4_cached_acl {
	enum nfs4_acl_type type;
	int cached;
	size_t len;
	char data[0];
};

enum nfs4_client_state {
	NFS4CLNT_MANAGER_RUNNING = 0,
	NFS4CLNT_CHECK_LEASE = 1,
	NFS4CLNT_LEASE_EXPIRED = 2,
	NFS4CLNT_RECLAIM_REBOOT = 3,
	NFS4CLNT_RECLAIM_NOGRACE = 4,
	NFS4CLNT_DELEGRETURN = 5,
	NFS4CLNT_SESSION_RESET = 6,
	NFS4CLNT_LEASE_CONFIRM = 7,
	NFS4CLNT_SERVER_SCOPE_MISMATCH = 8,
	NFS4CLNT_PURGE_STATE = 9,
	NFS4CLNT_BIND_CONN_TO_SESSION = 10,
	NFS4CLNT_MOVED = 11,
	NFS4CLNT_LEASE_MOVED = 12,
	NFS4CLNT_DELEGATION_EXPIRED = 13,
	NFS4CLNT_RUN_MANAGER = 14,
	NFS4CLNT_MANAGER_AVAILABLE = 15,
	NFS4CLNT_RECALL_RUNNING = 16,
	NFS4CLNT_RECALL_ANY_LAYOUT_READ = 17,
	NFS4CLNT_RECALL_ANY_LAYOUT_RW = 18,
	NFS4CLNT_DELEGRETURN_DELAYED = 19,
};

enum {
	NFS_OWNER_RECLAIM_REBOOT = 0,
	NFS_OWNER_RECLAIM_NOGRACE = 1,
};

enum {
	LK_STATE_IN_USE = 0,
	NFS_DELEGATED_STATE = 1,
	NFS_OPEN_STATE = 2,
	NFS_O_RDONLY_STATE = 3,
	NFS_O_WRONLY_STATE = 4,
	NFS_O_RDWR_STATE = 5,
	NFS_STATE_RECLAIM_REBOOT = 6,
	NFS_STATE_RECLAIM_NOGRACE = 7,
	NFS_STATE_POSIX_LOCKS = 8,
	NFS_STATE_RECOVERY_FAILED = 9,
	NFS_STATE_MAY_NOTIFY_LOCK = 10,
	NFS_STATE_CHANGE_WAIT = 11,
	NFS_CLNT_DST_SSC_COPY_STATE = 12,
	NFS_CLNT_SRC_SSC_COPY_STATE = 13,
	NFS_SRV_SSC_COPY_STATE = 14,
};

struct nfs4_exception {
	struct nfs4_state *state;
	struct inode *inode;
	nfs4_stateid *stateid;
	long int timeout;
	unsigned char task_is_privileged: 1;
	unsigned char delay: 1;
	unsigned char recovering: 1;
	unsigned char retry: 1;
	bool interruptible;
};

struct nfs4_opendata {
	struct kref kref;
	int: 32;
	struct nfs_openargs o_arg;
	struct nfs_openres o_res;
	struct nfs_open_confirmargs c_arg;
	struct nfs_open_confirmres c_res;
	struct nfs4_string owner_name;
	struct nfs4_string group_name;
	struct nfs4_label *a_label;
	struct nfs_fattr f_attr;
	struct dentry *dir;
	struct dentry *dentry;
	struct nfs4_state_owner *owner;
	struct nfs4_state *state;
	struct iattr attrs;
	struct nfs4_layoutget *lgp;
	long unsigned int timestamp;
	bool rpc_done;
	bool file_created;
	bool is_recover;
	bool cancelled;
	int rpc_status;
};

struct nfs4_add_xprt_data {
	struct nfs_client *clp;
	const struct cred *cred;
};

enum {
	NFS_DELEGATION_NEED_RECLAIM = 0,
	NFS_DELEGATION_RETURN = 1,
	NFS_DELEGATION_RETURN_IF_CLOSED = 2,
	NFS_DELEGATION_REFERENCED = 3,
	NFS_DELEGATION_RETURNING = 4,
	NFS_DELEGATION_REVOKED = 5,
	NFS_DELEGATION_TEST_EXPIRED = 6,
	NFS_DELEGATION_INODE_FREEING = 7,
	NFS_DELEGATION_RETURN_DELAYED = 8,
};

struct cb_notify_lock_args {
	struct nfs_fh cbnl_fh;
	int: 16;
	int: 32;
	struct nfs_lowner cbnl_owner;
	bool cbnl_valid;
	int: 24;
	int: 32;
};

enum {
	NFS_LAYOUT_RO_FAILED = 0,
	NFS_LAYOUT_RW_FAILED = 1,
	NFS_LAYOUT_BULK_RECALL = 2,
	NFS_LAYOUT_RETURN = 3,
	NFS_LAYOUT_RETURN_LOCK = 4,
	NFS_LAYOUT_RETURN_REQUESTED = 5,
	NFS_LAYOUT_INVALID_STID = 6,
	NFS_LAYOUT_FIRST_LAYOUTGET = 7,
	NFS_LAYOUT_INODE_FREEING = 8,
	NFS_LAYOUT_HASHED = 9,
	NFS_LAYOUT_DRAIN = 10,
};

enum nfs4_slot_tbl_state {
	NFS4_SLOT_TBL_DRAINING = 0,
};

enum nfs4_session_state {
	NFS4_SESSION_INITING = 0,
	NFS4_SESSION_ESTABLISHED = 1,
};

struct nfs4_call_sync_data {
	const struct nfs_server *seq_server;
	struct nfs4_sequence_args *seq_args;
	struct nfs4_sequence_res *seq_res;
};

struct nfs4_open_createattrs {
	struct nfs4_label *label;
	struct iattr *sattr;
	const __u32 verf[2];
};

struct nfs4_closedata {
	struct inode *inode;
	struct nfs4_state *state;
	struct nfs_closeargs arg;
	struct nfs_closeres res;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	long unsigned int timestamp;
	int: 32;
};

struct nfs4_createdata {
	struct rpc_message msg;
	struct nfs4_create_arg arg;
	struct nfs4_create_res res;
	struct nfs_fh fh;
	int: 16;
	int: 32;
	struct nfs_fattr fattr;
};

struct nfs4_renewdata {
	struct nfs_client *client;
	long unsigned int timestamp;
};

struct nfs4_delegreturndata {
	struct nfs4_delegreturnargs args;
	struct nfs4_delegreturnres res;
	struct nfs_fh fh;
	nfs4_stateid stateid;
	long unsigned int timestamp;
	struct {
		struct nfs4_layoutreturn_args arg;
		struct nfs4_layoutreturn_res res;
		struct nfs4_xdr_opaque_data ld_private;
		u32 roc_barrier;
		bool roc;
	} lr;
	struct nfs_fattr fattr;
	int rpc_status;
	struct inode *inode;
};

struct nfs4_unlockdata {
	struct nfs_locku_args arg;
	struct nfs_locku_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	struct nfs_lock_context *l_ctx;
	int: 32;
	struct file_lock fl;
	struct nfs_server *server;
	long unsigned int timestamp;
};

struct nfs4_lockdata {
	struct nfs_lock_args arg;
	struct nfs_lock_res res;
	struct nfs4_lock_state *lsp;
	struct nfs_open_context *ctx;
	int: 32;
	struct file_lock fl;
	long unsigned int timestamp;
	int rpc_status;
	int cancelled;
	struct nfs_server *server;
};

struct nfs4_lock_waiter {
	struct inode *inode;
	int: 32;
	struct nfs_lowner owner;
	wait_queue_entry_t wait;
	int: 32;
};

struct nfs_release_lockowner_data {
	struct nfs4_lock_state *lsp;
	struct nfs_server *server;
	struct nfs_release_lockowner_args args;
	struct nfs_release_lockowner_res res;
	long unsigned int timestamp;
	int: 32;
};

struct rpc_bind_conn_calldata {
	struct nfs_client *clp;
	const struct cred *cred;
};

struct nfs41_exchange_id_data {
	struct nfs41_exchange_id_res res;
	struct nfs41_exchange_id_args args;
	int: 32;
};

struct nfs4_get_lease_time_data {
	struct nfs4_get_lease_time_args *args;
	struct nfs4_get_lease_time_res *res;
	struct nfs_client *clp;
};

struct nfs4_sequence_data {
	struct nfs_client *clp;
	struct nfs4_sequence_args args;
	struct nfs4_sequence_res res;
};

struct nfs4_reclaim_complete_data {
	struct nfs_client *clp;
	struct nfs41_reclaim_complete_args arg;
	struct nfs41_reclaim_complete_res res;
};

struct nfs_free_stateid_data {
	struct nfs_server *server;
	struct nfs41_free_stateid_args args;
	struct nfs41_free_stateid_res res;
};

enum opentype4 {
	NFS4_OPEN_NOCREATE = 0,
	NFS4_OPEN_CREATE = 1,
};

enum limit_by4 {
	NFS4_LIMIT_SIZE = 1,
	NFS4_LIMIT_BLOCKS = 2,
};

enum open_delegation_type4 {
	NFS4_OPEN_DELEGATE_NONE = 0,
	NFS4_OPEN_DELEGATE_READ = 1,
	NFS4_OPEN_DELEGATE_WRITE = 2,
	NFS4_OPEN_DELEGATE_NONE_EXT = 3,
};

enum why_no_delegation4 {
	WND4_NOT_WANTED = 0,
	WND4_CONTENTION = 1,
	WND4_RESOURCE = 2,
	WND4_NOT_SUPP_FTYPE = 3,
	WND4_WRITE_DELEG_NOT_SUPP_FTYPE = 4,
	WND4_NOT_SUPP_UPGRADE = 5,
	WND4_NOT_SUPP_DOWNGRADE = 6,
	WND4_CANCELLED = 7,
	WND4_IS_DIR = 8,
};

enum lock_type4 {
	NFS4_UNLOCK_LT = 0,
	NFS4_READ_LT = 1,
	NFS4_WRITE_LT = 2,
	NFS4_READW_LT = 3,
	NFS4_WRITEW_LT = 4,
};

enum pnfs_layoutreturn_type {
	RETURN_FILE = 1,
	RETURN_FSID = 2,
	RETURN_ALL = 3,
};

enum data_content4 {
	NFS4_CONTENT_DATA = 0,
	NFS4_CONTENT_HOLE = 1,
};

struct nfs42_netaddr {
	char netid[5];
	char addr[58];
	u32 netid_len;
	u32 addr_len;
};

enum netloc_type4 {
	NL4_NAME = 1,
	NL4_URL = 2,
	NL4_NETADDR = 3,
};

struct nl4_server {
	enum netloc_type4 nl4_type;
	union {
		struct {
			int nl4_str_sz;
			char nl4_str[1025];
		};
		struct nfs42_netaddr nl4_addr;
	} u;
};

enum nfs4_setxattr_options {
	SETXATTR4_EITHER = 0,
	SETXATTR4_CREATE = 1,
	SETXATTR4_REPLACE = 2,
};

struct nfs42_layoutstat_res {
	struct nfs4_sequence_res seq_res;
	int num_dev;
	int rpc_status;
};

struct nfs42_device_error {
	struct nfs4_deviceid dev_id;
	int status;
	enum nfs_opnum4 opnum;
};

struct nfs42_layout_error {
	__u64 offset;
	__u64 length;
	nfs4_stateid stateid;
	struct nfs42_device_error errors[1];
	int: 32;
};

struct nfs42_layouterror_args {
	struct nfs4_sequence_args seq_args;
	struct inode *inode;
	unsigned int num_errors;
	struct nfs42_layout_error errors[5];
};

struct nfs42_layouterror_res {
	struct nfs4_sequence_res seq_res;
	unsigned int num_errors;
	int rpc_status;
};

struct nfs42_clone_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *src_fh;
	struct nfs_fh *dst_fh;
	nfs4_stateid src_stateid;
	nfs4_stateid dst_stateid;
	__u64 src_offset;
	__u64 dst_offset;
	__u64 count;
	const u32 *dst_bitmask;
	int: 32;
};

struct nfs42_clone_res {
	struct nfs4_sequence_res seq_res;
	unsigned int rpc_status;
	struct nfs_fattr *dst_fattr;
	const struct nfs_server *server;
};

struct nfs42_falloc_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *falloc_fh;
	nfs4_stateid falloc_stateid;
	u64 falloc_offset;
	u64 falloc_length;
	const u32 *falloc_bitmask;
	int: 32;
};

struct nfs42_falloc_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
	struct nfs_fattr *falloc_fattr;
	const struct nfs_server *falloc_server;
};

struct nfs42_copy_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *src_fh;
	nfs4_stateid src_stateid;
	u64 src_pos;
	struct nfs_fh *dst_fh;
	nfs4_stateid dst_stateid;
	u64 dst_pos;
	u64 count;
	bool sync;
	struct nl4_server *cp_src;
};

struct nfs42_write_res {
	nfs4_stateid stateid;
	int: 32;
	u64 count;
	struct nfs_writeverf verifier;
	int: 32;
};

struct nfs42_copy_res {
	struct nfs4_sequence_res seq_res;
	struct nfs42_write_res write_res;
	bool consecutive;
	bool synchronous;
	struct nfs_commitres commit_res;
	int: 32;
};

struct nfs42_offload_status_args {
	struct nfs4_sequence_args osa_seq_args;
	struct nfs_fh *osa_src_fh;
	nfs4_stateid osa_stateid;
};

struct nfs42_offload_status_res {
	struct nfs4_sequence_res osr_seq_res;
	uint64_t osr_count;
	int osr_status;
	int: 32;
};

struct nfs42_copy_notify_args {
	struct nfs4_sequence_args cna_seq_args;
	struct nfs_fh *cna_src_fh;
	nfs4_stateid cna_src_stateid;
	struct nl4_server cna_dst;
};

struct nfs42_copy_notify_res {
	struct nfs4_sequence_res cnr_seq_res;
	struct nfstime4 cnr_lease_time;
	nfs4_stateid cnr_stateid;
	struct nl4_server cnr_src;
};

struct nfs42_seek_args {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *sa_fh;
	nfs4_stateid sa_stateid;
	u64 sa_offset;
	u32 sa_what;
	int: 32;
};

struct nfs42_seek_res {
	struct nfs4_sequence_res seq_res;
	unsigned int status;
	u32 sr_eof;
	u64 sr_offset;
};

struct nfs42_setxattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
	u32 xattr_flags;
	size_t xattr_len;
	struct page **xattr_pages;
};

struct nfs42_setxattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs4_change_info cinfo;
};

struct nfs42_getxattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
	size_t xattr_len;
	struct page **xattr_pages;
};

struct nfs42_getxattrres {
	struct nfs4_sequence_res seq_res;
	size_t xattr_len;
};

struct nfs42_listxattrsargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	u32 count;
	u64 cookie;
	struct page **xattr_pages;
	int: 32;
};

struct nfs42_listxattrsres {
	struct nfs4_sequence_res seq_res;
	struct page *scratch;
	void *xattr_buf;
	size_t xattr_len;
	int: 32;
	u64 cookie;
	bool eof;
	size_t copied;
};

struct nfs42_removexattrargs {
	struct nfs4_sequence_args seq_args;
	struct nfs_fh *fh;
	const char *xattr_name;
};

struct nfs42_removexattrres {
	struct nfs4_sequence_res seq_res;
	struct nfs4_change_info cinfo;
};

struct compound_hdr {
	int32_t status;
	uint32_t nops;
	__be32 *nops_p;
	uint32_t taglen;
	char *tag;
	uint32_t replen;
	u32 minorversion;
};

struct read_plus_segment {
	enum data_content4 type;
	int: 32;
	uint64_t offset;
	union {
		struct {
			uint64_t length;
		} hole;
		struct {
			uint32_t length;
			unsigned int from;
		} data;
	};
};

struct nfs4_copy_state {
	struct list_head copies;
	struct list_head src_copies;
	nfs4_stateid stateid;
	struct completion completion;
	int: 32;
	uint64_t count;
	struct nfs_writeverf verf;
	int error;
	int flags;
	struct nfs4_state *parent_src_state;
	struct nfs4_state *parent_dst_state;
	int: 32;
};

struct nfs_referral_count {
	struct list_head list;
	const struct task_struct *task;
	unsigned int referral_count;
};

struct rpc_pipe_dir_object_ops;

struct rpc_pipe_dir_object {
	struct list_head pdo_head;
	const struct rpc_pipe_dir_object_ops *pdo_ops;
	void *pdo_data;
};

struct rpc_pipe_dir_object_ops {
	int (*create)(struct dentry *, struct rpc_pipe_dir_object *);
	void (*destroy)(struct dentry *, struct rpc_pipe_dir_object *);
};

struct rpc_inode {
	struct inode vfs_inode;
	void *private;
	struct rpc_pipe *pipe;
	wait_queue_head_t waitq;
	int: 32;
};

struct idmap_legacy_upcalldata;

struct idmap {
	struct rpc_pipe_dir_object idmap_pdo;
	struct rpc_pipe *idmap_pipe;
	struct idmap_legacy_upcalldata *idmap_upcall_data;
	struct mutex idmap_mutex;
	struct user_namespace *user_ns;
};

struct user_key_payload {
	struct callback_head rcu;
	short unsigned int datalen;
	int: 16;
	int: 32;
	char data[0];
};

struct request_key_auth {
	struct callback_head rcu;
	struct key *target_key;
	struct key *dest_keyring;
	const struct cred *cred;
	void *callout_info;
	size_t callout_len;
	pid_t pid;
	char op[8];
};

struct idmap_msg {
	__u8 im_type;
	__u8 im_conv;
	char im_name[128];
	__u32 im_id;
	__u8 im_status;
};

struct idmap_legacy_upcalldata {
	struct rpc_pipe_msg pipe_msg;
	struct idmap_msg idmap_msg;
	struct key *authkey;
	struct idmap *idmap;
};

enum {
	Opt_find_uid = 0,
	Opt_find_gid = 1,
	Opt_find_user = 2,
	Opt_find_group = 3,
	Opt_find_err = 4,
};

enum rpc_auth_stat {
	RPC_AUTH_OK = 0,
	RPC_AUTH_BADCRED = 1,
	RPC_AUTH_REJECTEDCRED = 2,
	RPC_AUTH_BADVERF = 3,
	RPC_AUTH_REJECTEDVERF = 4,
	RPC_AUTH_TOOWEAK = 5,
	RPCSEC_GSS_CREDPROBLEM = 13,
	RPCSEC_GSS_CTXPROBLEM = 14,
};

enum nfs4_callback_procnum {
	CB_NULL = 0,
	CB_COMPOUND = 1,
};

struct nfs_callback_data {
	unsigned int users;
	struct svc_serv *serv;
};

enum rpc_accept_stat {
	RPC_SUCCESS = 0,
	RPC_PROG_UNAVAIL = 1,
	RPC_PROG_MISMATCH = 2,
	RPC_PROC_UNAVAIL = 3,
	RPC_GARBAGE_ARGS = 4,
	RPC_SYSTEM_ERR = 5,
	RPC_DROP_REPLY = 60000,
};

enum nfs4_callback_opnum {
	OP_CB_GETATTR = 3,
	OP_CB_RECALL = 4,
	OP_CB_LAYOUTRECALL = 5,
	OP_CB_NOTIFY = 6,
	OP_CB_PUSH_DELEG = 7,
	OP_CB_RECALL_ANY = 8,
	OP_CB_RECALLABLE_OBJ_AVAIL = 9,
	OP_CB_RECALL_SLOT = 10,
	OP_CB_SEQUENCE = 11,
	OP_CB_WANTS_CANCELLED = 12,
	OP_CB_NOTIFY_LOCK = 13,
	OP_CB_NOTIFY_DEVICEID = 14,
	OP_CB_OFFLOAD = 15,
	OP_CB_ILLEGAL = 10044,
};

struct cb_process_state {
	__be32 drc_status;
	struct nfs_client *clp;
	struct nfs4_slot *slot;
	u32 minorversion;
	struct net *net;
};

struct cb_compound_hdr_arg {
	unsigned int taglen;
	const char *tag;
	unsigned int minorversion;
	unsigned int cb_ident;
	unsigned int nops;
};

struct cb_compound_hdr_res {
	__be32 *status;
	unsigned int taglen;
	const char *tag;
	__be32 *nops;
};

struct cb_getattrargs {
	struct nfs_fh fh;
	uint32_t bitmap[2];
};

struct cb_getattrres {
	__be32 status;
	uint32_t bitmap[2];
	int: 32;
	uint64_t size;
	uint64_t change_attr;
	struct timespec64 ctime;
	struct timespec64 mtime;
};

struct cb_recallargs {
	struct nfs_fh fh;
	nfs4_stateid stateid;
	uint32_t truncate;
};

struct referring_call {
	uint32_t rc_sequenceid;
	uint32_t rc_slotid;
};

struct referring_call_list {
	struct nfs4_sessionid rcl_sessionid;
	uint32_t rcl_nrefcalls;
	struct referring_call *rcl_refcalls;
};

struct cb_sequenceargs {
	struct sockaddr *csa_addr;
	struct nfs4_sessionid csa_sessionid;
	uint32_t csa_sequenceid;
	uint32_t csa_slotid;
	uint32_t csa_highestslotid;
	uint32_t csa_cachethis;
	uint32_t csa_nrclists;
	struct referring_call_list *csa_rclists;
};

struct cb_sequenceres {
	__be32 csr_status;
	struct nfs4_sessionid csr_sessionid;
	uint32_t csr_sequenceid;
	uint32_t csr_slotid;
	uint32_t csr_highestslotid;
	uint32_t csr_target_highestslotid;
};

struct cb_recallanyargs {
	uint32_t craa_objs_to_keep;
	uint32_t craa_type_mask;
};

struct cb_recallslotargs {
	uint32_t crsa_target_highest_slotid;
};

struct cb_layoutrecallargs {
	uint32_t cbl_recall_type;
	uint32_t cbl_layout_type;
	uint32_t cbl_layoutchanged;
	int: 32;
	union {
		struct {
			struct nfs_fh cbl_fh;
			int: 16;
			int: 32;
			struct pnfs_layout_range cbl_range;
			nfs4_stateid cbl_stateid;
			int: 32;
		};
		struct nfs_fsid cbl_fsid;
	};
};

struct cb_devicenotifyitem {
	uint32_t cbd_notify_type;
	uint32_t cbd_layout_type;
	struct nfs4_deviceid cbd_dev_id;
	uint32_t cbd_immediate;
};

struct cb_devicenotifyargs {
	uint32_t ndevs;
	struct cb_devicenotifyitem *devs;
};

struct cb_offloadargs {
	struct nfs_fh coa_fh;
	nfs4_stateid coa_stateid;
	uint32_t error;
	int: 32;
	uint64_t wr_count;
	struct nfs_writeverf wr_writeverf;
	int: 32;
};

struct callback_op {
	__be32 (*process_op)(void *, void *, struct cb_process_state *);
	__be32 (*decode_args)(struct svc_rqst *, struct xdr_stream *, void *);
	__be32 (*encode_res)(struct svc_rqst *, struct xdr_stream *, const void *);
	long int res_maxsize;
};

struct nfs4_ds_server {
	struct list_head list;
	struct rpc_clnt *rpc_clnt;
};

enum pnfs_update_layout_reason {
	PNFS_UPDATE_LAYOUT_UNKNOWN = 0,
	PNFS_UPDATE_LAYOUT_NO_PNFS = 1,
	PNFS_UPDATE_LAYOUT_RD_ZEROLEN = 2,
	PNFS_UPDATE_LAYOUT_MDSTHRESH = 3,
	PNFS_UPDATE_LAYOUT_NOMEM = 4,
	PNFS_UPDATE_LAYOUT_BULK_RECALL = 5,
	PNFS_UPDATE_LAYOUT_IO_TEST_FAIL = 6,
	PNFS_UPDATE_LAYOUT_FOUND_CACHED = 7,
	PNFS_UPDATE_LAYOUT_RETURN = 8,
	PNFS_UPDATE_LAYOUT_RETRY = 9,
	PNFS_UPDATE_LAYOUT_BLOCKED = 10,
	PNFS_UPDATE_LAYOUT_INVALID_OPEN = 11,
	PNFS_UPDATE_LAYOUT_SEND_LAYOUTGET = 12,
	PNFS_UPDATE_LAYOUT_EXIT = 13,
};

struct trace_event_raw_nfs4_clientid_event {
	struct trace_entry ent;
	u32 __data_loc_dstaddr;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_sequence_done {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int target_highest_slotid;
	long unsigned int status_flags;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int cachethis;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_seqid_err {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_slotid;
	unsigned int cachethis;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_offload {
	struct trace_entry ent;
	long unsigned int error;
	u32 fhandle;
	loff_t cb_count;
	int cb_how;
	int cb_stateid_seq;
	u32 cb_stateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_setup_sequence {
	struct trace_entry ent;
	unsigned int session;
	unsigned int slot_nr;
	unsigned int seq_nr;
	unsigned int highest_used_slotid;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_hostname;
	char __data[0];
};

struct trace_event_raw_nfs4_state_mgr_failed {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int state;
	u32 __data_loc_hostname;
	u32 __data_loc_section;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_bad_operation {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	u32 expected;
	char __data[0];
};

struct trace_event_raw_nfs4_xdr_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 op;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_cb_error_class {
	struct trace_entry ent;
	u32 xid;
	u32 cbident;
	char __data[0];
};

struct trace_event_raw_nfs4_open_event {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int flags;
	long unsigned int fmode;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	u64 dir;
	u32 __data_loc_name;
	int stateid_seq;
	u32 stateid_hash;
	int openstateid_seq;
	u32 openstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_cached_open {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_close {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lock_event {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int cmd;
	long unsigned int type;
	int: 32;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_set_lock {
	struct trace_entry ent;
	long unsigned int error;
	long unsigned int cmd;
	long unsigned int type;
	int: 32;
	loff_t start;
	loff_t end;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	int lockstateid_seq;
	u32 lockstateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_state_lock_reclaim {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int state_flags;
	long unsigned int lock_flags;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_set_delegation_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int fmode;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_delegreturn_exit {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_test_stateid_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_lookup_event {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 dir;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_lookupp {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 ino;
	long unsigned int error;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_rename {
	struct trace_entry ent;
	dev_t dev;
	long unsigned int error;
	u64 olddir;
	u32 __data_loc_oldname;
	int: 32;
	u64 newdir;
	u32 __data_loc_newname;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_inode_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_inode_stateid_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_getattr_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	unsigned int valid;
	long unsigned int error;
	char __data[0];
};

struct trace_event_raw_nfs4_inode_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	u32 __data_loc_dstaddr;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_inode_stateid_callback_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	u32 __data_loc_dstaddr;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_idmap_event {
	struct trace_entry ent;
	long unsigned int error;
	u32 id;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_nfs4_read_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_write_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	loff_t offset;
	u32 arg_count;
	u32 res_count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_commit_event {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	long unsigned int error;
	int: 32;
	loff_t offset;
	u32 count;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_layoutget {
	struct trace_entry ent;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	u32 iomode;
	int: 32;
	u64 offset;
	u64 count;
	long unsigned int error;
	int stateid_seq;
	u32 stateid_hash;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	char __data[0];
	int: 32;
};

struct trace_event_raw_pnfs_update_layout {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 fileid;
	u32 fhandle;
	int: 32;
	loff_t pos;
	u64 count;
	enum pnfs_iomode iomode;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	long int lseg;
	enum pnfs_update_layout_reason reason;
	char __data[0];
	int: 32;
};

struct trace_event_raw_pnfs_layout_event {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	u64 fileid;
	u32 fhandle;
	int: 32;
	loff_t pos;
	u64 count;
	enum pnfs_iomode iomode;
	int layoutstateid_seq;
	u32 layoutstateid_hash;
	long int lseg;
	char __data[0];
};

struct trace_event_raw_nfs4_deviceid_event {
	struct trace_entry ent;
	u32 __data_loc_dstaddr;
	unsigned char deviceid[16];
	char __data[0];
};

struct trace_event_raw_nfs4_deviceid_status {
	struct trace_entry ent;
	dev_t dev;
	int status;
	u32 __data_loc_dstaddr;
	unsigned char deviceid[16];
	char __data[0];
};

struct trace_event_raw_nfs4_flexfiles_io_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	loff_t offset;
	u32 count;
	int stateid_seq;
	u32 stateid_hash;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_ff_layout_commit_error {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	loff_t offset;
	u32 count;
	u32 __data_loc_dstaddr;
	char __data[0];
};

struct trace_event_raw_nfs4_llseek {
	struct trace_entry ent;
	long unsigned int error;
	u32 fhandle;
	u32 fileid;
	dev_t dev;
	int stateid_seq;
	u32 stateid_hash;
	loff_t offset_s;
	u32 what;
	int: 32;
	loff_t offset_r;
	u32 eof;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nfs4_sparse_event {
	struct trace_entry ent;
	long unsigned int error;
	int: 32;
	loff_t offset;
	loff_t len;
	dev_t dev;
	u32 fhandle;
	u64 fileid;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_copy {
	struct trace_entry ent;
	long unsigned int error;
	u32 src_fhandle;
	u32 src_fileid;
	u32 dst_fhandle;
	u32 dst_fileid;
	dev_t src_dev;
	dev_t dst_dev;
	int src_stateid_seq;
	u32 src_stateid_hash;
	int dst_stateid_seq;
	u32 dst_stateid_hash;
	int: 32;
	loff_t src_offset;
	loff_t dst_offset;
	bool sync;
	int: 24;
	int: 32;
	loff_t len;
	int res_stateid_seq;
	u32 res_stateid_hash;
	loff_t res_count;
	bool res_sync;
	bool res_cons;
	bool intra;
	char __data[0];
	int: 8;
	int: 32;
};

struct trace_event_raw_nfs4_clone {
	struct trace_entry ent;
	long unsigned int error;
	u32 src_fhandle;
	u32 src_fileid;
	u32 dst_fhandle;
	u32 dst_fileid;
	dev_t src_dev;
	dev_t dst_dev;
	int: 32;
	loff_t src_offset;
	loff_t dst_offset;
	int src_stateid_seq;
	u32 src_stateid_hash;
	int dst_stateid_seq;
	u32 dst_stateid_hash;
	loff_t len;
	char __data[0];
};

struct trace_event_raw_nfs4_copy_notify {
	struct trace_entry ent;
	long unsigned int error;
	u32 fhandle;
	u32 fileid;
	dev_t dev;
	int stateid_seq;
	u32 stateid_hash;
	int res_stateid_seq;
	u32 res_stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_offload_cancel {
	struct trace_entry ent;
	long unsigned int error;
	u32 fhandle;
	int stateid_seq;
	u32 stateid_hash;
	char __data[0];
};

struct trace_event_raw_nfs4_xattr_event {
	struct trace_entry ent;
	long unsigned int error;
	dev_t dev;
	u32 fhandle;
	int: 32;
	u64 fileid;
	u32 __data_loc_name;
	char __data[0];
	int: 32;
};

struct trace_event_data_offsets_nfs4_clientid_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_sequence_done {};

struct trace_event_data_offsets_nfs4_cb_sequence {};

struct trace_event_data_offsets_nfs4_cb_seqid_err {};

struct trace_event_data_offsets_nfs4_cb_offload {};

struct trace_event_data_offsets_nfs4_setup_sequence {};

struct trace_event_data_offsets_nfs4_state_mgr {
	u32 hostname;
};

struct trace_event_data_offsets_nfs4_state_mgr_failed {
	u32 hostname;
	u32 section;
};

struct trace_event_data_offsets_nfs4_xdr_bad_operation {};

struct trace_event_data_offsets_nfs4_xdr_event {};

struct trace_event_data_offsets_nfs4_cb_error_class {};

struct trace_event_data_offsets_nfs4_open_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_cached_open {};

struct trace_event_data_offsets_nfs4_close {};

struct trace_event_data_offsets_nfs4_lock_event {};

struct trace_event_data_offsets_nfs4_set_lock {};

struct trace_event_data_offsets_nfs4_state_lock_reclaim {};

struct trace_event_data_offsets_nfs4_set_delegation_event {};

struct trace_event_data_offsets_nfs4_delegreturn_exit {};

struct trace_event_data_offsets_nfs4_test_stateid_event {};

struct trace_event_data_offsets_nfs4_lookup_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_lookupp {};

struct trace_event_data_offsets_nfs4_rename {
	u32 oldname;
	u32 newname;
};

struct trace_event_data_offsets_nfs4_inode_event {};

struct trace_event_data_offsets_nfs4_inode_stateid_event {};

struct trace_event_data_offsets_nfs4_getattr_event {};

struct trace_event_data_offsets_nfs4_inode_callback_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_inode_stateid_callback_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_idmap_event {
	u32 name;
};

struct trace_event_data_offsets_nfs4_read_event {};

struct trace_event_data_offsets_nfs4_write_event {};

struct trace_event_data_offsets_nfs4_commit_event {};

struct trace_event_data_offsets_nfs4_layoutget {};

struct trace_event_data_offsets_pnfs_update_layout {};

struct trace_event_data_offsets_pnfs_layout_event {};

struct trace_event_data_offsets_nfs4_deviceid_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_deviceid_status {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_flexfiles_io_event {
	u32 dstaddr;
};

struct trace_event_data_offsets_ff_layout_commit_error {
	u32 dstaddr;
};

struct trace_event_data_offsets_nfs4_llseek {};

struct trace_event_data_offsets_nfs4_sparse_event {};

struct trace_event_data_offsets_nfs4_copy {};

struct trace_event_data_offsets_nfs4_clone {};

struct trace_event_data_offsets_nfs4_copy_notify {};

struct trace_event_data_offsets_nfs4_offload_cancel {};

struct trace_event_data_offsets_nfs4_xattr_event {
	u32 name;
};

typedef void (*btf_trace_nfs4_setclientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_setclientid_confirm)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_renew_async)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_exchange_id)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_create_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_destroy_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_destroy_clientid)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_bind_conn_to_session)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_sequence)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_reclaim_complete)(void *, const struct nfs_client *, int);

typedef void (*btf_trace_nfs4_sequence_done)(void *, const struct nfs4_session *, const struct nfs4_sequence_res *);

typedef void (*btf_trace_nfs4_cb_sequence)(void *, const struct cb_sequenceargs *, const struct cb_sequenceres *, __be32);

typedef void (*btf_trace_nfs4_cb_seqid_err)(void *, const struct cb_sequenceargs *, __be32);

typedef void (*btf_trace_nfs4_cb_offload)(void *, const struct nfs_fh *, const nfs4_stateid *, uint64_t, int, int);

typedef void (*btf_trace_nfs4_setup_sequence)(void *, const struct nfs4_session *, const struct nfs4_sequence_args *);

typedef void (*btf_trace_nfs4_state_mgr)(void *, const struct nfs_client *);

typedef void (*btf_trace_nfs4_state_mgr_failed)(void *, const struct nfs_client *, const char *, int);

typedef void (*btf_trace_nfs4_xdr_bad_operation)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs4_xdr_status)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs4_xdr_bad_filehandle)(void *, const struct xdr_stream *, u32, u32);

typedef void (*btf_trace_nfs_cb_no_clp)(void *, __be32, u32);

typedef void (*btf_trace_nfs_cb_badprinc)(void *, __be32, u32);

typedef void (*btf_trace_nfs4_open_reclaim)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_expired)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_open_file)(void *, const struct nfs_open_context *, int, int);

typedef void (*btf_trace_nfs4_cached_open)(void *, const struct nfs4_state *);

typedef void (*btf_trace_nfs4_close)(void *, const struct nfs4_state *, const struct nfs_closeargs *, const struct nfs_closeres *, int);

typedef void (*btf_trace_nfs4_get_lock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_unlock)(void *, const struct file_lock *, const struct nfs4_state *, int, int);

typedef void (*btf_trace_nfs4_set_lock)(void *, const struct file_lock *, const struct nfs4_state *, const nfs4_stateid *, int, int);

typedef void (*btf_trace_nfs4_state_lock_reclaim)(void *, const struct nfs4_state *, const struct nfs4_lock_state *);

typedef void (*btf_trace_nfs4_set_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_reclaim_delegation)(void *, const struct inode *, fmode_t);

typedef void (*btf_trace_nfs4_delegreturn_exit)(void *, const struct nfs4_delegreturnargs *, const struct nfs4_delegreturnres *, int);

typedef void (*btf_trace_nfs4_test_delegation_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_test_open_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_test_lock_stateid)(void *, const struct nfs4_state *, const struct nfs4_lock_state *, int);

typedef void (*btf_trace_nfs4_lookup)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_symlink)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mkdir)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_mknod)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_remove)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_get_fs_locations)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_secinfo)(void *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_lookupp)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_rename)(void *, const struct inode *, const struct qstr *, const struct inode *, const struct qstr *, int);

typedef void (*btf_trace_nfs4_access)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readlink)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_readdir)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_get_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_set_acl)(void *, const struct inode *, int);

typedef void (*btf_trace_nfs4_setattr)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_delegreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_open_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_close_stateid_update_wait)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_getattr)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_lookup_root)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_fsinfo)(void *, const struct nfs_server *, const struct nfs_fh *, const struct nfs_fattr *, int);

typedef void (*btf_trace_nfs4_cb_getattr)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, int);

typedef void (*btf_trace_nfs4_cb_recall)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_cb_layoutrecall_file)(void *, const struct nfs_client *, const struct nfs_fh *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_map_name_to_uid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_group_to_gid)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_uid_to_name)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_map_gid_to_group)(void *, const char *, int, u32, int);

typedef void (*btf_trace_nfs4_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_pnfs_read)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_pnfs_write)(void *, const struct nfs_pgio_header *, int);

typedef void (*btf_trace_nfs4_commit)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_pnfs_commit_ds)(void *, const struct nfs_commit_data *, int);

typedef void (*btf_trace_nfs4_layoutget)(void *, const struct nfs_open_context *, const struct pnfs_layout_range *, const struct pnfs_layout_range *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutcommit)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutreturn)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutreturn_on_close)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layouterror)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_nfs4_layoutstats)(void *, const struct inode *, const nfs4_stateid *, int);

typedef void (*btf_trace_pnfs_update_layout)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *, enum pnfs_update_layout_reason);

typedef void (*btf_trace_pnfs_mds_fallback_pg_init_read)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_pg_init_write)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_pg_get_mirror_count)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_read_done)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_write_done)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_read_pagelist)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_pnfs_mds_fallback_write_pagelist)(void *, struct inode *, loff_t, u64, enum pnfs_iomode, struct pnfs_layout_hdr *, struct pnfs_layout_segment *);

typedef void (*btf_trace_nfs4_deviceid_free)(void *, const struct nfs_client *, const struct nfs4_deviceid *);

typedef void (*btf_trace_nfs4_getdeviceinfo)(void *, const struct nfs_server *, const struct nfs4_deviceid *, int);

typedef void (*btf_trace_nfs4_find_deviceid)(void *, const struct nfs_server *, const struct nfs4_deviceid *, int);

typedef void (*btf_trace_ff_layout_read_error)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_ff_layout_write_error)(void *, const struct nfs_pgio_header *);

typedef void (*btf_trace_ff_layout_commit_error)(void *, const struct nfs_commit_data *);

typedef void (*btf_trace_nfs4_llseek)(void *, const struct inode *, const struct nfs42_seek_args *, const struct nfs42_seek_res *, int);

typedef void (*btf_trace_nfs4_fallocate)(void *, const struct inode *, const struct nfs42_falloc_args *, int);

typedef void (*btf_trace_nfs4_deallocate)(void *, const struct inode *, const struct nfs42_falloc_args *, int);

typedef void (*btf_trace_nfs4_copy)(void *, const struct inode *, const struct inode *, const struct nfs42_copy_args *, const struct nfs42_copy_res *, const struct nl4_server *, int);

typedef void (*btf_trace_nfs4_clone)(void *, const struct inode *, const struct inode *, const struct nfs42_clone_args *, int);

typedef void (*btf_trace_nfs4_copy_notify)(void *, const struct inode *, const struct nfs42_copy_notify_args *, const struct nfs42_copy_notify_res *, int);

typedef void (*btf_trace_nfs4_offload_cancel)(void *, const struct nfs42_offload_status_args *, int);

typedef void (*btf_trace_nfs4_getxattr)(void *, const struct inode *, const char *, int);

typedef void (*btf_trace_nfs4_setxattr)(void *, const struct inode *, const char *, int);

typedef void (*btf_trace_nfs4_removexattr)(void *, const struct inode *, const char *, int);

typedef void (*btf_trace_nfs4_listxattr)(void *, const struct inode *, int);

enum pnfs_layouttype {
	LAYOUT_NFSV4_1_FILES = 1,
	LAYOUT_OSD2_OBJECTS = 2,
	LAYOUT_BLOCK_VOLUME = 3,
	LAYOUT_FLEX_FILES = 4,
	LAYOUT_SCSI = 5,
	LAYOUT_TYPE_MAX = 6,
};

struct nfs42_layoutstat_data {
	struct inode *inode;
	struct nfs42_layoutstat_args args;
	struct nfs42_layoutstat_res res;
};

enum {
	NFS_LSEG_VALID = 0,
	NFS_LSEG_ROC = 1,
	NFS_LSEG_LAYOUTCOMMIT = 2,
	NFS_LSEG_LAYOUTRETURN = 3,
	NFS_LSEG_UNAVAILABLE = 4,
};

enum {
	NFS_DEVICEID_INVALID = 0,
	NFS_DEVICEID_UNAVAILABLE = 1,
	NFS_DEVICEID_NOCACHE = 2,
};

struct nfs4_pnfs_ds_addr {
	struct __kernel_sockaddr_storage da_addr;
	size_t da_addrlen;
	struct list_head da_node;
	char *da_remotestr;
	const char *da_netid;
	int da_transport;
};

struct nfs4_pnfs_ds {
	struct list_head ds_node;
	char *ds_remotestr;
	struct list_head ds_addrs;
	struct nfs_client *ds_clp;
	refcount_t ds_count;
	long unsigned int ds_state;
};

struct nfs42_layouterror_data {
	struct nfs42_layouterror_args args;
	struct nfs42_layouterror_res res;
	struct inode *inode;
	struct pnfs_layout_segment *lseg;
};

struct nfs42_offloadcancel_data {
	struct nfs_server *seq_server;
	struct nfs42_offload_status_args args;
	int: 32;
	struct nfs42_offload_status_res res;
};

struct nfs4_xattr_bucket {
	spinlock_t lock;
	struct hlist_head hlist;
	struct nfs4_xattr_cache *cache;
	bool draining;
};

struct nfs4_xattr_entry;

struct nfs4_xattr_cache {
	struct kref ref;
	struct nfs4_xattr_bucket buckets[64];
	struct list_head lru;
	struct list_head dispose;
	atomic_long_t nent;
	spinlock_t listxattr_lock;
	struct inode *inode;
	struct nfs4_xattr_entry *listxattr;
};

struct nfs4_xattr_entry {
	struct kref ref;
	struct hlist_node hnode;
	struct list_head lru;
	struct list_head dispose;
	char *xattr_name;
	void *xattr_value;
	size_t xattr_size;
	struct nfs4_xattr_bucket *bucket;
	uint32_t flags;
};

enum stripetype4 {
	STRIPE_SPARSE = 1,
	STRIPE_DENSE = 2,
};

struct nfs4_file_layout_dsaddr {
	struct nfs4_deviceid_node id_node;
	u32 stripe_count;
	u8 *stripe_indices;
	u32 ds_num;
	struct nfs4_pnfs_ds *ds_list[0];
};

struct nfs4_filelayout_segment {
	struct pnfs_layout_segment generic_hdr;
	u32 stripe_type;
	u32 commit_through_mds;
	u32 stripe_unit;
	u32 first_stripe_index;
	u64 pattern_offset;
	struct nfs4_deviceid deviceid;
	struct nfs4_file_layout_dsaddr *dsaddr;
	unsigned int num_fh;
	struct nfs_fh **fh_array;
	int: 32;
};

struct nfs4_filelayout {
	struct pnfs_layout_hdr generic_hdr;
	struct pnfs_ds_commit_info commit_info;
	int: 32;
};

struct nfs4_ff_ds_version {
	u32 version;
	u32 minor_version;
	u32 rsize;
	u32 wsize;
	bool tightly_coupled;
};

struct nfs4_ff_layout_ds {
	struct nfs4_deviceid_node id_node;
	u32 ds_versions_cnt;
	struct nfs4_ff_ds_version *ds_versions;
	struct nfs4_pnfs_ds *ds;
};

struct nfs4_ff_layout_ds_err {
	struct list_head list;
	u64 offset;
	u64 length;
	int status;
	enum nfs_opnum4 opnum;
	nfs4_stateid stateid;
	struct nfs4_deviceid deviceid;
	int: 32;
};

struct nfs4_ff_io_stat {
	__u64 ops_requested;
	__u64 bytes_requested;
	__u64 ops_completed;
	__u64 bytes_completed;
	__u64 bytes_not_delivered;
	ktime_t total_busy_time;
	ktime_t aggregate_completion_time;
};

struct nfs4_ff_busy_timer {
	ktime_t start_time;
	atomic_t n_ops;
	int: 32;
};

struct nfs4_ff_layoutstat {
	struct nfs4_ff_io_stat io_stat;
	struct nfs4_ff_busy_timer busy_timer;
};

struct nfs4_ff_layout_mirror {
	struct pnfs_layout_hdr *layout;
	struct list_head mirrors;
	u32 ds_count;
	u32 efficiency;
	struct nfs4_deviceid devid;
	struct nfs4_ff_layout_ds *mirror_ds;
	u32 fh_versions_cnt;
	struct nfs_fh *fh_versions;
	nfs4_stateid stateid;
	const struct cred *ro_cred;
	const struct cred *rw_cred;
	refcount_t ref;
	spinlock_t lock;
	long unsigned int flags;
	struct nfs4_ff_layoutstat read_stat;
	struct nfs4_ff_layoutstat write_stat;
	ktime_t start_time;
	u32 report_interval;
	int: 32;
};

struct nfs4_ff_layout_segment {
	struct pnfs_layout_segment generic_hdr;
	u64 stripe_unit;
	u32 flags;
	u32 mirror_array_cnt;
	struct nfs4_ff_layout_mirror *mirror_array[0];
};

struct nfs4_flexfile_layout {
	struct pnfs_layout_hdr generic_hdr;
	struct pnfs_ds_commit_info commit_info;
	struct list_head mirrors;
	struct list_head error_list;
	int: 32;
	ktime_t last_report_time;
};

struct nfs4_flexfile_layoutreturn_args {
	struct list_head errors;
	struct nfs42_layoutstat_devinfo devinfo[4];
	unsigned int num_errors;
	unsigned int num_dev;
	struct page *pages[1];
	int: 32;
};

enum nfs4_ff_op_type {
	NFS4_FF_OP_LAYOUTSTATS = 0,
	NFS4_FF_OP_LAYOUTRETURN = 1,
};

struct getdents_callback___2 {
	struct dir_context ctx;
	char *name;
	int: 32;
	u64 ino;
	int found;
	int sequence;
};

struct nlm_host;

struct nlm_lockowner {
	struct list_head list;
	refcount_t count;
	struct nlm_host *host;
	fl_owner_t owner;
	uint32_t pid;
};

struct nsm_handle;

struct nlm_host {
	struct hlist_node h_hash;
	struct __kernel_sockaddr_storage h_addr;
	size_t h_addrlen;
	struct __kernel_sockaddr_storage h_srcaddr;
	size_t h_srcaddrlen;
	struct rpc_clnt *h_rpcclnt;
	char *h_name;
	u32 h_version;
	short unsigned int h_proto;
	short unsigned int h_reclaiming: 1;
	short unsigned int h_server: 1;
	short unsigned int h_noresvport: 1;
	short unsigned int h_inuse: 1;
	wait_queue_head_t h_gracewait;
	struct rw_semaphore h_rwsem;
	u32 h_state;
	u32 h_nsmstate;
	u32 h_pidcount;
	refcount_t h_count;
	struct mutex h_mutex;
	long unsigned int h_nextrebind;
	long unsigned int h_expires;
	struct list_head h_lockowners;
	spinlock_t h_lock;
	struct list_head h_granted;
	struct list_head h_reclaim;
	struct nsm_handle *h_nsmhandle;
	char *h_addrbuf;
	struct net *net;
	const struct cred *h_cred;
	char nodename[65];
	const struct nlmclnt_operations *h_nlmclnt_ops;
};

enum {
	NLM_LCK_GRANTED = 0,
	NLM_LCK_DENIED = 1,
	NLM_LCK_DENIED_NOLOCKS = 2,
	NLM_LCK_BLOCKED = 3,
	NLM_LCK_DENIED_GRACE_PERIOD = 4,
	NLM_DEADLCK = 5,
	NLM_ROFS = 6,
	NLM_STALE_FH = 7,
	NLM_FBIG = 8,
	NLM_FAILED = 9,
};

struct nsm_private {
	unsigned char data[16];
};

struct nlm_lock {
	char *caller;
	unsigned int len;
	struct nfs_fh fh;
	struct xdr_netobj oh;
	u32 svid;
	u64 lock_start;
	u64 lock_len;
	struct file_lock fl;
};

struct nlm_cookie {
	unsigned char data[32];
	unsigned int len;
};

struct nlm_args {
	struct nlm_cookie cookie;
	int: 32;
	struct nlm_lock lock;
	u32 block;
	u32 reclaim;
	u32 state;
	u32 monitor;
	u32 fsm_access;
	u32 fsm_mode;
};

struct nlm_res {
	struct nlm_cookie cookie;
	__be32 status;
	struct nlm_lock lock;
};

struct nsm_handle {
	struct list_head sm_link;
	refcount_t sm_count;
	char *sm_mon_name;
	char *sm_name;
	struct __kernel_sockaddr_storage sm_addr;
	size_t sm_addrlen;
	unsigned int sm_monitored: 1;
	unsigned int sm_sticky: 1;
	struct nsm_private sm_priv;
	char sm_addrbuf[51];
};

struct nlm_block;

struct nlm_rqst {
	refcount_t a_count;
	unsigned int a_flags;
	struct nlm_host *a_host;
	int: 32;
	struct nlm_args a_args;
	struct nlm_res a_res;
	struct nlm_block *a_block;
	unsigned int a_retries;
	u8 a_owner[74];
	void *a_callback_data;
};

struct nlm_file;

struct nlm_block {
	struct kref b_count;
	struct list_head b_list;
	struct list_head b_flist;
	struct nlm_rqst *b_call;
	struct svc_serv *b_daemon;
	struct nlm_host *b_host;
	long unsigned int b_when;
	unsigned int b_id;
	unsigned char b_granted;
	struct nlm_file *b_file;
	struct cache_req *b_cache_req;
	struct cache_deferred_req *b_deferred_req;
	unsigned int b_flags;
};

struct nlm_share;

struct nlm_file {
	struct hlist_node f_list;
	struct nfs_fh f_handle;
	struct file *f_file[2];
	struct nlm_share *f_shares;
	struct list_head f_blocks;
	unsigned int f_locks;
	unsigned int f_count;
	struct mutex f_mutex;
};

struct nlm_wait {
	struct list_head b_list;
	wait_queue_head_t b_wait;
	struct nlm_host *b_host;
	struct file_lock *b_lock;
	short unsigned int b_reclaim;
	__be32 b_status;
};

struct nlm_wait;

struct nlm_reboot {
	char *mon;
	unsigned int len;
	u32 state;
	struct nsm_private priv;
};

struct lockd_net {
	unsigned int nlmsvc_users;
	long unsigned int next_gc;
	long unsigned int nrhosts;
	struct delayed_work grace_period_end;
	struct lock_manager lockd_manager;
	struct list_head nsm_handles;
};

struct nlm_lookup_host_info {
	const int server;
	const struct sockaddr *sap;
	const size_t salen;
	const short unsigned int protocol;
	const u32 version;
	const char *hostname;
	const size_t hostname_len;
	const int noresvport;
	struct net *net;
	const struct cred *cred;
};

enum {
	IPV4_DEVCONF_FORWARDING = 1,
	IPV4_DEVCONF_MC_FORWARDING = 2,
	IPV4_DEVCONF_PROXY_ARP = 3,
	IPV4_DEVCONF_ACCEPT_REDIRECTS = 4,
	IPV4_DEVCONF_SECURE_REDIRECTS = 5,
	IPV4_DEVCONF_SEND_REDIRECTS = 6,
	IPV4_DEVCONF_SHARED_MEDIA = 7,
	IPV4_DEVCONF_RP_FILTER = 8,
	IPV4_DEVCONF_ACCEPT_SOURCE_ROUTE = 9,
	IPV4_DEVCONF_BOOTP_RELAY = 10,
	IPV4_DEVCONF_LOG_MARTIANS = 11,
	IPV4_DEVCONF_TAG = 12,
	IPV4_DEVCONF_ARPFILTER = 13,
	IPV4_DEVCONF_MEDIUM_ID = 14,
	IPV4_DEVCONF_NOXFRM = 15,
	IPV4_DEVCONF_NOPOLICY = 16,
	IPV4_DEVCONF_FORCE_IGMP_VERSION = 17,
	IPV4_DEVCONF_ARP_ANNOUNCE = 18,
	IPV4_DEVCONF_ARP_IGNORE = 19,
	IPV4_DEVCONF_PROMOTE_SECONDARIES = 20,
	IPV4_DEVCONF_ARP_ACCEPT = 21,
	IPV4_DEVCONF_ARP_NOTIFY = 22,
	IPV4_DEVCONF_ACCEPT_LOCAL = 23,
	IPV4_DEVCONF_SRC_VMARK = 24,
	IPV4_DEVCONF_PROXY_ARP_PVLAN = 25,
	IPV4_DEVCONF_ROUTE_LOCALNET = 26,
	IPV4_DEVCONF_IGMPV2_UNSOLICITED_REPORT_INTERVAL = 27,
	IPV4_DEVCONF_IGMPV3_UNSOLICITED_REPORT_INTERVAL = 28,
	IPV4_DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 29,
	IPV4_DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 30,
	IPV4_DEVCONF_DROP_GRATUITOUS_ARP = 31,
	IPV4_DEVCONF_BC_FORWARDING = 32,
	IPV4_DEVCONF_ARP_EVICT_NOCARRIER = 33,
	__IPV4_DEVCONF_MAX = 34,
};

struct ipv4_devconf {
	void *sysctl;
	int data[33];
	long unsigned int state[2];
};

struct in_ifaddr;

struct ip_mc_list;

struct in_device {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	refcount_t refcnt;
	int dead;
	struct in_ifaddr *ifa_list;
	struct ip_mc_list *mc_list;
	struct ip_mc_list **mc_hash;
	int mc_count;
	spinlock_t mc_tomb_lock;
	struct ip_mc_list *mc_tomb;
	long unsigned int mr_v1_seen;
	long unsigned int mr_v2_seen;
	long unsigned int mr_maxdelay;
	long unsigned int mr_qi;
	long unsigned int mr_qri;
	unsigned char mr_qrv;
	unsigned char mr_gq_running;
	u32 mr_ifc_count;
	struct timer_list mr_gq_timer;
	struct timer_list mr_ifc_timer;
	struct neigh_parms *arp_parms;
	struct ipv4_devconf cnf;
	struct callback_head callback_head;
};

struct in_ifaddr {
	struct hlist_node hash;
	struct in_ifaddr *ifa_next;
	struct in_device *ifa_dev;
	struct callback_head callback_head;
	__be32 ifa_local;
	__be32 ifa_address;
	__be32 ifa_mask;
	__u32 ifa_rt_priority;
	__be32 ifa_broadcast;
	unsigned char ifa_scope;
	unsigned char ifa_prefixlen;
	unsigned char ifa_proto;
	__u32 ifa_flags;
	char ifa_label[16];
	__u32 ifa_valid_lft;
	__u32 ifa_preferred_lft;
	long unsigned int ifa_cstamp;
	long unsigned int ifa_tstamp;
};

struct inet6_ifaddr {
	struct in6_addr addr;
	__u32 prefix_len;
	__u32 rt_priority;
	__u32 valid_lft;
	__u32 prefered_lft;
	refcount_t refcnt;
	spinlock_t lock;
	int state;
	__u32 flags;
	__u8 dad_probes;
	__u8 stable_privacy_retry;
	__u16 scope;
	int: 32;
	__u64 dad_nonce;
	long unsigned int cstamp;
	long unsigned int tstamp;
	struct delayed_work dad_work;
	struct inet6_dev *idev;
	struct fib6_info *rt;
	struct hlist_node addr_lst;
	struct list_head if_list;
	struct list_head if_list_aux;
	struct list_head tmp_list;
	struct inet6_ifaddr *ifpub;
	int regen_count;
	bool tokenized;
	u8 ifa_proto;
	struct callback_head rcu;
	struct in6_addr peer_addr;
};

struct nlmsvc_binding {
	__be32 (*fopen)(struct svc_rqst *, struct nfs_fh *, struct file **, int);
	void (*fclose)(struct file *);
};

typedef int (*nlm_host_match_fn_t)(void *, struct nlm_host *);

struct nlm_share {
	struct nlm_share *s_next;
	struct nlm_host *s_host;
	struct nlm_file *s_file;
	struct xdr_netobj s_owner;
	u32 s_access;
	u32 s_mode;
};

enum {
	NSMPROC_NULL = 0,
	NSMPROC_STAT = 1,
	NSMPROC_MON = 2,
	NSMPROC_UNMON = 3,
	NSMPROC_UNMON_ALL = 4,
	NSMPROC_SIMU_CRASH = 5,
	NSMPROC_NOTIFY = 6,
};

struct nsm_args {
	struct nsm_private *priv;
	u32 prog;
	u32 vers;
	u32 proc;
	char *mon_name;
	const char *nodename;
};

struct nsm_res {
	u32 status;
	u32 state;
};

typedef u32 unicode_t;

struct utf8_table {
	int cmask;
	int cval;
	int shift;
	long int lmask;
	long int lval;
};

typedef struct {
	__u32 v32;
} jint32_t;

typedef struct {
	__u16 v16;
} jint16_t;

struct jffs2_full_dnode;

struct jffs2_full_dirent;

struct jffs2_inode_cache;

struct jffs2_inode_info {
	struct mutex sem;
	uint32_t highest_version;
	struct rb_root fragtree;
	struct jffs2_full_dnode *metadata;
	struct jffs2_full_dirent *dents;
	unsigned char *target;
	struct jffs2_inode_cache *inocache;
	uint16_t flags;
	uint8_t usercompr;
	struct inode vfs_inode;
};

struct jffs2_raw_node_ref;

struct jffs2_full_dnode {
	struct jffs2_raw_node_ref *raw;
	uint32_t ofs;
	uint32_t size;
	uint32_t frags;
};

struct jffs2_full_dirent {
	union {
		struct jffs2_raw_node_ref *raw;
		struct jffs2_inode_cache *ic;
	};
	struct jffs2_full_dirent *next;
	uint32_t version;
	uint32_t ino;
	unsigned int nhash;
	unsigned char type;
	unsigned char name[0];
};

struct jffs2_inode_cache {
	struct jffs2_full_dirent *scan_dents;
	struct jffs2_raw_node_ref *nodes;
	uint8_t class;
	uint8_t flags;
	uint16_t state;
	uint32_t ino;
	struct jffs2_inode_cache *next;
	uint32_t pino_nlink;
};

struct jffs2_mount_opts {
	bool override_compr;
	unsigned int compr;
	bool set_rp_size;
	unsigned int rp_size;
};

struct jffs2_eraseblock;

struct jffs2_inodirty;

struct jffs2_summary;

struct jffs2_sb_info {
	struct mtd_info *mtd;
	uint32_t highest_ino;
	uint32_t check_ino;
	unsigned int flags;
	struct task_struct *gc_task;
	struct completion gc_thread_start;
	struct completion gc_thread_exit;
	struct mutex alloc_sem;
	uint32_t cleanmarker_size;
	uint32_t flash_size;
	uint32_t used_size;
	uint32_t dirty_size;
	uint32_t wasted_size;
	uint32_t free_size;
	uint32_t erasing_size;
	uint32_t bad_size;
	uint32_t sector_size;
	uint32_t unchecked_size;
	uint32_t nr_free_blocks;
	uint32_t nr_erasing_blocks;
	uint8_t resv_blocks_write;
	uint8_t resv_blocks_deletion;
	uint8_t resv_blocks_gctrigger;
	uint8_t resv_blocks_gcbad;
	uint8_t resv_blocks_gcmerge;
	uint8_t vdirty_blocks_gctrigger;
	uint32_t nospc_dirty_size;
	uint32_t nr_blocks;
	struct jffs2_eraseblock *blocks;
	struct jffs2_eraseblock *nextblock;
	struct jffs2_eraseblock *gcblock;
	struct list_head clean_list;
	struct list_head very_dirty_list;
	struct list_head dirty_list;
	struct list_head erasable_list;
	struct list_head erasable_pending_wbuf_list;
	struct list_head erasing_list;
	struct list_head erase_checking_list;
	struct list_head erase_pending_list;
	struct list_head erase_complete_list;
	struct list_head free_list;
	struct list_head bad_list;
	struct list_head bad_used_list;
	spinlock_t erase_completion_lock;
	wait_queue_head_t erase_wait;
	wait_queue_head_t inocache_wq;
	int inocache_hashsize;
	struct jffs2_inode_cache **inocache_list;
	spinlock_t inocache_lock;
	struct mutex erase_free_sem;
	uint32_t wbuf_pagesize;
	unsigned char *wbuf;
	uint32_t wbuf_ofs;
	uint32_t wbuf_len;
	struct jffs2_inodirty *wbuf_inodes;
	struct rw_semaphore wbuf_sem;
	struct delayed_work wbuf_dwork;
	unsigned char *oobbuf;
	int oobavail;
	struct jffs2_summary *summary;
	struct jffs2_mount_opts mount_opts;
	void *os_priv;
};

struct jffs2_eraseblock {
	struct list_head list;
	int bad_count;
	uint32_t offset;
	uint32_t unchecked_size;
	uint32_t used_size;
	uint32_t dirty_size;
	uint32_t wasted_size;
	uint32_t free_size;
	uint32_t allocated_refs;
	struct jffs2_raw_node_ref *first_node;
	struct jffs2_raw_node_ref *last_node;
	struct jffs2_raw_node_ref *gc_node;
};

union jffs2_sum_mem;

struct jffs2_summary {
	uint32_t sum_size;
	uint32_t sum_num;
	uint32_t sum_padded;
	union jffs2_sum_mem *sum_list_head;
	union jffs2_sum_mem *sum_list_tail;
	jint32_t *sum_buf;
};

struct jffs2_raw_node_ref {
	struct jffs2_raw_node_ref *next_in_ino;
	uint32_t flash_offset;
};

struct jffs2_sum_unknown_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
};

struct jffs2_sum_inode_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t inode;
	jint32_t version;
	jint32_t offset;
	jint32_t totlen;
} __attribute__((packed));

struct jffs2_sum_dirent_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t offset;
	jint32_t pino;
	jint32_t version;
	jint32_t ino;
	uint8_t nsize;
	uint8_t type;
	uint8_t name[0];
} __attribute__((packed));

struct jffs2_sum_xattr_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t xid;
	jint32_t version;
	jint32_t offset;
	jint32_t totlen;
} __attribute__((packed));

struct jffs2_sum_xref_mem {
	union jffs2_sum_mem *next;
	jint16_t nodetype;
	jint32_t offset;
} __attribute__((packed));

union jffs2_sum_mem {
	struct jffs2_sum_unknown_mem u;
	struct jffs2_sum_inode_mem i;
	struct jffs2_sum_dirent_mem d;
	struct jffs2_sum_xattr_mem x;
	struct jffs2_sum_xref_mem r;
};

struct jffs2_compressor {
	struct list_head list;
	int priority;
	char *name;
	char compr;
	int (*compress)(unsigned char *, unsigned char *, uint32_t *, uint32_t *);
	int (*decompress)(unsigned char *, unsigned char *, uint32_t, uint32_t);
	int usecount;
	int disabled;
	unsigned char *compr_buf;
	uint32_t compr_buf_size;
	uint32_t stat_compr_orig_size;
	uint32_t stat_compr_new_size;
	uint32_t stat_compr_blocks;
	uint32_t stat_decompr_blocks;
};

typedef struct {
	__u32 m;
} jmode_t;

struct jffs2_raw_dirent {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t pino;
	jint32_t version;
	jint32_t ino;
	jint32_t mctime;
	__u8 nsize;
	__u8 type;
	__u8 unused[2];
	jint32_t node_crc;
	jint32_t name_crc;
	__u8 name[0];
};

struct jffs2_raw_inode {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t ino;
	jint32_t version;
	jmode_t mode;
	jint16_t uid;
	jint16_t gid;
	jint32_t isize;
	jint32_t atime;
	jint32_t mtime;
	jint32_t ctime;
	jint32_t offset;
	jint32_t csize;
	jint32_t dsize;
	__u8 compr;
	__u8 usercompr;
	jint16_t flags;
	jint32_t data_crc;
	jint32_t node_crc;
	__u8 data[0];
};

union jffs2_device_node {
	jint16_t old_id;
	jint32_t new_id;
};

typedef unsigned char u_char;

struct mtd_ecc_stats {
	__u32 corrected;
	__u32 failed;
	__u32 badblocks;
	__u32 bbtblocks;
};

struct mtd_debug_info {
	struct dentry *dfs_dir;
};

struct nvmem_device;

struct mtd_part {
	struct list_head node;
	u64 offset;
	u64 size;
	u32 flags;
	int: 32;
};

struct mtd_master {
	struct mutex partitions_lock;
	struct mutex chrdev_lock;
	unsigned int suspended: 1;
};

struct mtd_ooblayout_ops;

struct mtd_pairing_scheme;

struct mtd_erase_region_info;

struct erase_info;

struct mtd_oob_ops;

struct otp_info;

struct mtd_info {
	u_char type;
	uint32_t flags;
	uint64_t size;
	uint32_t erasesize;
	uint32_t writesize;
	uint32_t writebufsize;
	uint32_t oobsize;
	uint32_t oobavail;
	unsigned int erasesize_shift;
	unsigned int writesize_shift;
	unsigned int erasesize_mask;
	unsigned int writesize_mask;
	unsigned int bitflip_threshold;
	const char *name;
	int index;
	const struct mtd_ooblayout_ops *ooblayout;
	const struct mtd_pairing_scheme *pairing;
	unsigned int ecc_step_size;
	unsigned int ecc_strength;
	int numeraseregions;
	struct mtd_erase_region_info *eraseregions;
	int (*_erase)(struct mtd_info *, struct erase_info *);
	int (*_point)(struct mtd_info *, loff_t, size_t, size_t *, void **, resource_size_t *);
	int (*_unpoint)(struct mtd_info *, loff_t, size_t);
	int (*_read)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_panic_write)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_read_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_write_oob)(struct mtd_info *, loff_t, struct mtd_oob_ops *);
	int (*_get_fact_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_fact_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_get_user_prot_info)(struct mtd_info *, size_t, size_t *, struct otp_info *);
	int (*_read_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, u_char *);
	int (*_write_user_prot_reg)(struct mtd_info *, loff_t, size_t, size_t *, const u_char *);
	int (*_lock_user_prot_reg)(struct mtd_info *, loff_t, size_t);
	int (*_erase_user_prot_reg)(struct mtd_info *, loff_t, size_t);
	int (*_writev)(struct mtd_info *, const struct kvec *, long unsigned int, loff_t, size_t *);
	void (*_sync)(struct mtd_info *);
	int (*_lock)(struct mtd_info *, loff_t, uint64_t);
	int (*_unlock)(struct mtd_info *, loff_t, uint64_t);
	int (*_is_locked)(struct mtd_info *, loff_t, uint64_t);
	int (*_block_isreserved)(struct mtd_info *, loff_t);
	int (*_block_isbad)(struct mtd_info *, loff_t);
	int (*_block_markbad)(struct mtd_info *, loff_t);
	int (*_max_bad_blocks)(struct mtd_info *, loff_t, size_t);
	int (*_suspend)(struct mtd_info *);
	void (*_resume)(struct mtd_info *);
	void (*_reboot)(struct mtd_info *);
	int (*_get_device)(struct mtd_info *);
	void (*_put_device)(struct mtd_info *);
	bool oops_panic_write;
	struct notifier_block reboot_notifier;
	struct mtd_ecc_stats ecc_stats;
	int subpage_sft;
	void *priv;
	struct module *owner;
	struct device dev;
	int usecount;
	struct mtd_debug_info dbg;
	struct nvmem_device *nvmem;
	struct nvmem_device *otp_user_nvmem;
	struct nvmem_device *otp_factory_nvmem;
	struct mtd_info *parent;
	struct list_head partitions;
	struct mtd_part part;
	struct mtd_master master;
	int: 32;
};

struct otp_info {
	__u32 start;
	__u32 length;
	__u32 locked;
};

struct erase_info {
	uint64_t addr;
	uint64_t len;
	uint64_t fail_addr;
};

struct mtd_erase_region_info {
	uint64_t offset;
	uint32_t erasesize;
	uint32_t numblocks;
	long unsigned int *lockmap;
	int: 32;
};

struct mtd_req_stats {
	unsigned int uncorrectable_errors;
	unsigned int corrected_bitflips;
	unsigned int max_bitflips;
};

struct mtd_oob_ops {
	unsigned int mode;
	size_t len;
	size_t retlen;
	size_t ooblen;
	size_t oobretlen;
	uint32_t ooboffs;
	uint8_t *datbuf;
	uint8_t *oobbuf;
	struct mtd_req_stats *stats;
};

struct mtd_oob_region {
	u32 offset;
	u32 length;
};

struct mtd_ooblayout_ops {
	int (*ecc)(struct mtd_info *, int, struct mtd_oob_region *);
	int (*free)(struct mtd_info *, int, struct mtd_oob_region *);
};

struct mtd_pairing_info {
	int pair;
	int group;
};

struct mtd_pairing_scheme {
	int ngroups;
	int (*get_info)(struct mtd_info *, int, struct mtd_pairing_info *);
	int (*get_wunit)(struct mtd_info *, const struct mtd_pairing_info *);
};

struct jffs2_node_frag {
	struct rb_node rb;
	struct jffs2_full_dnode *node;
	uint32_t size;
	uint32_t ofs;
};

struct jffs2_tmp_dnode_info {
	struct rb_node rb;
	struct jffs2_full_dnode *fn;
	uint32_t version;
	uint32_t data_crc;
	uint32_t partial_crc;
	uint32_t csize;
	uint16_t overlapped;
};

struct jffs2_unknown_node {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
};

struct jffs2_raw_xattr {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t xid;
	jint32_t version;
	__u8 xprefix;
	__u8 name_len;
	jint16_t value_len;
	jint32_t data_crc;
	jint32_t node_crc;
	__u8 data[0];
};

struct jffs2_raw_xref {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t ino;
	jint32_t xid;
	jint32_t xseqno;
	jint32_t node_crc;
};

struct jffs2_raw_summary {
	jint16_t magic;
	jint16_t nodetype;
	jint32_t totlen;
	jint32_t hdr_crc;
	jint32_t sum_num;
	jint32_t cln_mkr;
	jint32_t padded;
	jint32_t sum_crc;
	jint32_t node_crc;
	jint32_t sum[0];
};

union jffs2_node_union {
	struct jffs2_raw_inode i;
	struct jffs2_raw_dirent d;
	struct jffs2_raw_xattr x;
	struct jffs2_raw_xref r;
	struct jffs2_raw_summary s;
	struct jffs2_unknown_node u;
};

struct jffs2_readinode_info {
	struct rb_root tn_root;
	struct jffs2_tmp_dnode_info *mdata_tn;
	uint32_t highest_version;
	uint32_t latest_mctime;
	uint32_t mctime_ver;
	struct jffs2_full_dirent *fds;
	struct jffs2_raw_node_ref *latest_ref;
};

struct jffs2_sum_marker {
	jint32_t offset;
	jint32_t magic;
};

enum {
	Opt_override_compr = 0,
	Opt_rp_size = 1,
};

enum {
	MTD_OPS_PLACE_OOB = 0,
	MTD_OPS_AUTO_OOB = 1,
	MTD_OPS_RAW = 2,
};

struct jffs2_inodirty {
	uint32_t ino;
	struct jffs2_inodirty *next;
};

struct jffs2_xattr_datum {
	void *always_null;
	struct jffs2_raw_node_ref *node;
	uint8_t class;
	uint8_t flags;
	uint16_t xprefix;
	struct list_head xindex;
	atomic_t refcnt;
	uint32_t xid;
	uint32_t version;
	uint32_t data_crc;
	uint32_t hashkey;
	char *xname;
	uint32_t name_len;
	char *xvalue;
	uint32_t value_len;
};

typedef unsigned char Byte;

typedef long unsigned int uLong;

struct internal_state;

struct z_stream_s {
	const Byte *next_in;
	uLong avail_in;
	uLong total_in;
	Byte *next_out;
	uLong avail_out;
	uLong total_out;
	char *msg;
	struct internal_state *state;
	void *workspace;
	int data_type;
	uLong adler;
	uLong reserved;
};

struct internal_state {
	int dummy;
};

typedef struct z_stream_s z_stream;

struct ubi_volume_info {
	int ubi_num;
	int vol_id;
	int size;
	int: 32;
	long long int used_bytes;
	int used_ebs;
	int vol_type;
	int corrupted;
	int upd_marker;
	int alignment;
	int usable_leb_size;
	int name_len;
	const char *name;
	dev_t cdev;
	int: 32;
};

struct ubi_device_info {
	int ubi_num;
	int leb_size;
	int leb_start;
	int min_io_size;
	int max_write_size;
	int ro_mode;
	dev_t cdev;
};

struct crypto_template;

struct crypto_spawn;

struct crypto_instance {
	struct crypto_alg alg;
	struct crypto_template *tmpl;
	union {
		struct hlist_node list;
		struct crypto_spawn *spawns;
	};
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_spawn {
	struct list_head list;
	struct crypto_alg *alg;
	union {
		struct crypto_instance *inst;
		struct crypto_spawn *next;
	};
	const struct crypto_type *frontend;
	u32 mask;
	bool dead;
	bool registered;
};

struct rtattr;

struct crypto_template {
	struct list_head list;
	struct hlist_head instances;
	struct module *module;
	int (*create)(struct crypto_template *, struct rtattr **);
	char name[128];
};

enum {
	UBIFS_COMPR_NONE = 0,
	UBIFS_COMPR_LZO = 1,
	UBIFS_COMPR_ZLIB = 2,
	UBIFS_COMPR_ZSTD = 3,
	UBIFS_COMPR_TYPES_CNT = 4,
};

enum {
	UBIFS_INO_NODE = 0,
	UBIFS_DATA_NODE = 1,
	UBIFS_DENT_NODE = 2,
	UBIFS_XENT_NODE = 3,
	UBIFS_TRUN_NODE = 4,
	UBIFS_PAD_NODE = 5,
	UBIFS_SB_NODE = 6,
	UBIFS_MST_NODE = 7,
	UBIFS_REF_NODE = 8,
	UBIFS_IDX_NODE = 9,
	UBIFS_CS_NODE = 10,
	UBIFS_ORPH_NODE = 11,
	UBIFS_AUTH_NODE = 12,
	UBIFS_SIG_NODE = 13,
	UBIFS_NODE_TYPES_CNT = 14,
};

struct ubifs_ch {
	__le32 magic;
	__le32 crc;
	__le64 sqnum;
	__le32 len;
	__u8 node_type;
	__u8 group_type;
	__u8 padding[2];
};

struct ubifs_sb_node {
	struct ubifs_ch ch;
	__u8 padding[2];
	__u8 key_hash;
	__u8 key_fmt;
	__le32 flags;
	__le32 min_io_size;
	__le32 leb_size;
	__le32 leb_cnt;
	__le32 max_leb_cnt;
	__le64 max_bud_bytes;
	__le32 log_lebs;
	__le32 lpt_lebs;
	__le32 orph_lebs;
	__le32 jhead_cnt;
	__le32 fanout;
	__le32 lsave_cnt;
	__le32 fmt_version;
	__le16 default_compr;
	__u8 padding1[2];
	__le32 rp_uid;
	__le32 rp_gid;
	__le64 rp_size;
	__le32 time_gran;
	__u8 uuid[16];
	__le32 ro_compat_version;
	__u8 hmac[64];
	__u8 hmac_wkm[64];
	__le16 hash_algo;
	__u8 hash_mst[64];
	__u8 padding2[3774];
};

struct ubifs_mst_node {
	struct ubifs_ch ch;
	__le64 highest_inum;
	__le64 cmt_no;
	__le32 flags;
	__le32 log_lnum;
	__le32 root_lnum;
	__le32 root_offs;
	__le32 root_len;
	__le32 gc_lnum;
	__le32 ihead_lnum;
	__le32 ihead_offs;
	__le64 index_size;
	__le64 total_free;
	__le64 total_dirty;
	__le64 total_used;
	__le64 total_dead;
	__le64 total_dark;
	__le32 lpt_lnum;
	__le32 lpt_offs;
	__le32 nhead_lnum;
	__le32 nhead_offs;
	__le32 ltab_lnum;
	__le32 ltab_offs;
	__le32 lsave_lnum;
	__le32 lsave_offs;
	__le32 lscan_lnum;
	__le32 empty_lebs;
	__le32 idx_lebs;
	__le32 leb_cnt;
	__u8 hash_root_idx[64];
	__u8 hash_lpt[64];
	__u8 hmac[64];
	__u8 padding[152];
};

enum {
	DIRTY_ZNODE = 0,
	COW_ZNODE = 1,
	OBSOLETE_ZNODE = 2,
};

enum {
	COMMIT_RESTING = 0,
	COMMIT_BACKGROUND = 1,
	COMMIT_REQUIRED = 2,
	COMMIT_RUNNING_BACKGROUND = 3,
	COMMIT_RUNNING_REQUIRED = 4,
	COMMIT_BROKEN = 5,
};

union ubifs_key {
	uint8_t u8[8];
	uint32_t u32[2];
	uint64_t u64[1];
	__le32 j32[2];
};

enum {
	LPROPS_UNCAT = 0,
	LPROPS_DIRTY = 1,
	LPROPS_DIRTY_IDX = 2,
	LPROPS_FREE = 3,
	LPROPS_HEAP_CNT = 3,
	LPROPS_EMPTY = 4,
	LPROPS_FREEABLE = 5,
	LPROPS_FRDI_IDX = 6,
	LPROPS_CAT_MASK = 15,
	LPROPS_TAKEN = 16,
	LPROPS_INDEX = 32,
};

struct ubifs_lprops {
	int free;
	int dirty;
	int flags;
	int lnum;
	union {
		struct list_head list;
		int hpos;
	};
};

struct ubifs_lpt_lprops {
	int free;
	int dirty;
	unsigned int tgc: 1;
	unsigned int cmt: 1;
};

struct ubifs_lp_stats {
	int empty_lebs;
	int taken_empty_lebs;
	int idx_lebs;
	int: 32;
	long long int total_free;
	long long int total_dirty;
	long long int total_used;
	long long int total_dead;
	long long int total_dark;
};

struct ubifs_nnode;

struct ubifs_cnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
};

struct ubifs_pnode;

struct ubifs_nbranch {
	int lnum;
	int offs;
	union {
		struct ubifs_nnode *nnode;
		struct ubifs_pnode *pnode;
		struct ubifs_cnode *cnode;
	};
};

struct ubifs_nnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
	struct ubifs_nbranch nbranch[4];
};

struct ubifs_pnode {
	struct ubifs_nnode *parent;
	struct ubifs_cnode *cnext;
	long unsigned int flags;
	int iip;
	int level;
	int num;
	struct ubifs_lprops lprops[4];
};

struct ubifs_lpt_heap {
	struct ubifs_lprops **arr;
	int cnt;
	int max_cnt;
};

struct ubifs_znode;

struct ubifs_zbranch {
	union ubifs_key key;
	union {
		struct ubifs_znode *znode;
		void *leaf;
	};
	int lnum;
	int offs;
	int len;
	u8 hash[0];
};

struct bu_info {
	union ubifs_key key;
	struct ubifs_zbranch zbranch[32];
	void *buf;
	int buf_len;
	int gc_seq;
	int cnt;
	int blk_cnt;
	int eof;
};

struct ubifs_budg_info {
	long long int idx_growth;
	long long int data_growth;
	long long int dd_growth;
	long long int uncommitted_idx;
	long long unsigned int old_idx_sz;
	int min_idx_lebs;
	unsigned int nospace: 1;
	unsigned int nospace_rp: 1;
	int page_budget;
	int inode_budget;
	int dent_budget;
	int: 32;
};

struct ubifs_node_range {
	union {
		int len;
		int min_len;
	};
	int max_len;
};

struct ubi_volume_desc;

struct ubifs_mount_opts {
	unsigned int unmount_mode: 2;
	unsigned int bulk_read: 2;
	unsigned int chk_data_crc: 2;
	unsigned int override_compr: 1;
	unsigned int compr_type: 2;
};

struct ubifs_jhead;

struct ubifs_orphan;

struct ubifs_debug_info;

struct ubifs_stats_info;

struct ubifs_info {
	struct super_block *vfs_sb;
	struct ubifs_sb_node *sup_node;
	ino_t highest_inum;
	int: 32;
	long long unsigned int max_sqnum;
	long long unsigned int cmt_no;
	spinlock_t cnt_lock;
	int fmt_version;
	int ro_compat_version;
	unsigned char uuid[16];
	int lhead_lnum;
	int lhead_offs;
	int ltail_lnum;
	struct mutex log_mutex;
	int min_log_bytes;
	long long int cmt_bud_bytes;
	struct rb_root buds;
	int: 32;
	long long int bud_bytes;
	spinlock_t buds_lock;
	int jhead_cnt;
	struct ubifs_jhead *jheads;
	int: 32;
	long long int max_bud_bytes;
	long long int bg_bud_bytes;
	struct list_head old_buds;
	int max_bud_cnt;
	struct rw_semaphore commit_sem;
	int cmt_state;
	spinlock_t cs_lock;
	wait_queue_head_t cmt_wq;
	struct kobject kobj;
	struct completion kobj_unregister;
	unsigned int big_lpt: 1;
	unsigned int space_fixup: 1;
	unsigned int double_hash: 1;
	unsigned int encrypted: 1;
	unsigned int no_chk_data_crc: 1;
	unsigned int bulk_read: 1;
	unsigned int default_compr: 2;
	unsigned int rw_incompat: 1;
	unsigned int assert_action: 2;
	unsigned int authenticated: 1;
	unsigned int superblock_need_write: 1;
	struct mutex tnc_mutex;
	int: 32;
	struct ubifs_zbranch zroot;
	struct ubifs_znode *cnext;
	struct ubifs_znode *enext;
	int *gap_lebs;
	void *cbuf;
	void *ileb_buf;
	int ileb_len;
	int ihead_lnum;
	int ihead_offs;
	int *ilebs;
	int ileb_cnt;
	int ileb_nxt;
	struct rb_root old_idx;
	int *bottom_up_buf;
	struct ubifs_mst_node *mst_node;
	int mst_offs;
	int max_bu_buf_len;
	struct mutex bu_mutex;
	int: 32;
	struct bu_info bu;
	struct mutex write_reserve_mutex;
	void *write_reserve_buf;
	int log_lebs;
	int: 32;
	long long int log_bytes;
	int log_last;
	int lpt_lebs;
	int lpt_first;
	int lpt_last;
	int orph_lebs;
	int orph_first;
	int orph_last;
	int main_lebs;
	int main_first;
	int: 32;
	long long int main_bytes;
	uint8_t key_hash_type;
	uint32_t (*key_hash)(const char *, int);
	int key_fmt;
	int key_len;
	int hash_len;
	int fanout;
	int min_io_size;
	int min_io_shift;
	int max_write_size;
	int max_write_shift;
	int leb_size;
	int leb_start;
	int half_leb_size;
	int idx_leb_size;
	int leb_cnt;
	int max_leb_cnt;
	unsigned int ro_media: 1;
	unsigned int ro_mount: 1;
	unsigned int ro_error: 1;
	atomic_long_t dirty_pg_cnt;
	atomic_long_t dirty_zn_cnt;
	atomic_long_t clean_zn_cnt;
	spinlock_t space_lock;
	int: 32;
	struct ubifs_lp_stats lst;
	struct ubifs_budg_info bi;
	long long unsigned int calc_idx_sz;
	int ref_node_alsz;
	int mst_node_alsz;
	int min_idx_node_sz;
	int max_idx_node_sz;
	long long int max_inode_sz;
	int max_znode_sz;
	int leb_overhead;
	int dead_wm;
	int dark_wm;
	int block_cnt;
	struct ubifs_node_range ranges[14];
	struct ubi_volume_desc *ubi;
	struct ubi_device_info di;
	int: 32;
	struct ubi_volume_info vi;
	struct rb_root orph_tree;
	struct list_head orph_list;
	struct list_head orph_new;
	struct ubifs_orphan *orph_cnext;
	struct ubifs_orphan *orph_dnext;
	spinlock_t orphan_lock;
	void *orph_buf;
	int new_orphans;
	int cmt_orphans;
	int tot_orphans;
	int max_orphans;
	int ohead_lnum;
	int ohead_offs;
	int no_orphs;
	struct task_struct *bgt;
	char bgt_name[24];
	int need_bgt;
	int need_wbuf_sync;
	int gc_lnum;
	void *sbuf;
	struct list_head idx_gc;
	int idx_gc_cnt;
	int gc_seq;
	int gced_lnum;
	struct list_head infos_list;
	struct mutex umount_mutex;
	unsigned int shrinker_run_no;
	int space_bits;
	int lpt_lnum_bits;
	int lpt_offs_bits;
	int lpt_spc_bits;
	int pcnt_bits;
	int lnum_bits;
	int nnode_sz;
	int pnode_sz;
	int ltab_sz;
	int lsave_sz;
	int pnode_cnt;
	int nnode_cnt;
	int lpt_hght;
	int pnodes_have;
	struct mutex lp_mutex;
	int lpt_lnum;
	int lpt_offs;
	int nhead_lnum;
	int nhead_offs;
	int lpt_drty_flgs;
	int dirty_nn_cnt;
	int dirty_pn_cnt;
	int check_lpt_free;
	int: 32;
	long long int lpt_sz;
	void *lpt_nod_buf;
	void *lpt_buf;
	struct ubifs_nnode *nroot;
	struct ubifs_cnode *lpt_cnext;
	struct ubifs_lpt_heap lpt_heap[3];
	struct ubifs_lpt_heap dirty_idx;
	struct list_head uncat_list;
	struct list_head empty_list;
	struct list_head freeable_list;
	struct list_head frdi_idx_list;
	int freeable_cnt;
	int in_a_category_cnt;
	int ltab_lnum;
	int ltab_offs;
	struct ubifs_lpt_lprops *ltab;
	struct ubifs_lpt_lprops *ltab_cmt;
	int lsave_cnt;
	int lsave_lnum;
	int lsave_offs;
	int *lsave;
	int lscan_lnum;
	int: 32;
	long long int rp_size;
	long long int report_rp_size;
	kuid_t rp_uid;
	kgid_t rp_gid;
	struct crypto_shash *hash_tfm;
	struct crypto_shash *hmac_tfm;
	int hmac_desc_len;
	char *auth_key_name;
	char *auth_hash_name;
	enum hash_algo auth_hash_algo;
	struct shash_desc *log_hash;
	unsigned int empty: 1;
	unsigned int need_recovery: 1;
	unsigned int replaying: 1;
	unsigned int mounting: 1;
	unsigned int remounting_rw: 1;
	unsigned int probing: 1;
	struct list_head replay_list;
	struct list_head replay_buds;
	long long unsigned int cs_sqnum;
	struct list_head unclean_leb_list;
	struct ubifs_mst_node *rcvrd_mst_node;
	struct rb_root size_tree;
	struct ubifs_mount_opts mount_opts;
	struct ubifs_debug_info *dbg;
	struct ubifs_stats_info *stats;
	int: 32;
};

struct ubifs_wbuf {
	struct ubifs_info *c;
	void *buf;
	int lnum;
	int offs;
	int avail;
	int used;
	int size;
	int jhead;
	int (*sync_callback)(struct ubifs_info *, int, int, int);
	struct mutex io_mutex;
	spinlock_t lock;
	int: 32;
	struct hrtimer timer;
	unsigned int no_timer: 1;
	unsigned int need_sync: 1;
	int next_ino;
	ino_t *inodes;
	int: 32;
};

struct ubifs_jhead {
	struct ubifs_wbuf wbuf;
	struct list_head buds_list;
	unsigned int grouped: 1;
	struct shash_desc *log_hash;
};

struct ubifs_znode {
	struct ubifs_znode *parent;
	struct ubifs_znode *cnext;
	struct ubifs_znode *cparent;
	int ciip;
	long unsigned int flags;
	int: 32;
	time64_t time;
	int level;
	int child_cnt;
	int iip;
	int alt;
	int lnum;
	int offs;
	int len;
	int: 32;
	struct ubifs_zbranch zbranch[0];
};

struct ubifs_orphan {
	struct rb_node rb;
	struct list_head list;
	struct list_head new_list;
	struct list_head child_list;
	struct ubifs_orphan *cnext;
	struct ubifs_orphan *dnext;
	ino_t inum;
	unsigned int new: 1;
	unsigned int cmt: 1;
	unsigned int del: 1;
};

struct ubifs_stats_info {
	unsigned int magic_errors;
	unsigned int node_errors;
	unsigned int crc_errors;
};

struct ubifs_debug_info {
	struct ubifs_zbranch old_zroot;
	int old_zroot_level;
	int: 32;
	long long unsigned int old_zroot_sqnum;
	int pc_happened;
	int pc_delay;
	long unsigned int pc_timeout;
	unsigned int pc_cnt;
	unsigned int pc_cnt_max;
	int: 32;
	long long int chk_lpt_sz;
	long long int chk_lpt_sz2;
	long long int chk_lpt_wastage;
	int chk_lpt_lebs;
	int new_nhead_offs;
	int new_ihead_lnum;
	int new_ihead_offs;
	struct ubifs_lp_stats saved_lst;
	struct ubifs_budg_info saved_bi;
	long long int saved_free;
	int saved_idx_gc_cnt;
	unsigned int chk_gen: 1;
	unsigned int chk_index: 1;
	unsigned int chk_orph: 1;
	unsigned int chk_lprops: 1;
	unsigned int chk_fs: 1;
	unsigned int tst_rcvry: 1;
	char dfs_dir_name[10];
	struct dentry *dfs_dir;
	struct dentry *dfs_dump_lprops;
	struct dentry *dfs_dump_budg;
	struct dentry *dfs_dump_tnc;
	struct dentry *dfs_chk_gen;
	struct dentry *dfs_chk_index;
	struct dentry *dfs_chk_orph;
	struct dentry *dfs_chk_lprops;
	struct dentry *dfs_chk_fs;
	struct dentry *dfs_tst_rcvry;
	struct dentry *dfs_ro_error;
	int: 32;
};

enum {
	UBIFS_ITYPE_REG = 0,
	UBIFS_ITYPE_DIR = 1,
	UBIFS_ITYPE_LNK = 2,
	UBIFS_ITYPE_BLK = 3,
	UBIFS_ITYPE_CHR = 4,
	UBIFS_ITYPE_FIFO = 5,
	UBIFS_ITYPE_SOCK = 6,
	UBIFS_ITYPES_CNT = 7,
};

enum {
	UBIFS_INO_KEY = 0,
	UBIFS_DATA_KEY = 1,
	UBIFS_DENT_KEY = 2,
	UBIFS_XENT_KEY = 3,
	UBIFS_KEY_TYPES_CNT = 4,
};

enum {
	UBIFS_COMPR_FL = 1,
	UBIFS_SYNC_FL = 2,
	UBIFS_IMMUTABLE_FL = 4,
	UBIFS_APPEND_FL = 8,
	UBIFS_DIRSYNC_FL = 16,
	UBIFS_XATTR_FL = 32,
	UBIFS_CRYPT_FL = 64,
};

struct ubifs_ino_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le64 creat_sqnum;
	__le64 size;
	__le64 atime_sec;
	__le64 ctime_sec;
	__le64 mtime_sec;
	__le32 atime_nsec;
	__le32 ctime_nsec;
	__le32 mtime_nsec;
	__le32 nlink;
	__le32 uid;
	__le32 gid;
	__le32 mode;
	__le32 flags;
	__le32 data_len;
	__le32 xattr_cnt;
	__le32 xattr_size;
	__u8 padding1[4];
	__le32 xattr_names;
	__le16 compr_type;
	__u8 padding2[26];
	__u8 data[0];
};

struct ubifs_dent_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le64 inum;
	__u8 padding1;
	__u8 type;
	__le16 nlen;
	__le32 cookie;
	__u8 name[0];
};

struct ubifs_data_node {
	struct ubifs_ch ch;
	__u8 key[16];
	__le32 size;
	__le16 compr_type;
	__le16 compr_size;
	__u8 data[0];
};

struct ubifs_trun_node {
	struct ubifs_ch ch;
	__le32 inum;
	__u8 padding[12];
	__le64 old_size;
	__le64 new_size;
};

struct ubifs_inode {
	struct inode vfs_inode;
	long long unsigned int creat_sqnum;
	long long unsigned int del_cmtno;
	unsigned int xattr_size;
	unsigned int xattr_cnt;
	unsigned int xattr_names;
	unsigned int dirty: 1;
	unsigned int xattr: 1;
	unsigned int bulk_read: 1;
	unsigned int compr_type: 2;
	struct mutex ui_mutex;
	struct rw_semaphore xattr_sem;
	spinlock_t ui_lock;
	loff_t synced_i_size;
	loff_t ui_size;
	int flags;
	long unsigned int last_page_read;
	long unsigned int read_in_a_row;
	int data_len;
	void *data;
	int: 32;
};

struct ubifs_budget_req {
	unsigned int fast: 1;
	unsigned int recalculate: 1;
	unsigned int new_page: 1;
	unsigned int dirtied_page: 1;
	unsigned int new_dent: 1;
	unsigned int mod_dent: 1;
	unsigned int new_ino: 1;
	unsigned int new_ino_d: 13;
	unsigned int dirtied_ino: 4;
	char: 8;
	unsigned int dirtied_ino_d: 15;
	int idx_growth;
	int data_growth;
	int dd_growth;
};

union ubifs_dev_desc {
	__le32 new;
	__le64 huge;
};

struct ubifs_global_debug_info {
	unsigned int chk_gen: 1;
	unsigned int chk_index: 1;
	unsigned int chk_orph: 1;
	unsigned int chk_lprops: 1;
	unsigned int chk_fs: 1;
	unsigned int tst_rcvry: 1;
};

enum {
	UBI_DYNAMIC_VOLUME = 3,
	UBI_STATIC_VOLUME = 4,
};

enum {
	UBI_READONLY = 1,
	UBI_READWRITE = 2,
	UBI_EXCLUSIVE = 3,
	UBI_METAONLY = 4,
};

struct crypto_comp {
	struct crypto_tfm base;
};

enum {
	UBIFS_SIMPLE_KEY_FMT = 0,
};

enum {
	UBIFS_MST_DIRTY = 1,
	UBIFS_MST_NO_ORPHS = 2,
	UBIFS_MST_RCVRY = 4,
};

enum {
	ASSACT_REPORT = 0,
	ASSACT_RO = 1,
	ASSACT_PANIC = 2,
};

struct ubifs_unclean_leb {
	struct list_head list;
	int lnum;
	int endpt;
};

struct ubifs_bud {
	int lnum;
	int start;
	int jhead;
	struct list_head list;
	struct rb_node rb;
	struct shash_desc *log_hash;
};

struct ubifs_compressor {
	int compr_type;
	struct crypto_comp *cc;
	struct mutex *comp_mutex;
	struct mutex *decomp_mutex;
	const char *name;
	const char *capi_name;
};

struct fscrypt_operations;

enum {
	Opt_fast_unmount = 0,
	Opt_norm_unmount = 1,
	Opt_bulk_read = 2,
	Opt_no_bulk_read = 3,
	Opt_chk_data_crc = 4,
	Opt_no_chk_data_crc = 5,
	Opt_override_compr___2 = 6,
	Opt_assert = 7,
	Opt_auth_key = 8,
	Opt_auth_hash_name = 9,
	Opt_ignore___2 = 10,
	Opt_err___5 = 11,
};

enum {
	UBIFS_KEY_HASH_R5 = 0,
	UBIFS_KEY_HASH_TEST = 1,
};

enum {
	UBIFS_FLG_BIGLPT = 2,
	UBIFS_FLG_SPACE_FIXUP = 4,
	UBIFS_FLG_DOUBLE_HASH = 8,
	UBIFS_FLG_ENCRYPTION = 16,
	UBIFS_FLG_AUTHENTICATION = 32,
};

struct ubifs_branch {
	__le32 lnum;
	__le32 offs;
	__le32 len;
	__u8 key[0];
};

struct ubifs_idx_node {
	struct ubifs_ch ch;
	__le16 child_cnt;
	__le16 level;
	__u8 branches[0];
};

struct ubifs_cs_node {
	struct ubifs_ch ch;
	__le64 cmt_no;
};

enum {
	UBIFS_NO_NODE_GROUP = 0,
	UBIFS_IN_NODE_GROUP = 1,
	UBIFS_LAST_OF_NODE_GROUP = 2,
};

struct ubifs_pad_node {
	struct ubifs_ch ch;
	__le32 pad_len;
};

struct ubifs_old_idx {
	struct rb_node rb;
	int lnum;
	int offs;
};

enum {
	NAME_LESS = 0,
	NAME_MATCHES = 1,
	NAME_GREATER = 2,
	NOT_ON_MEDIA = 3,
};

struct ubifs_scan_node {
	struct list_head list;
	union ubifs_key key;
	long long unsigned int sqnum;
	int type;
	int offs;
	int len;
	void *node;
};

struct ubifs_scan_leb {
	int lnum;
	int nodes_cnt;
	struct list_head nodes;
	int endpt;
	void *buf;
};

enum {
	SCANNED_GARBAGE = 0,
	SCANNED_EMPTY_SPACE = 4294967295,
	SCANNED_A_NODE = 4294967294,
	SCANNED_A_CORRUPT_NODE = 4294967293,
	SCANNED_A_BAD_PAD_NODE = 4294967292,
};

struct shash_alg {
	int (*init)(struct shash_desc *);
	int (*update)(struct shash_desc *, const u8 *, unsigned int);
	int (*final)(struct shash_desc *, u8 *);
	int (*finup)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*digest)(struct shash_desc *, const u8 *, unsigned int, u8 *);
	int (*export)(struct shash_desc *, void *);
	int (*import)(struct shash_desc *, const void *);
	int (*setkey)(struct crypto_shash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_shash *);
	void (*exit_tfm)(struct crypto_shash *);
	unsigned int descsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	unsigned int digestsize;
	unsigned int statesize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct ubifs_ref_node {
	struct ubifs_ch ch;
	__le32 lnum;
	__le32 offs;
	__le32 jhead;
	__u8 padding[28];
};

struct ubifs_auth_node {
	struct ubifs_ch ch;
	__u8 hmac[0];
};

struct replay_entry {
	int lnum;
	int offs;
	int len;
	u8 hash[0];
	unsigned int deletion: 1;
	long long unsigned int sqnum;
	struct list_head list;
	union ubifs_key key;
	union {
		struct fscrypt_name nm;
		struct {
			loff_t old_size;
			loff_t new_size;
		};
	};
};

struct bud_entry {
	struct list_head list;
	struct ubifs_bud *bud;
	int: 32;
	long long unsigned int sqnum;
	int free;
	int dirty;
};

struct done_ref {
	struct rb_node rb;
	int lnum;
};

enum {
	DIRTY_CNODE = 0,
	OBSOLETE_CNODE = 1,
	COW_CNODE = 2,
};

struct idx_node {
	struct list_head list;
	int iip;
	int: 32;
	union ubifs_key upper_key;
	struct ubifs_idx_node idx;
	int: 32;
};

enum {
	LEB_FREED = 0,
	LEB_FREED_IDX = 1,
	LEB_RETAINED = 2,
};

struct ubifs_gced_idx_leb {
	struct list_head list;
	int lnum;
	int unmap;
};

struct ubifs_orph_node {
	struct ubifs_ch ch;
	__le64 cmt_no;
	__le64 inos[0];
};

struct check_orphan {
	struct rb_node rb;
	ino_t inum;
};

struct check_info {
	long unsigned int last_ino;
	long unsigned int tot_inos;
	long unsigned int missing;
	int: 32;
	long long unsigned int leaf_cnt;
	struct ubifs_ino_node *node;
	struct rb_root root;
};

enum {
	LPT_SCAN_CONTINUE = 0,
	LPT_SCAN_ADD = 1,
	LPT_SCAN_STOP = 2,
};

typedef int (*ubifs_lpt_scan_callback)(struct ubifs_info *, const struct ubifs_lprops *, int, void *);

struct scan_data {
	int min_space;
	int pick_free;
	int lnum;
	int exclude_index;
};

enum {
	UBIFS_LPT_PNODE = 0,
	UBIFS_LPT_NNODE = 1,
	UBIFS_LPT_LTAB = 2,
	UBIFS_LPT_LSAVE = 3,
	UBIFS_LPT_NODE_CNT = 4,
	UBIFS_LPT_NOT_A_NODE = 15,
};

enum {
	LTAB_DIRTY = 1,
	LSAVE_DIRTY = 2,
};

struct lpt_scan_node {
	union {
		struct ubifs_nnode nnode;
		struct ubifs_pnode pnode;
		struct ubifs_cnode cnode;
	};
	int in_tree;
	union {
		struct ubifs_nnode *nnode;
		struct ubifs_pnode *pnode;
		struct ubifs_cnode *cnode;
	} ptr;
};

struct size_entry {
	struct rb_node rb;
	ino_t inum;
	loff_t i_size;
	loff_t d_size;
	int exists;
	struct inode *inode;
};

typedef int (*dbg_leaf_callback)(struct ubifs_info *, struct ubifs_zbranch *, void *);

typedef int (*dbg_znode_callback)(struct ubifs_info *, struct ubifs_znode *, void *);

struct fsck_inode {
	struct rb_node rb;
	ino_t inum;
	umode_t mode;
	unsigned int nlink;
	unsigned int xattr_cnt;
	int references;
	int calc_cnt;
	int: 32;
	long long int size;
	unsigned int xattr_sz;
	int: 32;
	long long int calc_sz;
	long long int calc_xcnt;
	long long int calc_xsz;
	unsigned int xattr_nms;
	int: 32;
	long long int calc_xnms;
};

struct fsck_data {
	struct rb_root inodes;
};

enum attr_id_t {
	attr_errors_magic = 0,
	attr_errors_node = 1,
	attr_errors_crc = 2,
};

struct ubifs_attr {
	struct attribute attr;
	enum attr_id_t attr_id;
};

typedef unsigned int autofs_wqt_t;

struct autofs_sb_info;

struct autofs_info {
	struct dentry *dentry;
	int flags;
	struct completion expire_complete;
	struct list_head active;
	struct list_head expiring;
	struct autofs_sb_info *sbi;
	long unsigned int last_used;
	int count;
	kuid_t uid;
	kgid_t gid;
	struct callback_head rcu;
};

struct autofs_wait_queue;

struct autofs_sb_info {
	u32 magic;
	int pipefd;
	struct file *pipe;
	struct pid *oz_pgrp;
	int version;
	int sub_version;
	int min_proto;
	int max_proto;
	unsigned int flags;
	long unsigned int exp_timeout;
	unsigned int type;
	struct super_block *sb;
	struct mutex wq_mutex;
	struct mutex pipe_mutex;
	spinlock_t fs_lock;
	struct autofs_wait_queue *queues;
	spinlock_t lookup_lock;
	struct list_head active_list;
	struct list_head expiring_list;
	struct callback_head rcu;
};

struct autofs_wait_queue {
	wait_queue_head_t queue;
	struct autofs_wait_queue *next;
	autofs_wqt_t wait_queue_token;
	int: 32;
	struct qstr name;
	u32 offset;
	u32 dev;
	u64 ino;
	kuid_t uid;
	kgid_t gid;
	pid_t pid;
	pid_t tgid;
	int status;
	unsigned int wait_ctr;
};

enum {
	Opt_err___6 = 0,
	Opt_fd = 1,
	Opt_uid___4 = 2,
	Opt_gid___5 = 3,
	Opt_pgrp = 4,
	Opt_minproto = 5,
	Opt_maxproto = 6,
	Opt_indirect = 7,
	Opt_direct = 8,
	Opt_offset = 9,
	Opt_strictexpire = 10,
	Opt_ignore___3 = 11,
};

enum {
	AUTOFS_IOC_READY_CMD = 96,
	AUTOFS_IOC_FAIL_CMD = 97,
	AUTOFS_IOC_CATATONIC_CMD = 98,
	AUTOFS_IOC_PROTOVER_CMD = 99,
	AUTOFS_IOC_SETTIMEOUT_CMD = 100,
	AUTOFS_IOC_EXPIRE_CMD = 101,
};

enum autofs_notify {
	NFY_NONE = 0,
	NFY_MOUNT = 1,
	NFY_EXPIRE = 2,
};

enum {
	AUTOFS_IOC_EXPIRE_MULTI_CMD = 102,
	AUTOFS_IOC_PROTOSUBVER_CMD = 103,
	AUTOFS_IOC_ASKUMOUNT_CMD = 112,
};

struct autofs_packet_hdr {
	int proto_version;
	int type;
};

struct autofs_packet_missing {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

struct autofs_packet_expire {
	struct autofs_packet_hdr hdr;
	int len;
	char name[256];
};

struct autofs_packet_expire_multi {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	int len;
	char name[256];
};

union autofs_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_packet_missing missing;
	struct autofs_packet_expire expire;
	struct autofs_packet_expire_multi expire_multi;
};

struct autofs_v5_packet {
	struct autofs_packet_hdr hdr;
	autofs_wqt_t wait_queue_token;
	__u32 dev;
	__u64 ino;
	__u32 uid;
	__u32 gid;
	__u32 pid;
	__u32 tgid;
	__u32 len;
	char name[256];
	int: 32;
};

typedef struct autofs_v5_packet autofs_packet_missing_indirect_t;

typedef struct autofs_v5_packet autofs_packet_expire_indirect_t;

typedef struct autofs_v5_packet autofs_packet_missing_direct_t;

typedef struct autofs_v5_packet autofs_packet_expire_direct_t;

union autofs_v5_packet_union {
	struct autofs_packet_hdr hdr;
	struct autofs_v5_packet v5_packet;
	autofs_packet_missing_indirect_t missing_indirect;
	autofs_packet_expire_indirect_t expire_indirect;
	autofs_packet_missing_direct_t missing_direct;
	autofs_packet_expire_direct_t expire_direct;
};

struct args_protover {
	__u32 version;
};

struct args_protosubver {
	__u32 sub_version;
};

struct args_openmount {
	__u32 devid;
};

struct args_ready {
	__u32 token;
};

struct args_fail {
	__u32 token;
	__s32 status;
};

struct args_setpipefd {
	__s32 pipefd;
};

struct args_timeout {
	__u64 timeout;
};

struct args_requester {
	__u32 uid;
	__u32 gid;
};

struct args_expire {
	__u32 how;
};

struct args_askumount {
	__u32 may_umount;
};

struct args_in {
	__u32 type;
};

struct args_out {
	__u32 devid;
	__u32 magic;
};

struct args_ismountpoint {
	union {
		struct args_in in;
		struct args_out out;
	};
};

struct autofs_dev_ioctl {
	__u32 ver_major;
	__u32 ver_minor;
	__u32 size;
	__s32 ioctlfd;
	union {
		struct args_protover protover;
		struct args_protosubver protosubver;
		struct args_openmount openmount;
		struct args_ready ready;
		struct args_fail fail;
		struct args_setpipefd setpipefd;
		struct args_timeout timeout;
		struct args_requester requester;
		struct args_expire expire;
		struct args_askumount askumount;
		struct args_ismountpoint ismountpoint;
	};
	char path[0];
};

enum {
	AUTOFS_DEV_IOCTL_VERSION_CMD = 113,
	AUTOFS_DEV_IOCTL_PROTOVER_CMD = 114,
	AUTOFS_DEV_IOCTL_PROTOSUBVER_CMD = 115,
	AUTOFS_DEV_IOCTL_OPENMOUNT_CMD = 116,
	AUTOFS_DEV_IOCTL_CLOSEMOUNT_CMD = 117,
	AUTOFS_DEV_IOCTL_READY_CMD = 118,
	AUTOFS_DEV_IOCTL_FAIL_CMD = 119,
	AUTOFS_DEV_IOCTL_SETPIPEFD_CMD = 120,
	AUTOFS_DEV_IOCTL_CATATONIC_CMD = 121,
	AUTOFS_DEV_IOCTL_TIMEOUT_CMD = 122,
	AUTOFS_DEV_IOCTL_REQUESTER_CMD = 123,
	AUTOFS_DEV_IOCTL_EXPIRE_CMD = 124,
	AUTOFS_DEV_IOCTL_ASKUMOUNT_CMD = 125,
	AUTOFS_DEV_IOCTL_ISMOUNTPOINT_CMD = 126,
};

typedef int (*ioctl_fn)(struct file *, struct autofs_sb_info *, struct autofs_dev_ioctl *);

enum fuse_opcode {
	FUSE_LOOKUP = 1,
	FUSE_FORGET = 2,
	FUSE_GETATTR = 3,
	FUSE_SETATTR = 4,
	FUSE_READLINK = 5,
	FUSE_SYMLINK = 6,
	FUSE_MKNOD = 8,
	FUSE_MKDIR = 9,
	FUSE_UNLINK = 10,
	FUSE_RMDIR = 11,
	FUSE_RENAME = 12,
	FUSE_LINK = 13,
	FUSE_OPEN = 14,
	FUSE_READ = 15,
	FUSE_WRITE = 16,
	FUSE_STATFS = 17,
	FUSE_RELEASE = 18,
	FUSE_FSYNC = 20,
	FUSE_SETXATTR = 21,
	FUSE_GETXATTR = 22,
	FUSE_LISTXATTR = 23,
	FUSE_REMOVEXATTR = 24,
	FUSE_FLUSH = 25,
	FUSE_INIT = 26,
	FUSE_OPENDIR = 27,
	FUSE_READDIR = 28,
	FUSE_RELEASEDIR = 29,
	FUSE_FSYNCDIR = 30,
	FUSE_GETLK = 31,
	FUSE_SETLK = 32,
	FUSE_SETLKW = 33,
	FUSE_ACCESS = 34,
	FUSE_CREATE = 35,
	FUSE_INTERRUPT = 36,
	FUSE_BMAP = 37,
	FUSE_DESTROY = 38,
	FUSE_IOCTL = 39,
	FUSE_POLL = 40,
	FUSE_NOTIFY_REPLY = 41,
	FUSE_BATCH_FORGET = 42,
	FUSE_FALLOCATE = 43,
	FUSE_READDIRPLUS = 44,
	FUSE_RENAME2 = 45,
	FUSE_LSEEK = 46,
	FUSE_COPY_FILE_RANGE = 47,
	FUSE_SETUPMAPPING = 48,
	FUSE_REMOVEMAPPING = 49,
	FUSE_SYNCFS = 50,
	FUSE_TMPFILE = 51,
	CUSE_INIT = 4096,
	CUSE_INIT_BSWAP_RESERVED = 1048576,
	FUSE_INIT_BSWAP_RESERVED = 436207616,
};

enum fuse_notify_code {
	FUSE_NOTIFY_POLL = 1,
	FUSE_NOTIFY_INVAL_INODE = 2,
	FUSE_NOTIFY_INVAL_ENTRY = 3,
	FUSE_NOTIFY_STORE = 4,
	FUSE_NOTIFY_RETRIEVE = 5,
	FUSE_NOTIFY_DELETE = 6,
	FUSE_NOTIFY_CODE_MAX = 7,
};

struct fuse_forget_in {
	uint64_t nlookup;
};

struct fuse_forget_one {
	uint64_t nodeid;
	uint64_t nlookup;
};

struct fuse_batch_forget_in {
	uint32_t count;
	uint32_t dummy;
};

struct fuse_interrupt_in {
	uint64_t unique;
};

struct fuse_notify_poll_wakeup_out {
	uint64_t kh;
};

struct fuse_in_header {
	uint32_t len;
	uint32_t opcode;
	uint64_t unique;
	uint64_t nodeid;
	uint32_t uid;
	uint32_t gid;
	uint32_t pid;
	uint32_t padding;
};

struct fuse_out_header {
	uint32_t len;
	int32_t error;
	uint64_t unique;
};

struct fuse_notify_inval_inode_out {
	uint64_t ino;
	int64_t off;
	int64_t len;
};

struct fuse_notify_inval_entry_out {
	uint64_t parent;
	uint32_t namelen;
	uint32_t padding;
};

struct fuse_notify_delete_out {
	uint64_t parent;
	uint64_t child;
	uint32_t namelen;
	uint32_t padding;
};

struct fuse_notify_store_out {
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_notify_retrieve_out {
	uint64_t notify_unique;
	uint64_t nodeid;
	uint64_t offset;
	uint32_t size;
	uint32_t padding;
};

struct fuse_notify_retrieve_in {
	uint64_t dummy1;
	uint64_t offset;
	uint32_t size;
	uint32_t dummy2;
	uint64_t dummy3;
	uint64_t dummy4;
};

struct fuse_forget_link {
	struct fuse_forget_one forget_one;
	struct fuse_forget_link *next;
	int: 32;
};

struct fuse_mount;

struct fuse_release_args;

struct fuse_file {
	struct fuse_mount *fm;
	struct fuse_release_args *release_args;
	u64 kh;
	u64 fh;
	u64 nodeid;
	refcount_t count;
	u32 open_flags;
	struct list_head write_entry;
	struct {
		struct mutex lock;
		int: 32;
		loff_t pos;
		loff_t cache_off;
		u64 version;
	} readdir;
	struct rb_node polled_node;
	wait_queue_head_t poll_wait;
	bool flock: 1;
	int: 31;
	int: 32;
};

struct fuse_conn;

struct fuse_mount {
	struct fuse_conn *fc;
	struct super_block *sb;
	struct list_head fc_entry;
};

struct fuse_in_arg {
	unsigned int size;
	const void *value;
};

struct fuse_arg {
	unsigned int size;
	void *value;
};

struct fuse_page_desc {
	unsigned int length;
	unsigned int offset;
};

struct fuse_args {
	uint64_t nodeid;
	uint32_t opcode;
	short unsigned int in_numargs;
	short unsigned int out_numargs;
	bool force: 1;
	bool noreply: 1;
	bool nocreds: 1;
	bool in_pages: 1;
	bool out_pages: 1;
	bool user_pages: 1;
	bool out_argvar: 1;
	bool page_zeroing: 1;
	bool page_replace: 1;
	bool may_block: 1;
	struct fuse_in_arg in_args[3];
	struct fuse_arg out_args[2];
	void (*end)(struct fuse_mount *, struct fuse_args *, int);
};

struct fuse_args_pages {
	struct fuse_args args;
	struct page **pages;
	struct fuse_page_desc *descs;
	unsigned int num_pages;
	int: 32;
};

enum fuse_req_flag {
	FR_ISREPLY = 0,
	FR_FORCE = 1,
	FR_BACKGROUND = 2,
	FR_WAITING = 3,
	FR_ABORTED = 4,
	FR_INTERRUPTED = 5,
	FR_LOCKED = 6,
	FR_PENDING = 7,
	FR_SENT = 8,
	FR_FINISHED = 9,
	FR_PRIVATE = 10,
	FR_ASYNC = 11,
};

struct fuse_req {
	struct list_head list;
	struct list_head intr_entry;
	struct fuse_args *args;
	refcount_t count;
	long unsigned int flags;
	int: 32;
	struct {
		struct fuse_in_header h;
	} in;
	struct {
		struct fuse_out_header h;
	} out;
	wait_queue_head_t waitq;
	struct fuse_mount *fm;
};

struct fuse_iqueue;

struct fuse_iqueue_ops {
	void (*wake_forget_and_unlock)(struct fuse_iqueue *);
	void (*wake_interrupt_and_unlock)(struct fuse_iqueue *);
	void (*wake_pending_and_unlock)(struct fuse_iqueue *);
	void (*release)(struct fuse_iqueue *);
};

struct fuse_iqueue {
	unsigned int connected;
	spinlock_t lock;
	wait_queue_head_t waitq;
	int: 32;
	u64 reqctr;
	struct list_head pending;
	struct list_head interrupts;
	struct fuse_forget_link forget_list_head;
	struct fuse_forget_link *forget_list_tail;
	int forget_batch;
	struct fasync_struct *fasync;
	const struct fuse_iqueue_ops *ops;
	void *priv;
	int: 32;
};

struct fuse_pqueue {
	unsigned int connected;
	spinlock_t lock;
	struct list_head *processing;
	struct list_head io;
};

struct fuse_dev {
	struct fuse_conn *fc;
	struct fuse_pqueue pq;
	struct list_head entry;
};

struct fuse_sync_bucket;

struct fuse_conn {
	spinlock_t lock;
	refcount_t count;
	atomic_t dev_count;
	struct callback_head rcu;
	kuid_t user_id;
	kgid_t group_id;
	struct pid_namespace *pid_ns;
	struct user_namespace *user_ns;
	unsigned int max_read;
	unsigned int max_write;
	unsigned int max_pages;
	unsigned int max_pages_limit;
	int: 32;
	struct fuse_iqueue iq;
	atomic64_t khctr;
	struct rb_root polled_files;
	unsigned int max_background;
	unsigned int congestion_threshold;
	unsigned int num_background;
	unsigned int active_background;
	struct list_head bg_queue;
	spinlock_t bg_lock;
	int initialized;
	int blocked;
	wait_queue_head_t blocked_waitq;
	unsigned int connected;
	bool aborted;
	unsigned int conn_error: 1;
	unsigned int conn_init: 1;
	unsigned int async_read: 1;
	unsigned int abort_err: 1;
	unsigned int atomic_o_trunc: 1;
	unsigned int export_support: 1;
	unsigned int writeback_cache: 1;
	unsigned int parallel_dirops: 1;
	unsigned int handle_killpriv: 1;
	unsigned int cache_symlinks: 1;
	unsigned int legacy_opts_show: 1;
	unsigned int handle_killpriv_v2: 1;
	unsigned int no_open: 1;
	unsigned int no_opendir: 1;
	unsigned int no_fsync: 1;
	unsigned int no_fsyncdir: 1;
	unsigned int no_flush: 1;
	unsigned int no_setxattr: 1;
	unsigned int setxattr_ext: 1;
	unsigned int no_getxattr: 1;
	unsigned int no_listxattr: 1;
	unsigned int no_removexattr: 1;
	unsigned int no_lock: 1;
	unsigned int no_access: 1;
	unsigned int no_create: 1;
	unsigned int no_interrupt: 1;
	unsigned int no_bmap: 1;
	unsigned int no_poll: 1;
	unsigned int big_writes: 1;
	unsigned int dont_mask: 1;
	unsigned int no_flock: 1;
	unsigned int no_fallocate: 1;
	unsigned int no_rename2: 1;
	unsigned int auto_inval_data: 1;
	unsigned int explicit_inval_data: 1;
	unsigned int do_readdirplus: 1;
	unsigned int readdirplus_auto: 1;
	unsigned int async_dio: 1;
	unsigned int no_lseek: 1;
	unsigned int posix_acl: 1;
	unsigned int default_permissions: 1;
	unsigned int allow_other: 1;
	unsigned int no_copy_file_range: 1;
	unsigned int destroy: 1;
	unsigned int delete_stale: 1;
	unsigned int no_control: 1;
	unsigned int no_force_umount: 1;
	unsigned int auto_submounts: 1;
	unsigned int sync_fs: 1;
	unsigned int init_security: 1;
	unsigned int inode_dax: 1;
	unsigned int no_tmpfile: 1;
	atomic_t num_waiting;
	unsigned int minor;
	struct list_head entry;
	dev_t dev;
	struct dentry *ctl_dentry[5];
	int ctl_ndents;
	u32 scramble_key[4];
	int: 32;
	atomic64_t attr_version;
	void (*release)(struct fuse_conn *);
	struct rw_semaphore killsb;
	struct list_head devices;
	struct list_head mounts;
	struct fuse_sync_bucket *curr_bucket;
};

struct fuse_sync_bucket {
	atomic_t count;
	wait_queue_head_t waitq;
	struct callback_head rcu;
};

struct fuse_copy_state {
	int write;
	struct fuse_req *req;
	struct iov_iter *iter;
	struct pipe_buffer *pipebufs;
	struct pipe_buffer *currbuf;
	struct pipe_inode_info *pipe;
	long unsigned int nr_segs;
	struct page *pg;
	unsigned int len;
	unsigned int offset;
	unsigned int move_pages: 1;
};

struct fuse_retrieve_args {
	struct fuse_args_pages ap;
	struct fuse_notify_retrieve_in inarg;
};

struct fuse_attr {
	uint64_t ino;
	uint64_t size;
	uint64_t blocks;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t nlink;
	uint32_t uid;
	uint32_t gid;
	uint32_t rdev;
	uint32_t blksize;
	uint32_t flags;
};

struct fuse_entry_out {
	uint64_t nodeid;
	uint64_t generation;
	uint64_t entry_valid;
	uint64_t attr_valid;
	uint32_t entry_valid_nsec;
	uint32_t attr_valid_nsec;
	struct fuse_attr attr;
};

struct fuse_getattr_in {
	uint32_t getattr_flags;
	uint32_t dummy;
	uint64_t fh;
};

struct fuse_attr_out {
	uint64_t attr_valid;
	uint32_t attr_valid_nsec;
	uint32_t dummy;
	struct fuse_attr attr;
};

struct fuse_mknod_in {
	uint32_t mode;
	uint32_t rdev;
	uint32_t umask;
	uint32_t padding;
};

struct fuse_mkdir_in {
	uint32_t mode;
	uint32_t umask;
};

struct fuse_rename2_in {
	uint64_t newdir;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_link_in {
	uint64_t oldnodeid;
};

struct fuse_setattr_in {
	uint32_t valid;
	uint32_t padding;
	uint64_t fh;
	uint64_t size;
	uint64_t lock_owner;
	uint64_t atime;
	uint64_t mtime;
	uint64_t ctime;
	uint32_t atimensec;
	uint32_t mtimensec;
	uint32_t ctimensec;
	uint32_t mode;
	uint32_t unused4;
	uint32_t uid;
	uint32_t gid;
	uint32_t unused5;
};

struct fuse_create_in {
	uint32_t flags;
	uint32_t mode;
	uint32_t umask;
	uint32_t open_flags;
};

struct fuse_open_out {
	uint64_t fh;
	uint32_t open_flags;
	uint32_t padding;
};

struct fuse_access_in {
	uint32_t mask;
	uint32_t padding;
};

struct fuse_secctx {
	uint32_t size;
	uint32_t padding;
};

struct fuse_secctx_header {
	uint32_t size;
	uint32_t nr_secctx;
};

struct fuse_inode {
	struct inode inode;
	u64 nodeid;
	u64 nlookup;
	struct fuse_forget_link *forget;
	int: 32;
	u64 i_time;
	u32 inval_mask;
	umode_t orig_i_mode;
	u64 orig_ino;
	u64 attr_version;
	union {
		struct {
			struct list_head write_files;
			struct list_head queued_writes;
			int writectr;
			wait_queue_head_t page_waitq;
			struct rb_root writepages;
		};
		struct {
			bool cached;
			int: 24;
			int: 32;
			loff_t size;
			loff_t pos;
			u64 version;
			struct timespec64 mtime;
			u64 iversion;
			spinlock_t lock;
			int: 32;
		} rdc;
	};
	long unsigned int state;
	struct mutex mutex;
	spinlock_t lock;
	int: 32;
};

enum {
	FUSE_I_ADVISE_RDPLUS = 0,
	FUSE_I_INIT_RDPLUS = 1,
	FUSE_I_SIZE_UNSTABLE = 2,
	FUSE_I_BAD = 3,
};

union fuse_dentry {
	u64 time;
	struct callback_head rcu;
};

struct fuse_file_lock {
	uint64_t start;
	uint64_t end;
	uint32_t type;
	uint32_t pid;
};

struct fuse_open_in {
	uint32_t flags;
	uint32_t open_flags;
};

struct fuse_release_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t release_flags;
	uint64_t lock_owner;
};

struct fuse_flush_in {
	uint64_t fh;
	uint32_t unused;
	uint32_t padding;
	uint64_t lock_owner;
};

struct fuse_read_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t read_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t size;
	uint32_t write_flags;
	uint64_t lock_owner;
	uint32_t flags;
	uint32_t padding;
};

struct fuse_write_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_fsync_in {
	uint64_t fh;
	uint32_t fsync_flags;
	uint32_t padding;
};

struct fuse_lk_in {
	uint64_t fh;
	uint64_t owner;
	struct fuse_file_lock lk;
	uint32_t lk_flags;
	uint32_t padding;
};

struct fuse_lk_out {
	struct fuse_file_lock lk;
};

struct fuse_bmap_in {
	uint64_t block;
	uint32_t blocksize;
	uint32_t padding;
};

struct fuse_bmap_out {
	uint64_t block;
};

struct fuse_poll_in {
	uint64_t fh;
	uint64_t kh;
	uint32_t flags;
	uint32_t events;
};

struct fuse_poll_out {
	uint32_t revents;
	uint32_t padding;
};

struct fuse_fallocate_in {
	uint64_t fh;
	uint64_t offset;
	uint64_t length;
	uint32_t mode;
	uint32_t padding;
};

struct fuse_lseek_in {
	uint64_t fh;
	uint64_t offset;
	uint32_t whence;
	uint32_t padding;
};

struct fuse_lseek_out {
	uint64_t offset;
};

struct fuse_copy_file_range_in {
	uint64_t fh_in;
	uint64_t off_in;
	uint64_t nodeid_out;
	uint64_t fh_out;
	uint64_t off_out;
	uint64_t len;
	uint64_t flags;
};

struct fuse_release_args {
	struct fuse_args args;
	struct fuse_release_in inarg;
	struct inode *inode;
	int: 32;
};

struct fuse_io_priv {
	struct kref refcnt;
	int async;
	spinlock_t lock;
	unsigned int reqs;
	ssize_t bytes;
	size_t size;
	__u64 offset;
	bool write;
	bool should_dirty;
	int err;
	struct kiocb *iocb;
	struct completion *done;
	bool blocking;
	int: 24;
	int: 32;
};

struct fuse_io_args {
	union {
		struct {
			struct fuse_read_in in;
			u64 attr_ver;
		} read;
		struct {
			struct fuse_write_in in;
			struct fuse_write_out out;
			bool page_locked;
			int: 24;
			int: 32;
		} write;
	};
	struct fuse_args_pages ap;
	struct fuse_io_priv *io;
	struct fuse_file *ff;
};

struct fuse_writepage_args {
	struct fuse_io_args ia;
	struct rb_node writepages_entry;
	struct list_head queue_entry;
	struct fuse_writepage_args *next;
	struct inode *inode;
	struct fuse_sync_bucket *bucket;
};

struct fuse_fill_wb_data {
	struct fuse_writepage_args *wpa;
	struct fuse_file *ff;
	struct inode *inode;
	struct page **orig_pages;
	unsigned int max_pages;
};

struct fuse_kstatfs {
	uint64_t blocks;
	uint64_t bfree;
	uint64_t bavail;
	uint64_t files;
	uint64_t ffree;
	uint32_t bsize;
	uint32_t namelen;
	uint32_t frsize;
	uint32_t padding;
	uint32_t spare[6];
};

struct fuse_statfs_out {
	struct fuse_kstatfs st;
};

struct fuse_init_in {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
	uint32_t flags2;
	uint32_t unused[11];
};

struct fuse_init_out {
	uint32_t major;
	uint32_t minor;
	uint32_t max_readahead;
	uint32_t flags;
	uint16_t max_background;
	uint16_t congestion_threshold;
	uint32_t max_write;
	uint32_t time_gran;
	uint16_t max_pages;
	uint16_t map_alignment;
	uint32_t flags2;
	uint32_t unused[7];
};

struct fuse_syncfs_in {
	uint64_t padding;
};

enum fuse_dax_mode {
	FUSE_DAX_INODE_DEFAULT = 0,
	FUSE_DAX_ALWAYS = 1,
	FUSE_DAX_NEVER = 2,
	FUSE_DAX_INODE_USER = 3,
};

struct fuse_fs_context {
	int fd;
	struct file *file;
	unsigned int rootmode;
	kuid_t user_id;
	kgid_t group_id;
	bool is_bdev: 1;
	bool fd_present: 1;
	bool rootmode_present: 1;
	bool user_id_present: 1;
	bool group_id_present: 1;
	bool default_permissions: 1;
	bool allow_other: 1;
	bool destroy: 1;
	bool no_control: 1;
	bool no_force_umount: 1;
	bool legacy_opts_show: 1;
	enum fuse_dax_mode dax_mode;
	unsigned int max_read;
	unsigned int blksize;
	const char *subtype;
	struct dax_device *dax_dev;
	void **fudptr;
};

enum {
	OPT_SOURCE = 0,
	OPT_SUBTYPE = 1,
	OPT_FD = 2,
	OPT_ROOTMODE = 3,
	OPT_USER_ID = 4,
	OPT_GROUP_ID = 5,
	OPT_DEFAULT_PERMISSIONS = 6,
	OPT_ALLOW_OTHER = 7,
	OPT_MAX_READ = 8,
	OPT_BLKSIZE = 9,
	OPT_ERR = 10,
};

struct fuse_inode_handle {
	u64 nodeid;
	u32 generation;
	int: 32;
};

struct fuse_init_args {
	struct fuse_args args;
	struct fuse_init_in in;
	struct fuse_init_out out;
};

struct fuse_setxattr_in {
	uint32_t size;
	uint32_t flags;
	uint32_t setxattr_flags;
	uint32_t padding;
};

struct fuse_getxattr_in {
	uint32_t size;
	uint32_t padding;
};

struct fuse_getxattr_out {
	uint32_t size;
	uint32_t padding;
};

struct fuse_dirent {
	uint64_t ino;
	uint64_t off;
	uint32_t namelen;
	uint32_t type;
	char name[0];
};

struct fuse_direntplus {
	struct fuse_entry_out entry_out;
	struct fuse_dirent dirent;
};

enum fuse_parse_result {
	FOUND_ERR = 4294967295,
	FOUND_NONE = 0,
	FOUND_SOME = 1,
	FOUND_ALL = 2,
};

struct fuse_ioctl_in {
	uint64_t fh;
	uint32_t flags;
	uint32_t cmd;
	uint64_t arg;
	uint32_t in_size;
	uint32_t out_size;
};

struct fuse_ioctl_iovec {
	uint64_t base;
	uint64_t len;
};

struct fuse_ioctl_out {
	int32_t result;
	uint32_t flags;
	uint32_t in_iovs;
	uint32_t out_iovs;
};

struct ovl_config {
	char *lowerdir;
	char *upperdir;
	char *workdir;
	bool default_permissions;
	bool redirect_dir;
	bool redirect_follow;
	const char *redirect_mode;
	bool index;
	bool uuid;
	bool nfs_export;
	int xino;
	bool metacopy;
	bool userxattr;
	bool ovl_volatile;
};

struct ovl_sb {
	struct super_block *sb;
	dev_t pseudo_dev;
	bool bad_uuid;
	bool is_lower;
};

struct ovl_layer {
	struct vfsmount *mnt;
	struct inode *trap;
	struct ovl_sb *fs;
	int idx;
	int fsid;
};

struct ovl_path {
	const struct ovl_layer *layer;
	struct dentry *dentry;
};

struct ovl_fs {
	unsigned int numlayer;
	unsigned int numfs;
	const struct ovl_layer *layers;
	struct ovl_sb *fs;
	struct dentry *workbasedir;
	struct dentry *workdir;
	struct dentry *indexdir;
	long int namelen;
	struct ovl_config config;
	const struct cred *creator_cred;
	bool tmpfile;
	bool noxattr;
	bool upperdir_locked;
	bool workdir_locked;
	bool share_whiteout;
	struct inode *workbasedir_trap;
	struct inode *workdir_trap;
	struct inode *indexdir_trap;
	int xino_mode;
	atomic_long_t last_ino;
	struct dentry *whiteout;
	errseq_t errseq;
};

struct ovl_entry {
	union {
		struct {
			long unsigned int flags;
		};
		struct callback_head rcu;
	};
	unsigned int numlower;
	struct ovl_path lowerstack[0];
};

struct ovl_dir_cache;

struct ovl_inode {
	union {
		struct ovl_dir_cache *cache;
		struct inode *lowerdata;
	};
	const char *redirect;
	u64 version;
	long unsigned int flags;
	int: 32;
	struct inode vfs_inode;
	struct dentry *__upperdentry;
	struct ovl_path lowerpath;
	struct mutex lock;
};

enum ovl_xattr {
	OVL_XATTR_OPAQUE = 0,
	OVL_XATTR_REDIRECT = 1,
	OVL_XATTR_ORIGIN = 2,
	OVL_XATTR_IMPURE = 3,
	OVL_XATTR_NLINK = 4,
	OVL_XATTR_UPPER = 5,
	OVL_XATTR_METACOPY = 6,
	OVL_XATTR_PROTATTR = 7,
};

enum ovl_inode_flag {
	OVL_IMPURE = 0,
	OVL_WHITEOUTS = 1,
	OVL_INDEX = 2,
	OVL_UPPERDATA = 3,
	OVL_CONST_INO = 4,
};

enum ovl_entry_flag {
	OVL_E_UPPER_ALIAS = 0,
	OVL_E_OPAQUE = 1,
	OVL_E_CONNECTED = 2,
};

enum {
	OVL_XINO_OFF = 0,
	OVL_XINO_AUTO = 1,
	OVL_XINO_ON = 2,
};

struct ovl_inode_params {
	struct inode *newinode;
	struct dentry *upperdentry;
	struct ovl_path *lowerpath;
	bool index;
	unsigned int numlower;
	char *redirect;
	struct dentry *lowerdata;
};

struct ovl_cattr {
	dev_t rdev;
	umode_t mode;
	const char *link;
	struct dentry *hardlink;
};

enum {
	OPT_LOWERDIR = 0,
	OPT_UPPERDIR = 1,
	OPT_WORKDIR = 2,
	OPT_DEFAULT_PERMISSIONS___2 = 3,
	OPT_REDIRECT_DIR = 4,
	OPT_INDEX_ON = 5,
	OPT_INDEX_OFF = 6,
	OPT_UUID_ON = 7,
	OPT_UUID_OFF = 8,
	OPT_NFS_EXPORT_ON = 9,
	OPT_USERXATTR = 10,
	OPT_NFS_EXPORT_OFF = 11,
	OPT_XINO_ON = 12,
	OPT_XINO_OFF = 13,
	OPT_XINO_AUTO = 14,
	OPT_METACOPY_ON = 15,
	OPT_METACOPY_OFF = 16,
	OPT_VOLATILE = 17,
	OPT_ERR___2 = 18,
};

struct ovl_fb {
	u8 version;
	u8 magic;
	u8 len;
	u8 flags;
	u8 type;
	uuid_t uuid;
	u32 fid[0];
} __attribute__((packed));

struct ovl_fh {
	u8 padding[3];
	union {
		struct ovl_fb fb;
		u8 buf[0];
	};
} __attribute__((packed));

struct ovl_lookup_data {
	struct super_block *sb;
	struct vfsmount *mnt;
	struct qstr name;
	bool is_dir;
	bool opaque;
	bool stop;
	bool last;
	char *redirect;
	bool metacopy;
	int: 24;
	int: 32;
};

enum ovl_path_type {
	__OVL_PATH_UPPER = 1,
	__OVL_PATH_MERGE = 2,
	__OVL_PATH_ORIGIN = 4,
};

struct ovl_aio_req {
	struct kiocb iocb;
	refcount_t ref;
	struct kiocb *orig_iocb;
	struct fd fd;
};

enum ovl_copyop {
	OVL_COPY = 0,
	OVL_CLONE = 1,
	OVL_DEDUPE = 2,
};

struct ovl_dir_cache {
	long int refcount;
	int: 32;
	u64 version;
	struct list_head entries;
	struct rb_root root;
	int: 32;
};

struct ovl_cache_entry {
	unsigned int len;
	unsigned int type;
	u64 real_ino;
	u64 ino;
	struct list_head l_node;
	struct rb_node node;
	struct ovl_cache_entry *next_maybe_whiteout;
	bool is_upper;
	bool is_whiteout;
	char name[0];
	int: 16;
	int: 32;
};

struct ovl_readdir_data {
	struct dir_context ctx;
	struct dentry *dentry;
	bool is_lowest;
	struct rb_root *root;
	struct list_head *list;
	struct list_head middle;
	struct ovl_cache_entry *first_maybe_whiteout;
	int count;
	int err;
	bool is_upper;
	bool d_type_supported;
};

struct ovl_dir_file {
	bool is_real;
	bool is_upper;
	struct ovl_dir_cache *cache;
	struct list_head *cursor;
	struct file *realfile;
	struct file *upperfile;
};

struct ovl_readdir_translate {
	struct dir_context *orig_ctx;
	struct ovl_dir_cache *cache;
	struct dir_context ctx;
	u64 parent_ino;
	int fsid;
	int xinobits;
	bool xinowarn;
	int: 24;
	int: 32;
};

struct ovl_copy_up_ctx {
	struct dentry *parent;
	struct dentry *dentry;
	struct path lowerpath;
	struct kstat stat;
	struct kstat pstat;
	const char *link;
	struct dentry *destdir;
	struct qstr destname;
	struct dentry *workdir;
	bool origin;
	bool indexed;
	bool metacopy;
};

struct ovl_cu_creds {
	const struct cred *old;
	struct cred *new;
};

typedef struct vfsmount * (*debugfs_automount_t)(struct dentry *, void *);

struct debugfs_fsdata {
	const struct file_operations *real_fops;
	refcount_t active_users;
	struct completion active_users_drained;
};

struct debugfs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	unsigned int opts;
};

enum {
	Opt_uid___5 = 0,
	Opt_gid___6 = 1,
	Opt_mode___4 = 2,
	Opt_err___7 = 3,
};

struct debugfs_fs_info {
	struct debugfs_mount_opts mount_opts;
};

struct debugfs_blob_wrapper {
	void *data;
	long unsigned int size;
};

struct debugfs_reg32 {
	char *name;
	long unsigned int offset;
};

struct debugfs_regset32 {
	const struct debugfs_reg32 *regs;
	int nregs;
	void *base;
	struct device *dev;
};

struct debugfs_u32_array {
	u32 *array;
	u32 n_elements;
};

struct debugfs_devm_entry {
	int (*read)(struct seq_file *, void *);
	struct device *dev;
};

struct tracefs_dir_ops {
	int (*mkdir)(const char *);
	int (*rmdir)(const char *);
};

struct tracefs_mount_opts {
	kuid_t uid;
	kgid_t gid;
	umode_t mode;
	unsigned int opts;
};

struct tracefs_fs_info {
	struct tracefs_mount_opts mount_opts;
};

typedef int __kernel_key_t;

typedef __kernel_key_t key_t;

struct ipc_perm {
	__kernel_key_t key;
	__kernel_uid_t uid;
	__kernel_gid_t gid;
	__kernel_uid_t cuid;
	__kernel_gid_t cgid;
	__kernel_mode_t mode;
	short unsigned int seq;
};

struct ipc64_perm {
	__kernel_key_t key;
	__kernel_uid32_t uid;
	__kernel_gid32_t gid;
	__kernel_uid32_t cuid;
	__kernel_gid32_t cgid;
	__kernel_mode_t mode;
	unsigned char __pad1[2];
	short unsigned int seq;
	short unsigned int __pad2;
	__kernel_ulong_t __unused1;
	__kernel_ulong_t __unused2;
};

struct kern_ipc_perm {
	spinlock_t lock;
	bool deleted;
	int id;
	key_t key;
	kuid_t uid;
	kgid_t gid;
	kuid_t cuid;
	kgid_t cgid;
	umode_t mode;
	long unsigned int seq;
	void *security;
	struct rhash_head khtnode;
	struct callback_head rcu;
	refcount_t refcount;
	int: 32;
};

struct ipc_params {
	key_t key;
	int flg;
	union {
		size_t size;
		int nsems;
	} u;
};

struct ipc_ops {
	int (*getnew)(struct ipc_namespace *, struct ipc_params *);
	int (*associate)(struct kern_ipc_perm *, int);
	int (*more_checks)(struct kern_ipc_perm *, struct ipc_params *);
};

struct ipc_proc_iface {
	const char *path;
	const char *header;
	int ids;
	int (*show)(struct seq_file *, void *);
};

struct ipc_proc_iter {
	struct ipc_namespace *ns;
	struct pid_namespace *pid_ns;
	struct ipc_proc_iface *iface;
};

struct msg_msgseg;

struct msg_msg {
	struct list_head m_list;
	long int m_type;
	size_t m_ts;
	struct msg_msgseg *next;
	void *security;
};

struct msg_msgseg {
	struct msg_msgseg *next;
};

typedef short unsigned int __kernel_ipc_pid_t;

typedef __kernel_long_t __kernel_old_time_t;

struct msgbuf {
	__kernel_long_t mtype;
	char mtext[1];
};

struct msg;

struct msqid_ds {
	struct ipc_perm msg_perm;
	struct msg *msg_first;
	struct msg *msg_last;
	__kernel_old_time_t msg_stime;
	__kernel_old_time_t msg_rtime;
	__kernel_old_time_t msg_ctime;
	long unsigned int msg_lcbytes;
	long unsigned int msg_lqbytes;
	short unsigned int msg_cbytes;
	short unsigned int msg_qnum;
	short unsigned int msg_qbytes;
	__kernel_ipc_pid_t msg_lspid;
	__kernel_ipc_pid_t msg_lrpid;
};

struct msqid64_ds {
	struct ipc64_perm msg_perm;
	long unsigned int msg_stime;
	long unsigned int msg_stime_high;
	long unsigned int msg_rtime;
	long unsigned int msg_rtime_high;
	long unsigned int msg_ctime;
	long unsigned int msg_ctime_high;
	long unsigned int msg_cbytes;
	long unsigned int msg_qnum;
	long unsigned int msg_qbytes;
	__kernel_pid_t msg_lspid;
	__kernel_pid_t msg_lrpid;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct msginfo {
	int msgpool;
	int msgmap;
	int msgmax;
	int msgmnb;
	int msgmni;
	int msgssz;
	int msgtql;
	short unsigned int msgseg;
};

struct msg_queue {
	struct kern_ipc_perm q_perm;
	time64_t q_stime;
	time64_t q_rtime;
	time64_t q_ctime;
	long unsigned int q_cbytes;
	long unsigned int q_qnum;
	long unsigned int q_qbytes;
	struct pid *q_lspid;
	struct pid *q_lrpid;
	struct list_head q_messages;
	struct list_head q_receivers;
	struct list_head q_senders;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct msg_receiver {
	struct list_head r_list;
	struct task_struct *r_tsk;
	int r_mode;
	long int r_msgtype;
	long int r_maxsize;
	struct msg_msg *r_msg;
};

struct msg_sender {
	struct list_head list;
	struct task_struct *tsk;
	size_t msgsz;
};

struct sem;

struct sem_queue;

struct sem_undo;

struct semid_ds {
	struct ipc_perm sem_perm;
	__kernel_old_time_t sem_otime;
	__kernel_old_time_t sem_ctime;
	struct sem *sem_base;
	struct sem_queue *sem_pending;
	struct sem_queue **sem_pending_last;
	struct sem_undo *undo;
	short unsigned int sem_nsems;
};

struct sem {
	int semval;
	struct pid *sempid;
	spinlock_t lock;
	struct list_head pending_alter;
	struct list_head pending_const;
	int: 32;
	time64_t sem_otime;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sembuf;

struct sem_queue {
	struct list_head list;
	struct task_struct *sleeper;
	struct sem_undo *undo;
	struct pid *pid;
	int status;
	struct sembuf *sops;
	struct sembuf *blocking;
	int nsops;
	bool alter;
	bool dupsop;
};

struct sem_undo {
	struct list_head list_proc;
	struct callback_head rcu;
	struct sem_undo_list *ulp;
	struct list_head list_id;
	int semid;
	short int *semadj;
};

struct semid64_ds {
	struct ipc64_perm sem_perm;
	long unsigned int sem_otime;
	long unsigned int sem_otime_high;
	long unsigned int sem_ctime;
	long unsigned int sem_ctime_high;
	long unsigned int sem_nsems;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct sembuf {
	short unsigned int sem_num;
	short int sem_op;
	short int sem_flg;
};

struct seminfo {
	int semmap;
	int semmni;
	int semmns;
	int semmnu;
	int semmsl;
	int semopm;
	int semume;
	int semusz;
	int semvmx;
	int semaem;
};

struct sem_undo_list {
	refcount_t refcnt;
	spinlock_t lock;
	struct list_head list_proc;
};

struct sem_array {
	struct kern_ipc_perm sem_perm;
	time64_t sem_ctime;
	struct list_head pending_alter;
	struct list_head pending_const;
	struct list_head list_id;
	int sem_nsems;
	int complex_count;
	unsigned int use_global_lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct sem sems[0];
};

struct shmid_ds {
	struct ipc_perm shm_perm;
	int shm_segsz;
	__kernel_old_time_t shm_atime;
	__kernel_old_time_t shm_dtime;
	__kernel_old_time_t shm_ctime;
	__kernel_ipc_pid_t shm_cpid;
	__kernel_ipc_pid_t shm_lpid;
	short unsigned int shm_nattch;
	short unsigned int shm_unused;
	void *shm_unused2;
	void *shm_unused3;
};

struct shmid64_ds {
	struct ipc64_perm shm_perm;
	__kernel_size_t shm_segsz;
	long unsigned int shm_atime;
	long unsigned int shm_atime_high;
	long unsigned int shm_dtime;
	long unsigned int shm_dtime_high;
	long unsigned int shm_ctime;
	long unsigned int shm_ctime_high;
	__kernel_pid_t shm_cpid;
	__kernel_pid_t shm_lpid;
	long unsigned int shm_nattch;
	long unsigned int __unused4;
	long unsigned int __unused5;
};

struct shminfo64 {
	long unsigned int shmmax;
	long unsigned int shmmin;
	long unsigned int shmmni;
	long unsigned int shmseg;
	long unsigned int shmall;
	long unsigned int __unused1;
	long unsigned int __unused2;
	long unsigned int __unused3;
	long unsigned int __unused4;
};

struct shminfo {
	int shmmax;
	int shmmin;
	int shmmni;
	int shmseg;
	int shmall;
};

struct shm_info {
	int used_ids;
	__kernel_ulong_t shm_tot;
	__kernel_ulong_t shm_rss;
	__kernel_ulong_t shm_swp;
	__kernel_ulong_t swap_attempts;
	__kernel_ulong_t swap_successes;
};

struct shmid_kernel {
	struct kern_ipc_perm shm_perm;
	struct file *shm_file;
	long unsigned int shm_nattch;
	long unsigned int shm_segsz;
	int: 32;
	time64_t shm_atim;
	time64_t shm_dtim;
	time64_t shm_ctim;
	struct pid *shm_cprid;
	struct pid *shm_lprid;
	struct ucounts *mlock_ucounts;
	struct task_struct *shm_creator;
	struct list_head shm_clist;
	struct ipc_namespace *ns;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct shm_file_data {
	int id;
	struct ipc_namespace *ns;
	struct file *file;
	const struct vm_operations_struct *vm_ops;
};

typedef int __kernel_mqd_t;

typedef __kernel_mqd_t mqd_t;

struct mq_attr {
	__kernel_long_t mq_flags;
	__kernel_long_t mq_maxmsg;
	__kernel_long_t mq_msgsize;
	__kernel_long_t mq_curmsgs;
	__kernel_long_t __reserved[4];
};

struct mqueue_fs_context {
	struct ipc_namespace *ipc_ns;
	bool newns;
};

struct posix_msg_tree_node {
	struct rb_node rb_node;
	struct list_head msg_list;
	int priority;
};

struct ext_wait_queue {
	struct task_struct *task;
	struct list_head list;
	struct msg_msg *msg;
	int state;
};

struct mqueue_inode_info {
	spinlock_t lock;
	int: 32;
	struct inode vfs_inode;
	wait_queue_head_t wait_q;
	struct rb_root msg_tree;
	struct rb_node *msg_tree_rightmost;
	struct posix_msg_tree_node *node_cache;
	struct mq_attr attr;
	struct sigevent notify;
	struct pid *notify_owner;
	u32 notify_self_exec_id;
	struct user_namespace *notify_user_ns;
	struct ucounts *ucounts;
	struct sock *notify_sock;
	struct sk_buff *notify_cookie;
	struct ext_wait_queue e_wait_q[2];
	long unsigned int qsize;
	int: 32;
};

enum key_state {
	KEY_IS_UNINSTANTIATED = 0,
	KEY_IS_POSITIVE = 1,
};

struct key_user {
	struct rb_node node;
	struct mutex cons_lock;
	spinlock_t lock;
	refcount_t usage;
	atomic_t nkeys;
	atomic_t nikeys;
	kuid_t uid;
	int qnkeys;
	int qnbytes;
};

enum key_notification_subtype {
	NOTIFY_KEY_INSTANTIATED = 0,
	NOTIFY_KEY_UPDATED = 1,
	NOTIFY_KEY_LINKED = 2,
	NOTIFY_KEY_UNLINKED = 3,
	NOTIFY_KEY_CLEARED = 4,
	NOTIFY_KEY_REVOKED = 5,
	NOTIFY_KEY_INVALIDATED = 6,
	NOTIFY_KEY_SETATTR = 7,
};

struct assoc_array_edit;

struct assoc_array_ops {
	long unsigned int (*get_key_chunk)(const void *, int);
	long unsigned int (*get_object_key_chunk)(const void *, int);
	bool (*compare_object)(const void *, const void *);
	int (*diff_objects)(const void *, const void *);
	void (*free_object)(void *);
};

struct assoc_array_node {
	struct assoc_array_ptr *back_pointer;
	u8 parent_slot;
	struct assoc_array_ptr *slots[16];
	long unsigned int nr_leaves_on_branch;
};

struct assoc_array_shortcut {
	struct assoc_array_ptr *back_pointer;
	int parent_slot;
	int skip_to_level;
	struct assoc_array_ptr *next_node;
	long unsigned int index_key[0];
};

struct assoc_array_edit {
	struct callback_head rcu;
	struct assoc_array *array;
	const struct assoc_array_ops *ops;
	const struct assoc_array_ops *ops_for_excised_subtree;
	struct assoc_array_ptr *leaf;
	struct assoc_array_ptr **leaf_p;
	struct assoc_array_ptr *dead_leaf;
	struct assoc_array_ptr *new_meta[3];
	struct assoc_array_ptr *excised_meta[1];
	struct assoc_array_ptr *excised_subtree;
	struct assoc_array_ptr **set_backpointers[16];
	struct assoc_array_ptr *set_backpointers_to;
	struct assoc_array_node *adjust_count_on;
	long int adjust_count_by;
	struct {
		struct assoc_array_ptr **ptr;
		struct assoc_array_ptr *to;
	} set[2];
	struct {
		u8 *p;
		u8 to;
	} set_parent_slot[1];
	u8 segment_cache[17];
};

struct keyring_search_context {
	struct keyring_index_key index_key;
	const struct cred *cred;
	struct key_match_data match_data;
	unsigned int flags;
	int (*iterator)(const void *, void *);
	int skipped_ret;
	bool possessed;
	key_ref_t result;
	int: 32;
	time64_t now;
};

struct keyring_read_iterator_context {
	size_t buflen;
	size_t count;
	key_serial_t *buffer;
};

struct keyctl_dh_params {
	union {
		__s32 private;
		__s32 priv;
	};
	__s32 prime;
	__s32 base;
};

struct keyctl_kdf_params {
	char *hashname;
	char *otherinfo;
	__u32 otherinfolen;
	__u32 __spare[8];
};

struct keyctl_pkey_query {
	__u32 supported_ops;
	__u32 key_size;
	__u16 max_data_size;
	__u16 max_sig_size;
	__u16 max_enc_size;
	__u16 max_dec_size;
	__u32 __spare[10];
};

struct keyctl_pkey_params {
	__s32 key_id;
	__u32 in_len;
	union {
		__u32 out_len;
		__u32 in2_len;
	};
	__u32 __spare[7];
};

enum {
	Opt_err___8 = 0,
	Opt_enc = 1,
	Opt_hash = 2,
};

struct vfs_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
};

struct vfs_ns_cap_data {
	__le32 magic_etc;
	struct {
		__le32 permitted;
		__le32 inheritable;
	} data[2];
	__le32 rootid;
};

struct cpu_vfs_cap_data {
	__u32 magic_etc;
	kernel_cap_t permitted;
	kernel_cap_t inheritable;
	kuid_t rootid;
};

enum devcg_behavior {
	DEVCG_DEFAULT_NONE = 0,
	DEVCG_DEFAULT_ALLOW = 1,
	DEVCG_DEFAULT_DENY = 2,
};

struct dev_exception_item {
	u32 major;
	u32 minor;
	short int type;
	short int access;
	struct list_head list;
	struct callback_head rcu;
};

struct dev_cgroup {
	struct cgroup_subsys_state css;
	struct list_head exceptions;
	enum devcg_behavior behavior;
	int: 32;
};

struct crypto_async_request;

typedef void (*crypto_completion_t)(struct crypto_async_request *, int);

struct crypto_async_request {
	struct list_head list;
	crypto_completion_t complete;
	void *data;
	struct crypto_tfm *tfm;
	u32 flags;
};

struct crypto_wait {
	struct completion completion;
	int err;
};

enum {
	CRYPTO_MSG_ALG_REQUEST = 0,
	CRYPTO_MSG_ALG_REGISTER = 1,
	CRYPTO_MSG_ALG_LOADED = 2,
};

struct crypto_larval {
	struct crypto_alg alg;
	struct crypto_alg *adult;
	struct completion completion;
	u32 mask;
	bool test_started;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct crypto_cipher {
	struct crypto_tfm base;
};

struct rtattr {
	short unsigned int rta_len;
	short unsigned int rta_type;
};

struct crypto_queue {
	struct list_head list;
	struct list_head *backlog;
	unsigned int qlen;
	unsigned int max_qlen;
};

struct crypto_attr_alg {
	char name[128];
};

struct crypto_attr_type {
	u32 type;
	u32 mask;
};

enum {
	CRYPTOA_UNSPEC = 0,
	CRYPTOA_ALG = 1,
	CRYPTOA_TYPE = 2,
	__CRYPTOA_MAX = 3,
};

struct scatter_walk {
	struct scatterlist *sg;
	unsigned int offset;
};

struct aead_request {
	struct crypto_async_request base;
	unsigned int assoclen;
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_aead;

struct aead_alg {
	int (*setkey)(struct crypto_aead *, const u8 *, unsigned int);
	int (*setauthsize)(struct crypto_aead *, unsigned int);
	int (*encrypt)(struct aead_request *);
	int (*decrypt)(struct aead_request *);
	int (*init)(struct crypto_aead *);
	void (*exit)(struct crypto_aead *);
	unsigned int ivsize;
	unsigned int maxauthsize;
	unsigned int chunksize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct crypto_aead {
	unsigned int authsize;
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct aead_instance {
	void (*free)(struct aead_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct aead_alg alg;
	};
};

struct crypto_aead_spawn {
	struct crypto_spawn base;
};

enum crypto_attr_type_t {
	CRYPTOCFGA_UNSPEC = 0,
	CRYPTOCFGA_PRIORITY_VAL = 1,
	CRYPTOCFGA_REPORT_LARVAL = 2,
	CRYPTOCFGA_REPORT_HASH = 3,
	CRYPTOCFGA_REPORT_BLKCIPHER = 4,
	CRYPTOCFGA_REPORT_AEAD = 5,
	CRYPTOCFGA_REPORT_COMPRESS = 6,
	CRYPTOCFGA_REPORT_RNG = 7,
	CRYPTOCFGA_REPORT_CIPHER = 8,
	CRYPTOCFGA_REPORT_AKCIPHER = 9,
	CRYPTOCFGA_REPORT_KPP = 10,
	CRYPTOCFGA_REPORT_ACOMP = 11,
	CRYPTOCFGA_STAT_LARVAL = 12,
	CRYPTOCFGA_STAT_HASH = 13,
	CRYPTOCFGA_STAT_BLKCIPHER = 14,
	CRYPTOCFGA_STAT_AEAD = 15,
	CRYPTOCFGA_STAT_COMPRESS = 16,
	CRYPTOCFGA_STAT_RNG = 17,
	CRYPTOCFGA_STAT_CIPHER = 18,
	CRYPTOCFGA_STAT_AKCIPHER = 19,
	CRYPTOCFGA_STAT_KPP = 20,
	CRYPTOCFGA_STAT_ACOMP = 21,
	__CRYPTOCFGA_MAX = 22,
};

struct crypto_report_aead {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int maxauthsize;
	unsigned int ivsize;
};

struct crypto_sync_skcipher;

struct aead_geniv_ctx {
	spinlock_t lock;
	struct crypto_aead *child;
	struct crypto_sync_skcipher *sknull;
	u8 salt[0];
};

struct crypto_rng;

struct rng_alg {
	int (*generate)(struct crypto_rng *, const u8 *, unsigned int, u8 *, unsigned int);
	int (*seed)(struct crypto_rng *, const u8 *, unsigned int);
	void (*set_ent)(struct crypto_rng *, const u8 *, unsigned int);
	unsigned int seedsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct crypto_rng {
	struct crypto_tfm base;
};

struct crypto_cipher_spawn {
	struct crypto_spawn base;
};

struct skcipher_request {
	unsigned int cryptlen;
	u8 *iv;
	struct scatterlist *src;
	struct scatterlist *dst;
	struct crypto_async_request base;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_skcipher {
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct crypto_sync_skcipher {
	struct crypto_skcipher base;
};

struct skcipher_alg {
	int (*setkey)(struct crypto_skcipher *, const u8 *, unsigned int);
	int (*encrypt)(struct skcipher_request *);
	int (*decrypt)(struct skcipher_request *);
	int (*init)(struct crypto_skcipher *);
	void (*exit)(struct crypto_skcipher *);
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
	unsigned int chunksize;
	unsigned int walksize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct skcipher_instance {
	void (*free)(struct skcipher_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct skcipher_alg alg;
	};
};

struct crypto_skcipher_spawn {
	struct crypto_spawn base;
};

struct skcipher_walk {
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} src;
	union {
		struct {
			struct page *page;
			long unsigned int offset;
		} phys;
		struct {
			u8 *page;
			void *addr;
		} virt;
	} dst;
	struct scatter_walk in;
	unsigned int nbytes;
	struct scatter_walk out;
	unsigned int total;
	struct list_head buffers;
	u8 *page;
	u8 *buffer;
	u8 *oiv;
	void *iv;
	unsigned int ivsize;
	int flags;
	unsigned int blocksize;
	unsigned int stride;
	unsigned int alignmask;
};

struct skcipher_ctx_simple {
	struct crypto_cipher *cipher;
};

struct crypto_report_blkcipher {
	char type[64];
	char geniv[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
	unsigned int ivsize;
};

enum {
	SKCIPHER_WALK_PHYS = 1,
	SKCIPHER_WALK_SLOW = 2,
	SKCIPHER_WALK_COPY = 4,
	SKCIPHER_WALK_DIFF = 8,
	SKCIPHER_WALK_SLEEP = 16,
};

struct skcipher_walk_buffer {
	struct list_head entry;
	struct scatter_walk dst;
	unsigned int len;
	u8 *data;
	u8 buffer[0];
};

struct hash_alg_common {
	unsigned int digestsize;
	unsigned int statesize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct ahash_request {
	struct crypto_async_request base;
	unsigned int nbytes;
	struct scatterlist *src;
	u8 *result;
	void *priv;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_ahash;

struct ahash_alg {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	int (*init_tfm)(struct crypto_ahash *);
	void (*exit_tfm)(struct crypto_ahash *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct hash_alg_common halg;
};

struct crypto_ahash {
	int (*init)(struct ahash_request *);
	int (*update)(struct ahash_request *);
	int (*final)(struct ahash_request *);
	int (*finup)(struct ahash_request *);
	int (*digest)(struct ahash_request *);
	int (*export)(struct ahash_request *, void *);
	int (*import)(struct ahash_request *, const void *);
	int (*setkey)(struct crypto_ahash *, const u8 *, unsigned int);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct crypto_hash_walk {
	char *data;
	unsigned int offset;
	unsigned int alignmask;
	struct page *pg;
	unsigned int entrylen;
	unsigned int total;
	struct scatterlist *sg;
	unsigned int flags;
};

struct ahash_instance {
	void (*free)(struct ahash_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct ahash_alg alg;
	};
};

struct crypto_ahash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_hash {
	char type[64];
	unsigned int blocksize;
	unsigned int digestsize;
};

struct ahash_request_priv {
	crypto_completion_t complete;
	void *data;
	u8 *result;
	u32 flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *ubuf[0];
};

struct shash_instance {
	void (*free)(struct shash_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[128];
			struct crypto_instance base;
		} s;
		struct shash_alg alg;
	};
};

struct crypto_shash_spawn {
	struct crypto_spawn base;
};

struct crypto_report_akcipher {
	char type[64];
};

struct akcipher_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_akcipher {
	struct crypto_tfm base;
};

struct akcipher_alg {
	int (*sign)(struct akcipher_request *);
	int (*verify)(struct akcipher_request *);
	int (*encrypt)(struct akcipher_request *);
	int (*decrypt)(struct akcipher_request *);
	int (*set_pub_key)(struct crypto_akcipher *, const void *, unsigned int);
	int (*set_priv_key)(struct crypto_akcipher *, const void *, unsigned int);
	unsigned int (*max_size)(struct crypto_akcipher *);
	int (*init)(struct crypto_akcipher *);
	void (*exit)(struct crypto_akcipher *);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct akcipher_instance {
	void (*free)(struct akcipher_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct akcipher_alg alg;
	};
};

struct crypto_akcipher_spawn {
	struct crypto_spawn base;
};

struct crypto_report_kpp {
	char type[64];
};

struct kpp_request {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int src_len;
	unsigned int dst_len;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_kpp {
	struct crypto_tfm base;
};

struct kpp_alg {
	int (*set_secret)(struct crypto_kpp *, const void *, unsigned int);
	int (*generate_public_key)(struct kpp_request *);
	int (*compute_shared_secret)(struct kpp_request *);
	unsigned int (*max_size)(struct crypto_kpp *);
	int (*init)(struct crypto_kpp *);
	void (*exit)(struct crypto_kpp *);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct kpp_instance {
	void (*free)(struct kpp_instance *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct {
			char head[64];
			struct crypto_instance base;
		} s;
		struct kpp_alg alg;
	};
};

struct crypto_kpp_spawn {
	struct crypto_spawn base;
};

enum asn1_class {
	ASN1_UNIV = 0,
	ASN1_APPL = 1,
	ASN1_CONT = 2,
	ASN1_PRIV = 3,
};

enum asn1_method {
	ASN1_PRIM = 0,
	ASN1_CONS = 1,
};

enum asn1_tag {
	ASN1_EOC = 0,
	ASN1_BOOL = 1,
	ASN1_INT = 2,
	ASN1_BTS = 3,
	ASN1_OTS = 4,
	ASN1_NULL = 5,
	ASN1_OID = 6,
	ASN1_ODE = 7,
	ASN1_EXT = 8,
	ASN1_REAL = 9,
	ASN1_ENUM = 10,
	ASN1_EPDV = 11,
	ASN1_UTF8STR = 12,
	ASN1_RELOID = 13,
	ASN1_SEQ = 16,
	ASN1_SET = 17,
	ASN1_NUMSTR = 18,
	ASN1_PRNSTR = 19,
	ASN1_TEXSTR = 20,
	ASN1_VIDSTR = 21,
	ASN1_IA5STR = 22,
	ASN1_UNITIM = 23,
	ASN1_GENTIM = 24,
	ASN1_GRASTR = 25,
	ASN1_VISSTR = 26,
	ASN1_GENSTR = 27,
	ASN1_UNISTR = 28,
	ASN1_CHRSTR = 29,
	ASN1_BMPSTR = 30,
	ASN1_LONG_TAG = 31,
};

typedef int (*asn1_action_t)(void *, size_t, unsigned char, const void *, size_t);

struct asn1_decoder {
	const unsigned char *machine;
	size_t machlen;
	const asn1_action_t *actions;
};

enum asn1_opcode {
	ASN1_OP_MATCH = 0,
	ASN1_OP_MATCH_OR_SKIP = 1,
	ASN1_OP_MATCH_ACT = 2,
	ASN1_OP_MATCH_ACT_OR_SKIP = 3,
	ASN1_OP_MATCH_JUMP = 4,
	ASN1_OP_MATCH_JUMP_OR_SKIP = 5,
	ASN1_OP_MATCH_ANY = 8,
	ASN1_OP_MATCH_ANY_OR_SKIP = 9,
	ASN1_OP_MATCH_ANY_ACT = 10,
	ASN1_OP_MATCH_ANY_ACT_OR_SKIP = 11,
	ASN1_OP_COND_MATCH_OR_SKIP = 17,
	ASN1_OP_COND_MATCH_ACT_OR_SKIP = 19,
	ASN1_OP_COND_MATCH_JUMP_OR_SKIP = 21,
	ASN1_OP_COND_MATCH_ANY = 24,
	ASN1_OP_COND_MATCH_ANY_OR_SKIP = 25,
	ASN1_OP_COND_MATCH_ANY_ACT = 26,
	ASN1_OP_COND_MATCH_ANY_ACT_OR_SKIP = 27,
	ASN1_OP_COND_FAIL = 28,
	ASN1_OP_COMPLETE = 29,
	ASN1_OP_ACT = 30,
	ASN1_OP_MAYBE_ACT = 31,
	ASN1_OP_END_SEQ = 32,
	ASN1_OP_END_SET = 33,
	ASN1_OP_END_SEQ_OF = 34,
	ASN1_OP_END_SET_OF = 35,
	ASN1_OP_END_SEQ_ACT = 36,
	ASN1_OP_END_SET_ACT = 37,
	ASN1_OP_END_SEQ_OF_ACT = 38,
	ASN1_OP_END_SET_OF_ACT = 39,
	ASN1_OP_RETURN = 40,
	ASN1_OP__NR = 41,
};

enum rsapubkey_actions {
	ACT_rsa_get_e = 0,
	ACT_rsa_get_n = 1,
	NR__rsapubkey_actions = 2,
};

enum rsaprivkey_actions {
	ACT_rsa_get_d = 0,
	ACT_rsa_get_dp = 1,
	ACT_rsa_get_dq = 2,
	ACT_rsa_get_e___2 = 3,
	ACT_rsa_get_n___2 = 4,
	ACT_rsa_get_p = 5,
	ACT_rsa_get_q = 6,
	ACT_rsa_get_qinv = 7,
	NR__rsaprivkey_actions = 8,
};

typedef long unsigned int mpi_limb_t;

struct gcry_mpi {
	int alloced;
	int nlimbs;
	int nbits;
	int sign;
	unsigned int flags;
	mpi_limb_t *d;
};

typedef struct gcry_mpi *MPI;

struct rsa_key {
	const u8 *n;
	const u8 *e;
	const u8 *d;
	const u8 *p;
	const u8 *q;
	const u8 *dp;
	const u8 *dq;
	const u8 *qinv;
	size_t n_sz;
	size_t e_sz;
	size_t d_sz;
	size_t p_sz;
	size_t q_sz;
	size_t dp_sz;
	size_t dq_sz;
	size_t qinv_sz;
};

struct rsa_mpi_key {
	MPI n;
	MPI e;
	MPI d;
	MPI p;
	MPI q;
	MPI dp;
	MPI dq;
	MPI qinv;
};

struct asn1_decoder;

struct rsa_asn1_template {
	const char *name;
	const u8 *data;
	size_t size;
};

struct pkcs1pad_ctx {
	struct crypto_akcipher *child;
	unsigned int key_size;
};

struct pkcs1pad_inst_ctx {
	struct crypto_akcipher_spawn spawn;
	const struct rsa_asn1_template *digest_info;
};

struct pkcs1pad_request {
	struct scatterlist in_sg[2];
	struct scatterlist out_sg[1];
	uint8_t *in_buf;
	uint8_t *out_buf;
	int: 32;
	int: 32;
	struct akcipher_request child_req;
};

struct crypto_report_acomp {
	char type[64];
};

struct acomp_req {
	struct crypto_async_request base;
	struct scatterlist *src;
	struct scatterlist *dst;
	unsigned int slen;
	unsigned int dlen;
	u32 flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	void *__ctx[0];
};

struct crypto_acomp {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_tfm base;
};

struct acomp_alg {
	int (*compress)(struct acomp_req *);
	int (*decompress)(struct acomp_req *);
	void (*dst_free)(struct scatterlist *);
	int (*init)(struct crypto_acomp *);
	void (*exit)(struct crypto_acomp *);
	unsigned int reqsize;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct crypto_report_comp {
	char type[64];
};

struct crypto_scomp {
	struct crypto_tfm base;
};

struct scomp_alg {
	void * (*alloc_ctx)(struct crypto_scomp *);
	void (*free_ctx)(struct crypto_scomp *, void *);
	int (*compress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int (*decompress)(struct crypto_scomp *, const u8 *, unsigned int, u8 *, unsigned int *, void *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct crypto_alg base;
};

struct scomp_scratch {
	spinlock_t lock;
	void *src;
	void *dst;
};

struct cryptomgr_param {
	struct rtattr *tb[34];
	struct {
		struct rtattr attr;
		struct crypto_attr_type data;
	} type;
	struct {
		struct rtattr attr;
		struct crypto_attr_alg data;
	} attrs[32];
	char template[128];
	struct crypto_larval *larval;
	u32 otype;
	u32 omask;
};

struct crypto_test_param {
	char driver[128];
	char alg[128];
	u32 type;
};

enum {
	CRYPTO_MSG_BASE = 16,
	CRYPTO_MSG_NEWALG = 16,
	CRYPTO_MSG_DELALG = 17,
	CRYPTO_MSG_UPDATEALG = 18,
	CRYPTO_MSG_GETALG = 19,
	CRYPTO_MSG_DELRNG = 20,
	CRYPTO_MSG_GETSTAT = 21,
	__CRYPTO_MSG_MAX = 22,
};

struct crypto_user_alg {
	char cru_name[64];
	char cru_driver_name[64];
	char cru_module_name[64];
	__u32 cru_type;
	__u32 cru_mask;
	__u32 cru_refcnt;
	__u32 cru_flags;
};

struct crypto_report_larval {
	char type[64];
};

struct crypto_report_cipher {
	char type[64];
	unsigned int blocksize;
	unsigned int min_keysize;
	unsigned int max_keysize;
};

struct netlink_kernel_cfg {
	unsigned int groups;
	unsigned int flags;
	void (*input)(struct sk_buff *);
	struct mutex *cb_mutex;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
};

struct netlink_dump_control {
	int (*start)(struct netlink_callback *);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
	void *data;
	struct module *module;
	u32 min_dump_alloc;
};

enum {
	NLA_UNSPEC = 0,
	NLA_U8 = 1,
	NLA_U16 = 2,
	NLA_U32 = 3,
	NLA_U64 = 4,
	NLA_STRING = 5,
	NLA_FLAG = 6,
	NLA_MSECS = 7,
	NLA_NESTED = 8,
	NLA_NESTED_ARRAY = 9,
	NLA_NUL_STRING = 10,
	NLA_BINARY = 11,
	NLA_S8 = 12,
	NLA_S16 = 13,
	NLA_S32 = 14,
	NLA_S64 = 15,
	NLA_BITFIELD32 = 16,
	NLA_REJECT = 17,
	NLA_BE16 = 18,
	NLA_BE32 = 19,
	__NLA_TYPE_MAX = 20,
};

enum netlink_validation {
	NL_VALIDATE_LIBERAL = 0,
	NL_VALIDATE_TRAILING = 1,
	NL_VALIDATE_MAXTYPE = 2,
	NL_VALIDATE_UNSPEC = 4,
	NL_VALIDATE_STRICT_ATTRS = 8,
	NL_VALIDATE_NESTED = 16,
};

struct crypto_dump_info {
	struct sk_buff *in_skb;
	struct sk_buff *out_skb;
	u32 nlmsg_seq;
	u16 nlmsg_flags;
};

struct crypto_link {
	int (*doit)(struct sk_buff *, struct nlmsghdr *, struct nlattr **);
	int (*dump)(struct sk_buff *, struct netlink_callback *);
	int (*done)(struct netlink_callback *);
};

struct cmac_tfm_ctx {
	struct crypto_cipher *child;
	u8 ctx[0];
};

struct cmac_desc_ctx {
	unsigned int len;
	u8 ctx[0];
};

struct hmac_ctx {
	struct crypto_shash *hash;
};

struct sha1_state {
	u32 state[5];
	int: 32;
	u64 count;
	u8 buffer[64];
};

typedef void sha1_block_fn(struct sha1_state *, const u8 *, int);

struct sha256_state {
	u32 state[8];
	u64 count;
	u8 buf[64];
};

struct sha512_state {
	u64 state[8];
	u64 count[2];
	u8 buf[128];
};

typedef void sha512_block_fn(struct sha512_state *, const u8 *, int);

typedef struct {
	u64 a;
	u64 b;
} u128;

typedef struct {
	__be64 a;
	__be64 b;
} be128;

typedef struct {
	__le64 b;
	__le64 a;
} le128;

struct gf128mul_4k {
	be128 t[256];
};

struct gf128mul_64k {
	struct gf128mul_4k *t[16];
};

struct crypto_rfc3686_ctx {
	struct crypto_skcipher *child;
	u8 nonce[4];
};

struct crypto_rfc3686_req_ctx {
	u8 iv[16];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct skcipher_request subreq;
};

struct gcm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn ghash;
};

struct crypto_gcm_ctx {
	struct crypto_skcipher *ctr;
	struct crypto_ahash *ghash;
};

struct crypto_rfc4106_ctx {
	struct crypto_aead *child;
	u8 nonce[4];
};

struct crypto_rfc4106_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct aead_request subreq;
};

struct crypto_rfc4543_instance_ctx {
	struct crypto_aead_spawn aead;
};

struct crypto_rfc4543_ctx {
	struct crypto_aead *child;
	struct crypto_sync_skcipher *null;
	u8 nonce[4];
};

struct crypto_rfc4543_req_ctx {
	struct aead_request subreq;
};

struct crypto_gcm_ghash_ctx {
	unsigned int cryptlen;
	struct scatterlist *src;
	int (*complete)(struct aead_request *, u32);
};

struct crypto_gcm_req_priv_ctx {
	u8 iv[16];
	u8 auth_tag[16];
	u8 iauth_tag[16];
	struct scatterlist src[3];
	struct scatterlist dst[3];
	struct scatterlist sg;
	struct crypto_gcm_ghash_ctx ghash_ctx;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	} u;
};

struct ccm_instance_ctx {
	struct crypto_skcipher_spawn ctr;
	struct crypto_ahash_spawn mac;
};

struct crypto_ccm_ctx {
	struct crypto_ahash *mac;
	struct crypto_skcipher *ctr;
};

struct crypto_rfc4309_ctx {
	struct crypto_aead *child;
	u8 nonce[3];
};

struct crypto_rfc4309_req_ctx {
	struct scatterlist src[3];
	struct scatterlist dst[3];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct aead_request subreq;
};

struct crypto_ccm_req_priv_ctx {
	u8 odata[16];
	u8 idata[16];
	u8 auth_tag[16];
	u32 flags;
	struct scatterlist src[3];
	struct scatterlist dst[3];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		struct ahash_request ahreq;
		struct skcipher_request skreq;
	};
};

struct cbcmac_tfm_ctx {
	struct crypto_cipher *child;
};

struct cbcmac_desc_ctx {
	unsigned int len;
};

struct crypto_aes_ctx {
	u32 key_enc[60];
	u32 key_dec[60];
	u32 key_length;
};

struct deflate_ctx {
	struct z_stream_s comp_stream;
	struct z_stream_s decomp_stream;
};

struct michael_mic_ctx {
	u32 l;
	u32 r;
};

struct michael_mic_desc_ctx {
	__le32 pending;
	size_t pending_len;
	u32 l;
	u32 r;
};

struct chksum_ctx {
	u32 key;
};

struct chksum_desc_ctx {
	u32 crc;
};

struct chksum_desc_ctx___2 {
	__u16 crc;
};

struct lzo_ctx {
	void *lzo_comp_mem;
};

struct lzorle_ctx {
	void *lzorle_comp_mem;
};

struct crypto_report_rng {
	char type[64];
	unsigned int seedsize;
};

struct drbg_string {
	const unsigned char *buf;
	size_t len;
	struct list_head list;
};

typedef uint32_t drbg_flag_t;

struct drbg_core {
	drbg_flag_t flags;
	__u8 statelen;
	__u8 blocklen_bytes;
	char cra_name[128];
	char backend_cra_name[128];
};

struct drbg_state;

struct drbg_state_ops {
	int (*update)(struct drbg_state *, struct list_head *, int);
	int (*generate)(struct drbg_state *, unsigned char *, unsigned int, struct list_head *);
	int (*crypto_init)(struct drbg_state *);
	int (*crypto_fini)(struct drbg_state *);
};

enum drbg_seed_state {
	DRBG_SEED_STATE_UNSEEDED = 0,
	DRBG_SEED_STATE_PARTIAL = 1,
	DRBG_SEED_STATE_FULL = 2,
};

struct drbg_state {
	struct mutex drbg_mutex;
	unsigned char *V;
	unsigned char *Vbuf;
	unsigned char *C;
	unsigned char *Cbuf;
	size_t reseed_ctr;
	size_t reseed_threshold;
	unsigned char *scratchpad;
	unsigned char *scratchpadbuf;
	void *priv_data;
	struct crypto_skcipher *ctr_handle;
	struct skcipher_request *ctr_req;
	__u8 *outscratchpadbuf;
	__u8 *outscratchpad;
	struct crypto_wait ctr_wait;
	struct scatterlist sg_in;
	struct scatterlist sg_out;
	enum drbg_seed_state seeded;
	long unsigned int last_seed_time;
	bool pr;
	bool fips_primed;
	unsigned char *prev;
	struct crypto_rng *jent;
	const struct drbg_state_ops *d_ops;
	const struct drbg_core *core;
	struct drbg_string test_data;
};

enum drbg_prefixes {
	DRBG_PREFIX0 = 0,
	DRBG_PREFIX1 = 1,
	DRBG_PREFIX2 = 2,
	DRBG_PREFIX3 = 3,
};

struct sdesc {
	struct shash_desc shash;
	char ctx[0];
};

struct rand_data {
	__u64 data;
	__u64 old_data;
	__u64 prev_time;
	__u64 last_delta;
	__s64 last_delta2;
	unsigned int osr;
	unsigned char *mem;
	unsigned int memlocation;
	unsigned int memblocks;
	unsigned int memblocksize;
	unsigned int memaccessloops;
	int rct_count;
	unsigned int apt_observations;
	unsigned int apt_count;
	unsigned int apt_base;
	unsigned int apt_base_set: 1;
	unsigned int health_failure: 1;
	int: 30;
	int: 32;
};

struct rand_data;

struct jitterentropy {
	spinlock_t jent_lock;
	struct rand_data *entropy_collector;
	unsigned int reset_cnt;
};

struct ghash_ctx {
	struct gf128mul_4k *gf128;
};

struct ghash_desc_ctx {
	u8 buffer[16];
	u32 bytes;
};

struct ZSTD_CCtx_s;

typedef struct ZSTD_CCtx_s ZSTD_CCtx;

struct ZSTD_DCtx_s;

typedef struct ZSTD_DCtx_s ZSTD_DCtx;

typedef enum {
	ZSTD_fast = 1,
	ZSTD_dfast = 2,
	ZSTD_greedy = 3,
	ZSTD_lazy = 4,
	ZSTD_lazy2 = 5,
	ZSTD_btlazy2 = 6,
	ZSTD_btopt = 7,
	ZSTD_btultra = 8,
	ZSTD_btultra2 = 9,
} ZSTD_strategy;

typedef struct {
	unsigned int windowLog;
	unsigned int chainLog;
	unsigned int hashLog;
	unsigned int searchLog;
	unsigned int minMatch;
	unsigned int targetLength;
	ZSTD_strategy strategy;
} ZSTD_compressionParameters;

typedef struct {
	int contentSizeFlag;
	int checksumFlag;
	int noDictIDFlag;
} ZSTD_frameParameters;

typedef struct {
	ZSTD_compressionParameters cParams;
	ZSTD_frameParameters fParams;
} ZSTD_parameters;

typedef void * (*ZSTD_allocFunction)(void *, size_t);

typedef void (*ZSTD_freeFunction)(void *, void *);

typedef struct {
	ZSTD_allocFunction customAlloc;
	ZSTD_freeFunction customFree;
	void *opaque;
} ZSTD_customMem;

typedef ZSTD_parameters zstd_parameters;

typedef ZSTD_CCtx zstd_cctx;

typedef ZSTD_DCtx zstd_dctx;

struct zstd_ctx {
	zstd_cctx *cctx;
	zstd_dctx *dctx;
	void *cwksp;
	void *dwksp;
};

struct ecc_point {
	u64 *x;
	u64 *y;
	u8 ndigits;
};

struct ecc_curve {
	char *name;
	struct ecc_point g;
	u64 *p;
	u64 *n;
	u64 *a;
	u64 *b;
};

typedef struct {
	u64 m_low;
	u64 m_high;
} uint128_t;

struct ecdh {
	char *key;
	short unsigned int key_size;
};

struct ecdh_ctx {
	unsigned int curve_id;
	unsigned int ndigits;
	u64 private_key[8];
};

enum {
	CRYPTO_KPP_SECRET_TYPE_UNKNOWN = 0,
	CRYPTO_KPP_SECRET_TYPE_DH = 1,
	CRYPTO_KPP_SECRET_TYPE_ECDH = 2,
};

struct kpp_secret {
	short unsigned int type;
	short unsigned int len;
};

enum asymmetric_payload_bits {
	asym_crypto = 0,
	asym_subtype = 1,
	asym_key_ids = 2,
	asym_auth = 3,
};

struct asymmetric_key_id {
	short unsigned int len;
	unsigned char data[0];
};

struct asymmetric_key_ids {
	void *id[3];
};

struct public_key_signature;

struct asymmetric_key_subtype {
	struct module *owner;
	const char *name;
	short unsigned int name_len;
	void (*describe)(const struct key *, struct seq_file *);
	void (*destroy)(void *, void *);
	int (*query)(const struct kernel_pkey_params *, struct kernel_pkey_query *);
	int (*eds_op)(struct kernel_pkey_params *, const void *, void *);
	int (*verify_signature)(const struct key *, const struct public_key_signature *);
};

struct public_key_signature {
	struct asymmetric_key_id *auth_ids[3];
	u8 *s;
	u8 *digest;
	u32 s_size;
	u32 digest_size;
	const char *pkey_algo;
	const char *hash_algo;
	const char *encoding;
	const void *data;
	unsigned int data_size;
};

struct asymmetric_key_parser {
	struct list_head link;
	struct module *owner;
	const char *name;
	int (*parse)(struct key_preparsed_payload *);
};

enum OID {
	OID_id_dsa_with_sha1 = 0,
	OID_id_dsa = 1,
	OID_id_ecPublicKey = 2,
	OID_id_prime192v1 = 3,
	OID_id_prime256v1 = 4,
	OID_id_ecdsa_with_sha1 = 5,
	OID_id_ecdsa_with_sha224 = 6,
	OID_id_ecdsa_with_sha256 = 7,
	OID_id_ecdsa_with_sha384 = 8,
	OID_id_ecdsa_with_sha512 = 9,
	OID_rsaEncryption = 10,
	OID_md2WithRSAEncryption = 11,
	OID_md3WithRSAEncryption = 12,
	OID_md4WithRSAEncryption = 13,
	OID_sha1WithRSAEncryption = 14,
	OID_sha256WithRSAEncryption = 15,
	OID_sha384WithRSAEncryption = 16,
	OID_sha512WithRSAEncryption = 17,
	OID_sha224WithRSAEncryption = 18,
	OID_data = 19,
	OID_signed_data = 20,
	OID_email_address = 21,
	OID_contentType = 22,
	OID_messageDigest = 23,
	OID_signingTime = 24,
	OID_smimeCapabilites = 25,
	OID_smimeAuthenticatedAttrs = 26,
	OID_md2 = 27,
	OID_md4 = 28,
	OID_md5 = 29,
	OID_mskrb5 = 30,
	OID_krb5 = 31,
	OID_krb5u2u = 32,
	OID_msIndirectData = 33,
	OID_msStatementType = 34,
	OID_msSpOpusInfo = 35,
	OID_msPeImageDataObjId = 36,
	OID_msIndividualSPKeyPurpose = 37,
	OID_msOutlookExpress = 38,
	OID_ntlmssp = 39,
	OID_spnego = 40,
	OID_IAKerb = 41,
	OID_PKU2U = 42,
	OID_Scram = 43,
	OID_certAuthInfoAccess = 44,
	OID_sha1 = 45,
	OID_id_ansip384r1 = 46,
	OID_sha256 = 47,
	OID_sha384 = 48,
	OID_sha512 = 49,
	OID_sha224 = 50,
	OID_commonName = 51,
	OID_surname = 52,
	OID_countryName = 53,
	OID_locality = 54,
	OID_stateOrProvinceName = 55,
	OID_organizationName = 56,
	OID_organizationUnitName = 57,
	OID_title = 58,
	OID_description = 59,
	OID_name = 60,
	OID_givenName = 61,
	OID_initials = 62,
	OID_generationalQualifier = 63,
	OID_subjectKeyIdentifier = 64,
	OID_keyUsage = 65,
	OID_subjectAltName = 66,
	OID_issuerAltName = 67,
	OID_basicConstraints = 68,
	OID_crlDistributionPoints = 69,
	OID_certPolicies = 70,
	OID_authorityKeyIdentifier = 71,
	OID_extKeyUsage = 72,
	OID_NetlogonMechanism = 73,
	OID_appleLocalKdcSupported = 74,
	OID_gostCPSignA = 75,
	OID_gostCPSignB = 76,
	OID_gostCPSignC = 77,
	OID_gost2012PKey256 = 78,
	OID_gost2012PKey512 = 79,
	OID_gost2012Digest256 = 80,
	OID_gost2012Digest512 = 81,
	OID_gost2012Signature256 = 82,
	OID_gost2012Signature512 = 83,
	OID_gostTC26Sign256A = 84,
	OID_gostTC26Sign256B = 85,
	OID_gostTC26Sign256C = 86,
	OID_gostTC26Sign256D = 87,
	OID_gostTC26Sign512A = 88,
	OID_gostTC26Sign512B = 89,
	OID_gostTC26Sign512C = 90,
	OID_sm2 = 91,
	OID_sm3 = 92,
	OID_SM2_with_SM3 = 93,
	OID_sm3WithRSAEncryption = 94,
	OID_TPMLoadableKey = 95,
	OID_TPMImportableKey = 96,
	OID_TPMSealedData = 97,
	OID__NR = 98,
};

struct public_key {
	void *key;
	u32 keylen;
	enum OID algo;
	void *params;
	u32 paramlen;
	bool key_is_private;
	const char *id_type;
	const char *pkey_algo;
};

enum x509_actions {
	ACT_x509_extract_key_data = 0,
	ACT_x509_extract_name_segment = 1,
	ACT_x509_note_OID = 2,
	ACT_x509_note_issuer = 3,
	ACT_x509_note_not_after = 4,
	ACT_x509_note_not_before = 5,
	ACT_x509_note_params = 6,
	ACT_x509_note_serial = 7,
	ACT_x509_note_sig_algo = 8,
	ACT_x509_note_signature = 9,
	ACT_x509_note_subject = 10,
	ACT_x509_note_tbs_certificate = 11,
	ACT_x509_process_extension = 12,
	NR__x509_actions = 13,
};

enum x509_akid_actions {
	ACT_x509_akid_note_kid = 0,
	ACT_x509_akid_note_name = 1,
	ACT_x509_akid_note_serial = 2,
	ACT_x509_extract_name_segment___2 = 3,
	ACT_x509_note_OID___2 = 4,
	NR__x509_akid_actions = 5,
};

struct x509_certificate {
	struct x509_certificate *next;
	struct x509_certificate *signer;
	struct public_key *pub;
	struct public_key_signature *sig;
	char *issuer;
	char *subject;
	struct asymmetric_key_id *id;
	struct asymmetric_key_id *skid;
	time64_t valid_from;
	time64_t valid_to;
	const void *tbs;
	unsigned int tbs_size;
	unsigned int raw_sig_size;
	const void *raw_sig;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_subject;
	unsigned int raw_subject_size;
	unsigned int raw_skid_size;
	const void *raw_skid;
	unsigned int index;
	bool seen;
	bool verified;
	bool self_signed;
	bool unsupported_sig;
	bool blacklisted;
	int: 24;
	int: 32;
};

struct x509_parse_context {
	struct x509_certificate *cert;
	long unsigned int data;
	const void *key;
	size_t key_size;
	const void *params;
	size_t params_size;
	enum OID key_algo;
	enum OID last_oid;
	enum OID sig_algo;
	u8 o_size;
	u8 cn_size;
	u8 email_size;
	u16 o_offset;
	u16 cn_offset;
	u16 email_offset;
	unsigned int raw_akid_size;
	const void *raw_akid;
	const void *akid_raw_issuer;
	unsigned int akid_raw_issuer_size;
};

enum blacklist_hash_type {
	BLACKLIST_HASH_X509_TBS = 1,
	BLACKLIST_HASH_BINARY = 2,
};

enum pkcs7_actions {
	ACT_pkcs7_check_content_type = 0,
	ACT_pkcs7_extract_cert = 1,
	ACT_pkcs7_note_OID = 2,
	ACT_pkcs7_note_certificate_list = 3,
	ACT_pkcs7_note_content = 4,
	ACT_pkcs7_note_data = 5,
	ACT_pkcs7_note_signed_info = 6,
	ACT_pkcs7_note_signeddata_version = 7,
	ACT_pkcs7_note_signerinfo_version = 8,
	ACT_pkcs7_sig_note_authenticated_attr = 9,
	ACT_pkcs7_sig_note_digest_algo = 10,
	ACT_pkcs7_sig_note_issuer = 11,
	ACT_pkcs7_sig_note_pkey_algo = 12,
	ACT_pkcs7_sig_note_serial = 13,
	ACT_pkcs7_sig_note_set_of_authattrs = 14,
	ACT_pkcs7_sig_note_signature = 15,
	ACT_pkcs7_sig_note_skid = 16,
	NR__pkcs7_actions = 17,
};

struct pkcs7_signed_info {
	struct pkcs7_signed_info *next;
	struct x509_certificate *signer;
	unsigned int index;
	bool unsupported_crypto;
	bool blacklisted;
	const void *msgdigest;
	unsigned int msgdigest_len;
	unsigned int authattrs_len;
	const void *authattrs;
	long unsigned int aa_set;
	int: 32;
	time64_t signing_time;
	struct public_key_signature *sig;
	int: 32;
};

struct pkcs7_message {
	struct x509_certificate *certs;
	struct x509_certificate *crl;
	struct pkcs7_signed_info *signed_infos;
	u8 version;
	bool have_authattrs;
	enum OID data_type;
	size_t data_len;
	size_t data_hdrlen;
	const void *data;
};

struct pkcs7_parse_context {
	struct pkcs7_message *msg;
	struct pkcs7_signed_info *sinfo;
	struct pkcs7_signed_info **ppsinfo;
	struct x509_certificate *certs;
	struct x509_certificate **ppcerts;
	long unsigned int data;
	enum OID last_oid;
	unsigned int x509_index;
	unsigned int sinfo_index;
	const void *raw_serial;
	unsigned int raw_serial_size;
	unsigned int raw_issuer_size;
	const void *raw_issuer;
	const void *raw_skid;
	unsigned int raw_skid_size;
	bool expect_skid;
};

enum {
	DISK_EVENT_MEDIA_CHANGE = 1,
	DISK_EVENT_EJECT_REQUEST = 2,
};

enum {
	DISK_EVENT_FLAG_POLL = 1,
	DISK_EVENT_FLAG_UEVENT = 2,
	DISK_EVENT_FLAG_BLOCK_ON_EXCL_WRITE = 4,
};

struct blk_integrity_profile;

struct blk_integrity {
	const struct blk_integrity_profile *profile;
	unsigned char flags;
	unsigned char tuple_size;
	unsigned char interval_exp;
	unsigned char tag_size;
};

struct blk_integrity_iter;

typedef blk_status_t integrity_processing_fn(struct blk_integrity_iter *);

typedef void integrity_prepare_fn(struct request *);

typedef void integrity_complete_fn(struct request *, unsigned int);

struct blk_integrity_profile {
	integrity_processing_fn *generate_fn;
	integrity_processing_fn *verify_fn;
	integrity_prepare_fn *prepare_fn;
	integrity_complete_fn *complete_fn;
	const char *name;
};

struct blk_flush_queue {
	unsigned int flush_pending_idx: 1;
	unsigned int flush_running_idx: 1;
	blk_status_t rq_status;
	long unsigned int flush_pending_since;
	struct list_head flush_queue[2];
	struct list_head flush_data_in_flight;
	struct request *flush_rq;
	spinlock_t mq_flush_lock;
};

struct blk_integrity_iter {
	void *prot_buf;
	void *data_buf;
	sector_t seed;
	unsigned int data_size;
	short unsigned int interval;
	unsigned char tuple_size;
	const char *disk_name;
	int: 32;
};

struct bdev_inode {
	struct block_device bdev;
	struct inode vfs_inode;
};

enum {
	DIO_SHOULD_DIRTY = 1,
	DIO_IS_SYNC = 2,
};

struct blkdev_dio {
	union {
		struct kiocb *iocb;
		struct task_struct *waiter;
	};
	size_t size;
	atomic_t ref;
	unsigned int flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct bio bio;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bio_alloc_cache {
	struct bio *free_list;
	unsigned int nr;
};

enum rq_qos_id {
	RQ_QOS_WBT = 0,
	RQ_QOS_LATENCY = 1,
	RQ_QOS_COST = 2,
};

struct rq_qos_ops;

struct rq_qos {
	struct rq_qos_ops *ops;
	struct request_queue *q;
	enum rq_qos_id id;
	struct rq_qos *next;
	struct dentry *debugfs_dir;
};

enum {
	sysctl_hung_task_timeout_secs = 0,
};

enum xen_domain_type {
	XEN_NATIVE = 0,
	XEN_PV_DOMAIN = 1,
	XEN_HVM_DOMAIN = 2,
};

struct blk_mq_debugfs_attr {
	const char *name;
	umode_t mode;
	int (*show)(void *, struct seq_file *);
	ssize_t (*write)(void *, const char *, size_t, loff_t *);
	const struct seq_operations *seq_ops;
};

struct rq_qos_ops {
	void (*throttle)(struct rq_qos *, struct bio *);
	void (*track)(struct rq_qos *, struct request *, struct bio *);
	void (*merge)(struct rq_qos *, struct request *, struct bio *);
	void (*issue)(struct rq_qos *, struct request *);
	void (*requeue)(struct rq_qos *, struct request *);
	void (*done)(struct rq_qos *, struct request *);
	void (*done_bio)(struct rq_qos *, struct bio *);
	void (*cleanup)(struct rq_qos *, struct bio *);
	void (*queue_depth_changed)(struct rq_qos *);
	void (*exit)(struct rq_qos *);
	const struct blk_mq_debugfs_attr *debugfs_attrs;
};

struct biovec_slab {
	int nr_vecs;
	char *name;
	struct kmem_cache *slab;
};

struct bio_slab {
	struct kmem_cache *slab;
	unsigned int slab_ref;
	unsigned int slab_size;
	char name[8];
};

struct elevator_type;

struct elevator_queue {
	struct elevator_type *type;
	void *elevator_data;
	struct kobject kobj;
	struct mutex sysfs_lock;
	unsigned int registered: 1;
	struct hlist_head hash[64];
};

struct blk_mq_ctxs;

struct blk_mq_ctx {
	struct {
		spinlock_t lock;
		struct list_head rq_lists[3];
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
		int: 32;
	};
	unsigned int cpu;
	short unsigned int index_hw[3];
	struct blk_mq_hw_ctx *hctxs[3];
	struct request_queue *queue;
	struct blk_mq_ctxs *ctxs;
	struct kobject kobj;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct blk_stat_callback {
	struct list_head list;
	struct timer_list timer;
	struct blk_rq_stat *cpu_stat;
	int (*bucket_fn)(const struct request *);
	unsigned int buckets;
	struct blk_rq_stat *stat;
	void (*timer_fn)(struct blk_stat_callback *);
	void *data;
	struct callback_head rcu;
};

enum {
	BLK_MQ_F_SHOULD_MERGE = 1,
	BLK_MQ_F_TAG_QUEUE_SHARED = 2,
	BLK_MQ_F_STACKING = 4,
	BLK_MQ_F_TAG_HCTX_SHARED = 8,
	BLK_MQ_F_BLOCKING = 32,
	BLK_MQ_F_NO_SCHED = 64,
	BLK_MQ_F_NO_SCHED_BY_DEFAULT = 128,
	BLK_MQ_F_ALLOC_POLICY_START_BIT = 8,
	BLK_MQ_F_ALLOC_POLICY_BITS = 1,
	BLK_MQ_S_STOPPED = 0,
	BLK_MQ_S_TAG_ACTIVE = 1,
	BLK_MQ_S_SCHED_RESTART = 2,
	BLK_MQ_S_INACTIVE = 3,
	BLK_MQ_MAX_DEPTH = 10240,
	BLK_MQ_CPU_WORK_BATCH = 8,
};

enum elv_merge {
	ELEVATOR_NO_MERGE = 0,
	ELEVATOR_FRONT_MERGE = 1,
	ELEVATOR_BACK_MERGE = 2,
	ELEVATOR_DISCARD_MERGE = 3,
};

struct blk_mq_alloc_data;

struct elevator_mq_ops {
	int (*init_sched)(struct request_queue *, struct elevator_type *);
	void (*exit_sched)(struct elevator_queue *);
	int (*init_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*exit_hctx)(struct blk_mq_hw_ctx *, unsigned int);
	void (*depth_updated)(struct blk_mq_hw_ctx *);
	bool (*allow_merge)(struct request_queue *, struct request *, struct bio *);
	bool (*bio_merge)(struct request_queue *, struct bio *, unsigned int);
	int (*request_merge)(struct request_queue *, struct request **, struct bio *);
	void (*request_merged)(struct request_queue *, struct request *, enum elv_merge);
	void (*requests_merged)(struct request_queue *, struct request *, struct request *);
	void (*limit_depth)(blk_opf_t, struct blk_mq_alloc_data *);
	void (*prepare_request)(struct request *);
	void (*finish_request)(struct request *);
	void (*insert_requests)(struct blk_mq_hw_ctx *, struct list_head *, bool);
	struct request * (*dispatch_request)(struct blk_mq_hw_ctx *);
	bool (*has_work)(struct blk_mq_hw_ctx *);
	void (*completed_request)(struct request *, u64);
	void (*requeue_request)(struct request *);
	struct request * (*former_request)(struct request_queue *, struct request *);
	struct request * (*next_request)(struct request_queue *, struct request *);
	void (*init_icq)(struct io_cq *);
	void (*exit_icq)(struct io_cq *);
};

struct elv_fs_entry;

struct elevator_type {
	struct kmem_cache *icq_cache;
	struct elevator_mq_ops ops;
	size_t icq_size;
	size_t icq_align;
	struct elv_fs_entry *elevator_attrs;
	const char *elevator_name;
	const char *elevator_alias;
	const unsigned int elevator_features;
	struct module *elevator_owner;
	const struct blk_mq_debugfs_attr *queue_debugfs_attrs;
	const struct blk_mq_debugfs_attr *hctx_debugfs_attrs;
	char icq_cache_name[22];
	struct list_head list;
};

struct blk_mq_alloc_data {
	struct request_queue *q;
	blk_mq_req_flags_t flags;
	unsigned int shallow_depth;
	blk_opf_t cmd_flags;
	req_flags_t rq_flags;
	unsigned int nr_tags;
	struct request **cached_rq;
	struct blk_mq_ctx *ctx;
	struct blk_mq_hw_ctx *hctx;
};

struct elv_fs_entry {
	struct attribute attr;
	ssize_t (*show)(struct elevator_queue *, char *);
	ssize_t (*store)(struct elevator_queue *, const char *, size_t);
};

struct blk_mq_ctxs {
	struct kobject kobj;
	struct blk_mq_ctx *queue_ctx;
};

enum {
	WBT_RWQ_BG = 0,
	WBT_RWQ_KSWAPD = 1,
	WBT_RWQ_DISCARD = 2,
	WBT_NUM_RWQ = 3,
};

struct blk_plug_cb;

typedef void (*blk_plug_cb_fn)(struct blk_plug_cb *, bool);

struct blk_plug_cb {
	struct list_head list;
	blk_plug_cb_fn callback;
	void *data;
};

enum {
	BLK_MQ_REQ_NOWAIT = 1,
	BLK_MQ_REQ_RESERVED = 2,
	BLK_MQ_REQ_PM = 4,
};

struct trace_event_raw_block_buffer {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	size_t size;
	char __data[0];
	int: 32;
};

struct trace_event_raw_block_rq_requeue {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
};

struct trace_event_raw_block_rq_completion {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	u32 __data_loc_cmd;
	char __data[0];
	int: 32;
};

struct trace_event_raw_block_rq {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	unsigned int bytes;
	char rwbs[8];
	char comm[16];
	u32 __data_loc_cmd;
	char __data[0];
	int: 32;
};

struct trace_event_raw_block_bio_complete {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	int error;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_bio {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
	int: 32;
};

struct trace_event_raw_block_plug {
	struct trace_entry ent;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_unplug {
	struct trace_entry ent;
	int nr_rq;
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_split {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	sector_t new_sector;
	char rwbs[8];
	char comm[16];
	char __data[0];
};

struct trace_event_raw_block_bio_remap {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	char rwbs[8];
	char __data[0];
};

struct trace_event_raw_block_rq_remap {
	struct trace_entry ent;
	dev_t dev;
	int: 32;
	sector_t sector;
	unsigned int nr_sector;
	dev_t old_dev;
	sector_t old_sector;
	unsigned int nr_bios;
	char rwbs[8];
	char __data[0];
	int: 32;
};

struct trace_event_data_offsets_block_buffer {};

struct trace_event_data_offsets_block_rq_requeue {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq_completion {
	u32 cmd;
};

struct trace_event_data_offsets_block_rq {
	u32 cmd;
};

struct trace_event_data_offsets_block_bio_complete {};

struct trace_event_data_offsets_block_bio {};

struct trace_event_data_offsets_block_plug {};

struct trace_event_data_offsets_block_unplug {};

struct trace_event_data_offsets_block_split {};

struct trace_event_data_offsets_block_bio_remap {};

struct trace_event_data_offsets_block_rq_remap {};

typedef void (*btf_trace_block_touch_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_dirty_buffer)(void *, struct buffer_head *);

typedef void (*btf_trace_block_rq_requeue)(void *, struct request *);

typedef void (*btf_trace_block_rq_complete)(void *, struct request *, blk_status_t, unsigned int);

typedef void (*btf_trace_block_rq_error)(void *, struct request *, blk_status_t, unsigned int);

typedef void (*btf_trace_block_rq_insert)(void *, struct request *);

typedef void (*btf_trace_block_rq_issue)(void *, struct request *);

typedef void (*btf_trace_block_rq_merge)(void *, struct request *);

typedef void (*btf_trace_block_bio_complete)(void *, struct request_queue *, struct bio *);

typedef void (*btf_trace_block_bio_bounce)(void *, struct bio *);

typedef void (*btf_trace_block_bio_backmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_frontmerge)(void *, struct bio *);

typedef void (*btf_trace_block_bio_queue)(void *, struct bio *);

typedef void (*btf_trace_block_getrq)(void *, struct bio *);

typedef void (*btf_trace_block_plug)(void *, struct request_queue *);

typedef void (*btf_trace_block_unplug)(void *, struct request_queue *, unsigned int, bool);

typedef void (*btf_trace_block_split)(void *, struct bio *, unsigned int);

typedef void (*btf_trace_block_bio_remap)(void *, struct bio *, dev_t, sector_t);

typedef void (*btf_trace_block_rq_remap)(void *, struct request *, dev_t, sector_t);

enum blkg_rwstat_type {
	BLKG_RWSTAT_READ = 0,
	BLKG_RWSTAT_WRITE = 1,
	BLKG_RWSTAT_SYNC = 2,
	BLKG_RWSTAT_ASYNC = 3,
	BLKG_RWSTAT_DISCARD = 4,
	BLKG_RWSTAT_NR = 5,
	BLKG_RWSTAT_TOTAL = 5,
};

enum {
	LIMIT_LOW = 0,
	LIMIT_MAX = 1,
	LIMIT_CNT = 2,
};

struct queue_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct request_queue *, char *);
	ssize_t (*store)(struct request_queue *, const char *, size_t);
};

enum {
	BLK_MQ_NO_TAG = 4294967295,
	BLK_MQ_TAG_MIN = 1,
	BLK_MQ_TAG_MAX = 4294967294,
};

enum {
	REQ_FSEQ_PREFLUSH = 1,
	REQ_FSEQ_DATA = 2,
	REQ_FSEQ_POSTFLUSH = 4,
	REQ_FSEQ_DONE = 8,
	REQ_FSEQ_ACTIONS = 7,
	FLUSH_PENDING_TIMEOUT = 500,
};

struct rq_map_data {
	struct page **pages;
	long unsigned int offset;
	short unsigned int page_order;
	short unsigned int nr_entries;
	bool null_mapped;
	bool from_user;
};

struct bio_map_data {
	bool is_our_pages: 1;
	bool is_null_mapped: 1;
	int: 30;
	int: 32;
	struct iov_iter iter;
	struct iovec iov[0];
};

struct req_iterator {
	struct bvec_iter iter;
	struct bio *bio;
};

enum bio_merge_status {
	BIO_MERGE_OK = 0,
	BIO_MERGE_NONE = 1,
	BIO_MERGE_FAILED = 2,
};

typedef bool (*sb_for_each_fn)(struct sbitmap *, unsigned int, void *);

enum {
	BLK_MQ_UNIQUE_TAG_BITS = 16,
	BLK_MQ_UNIQUE_TAG_MASK = 65535,
};

struct mq_inflight {
	struct block_device *part;
	unsigned int inflight[2];
};

struct blk_rq_wait {
	struct completion done;
	blk_status_t ret;
};

struct flush_busy_ctx_data {
	struct blk_mq_hw_ctx *hctx;
	struct list_head *list;
};

struct dispatch_rq_data {
	struct blk_mq_hw_ctx *hctx;
	struct request *rq;
};

enum prep_dispatch {
	PREP_DISPATCH_OK = 0,
	PREP_DISPATCH_NO_TAG = 1,
	PREP_DISPATCH_NO_BUDGET = 2,
};

struct rq_iter_data {
	struct blk_mq_hw_ctx *hctx;
	bool has_rq;
};

struct blk_mq_qe_pair {
	struct list_head node;
	struct request_queue *q;
	struct elevator_type *type;
};

struct sbq_wait {
	struct sbitmap_queue *sbq;
	struct wait_queue_entry wait;
};

typedef bool busy_tag_iter_fn(struct request *, void *);

struct bt_iter_data {
	struct blk_mq_hw_ctx *hctx;
	struct request_queue *q;
	busy_tag_iter_fn *fn;
	void *data;
	bool reserved;
};

struct bt_tags_iter_data {
	struct blk_mq_tags *tags;
	busy_tag_iter_fn *fn;
	void *data;
	unsigned int flags;
};

struct blk_queue_stats {
	struct list_head callbacks;
	spinlock_t lock;
	int accounting;
};

struct blk_mq_hw_ctx_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_mq_hw_ctx *, char *);
	ssize_t (*store)(struct blk_mq_hw_ctx *, const char *, size_t);
};

struct hd_geometry {
	unsigned char heads;
	unsigned char sectors;
	short unsigned int cylinders;
	long unsigned int start;
};

struct blkpg_ioctl_arg {
	int op;
	int flags;
	int datalen;
	void *data;
};

struct blkpg_partition {
	long long int start;
	long long int length;
	int pno;
	char devname[64];
	char volname[64];
	int: 32;
};

struct pr_reservation {
	__u64 key;
	__u32 type;
	__u32 flags;
};

struct pr_registration {
	__u64 old_key;
	__u64 new_key;
	__u32 flags;
	__u32 __pad;
};

struct pr_preempt {
	__u64 old_key;
	__u64 new_key;
	__u32 type;
	__u32 flags;
};

struct pr_clear {
	__u64 key;
	__u32 flags;
	__u32 __pad;
};

struct klist_node;

struct klist {
	spinlock_t k_lock;
	struct list_head k_list;
	void (*get)(struct klist_node *);
	void (*put)(struct klist_node *);
};

struct klist_node {
	void *n_klist;
	struct list_head n_node;
	struct kref n_ref;
};

struct klist_iter {
	struct klist *i_klist;
	struct klist_node *i_cur;
};

struct class_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

enum {
	GENHD_FL_REMOVABLE = 1,
	GENHD_FL_HIDDEN = 2,
	GENHD_FL_NO_PART = 4,
};

struct badblocks {
	struct device *dev;
	int count;
	int unacked_exist;
	int shift;
	u64 *page;
	int changed;
	seqlock_t lock;
	sector_t sector;
	sector_t size;
};

struct blk_major_name {
	struct blk_major_name *next;
	int major;
	char name[16];
	void (*probe)(dev_t);
};

enum {
	IOPRIO_WHO_PROCESS = 1,
	IOPRIO_WHO_PGRP = 2,
	IOPRIO_WHO_USER = 3,
};

struct parsed_partitions {
	struct gendisk *disk;
	char name[32];
	struct {
		sector_t from;
		sector_t size;
		int flags;
		bool has_info;
		struct partition_meta_info info;
		int: 16;
		int: 32;
	} *parts;
	int next;
	int limit;
	bool access_beyond_eod;
	char *pp_buf;
};

typedef struct {
	struct folio *v;
} Sector;

struct msdos_partition {
	u8 boot_ind;
	u8 head;
	u8 sector;
	u8 cyl;
	u8 sys_ind;
	u8 end_head;
	u8 end_sector;
	u8 end_cyl;
	__le32 start_sect;
	__le32 nr_sects;
};

enum msdos_sys_ind {
	DOS_EXTENDED_PARTITION = 5,
	LINUX_EXTENDED_PARTITION = 133,
	WIN98_EXTENDED_PARTITION = 15,
	LINUX_DATA_PARTITION = 131,
	LINUX_LVM_PARTITION = 142,
	LINUX_RAID_PARTITION = 253,
	SOLARIS_X86_PARTITION = 130,
	NEW_SOLARIS_X86_PARTITION = 191,
	DM6_AUX1PARTITION = 81,
	DM6_AUX3PARTITION = 83,
	DM6_PARTITION = 84,
	EZD_PARTITION = 85,
	FREEBSD_PARTITION = 165,
	OPENBSD_PARTITION = 166,
	NETBSD_PARTITION = 169,
	BSDI_PARTITION = 183,
	MINIX_PARTITION = 129,
	UNIXWARE_PARTITION = 99,
};

typedef struct {
	__u8 b[16];
} guid_t;

typedef guid_t efi_guid_t;

struct _gpt_header {
	__le64 signature;
	__le32 revision;
	__le32 header_size;
	__le32 header_crc32;
	__le32 reserved1;
	__le64 my_lba;
	__le64 alternate_lba;
	__le64 first_usable_lba;
	__le64 last_usable_lba;
	efi_guid_t disk_guid;
	__le64 partition_entry_lba;
	__le32 num_partition_entries;
	__le32 sizeof_partition_entry;
	__le32 partition_entry_array_crc32;
};

typedef struct _gpt_header gpt_header;

struct _gpt_entry_attributes {
	u64 required_to_function: 1;
	u64 reserved: 47;
	u64 type_guid_specific: 16;
};

typedef struct _gpt_entry_attributes gpt_entry_attributes;

struct _gpt_entry {
	efi_guid_t partition_type_guid;
	efi_guid_t unique_partition_guid;
	__le64 starting_lba;
	__le64 ending_lba;
	gpt_entry_attributes attributes;
	__le16 partition_name[36];
};

typedef struct _gpt_entry gpt_entry;

struct _gpt_mbr_record {
	u8 boot_indicator;
	u8 start_head;
	u8 start_sector;
	u8 start_track;
	u8 os_type;
	u8 end_head;
	u8 end_sector;
	u8 end_track;
	__le32 starting_lba;
	__le32 size_in_lba;
};

typedef struct _gpt_mbr_record gpt_mbr_record;

struct _legacy_mbr {
	u8 boot_code[440];
	__le32 unique_mbr_signature;
	__le16 unknown;
	gpt_mbr_record partition_record[4];
	__le16 signature;
} __attribute__((packed));

typedef struct _legacy_mbr legacy_mbr;

struct rq_wait {
	wait_queue_head_t wait;
	atomic_t inflight;
};

struct rq_depth {
	unsigned int max_depth;
	int scale_step;
	bool scaled_max;
	unsigned int queue_depth;
	unsigned int default_depth;
};

typedef bool acquire_inflight_cb_t(struct rq_wait *, void *);

typedef void cleanup_cb_t(struct rq_wait *, void *);

struct rq_qos_wait_data {
	struct wait_queue_entry wq;
	struct task_struct *task;
	struct rq_wait *rqw;
	acquire_inflight_cb_t *cb;
	void *private_data;
	bool got_token;
};

struct disk_events {
	struct list_head node;
	struct gendisk *disk;
	spinlock_t lock;
	struct mutex block_mutex;
	int block;
	unsigned int pending;
	unsigned int clearing;
	long int poll_msecs;
	struct delayed_work dwork;
};

struct blk_ia_range_sysfs_entry {
	struct attribute attr;
	ssize_t (*show)(struct blk_independent_access_range *, char *);
};

enum dd_data_dir {
	DD_READ = 0,
	DD_WRITE = 1,
};

enum {
	DD_DIR_COUNT = 2,
};

enum dd_prio {
	DD_RT_PRIO = 0,
	DD_BE_PRIO = 1,
	DD_IDLE_PRIO = 2,
	DD_PRIO_MAX = 2,
};

enum {
	DD_PRIO_COUNT = 3,
};

struct io_stats_per_prio {
	uint32_t inserted;
	uint32_t merged;
	uint32_t dispatched;
	atomic_t completed;
};

struct dd_per_prio {
	struct list_head dispatch;
	struct rb_root sort_list[2];
	struct list_head fifo_list[2];
	struct request *next_rq[2];
	struct io_stats_per_prio stats;
};

struct deadline_data {
	struct dd_per_prio per_prio[3];
	enum dd_data_dir last_dir;
	unsigned int batching;
	unsigned int starved;
	int fifo_expire[2];
	int fifo_batch;
	int writes_starved;
	int front_merges;
	u32 async_depth;
	int prio_aging_expire;
	spinlock_t lock;
	spinlock_t zone_lock;
};

struct trace_event_raw_kyber_latency {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char type[8];
	u8 percentile;
	u8 numerator;
	u8 denominator;
	unsigned int samples;
	char __data[0];
};

struct trace_event_raw_kyber_adjust {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	unsigned int depth;
	char __data[0];
};

struct trace_event_raw_kyber_throttled {
	struct trace_entry ent;
	dev_t dev;
	char domain[16];
	char __data[0];
};

struct trace_event_data_offsets_kyber_latency {};

struct trace_event_data_offsets_kyber_adjust {};

struct trace_event_data_offsets_kyber_throttled {};

typedef void (*btf_trace_kyber_latency)(void *, dev_t, const char *, const char *, unsigned int, unsigned int, unsigned int, unsigned int);

typedef void (*btf_trace_kyber_adjust)(void *, dev_t, const char *, unsigned int);

typedef void (*btf_trace_kyber_throttled)(void *, dev_t, const char *);

enum {
	KYBER_READ = 0,
	KYBER_WRITE = 1,
	KYBER_DISCARD = 2,
	KYBER_OTHER = 3,
	KYBER_NUM_DOMAINS = 4,
};

enum {
	KYBER_ASYNC_PERCENT = 75,
};

enum {
	KYBER_LATENCY_SHIFT = 2,
	KYBER_GOOD_BUCKETS = 4,
	KYBER_LATENCY_BUCKETS = 8,
};

enum {
	KYBER_TOTAL_LATENCY = 0,
	KYBER_IO_LATENCY = 1,
};

struct kyber_cpu_latency {
	atomic_t buckets[48];
};

struct kyber_ctx_queue {
	spinlock_t lock;
	struct list_head rq_list[4];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct kyber_queue_data {
	struct request_queue *q;
	dev_t dev;
	struct sbitmap_queue domain_tokens[4];
	unsigned int async_depth;
	struct kyber_cpu_latency *cpu_latency;
	struct timer_list timer;
	unsigned int latency_buckets[48];
	long unsigned int latency_timeout[3];
	int domain_p99[3];
	int: 32;
	u64 latency_targets[3];
};

struct kyber_hctx_data {
	spinlock_t lock;
	struct list_head rqs[4];
	unsigned int cur_domain;
	unsigned int batching;
	struct kyber_ctx_queue *kcqs;
	struct sbitmap kcq_map[4];
	struct sbq_wait domain_wait[4];
	struct sbq_wait_state *domain_ws[4];
	atomic_t wait_index[4];
};

struct flush_kcq_data {
	struct kyber_hctx_data *khd;
	unsigned int sched_domain;
	struct list_head *list;
};

struct virtio_device_id {
	__u32 device;
	__u32 vendor;
};

struct virtio_device;

struct virtqueue {
	struct list_head list;
	void (*callback)(struct virtqueue *);
	const char *name;
	struct virtio_device *vdev;
	unsigned int index;
	unsigned int num_free;
	unsigned int num_max;
	void *priv;
	bool reset;
};

struct vringh_config_ops;

struct virtio_config_ops;

struct virtio_device {
	int index;
	bool failed;
	bool config_enabled;
	bool config_change_pending;
	spinlock_t config_lock;
	spinlock_t vqs_list_lock;
	struct device dev;
	struct virtio_device_id id;
	const struct virtio_config_ops *config;
	const struct vringh_config_ops *vringh_config;
	struct list_head vqs;
	u64 features;
	void *priv;
	int: 32;
};

typedef void vq_callback_t(struct virtqueue *);

struct irq_affinity;

struct virtio_shm_region;

struct virtio_config_ops {
	void (*get)(struct virtio_device *, unsigned int, void *, unsigned int);
	void (*set)(struct virtio_device *, unsigned int, const void *, unsigned int);
	u32 (*generation)(struct virtio_device *);
	u8 (*get_status)(struct virtio_device *);
	void (*set_status)(struct virtio_device *, u8);
	void (*reset)(struct virtio_device *);
	int (*find_vqs)(struct virtio_device *, unsigned int, struct virtqueue **, vq_callback_t **, const char * const *, const bool *, struct irq_affinity *);
	void (*del_vqs)(struct virtio_device *);
	void (*synchronize_cbs)(struct virtio_device *);
	u64 (*get_features)(struct virtio_device *);
	int (*finalize_features)(struct virtio_device *);
	const char * (*bus_name)(struct virtio_device *);
	int (*set_vq_affinity)(struct virtqueue *, const struct cpumask *);
	const struct cpumask * (*get_vq_affinity)(struct virtio_device *, int);
	bool (*get_shm_region)(struct virtio_device *, struct virtio_shm_region *, u8);
	int (*disable_vq_and_reset)(struct virtqueue *);
	int (*enable_vq_after_reset)(struct virtqueue *);
};

struct virtio_shm_region {
	u64 addr;
	u64 len;
};

struct show_busy_params {
	struct seq_file *m;
	struct blk_mq_hw_ctx *hctx;
};

struct bd_holder_disk {
	struct list_head list;
	struct block_device *bdev;
	int refcnt;
};

struct xa_limit {
	u32 max;
	u32 min;
};

typedef u32 compat_ulong_t;

enum {
	IORING_CQE_BUFFER_SHIFT = 16,
};

struct io_sqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 flags;
	__u32 dropped;
	__u32 array;
	__u32 resv1;
	__u64 resv2;
};

struct io_cqring_offsets {
	__u32 head;
	__u32 tail;
	__u32 ring_mask;
	__u32 ring_entries;
	__u32 overflow;
	__u32 cqes;
	__u32 flags;
	__u32 resv1;
	__u64 resv2;
};

struct io_uring_params {
	__u32 sq_entries;
	__u32 cq_entries;
	__u32 flags;
	__u32 sq_thread_cpu;
	__u32 sq_thread_idle;
	__u32 features;
	__u32 wq_fd;
	__u32 resv[3];
	struct io_sqring_offsets sq_off;
	struct io_cqring_offsets cq_off;
};

struct io_uring_probe_op {
	__u8 op;
	__u8 resv;
	__u16 flags;
	__u32 resv2;
};

struct io_uring_probe {
	__u8 last_op;
	__u8 ops_len;
	__u16 resv;
	__u32 resv2[3];
	struct io_uring_probe_op ops[0];
};

struct io_uring_restriction {
	__u16 opcode;
	union {
		__u8 register_op;
		__u8 sqe_op;
		__u8 sqe_flags;
	};
	__u8 resv;
	__u32 resv2[3];
};

struct io_uring_buf {
	__u64 addr;
	__u32 len;
	__u16 bid;
	__u16 resv;
};

struct io_uring_buf_ring {
	union {
		struct {
			__u64 resv1;
			__u32 resv2;
			__u16 resv3;
			__u16 tail;
		};
		struct io_uring_buf bufs[0];
	};
};

enum {
	IORING_RESTRICTION_REGISTER_OP = 0,
	IORING_RESTRICTION_SQE_OP = 1,
	IORING_RESTRICTION_SQE_FLAGS_ALLOWED = 2,
	IORING_RESTRICTION_SQE_FLAGS_REQUIRED = 3,
	IORING_RESTRICTION_LAST = 4,
};

struct io_uring_getevents_arg {
	__u64 sigmask;
	__u32 sigmask_sz;
	__u32 pad;
	__u64 ts;
};

enum io_uring_cmd_flags {
	IO_URING_F_COMPLETE_DEFER = 1,
	IO_URING_F_UNLOCKED = 2,
	IO_URING_F_NONBLOCK = 2147483648,
	IO_URING_F_SQE128 = 4,
	IO_URING_F_CQE32 = 8,
	IO_URING_F_IOPOLL = 16,
	IO_URING_F_MULTISHOT = 32,
};

struct io_rsrc_node {
	struct percpu_ref refs;
	struct list_head node;
	struct list_head rsrc_list;
	struct io_rsrc_data *rsrc_data;
	struct llist_node llist;
	bool done;
};

struct io_mapped_ubuf {
	u64 ubuf;
	u64 ubuf_end;
	unsigned int nr_bvecs;
	long unsigned int acct_pages;
	struct bio_vec bvec[0];
};

struct io_buffer_list {
	union {
		struct list_head buf_list;
		struct {
			struct page **buf_pages;
			struct io_uring_buf_ring *buf_ring;
		};
	};
	__u16 bgid;
	__u16 buf_nr_pages;
	__u16 nr_entries;
	__u16 head;
	__u16 mask;
};

struct io_sq_data {
	refcount_t refs;
	atomic_t park_pending;
	struct mutex lock;
	struct list_head ctx_list;
	struct task_struct *thread;
	struct wait_queue_head wait;
	unsigned int sq_thread_idle;
	int sq_cpu;
	pid_t task_pid;
	pid_t task_tgid;
	long unsigned int state;
	struct completion exited;
};

struct io_rsrc_put;

typedef void rsrc_put_fn(struct io_ring_ctx *, struct io_rsrc_put *);

struct io_rsrc_data {
	struct io_ring_ctx *ctx;
	u64 **tags;
	unsigned int nr;
	rsrc_put_fn *do_put;
	atomic_t refs;
	struct completion done;
	bool quiesce;
};

enum {
	REQ_F_FIXED_FILE = 1,
	REQ_F_IO_DRAIN = 2,
	REQ_F_LINK = 4,
	REQ_F_HARDLINK = 8,
	REQ_F_FORCE_ASYNC = 16,
	REQ_F_BUFFER_SELECT = 32,
	REQ_F_CQE_SKIP = 64,
	REQ_F_FAIL = 256,
	REQ_F_INFLIGHT = 512,
	REQ_F_CUR_POS = 1024,
	REQ_F_NOWAIT = 2048,
	REQ_F_LINK_TIMEOUT = 4096,
	REQ_F_NEED_CLEANUP = 8192,
	REQ_F_POLLED = 16384,
	REQ_F_BUFFER_SELECTED = 32768,
	REQ_F_BUFFER_RING = 65536,
	REQ_F_REISSUE = 131072,
	REQ_F_SUPPORT_NOWAIT = 1073741824,
	REQ_F_ISREG = 2147483648,
	REQ_F_CREDS = 262144,
	REQ_F_REFCOUNT = 524288,
	REQ_F_ARM_LTIMEOUT = 1048576,
	REQ_F_ASYNC_DATA = 2097152,
	REQ_F_SKIP_LINK_CQES = 4194304,
	REQ_F_SINGLE_POLL = 8388608,
	REQ_F_DOUBLE_POLL = 16777216,
	REQ_F_PARTIAL_IO = 33554432,
	REQ_F_APOLL_MULTISHOT = 134217728,
	REQ_F_CQE32_INIT = 67108864,
	REQ_F_CLEAR_POLLIN = 268435456,
	REQ_F_HASH_LOCKED = 536870912,
};

struct io_buffer {
	struct list_head list;
	__u64 addr;
	__u32 len;
	__u16 bid;
	__u16 bgid;
};

struct io_poll {
	struct file *file;
	struct wait_queue_head *head;
	__poll_t events;
	struct wait_queue_entry wait;
};

struct io_cache_entry {
	struct hlist_node node;
};

struct async_poll {
	union {
		struct io_poll poll;
		struct io_cache_entry cache;
	};
	struct io_poll *double_poll;
};

struct io_overflow_cqe {
	struct list_head list;
	struct io_uring_cqe cqe;
};

struct trace_event_raw_io_uring_create {
	struct trace_entry ent;
	int fd;
	void *ctx;
	u32 sq_entries;
	u32 cq_entries;
	u32 flags;
	char __data[0];
};

struct trace_event_raw_io_uring_register {
	struct trace_entry ent;
	void *ctx;
	unsigned int opcode;
	unsigned int nr_files;
	unsigned int nr_bufs;
	long int ret;
	char __data[0];
};

struct trace_event_raw_io_uring_file_get {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	int fd;
	char __data[0];
	int: 32;
};

struct trace_event_raw_io_uring_queue_async_work {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	u8 opcode;
	unsigned int flags;
	struct io_wq_work *work;
	int rw;
	u32 __data_loc_op_str;
	char __data[0];
	int: 32;
};

struct trace_event_raw_io_uring_defer {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int data;
	u8 opcode;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	void *target_req;
	char __data[0];
};

struct trace_event_raw_io_uring_cqring_wait {
	struct trace_entry ent;
	void *ctx;
	int min_events;
	char __data[0];
};

struct trace_event_raw_io_uring_fail_link {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	void *link;
	u32 __data_loc_op_str;
	char __data[0];
	int: 32;
};

struct trace_event_raw_io_uring_complete {
	struct trace_entry ent;
	void *ctx;
	void *req;
	u64 user_data;
	int res;
	unsigned int cflags;
	u64 extra1;
	u64 extra2;
	char __data[0];
};

struct trace_event_raw_io_uring_submit_sqe {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	u32 flags;
	bool force_nonblock;
	bool sq_thread;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_poll_arm {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	int mask;
	int events;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_task_add {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	int mask;
	u32 __data_loc_op_str;
	char __data[0];
	int: 32;
};

struct trace_event_raw_io_uring_req_failed {
	struct trace_entry ent;
	void *ctx;
	void *req;
	long long unsigned int user_data;
	u8 opcode;
	u8 flags;
	u8 ioprio;
	int: 8;
	int: 32;
	u64 off;
	u64 addr;
	u32 len;
	u32 op_flags;
	u16 buf_index;
	u16 personality;
	u32 file_index;
	u64 pad1;
	u64 addr3;
	int error;
	u32 __data_loc_op_str;
	char __data[0];
};

struct trace_event_raw_io_uring_cqe_overflow {
	struct trace_entry ent;
	void *ctx;
	int: 32;
	long long unsigned int user_data;
	s32 res;
	u32 cflags;
	void *ocqe;
	char __data[0];
	int: 32;
};

struct trace_event_raw_io_uring_task_work_run {
	struct trace_entry ent;
	void *tctx;
	unsigned int count;
	unsigned int loops;
	char __data[0];
};

struct trace_event_raw_io_uring_short_write {
	struct trace_entry ent;
	void *ctx;
	int: 32;
	u64 fpos;
	u64 wanted;
	u64 got;
	char __data[0];
};

struct trace_event_raw_io_uring_local_work_run {
	struct trace_entry ent;
	void *ctx;
	int count;
	unsigned int loops;
	char __data[0];
};

struct trace_event_data_offsets_io_uring_create {};

struct trace_event_data_offsets_io_uring_register {};

struct trace_event_data_offsets_io_uring_file_get {};

struct trace_event_data_offsets_io_uring_queue_async_work {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_defer {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_link {};

struct trace_event_data_offsets_io_uring_cqring_wait {};

struct trace_event_data_offsets_io_uring_fail_link {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_complete {};

struct trace_event_data_offsets_io_uring_submit_sqe {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_poll_arm {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_task_add {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_req_failed {
	u32 op_str;
};

struct trace_event_data_offsets_io_uring_cqe_overflow {};

struct trace_event_data_offsets_io_uring_task_work_run {};

struct trace_event_data_offsets_io_uring_short_write {};

struct trace_event_data_offsets_io_uring_local_work_run {};

typedef void (*btf_trace_io_uring_create)(void *, int, void *, u32, u32, u32);

typedef void (*btf_trace_io_uring_register)(void *, void *, unsigned int, unsigned int, unsigned int, long int);

typedef void (*btf_trace_io_uring_file_get)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_queue_async_work)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_defer)(void *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_link)(void *, struct io_kiocb *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_cqring_wait)(void *, void *, int);

typedef void (*btf_trace_io_uring_fail_link)(void *, struct io_kiocb *, struct io_kiocb *);

typedef void (*btf_trace_io_uring_complete)(void *, void *, void *, u64, int, unsigned int, u64, u64);

typedef void (*btf_trace_io_uring_submit_sqe)(void *, struct io_kiocb *, bool);

typedef void (*btf_trace_io_uring_poll_arm)(void *, struct io_kiocb *, int, int);

typedef void (*btf_trace_io_uring_task_add)(void *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_req_failed)(void *, const struct io_uring_sqe *, struct io_kiocb *, int);

typedef void (*btf_trace_io_uring_cqe_overflow)(void *, void *, long long unsigned int, s32, u32, void *);

typedef void (*btf_trace_io_uring_task_work_run)(void *, void *, unsigned int, unsigned int);

typedef void (*btf_trace_io_uring_short_write)(void *, void *, u64, u64, u64);

typedef void (*btf_trace_io_uring_local_work_run)(void *, void *, int, unsigned int);

enum {
	IO_WQ_WORK_CANCEL = 1,
	IO_WQ_WORK_HASHED = 2,
	IO_WQ_WORK_UNBOUND = 4,
	IO_WQ_WORK_CONCURRENT = 16,
	IO_WQ_HASH_SHIFT = 24,
};

enum io_wq_cancel {
	IO_WQ_CANCEL_OK = 0,
	IO_WQ_CANCEL_RUNNING = 1,
	IO_WQ_CANCEL_NOTFOUND = 2,
};

enum {
	IOU_OK = 0,
	IOU_ISSUE_SKIP_COMPLETE = 4294966767,
	IOU_STOP_MULTISHOT = 4294967171,
};

struct io_op_def {
	unsigned int needs_file: 1;
	unsigned int plug: 1;
	unsigned int hash_reg_file: 1;
	unsigned int unbound_nonreg_file: 1;
	unsigned int pollin: 1;
	unsigned int pollout: 1;
	unsigned int poll_exclusive: 1;
	unsigned int buffer_select: 1;
	unsigned int not_supported: 1;
	unsigned int audit_skip: 1;
	unsigned int ioprio: 1;
	unsigned int iopoll: 1;
	unsigned int manual_alloc: 1;
	short unsigned int async_size;
	const char *name;
	int (*prep)(struct io_kiocb *, const struct io_uring_sqe *);
	int (*issue)(struct io_kiocb *, unsigned int);
	int (*prep_async)(struct io_kiocb *);
	void (*cleanup)(struct io_kiocb *);
	void (*fail)(struct io_kiocb *);
};

struct io_tctx_node {
	struct list_head ctx_node;
	struct task_struct *task;
	struct io_ring_ctx *ctx;
};

enum {
	IORING_RSRC_FILE = 0,
	IORING_RSRC_BUFFER = 1,
};

struct io_rsrc_put {
	struct list_head list;
	u64 tag;
	union {
		void *rsrc;
		struct file *file;
		struct io_mapped_ubuf *buf;
	};
	int: 32;
};

enum {
	IO_APOLL_OK = 0,
	IO_APOLL_ABORTED = 1,
	IO_APOLL_READY = 2,
};

enum {
	IO_CHECK_CQ_OVERFLOW_BIT = 0,
	IO_CHECK_CQ_DROPPED_BIT = 1,
};

enum {
	IO_EVENTFD_OP_SIGNAL_BIT = 0,
	IO_EVENTFD_OP_FREE_BIT = 1,
};

struct io_defer_entry {
	struct list_head list;
	struct io_kiocb *req;
	u32 seq;
};

struct io_wait_queue {
	struct wait_queue_entry wq;
	struct io_ring_ctx *ctx;
	unsigned int cq_tail;
	unsigned int nr_timeouts;
};

struct io_tctx_exit {
	struct callback_head task_work;
	struct completion completion;
	struct io_ring_ctx *ctx;
};

struct io_task_cancel {
	struct task_struct *task;
	bool all;
};

struct creds;

struct io_xattr {
	struct file *file;
	struct xattr_ctx ctx;
	struct filename *filename;
};

struct io_rename {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_unlink {
	struct file *file;
	int dfd;
	int flags;
	struct filename *filename;
};

struct io_mkdir {
	struct file *file;
	int dfd;
	umode_t mode;
	struct filename *filename;
};

struct io_link {
	struct file *file;
	int old_dfd;
	int new_dfd;
	struct filename *oldpath;
	struct filename *newpath;
	int flags;
};

struct io_splice {
	struct file *file_out;
	int: 32;
	loff_t off_out;
	loff_t off_in;
	u64 len;
	int splice_fd_in;
	unsigned int flags;
};

struct io_sync {
	struct file *file;
	int: 32;
	loff_t len;
	loff_t off;
	int flags;
	int mode;
};

struct io_fadvise {
	struct file *file;
	int: 32;
	u64 offset;
	u32 len;
	u32 advice;
};

struct io_madvise {
	struct file *file;
	int: 32;
	u64 addr;
	u32 len;
	u32 advice;
};

struct io_uring_file_index_range {
	__u32 off;
	__u32 len;
	__u64 resv;
};

struct io_open {
	struct file *file;
	int dfd;
	u32 file_slot;
	struct filename *filename;
	struct open_how how;
	long unsigned int nofile;
	int: 32;
};

struct io_close {
	struct file *file;
	int fd;
	u32 file_slot;
};

struct io_epoll {
	struct file *file;
	int epfd;
	int op;
	int fd;
	struct epoll_event event;
};

struct io_statx {
	struct file *file;
	int dfd;
	unsigned int mask;
	unsigned int flags;
	struct filename *filename;
	struct statx *buffer;
};

struct user_msghdr {
	void *msg_name;
	int msg_namelen;
	struct iovec *msg_iov;
	__kernel_size_t msg_iovlen;
	void *msg_control;
	__kernel_size_t msg_controllen;
	unsigned int msg_flags;
};

typedef u32 compat_size_t;

struct compat_msghdr {
	compat_uptr_t msg_name;
	compat_int_t msg_namelen;
	compat_uptr_t msg_iov;
	compat_size_t msg_iovlen;
	compat_uptr_t msg_control;
	compat_size_t msg_controllen;
	compat_uint_t msg_flags;
};

struct io_uring_recvmsg_out {
	__u32 namelen;
	__u32 controllen;
	__u32 payloadlen;
	__u32 flags;
};

struct io_async_msghdr {
	union {
		struct iovec fast_iov[8];
		struct {
			struct iovec fast_iov_one;
			__kernel_size_t controllen;
			int namelen;
			__kernel_size_t payloadlen;
		};
		struct io_cache_entry cache;
	};
	struct iovec *free_iov;
	struct sockaddr *uaddr;
	struct msghdr msg;
	struct __kernel_sockaddr_storage addr;
};

struct io_async_connect {
	struct __kernel_sockaddr_storage address;
};

enum {
	SKBFL_ZEROCOPY_ENABLE = 1,
	SKBFL_SHARED_FRAG = 2,
	SKBFL_PURE_ZEROCOPY = 4,
	SKBFL_DONT_ORPHAN = 8,
	SKBFL_MANAGED_FRAG_REFS = 16,
};

struct io_notif_data {
	struct file *file;
	struct ubuf_info uarg;
	long unsigned int account_pages;
};

struct io_shutdown {
	struct file *file;
	int how;
};

struct io_accept {
	struct file *file;
	struct sockaddr *addr;
	int *addr_len;
	int flags;
	u32 file_slot;
	long unsigned int nofile;
};

struct io_socket {
	struct file *file;
	int domain;
	int type;
	int protocol;
	int flags;
	u32 file_slot;
	long unsigned int nofile;
};

struct io_connect {
	struct file *file;
	struct sockaddr *addr;
	int addr_len;
	bool in_progress;
};

struct io_sr_msg {
	struct file *file;
	union {
		struct compat_msghdr *umsg_compat;
		struct user_msghdr *umsg;
		void *buf;
	};
	unsigned int len;
	unsigned int done_io;
	unsigned int msg_flags;
	u16 flags;
	u16 addr_len;
	void *addr;
	struct io_kiocb *notif;
};

struct io_recvmsg_multishot_hdr {
	struct io_uring_recvmsg_out msg;
	struct __kernel_sockaddr_storage addr;
};

enum {
	IORING_MSG_DATA = 0,
	IORING_MSG_SEND_FD = 1,
};

struct io_msg {
	struct file *file;
	int: 32;
	u64 user_data;
	u32 len;
	u32 cmd;
	u32 src_fd;
	u32 dst_fd;
	u32 flags;
	int: 32;
};

struct io_cancel_data {
	struct io_ring_ctx *ctx;
	int: 32;
	union {
		u64 data;
		struct file *file;
	};
	u32 flags;
	int seq;
};

struct io_timeout_data {
	struct io_kiocb *req;
	int: 32;
	struct hrtimer timer;
	struct timespec64 ts;
	enum hrtimer_mode mode;
	u32 flags;
};

struct io_timeout {
	struct file *file;
	u32 off;
	u32 target_seq;
	struct list_head list;
	struct io_kiocb *head;
	struct io_kiocb *prev;
};

struct io_timeout_rem {
	struct file *file;
	int: 32;
	u64 addr;
	struct timespec64 ts;
	u32 flags;
	bool ltimeout;
};

enum {
	IO_SQ_THREAD_SHOULD_STOP = 0,
	IO_SQ_THREAD_SHOULD_PARK = 1,
};

struct io_uring_rsrc_update {
	__u32 offset;
	__u32 resv;
	__u64 data;
};

typedef struct io_wq_work *free_work_fn(struct io_wq_work *);

typedef void io_wq_work_fn(struct io_wq_work *);

struct io_wq_data {
	struct io_wq_hash *hash;
	struct task_struct *task;
	io_wq_work_fn *do_work;
	free_work_fn *free_work;
};

struct io_poll_update {
	struct file *file;
	int: 32;
	u64 old_user_data;
	u64 new_user_data;
	__poll_t events;
	bool update_events;
	bool update_user_data;
};

struct io_poll_table {
	struct poll_table_struct pt;
	struct io_kiocb *req;
	int nr_entries;
	int error;
	bool owning;
	__poll_t result_mask;
};

enum {
	IOU_POLL_DONE = 0,
	IOU_POLL_NO_ACTION = 1,
	IOU_POLL_REMOVE_POLL_USE_RES = 2,
};

struct io_uring_sync_cancel_reg {
	__u64 addr;
	__s32 fd;
	__u32 flags;
	struct __kernel_timespec timeout;
	__u64 pad[4];
};

struct io_cancel {
	struct file *file;
	int: 32;
	u64 addr;
	u32 flags;
	s32 fd;
};

struct io_uring_buf_reg {
	__u64 ring_addr;
	__u32 ring_entries;
	__u16 bgid;
	__u16 pad;
	__u64 resv[3];
};

struct io_provide_buf {
	struct file *file;
	int: 32;
	__u64 addr;
	__u32 len;
	__u32 bgid;
	__u16 nbufs;
	__u16 bid;
	int: 32;
};

struct io_uring_rsrc_register {
	__u32 nr;
	__u32 flags;
	__u64 resv2;
	__u64 data;
	__u64 tags;
};

struct io_uring_rsrc_update2 {
	__u32 offset;
	__u32 resv;
	__u64 data;
	__u64 tags;
	__u32 nr;
	__u32 resv2;
};

struct scm_fp_list {
	short int count;
	short int max;
	struct user_struct *user;
	struct file *fp[253];
};

struct unix_skb_parms {
	struct pid *pid;
	kuid_t uid;
	kgid_t gid;
	struct scm_fp_list *fp;
	u32 consumed;
};

struct io_rsrc_update {
	struct file *file;
	int: 32;
	u64 arg;
	u32 nr_args;
	u32 offset;
};

struct iov_iter_state {
	size_t iov_offset;
	size_t count;
	long unsigned int nr_segs;
};

struct io_rw_state {
	struct iov_iter iter;
	struct iov_iter_state iter_state;
	struct iovec fast_iov[8];
	int: 32;
};

struct io_async_rw {
	struct io_rw_state s;
	const struct iovec *free_iovec;
	size_t bytes_done;
	struct wait_page_queue wpq;
	int: 32;
};

struct io_rw {
	struct kiocb kiocb;
	u64 addr;
	u32 len;
	rwf_t flags;
};

enum {
	IO_WQ_BOUND = 0,
	IO_WQ_UNBOUND = 1,
};

struct io_wqe;

struct io_wq {
	long unsigned int state;
	free_work_fn *free_work;
	io_wq_work_fn *do_work;
	struct io_wq_hash *hash;
	atomic_t worker_refs;
	struct completion worker_done;
	struct hlist_node cpuhp_node;
	struct task_struct *task;
	struct io_wqe *wqes[0];
};

typedef bool work_cancel_fn(struct io_wq_work *, void *);

enum {
	IO_WORKER_F_UP = 1,
	IO_WORKER_F_RUNNING = 2,
	IO_WORKER_F_FREE = 4,
	IO_WORKER_F_BOUND = 8,
};

enum {
	IO_WQ_BIT_EXIT = 0,
};

enum {
	IO_ACCT_STALLED_BIT = 0,
};

struct io_worker {
	refcount_t ref;
	unsigned int flags;
	struct hlist_nulls_node nulls_node;
	struct list_head all_list;
	struct task_struct *task;
	struct io_wqe *wqe;
	struct io_wq_work *cur_work;
	struct io_wq_work *next_work;
	raw_spinlock_t lock;
	struct completion ref_done;
	long unsigned int create_state;
	struct callback_head create_work;
	int create_index;
	union {
		struct callback_head rcu;
		struct work_struct work;
	};
};

struct io_wqe_acct {
	unsigned int nr_workers;
	unsigned int max_workers;
	int index;
	atomic_t nr_running;
	raw_spinlock_t lock;
	struct io_wq_work_list work_list;
	long unsigned int flags;
};

struct io_wqe {
	raw_spinlock_t lock;
	struct io_wqe_acct acct[2];
	int node;
	struct hlist_nulls_head free_list;
	struct list_head all_list;
	struct wait_queue_entry wait;
	struct io_wq *wq;
	struct io_wq_work *hash_tail[32];
	cpumask_var_t cpu_mask;
};

enum {
	IO_WQ_ACCT_BOUND = 0,
	IO_WQ_ACCT_UNBOUND = 1,
	IO_WQ_ACCT_NR = 2,
};

struct io_cb_cancel_data {
	work_cancel_fn *fn;
	void *data;
	int nr_running;
	int nr_pending;
	bool cancel_all;
};

struct online_data {
	unsigned int cpu;
	bool online;
};

typedef void (*swap_r_func_t)(void *, void *, int, const void *);

typedef void (*swap_func_t)(void *, void *, int);

typedef int (*cmp_r_func_t)(const void *, const void *, const void *);

struct wrapper {
	cmp_func_t cmp;
	swap_func_t swap;
};

typedef int __kernel_ptrdiff_t;

typedef __kernel_ptrdiff_t ptrdiff_t;

struct region {
	unsigned int start;
	unsigned int off;
	unsigned int group_len;
	unsigned int end;
	unsigned int nbits;
};

enum {
	REG_OP_ISFREE = 0,
	REG_OP_ALLOC = 1,
	REG_OP_RELEASE = 2,
};

struct sg_append_table {
	struct sg_table sgt;
	struct scatterlist *prv;
	unsigned int total_nents;
};

typedef struct scatterlist *sg_alloc_fn(unsigned int, gfp_t);

typedef void sg_free_fn(struct scatterlist *, unsigned int);

struct sg_page_iter {
	struct scatterlist *sg;
	unsigned int sg_pgoffset;
	unsigned int __nents;
	int __pg_advance;
};

struct sg_dma_page_iter {
	struct sg_page_iter base;
};

struct sg_mapping_iter {
	struct page *page;
	void *addr;
	size_t length;
	size_t consumed;
	struct sg_page_iter piter;
	unsigned int __offset;
	unsigned int __remaining;
	unsigned int __flags;
};

typedef int (*list_cmp_func_t)(void *, const struct list_head *, const struct list_head *);

struct csum_state {
	__wsum csum;
	size_t off;
};

typedef s32 compat_ssize_t;

struct compat_iovec {
	compat_uptr_t iov_base;
	compat_size_t iov_len;
};

struct rhashtable_walker {
	struct list_head list;
	struct bucket_table *tbl;
};

struct rhashtable_iter {
	struct rhashtable *ht;
	struct rhash_head *p;
	struct rhlist_head *list;
	struct rhashtable_walker walker;
	unsigned int slot;
	unsigned int skip;
	bool end_of_table;
};

union nested_table {
	union nested_table *table;
	struct rhash_lock_head *bucket;
};

struct once_work {
	struct work_struct work;
	struct static_key_true *key;
	struct module *module;
};

struct genradix_iter {
	size_t offset;
	size_t pos;
};

struct genradix_node {
	union {
		struct genradix_node *children[1024];
		u8 data[4096];
	};
};

enum string_size_units {
	STRING_UNITS_10 = 0,
	STRING_UNITS_2 = 1,
};

struct strarray {
	char **array;
	size_t n;
};

struct reciprocal_value_adv {
	u32 m;
	u8 sh;
	u8 exp;
	bool is_wide_m;
};

struct arc4_ctx {
	u32 S[256];
	u32 x;
	u32 y;
};

enum blake2s_lengths {
	BLAKE2S_BLOCK_SIZE = 64,
	BLAKE2S_HASH_SIZE = 32,
	BLAKE2S_KEY_SIZE = 32,
	BLAKE2S_128_HASH_SIZE = 16,
	BLAKE2S_160_HASH_SIZE = 20,
	BLAKE2S_224_HASH_SIZE = 28,
	BLAKE2S_256_HASH_SIZE = 32,
};

struct blake2s_state {
	u32 h[8];
	u32 t[2];
	u32 f[2];
	u8 buf[64];
	unsigned int buflen;
	unsigned int outlen;
};

enum blake2s_iv {
	BLAKE2S_IV0 = 1779033703,
	BLAKE2S_IV1 = 3144134277,
	BLAKE2S_IV2 = 1013904242,
	BLAKE2S_IV3 = 2773480762,
	BLAKE2S_IV4 = 1359893119,
	BLAKE2S_IV5 = 2600822924,
	BLAKE2S_IV6 = 528734635,
	BLAKE2S_IV7 = 1541459225,
};

enum devm_ioremap_type {
	DEVM_IOREMAP = 0,
	DEVM_IOREMAP_UC = 1,
	DEVM_IOREMAP_WC = 2,
	DEVM_IOREMAP_NP = 3,
};

struct pcim_iomap_devres {
	void *table[6];
};

struct arch_io_reserve_memtype_wc_devres {
	resource_size_t start;
	resource_size_t size;
};

enum assoc_array_walk_status {
	assoc_array_walk_tree_empty = 0,
	assoc_array_walk_found_terminal_node = 1,
	assoc_array_walk_found_wrong_shortcut = 2,
};

struct assoc_array_walk_result {
	struct {
		struct assoc_array_node *node;
		int level;
		int slot;
	} terminal_node;
	struct {
		struct assoc_array_shortcut *shortcut;
		int level;
		int sc_level;
		long unsigned int sc_segments;
		long unsigned int dissimilarity;
	} wrong_shortcut;
};

struct assoc_array_delete_collapse_context {
	struct assoc_array_node *node;
	const void *skip_leaf;
	int slot;
};

struct xxh32_state {
	uint32_t total_len_32;
	uint32_t large_len;
	uint32_t v1;
	uint32_t v2;
	uint32_t v3;
	uint32_t v4;
	uint32_t mem32[4];
	uint32_t memsize;
};

struct xxh64_state {
	uint64_t total_len;
	uint64_t v1;
	uint64_t v2;
	uint64_t v3;
	uint64_t v4;
	uint64_t mem64[4];
	uint32_t memsize;
	int: 32;
};

struct gen_pool_chunk {
	struct list_head next_chunk;
	atomic_long_t avail;
	phys_addr_t phys_addr;
	void *owner;
	long unsigned int start_addr;
	long unsigned int end_addr;
	long unsigned int bits[0];
};

struct genpool_data_align {
	int align;
};

struct genpool_data_fixed {
	long unsigned int offset;
};

typedef z_stream *z_streamp;

typedef struct {
	unsigned char op;
	unsigned char bits;
	short unsigned int val;
} code;

typedef enum {
	HEAD = 0,
	FLAGS = 1,
	TIME = 2,
	OS = 3,
	EXLEN = 4,
	EXTRA = 5,
	NAME = 6,
	COMMENT = 7,
	HCRC = 8,
	DICTID = 9,
	DICT = 10,
	TYPE = 11,
	TYPEDO = 12,
	STORED = 13,
	COPY = 14,
	TABLE = 15,
	LENLENS = 16,
	CODELENS = 17,
	LEN = 18,
	LENEXT = 19,
	DIST = 20,
	DISTEXT = 21,
	MATCH = 22,
	LIT = 23,
	CHECK = 24,
	LENGTH = 25,
	DONE = 26,
	BAD = 27,
	MEM = 28,
	SYNC = 29,
} inflate_mode;

struct inflate_state {
	inflate_mode mode;
	int last;
	int wrap;
	int havedict;
	int flags;
	unsigned int dmax;
	long unsigned int check;
	long unsigned int total;
	unsigned int wbits;
	unsigned int wsize;
	unsigned int whave;
	unsigned int write;
	unsigned char *window;
	long unsigned int hold;
	unsigned int bits;
	unsigned int length;
	unsigned int offset;
	unsigned int extra;
	const code *lencode;
	const code *distcode;
	unsigned int lenbits;
	unsigned int distbits;
	unsigned int ncode;
	unsigned int nlen;
	unsigned int ndist;
	unsigned int have;
	code *next;
	short unsigned int lens[320];
	short unsigned int work[288];
	code codes[2048];
};

union uu {
	short unsigned int us;
	unsigned char b[2];
};

typedef unsigned int uInt;

struct inflate_workspace {
	struct inflate_state inflate_state;
	unsigned char working_window[32768];
};

typedef enum {
	CODES = 0,
	LENS = 1,
	DISTS = 2,
} codetype;

typedef unsigned char uch;

typedef short unsigned int ush;

typedef long unsigned int ulg;

struct ct_data_s {
	union {
		ush freq;
		ush code;
	} fc;
	union {
		ush dad;
		ush len;
	} dl;
};

typedef struct ct_data_s ct_data;

struct static_tree_desc_s {
	const ct_data *static_tree;
	const int *extra_bits;
	int extra_base;
	int elems;
	int max_length;
};

typedef struct static_tree_desc_s static_tree_desc;

struct tree_desc_s {
	ct_data *dyn_tree;
	int max_code;
	static_tree_desc *stat_desc;
};

typedef ush Pos;

typedef unsigned int IPos;

struct deflate_state {
	z_streamp strm;
	int status;
	Byte *pending_buf;
	ulg pending_buf_size;
	Byte *pending_out;
	int pending;
	int noheader;
	Byte data_type;
	Byte method;
	int last_flush;
	uInt w_size;
	uInt w_bits;
	uInt w_mask;
	Byte *window;
	ulg window_size;
	Pos *prev;
	Pos *head;
	uInt ins_h;
	uInt hash_size;
	uInt hash_bits;
	uInt hash_mask;
	uInt hash_shift;
	long int block_start;
	uInt match_length;
	IPos prev_match;
	int match_available;
	uInt strstart;
	uInt match_start;
	uInt lookahead;
	uInt prev_length;
	uInt max_chain_length;
	uInt max_lazy_match;
	int level;
	int strategy;
	uInt good_match;
	int nice_match;
	struct ct_data_s dyn_ltree[573];
	struct ct_data_s dyn_dtree[61];
	struct ct_data_s bl_tree[39];
	struct tree_desc_s l_desc;
	struct tree_desc_s d_desc;
	struct tree_desc_s bl_desc;
	ush bl_count[16];
	int heap[573];
	int heap_len;
	int heap_max;
	uch depth[573];
	uch *l_buf;
	uInt lit_bufsize;
	uInt last_lit;
	ush *d_buf;
	ulg opt_len;
	ulg static_len;
	ulg compressed_len;
	uInt matches;
	int last_eob_len;
	ush bi_buf;
	int bi_valid;
};

typedef struct deflate_state deflate_state;

typedef enum {
	need_more = 0,
	block_done = 1,
	finish_started = 2,
	finish_done = 3,
} block_state;

typedef block_state (*compress_func)(deflate_state *, int);

struct deflate_workspace {
	deflate_state deflate_memory;
	Byte *window_memory;
	Pos *prev_memory;
	Pos *head_memory;
	char *overlay_memory;
};

typedef struct deflate_workspace deflate_workspace;

struct config_s {
	ush good_length;
	ush max_lazy;
	ush nice_length;
	ush max_chain;
	compress_func func;
};

typedef struct config_s config;

typedef struct tree_desc_s tree_desc;

typedef struct {
	const uint8_t *externalDict;
	size_t extDictSize;
	const uint8_t *prefixEnd;
	size_t prefixSize;
} LZ4_streamDecode_t_internal;

typedef union {
	long long unsigned int table[4];
	LZ4_streamDecode_t_internal internal_donotuse;
} LZ4_streamDecode_t;

typedef uint8_t BYTE;

typedef uint16_t U16;

typedef uint32_t U32;

typedef uintptr_t uptrval;

typedef enum {
	noDict = 0,
	withPrefix64k = 1,
	usingExtDict = 2,
} dict_directive;

typedef enum {
	endOnOutputSize = 0,
	endOnInputSize = 1,
} endCondition_directive;

typedef enum {
	decode_full_block = 0,
	partial_decode = 1,
} earlyEnd_directive;

typedef s16 int16_t;

struct ZSTD_inBuffer_s {
	const void *src;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_inBuffer_s ZSTD_inBuffer;

struct ZSTD_outBuffer_s {
	void *dst;
	size_t size;
	size_t pos;
};

typedef struct ZSTD_outBuffer_s ZSTD_outBuffer;

typedef ZSTD_CCtx ZSTD_CStream;

typedef ZSTD_compressionParameters zstd_compression_parameters;

typedef ZSTD_inBuffer zstd_in_buffer;

typedef ZSTD_outBuffer zstd_out_buffer;

typedef ZSTD_CStream zstd_cstream;

typedef int16_t S16;

typedef uint64_t U64;

typedef struct {
	size_t bitContainer;
	unsigned int bitPos;
	char *startPtr;
	char *ptr;
	char *endPtr;
} BIT_CStream_t;

typedef unsigned int FSE_CTable;

typedef struct {
	ptrdiff_t value;
	const void *stateTable;
	const void *symbolTT;
	unsigned int stateLog;
} FSE_CState_t;

typedef struct {
	int deltaFindState;
	U32 deltaNbBits;
} FSE_symbolCompressionTransform;

typedef enum {
	trustInput = 0,
	checkMaxSymbolValue = 1,
} HIST_checkInput_e;

struct HUF_CElt_s {
	U16 val;
	BYTE nbBits;
};

typedef struct HUF_CElt_s HUF_CElt;

typedef enum {
	HUF_repeat_none = 0,
	HUF_repeat_check = 1,
	HUF_repeat_valid = 2,
} HUF_repeat;

typedef struct {
	FSE_CTable CTable[59];
	U32 scratchBuffer[30];
	unsigned int count[13];
	S16 norm[13];
} HUF_CompressWeightsWksp;

typedef struct {
	HUF_CompressWeightsWksp wksp;
	BYTE bitsToWeight[13];
	BYTE huffWeight[255];
} HUF_WriteCTableWksp;

struct nodeElt_s {
	U32 count;
	U16 parent;
	BYTE byte;
	BYTE nbBits;
};

typedef struct nodeElt_s nodeElt;

typedef struct {
	U32 base;
	U32 curr;
} rankPos;

typedef nodeElt huffNodeTable[512];

typedef struct {
	huffNodeTable huffNodeTbl;
	rankPos rankPosition[32];
} HUF_buildCTable_wksp_tables;

typedef enum {
	HUF_singleStream = 0,
	HUF_fourStreams = 1,
} HUF_nbStreams_e;

typedef struct {
	unsigned int count[256];
	HUF_CElt CTable[256];
	union {
		HUF_buildCTable_wksp_tables buildCTable_wksp;
		HUF_WriteCTableWksp writeCTable_wksp;
	} wksps;
} HUF_compress_tables_t;

typedef struct {
	U32 f1c;
	U32 f1d;
	U32 f7b;
	U32 f7c;
} ZSTD_cpuid_t;

typedef enum {
	FSE_repeat_none = 0,
	FSE_repeat_check = 1,
	FSE_repeat_valid = 2,
} FSE_repeat;

typedef enum {
	ZSTDcs_created = 0,
	ZSTDcs_init = 1,
	ZSTDcs_ongoing = 2,
	ZSTDcs_ending = 3,
} ZSTD_compressionStage_e;

typedef enum {
	ZSTD_f_zstd1 = 0,
	ZSTD_f_zstd1_magicless = 1,
} ZSTD_format_e;

typedef enum {
	ZSTD_dictDefaultAttach = 0,
	ZSTD_dictForceAttach = 1,
	ZSTD_dictForceCopy = 2,
	ZSTD_dictForceLoad = 3,
} ZSTD_dictAttachPref_e;

typedef enum {
	ZSTD_lcm_auto = 0,
	ZSTD_lcm_huffman = 1,
	ZSTD_lcm_uncompressed = 2,
} ZSTD_literalCompressionMode_e;

typedef struct {
	U32 enableLdm;
	U32 hashLog;
	U32 bucketSizeLog;
	U32 minMatchLength;
	U32 hashRateLog;
	U32 windowLog;
} ldmParams_t;

typedef enum {
	ZSTD_bm_buffered = 0,
	ZSTD_bm_stable = 1,
} ZSTD_bufferMode_e;

typedef enum {
	ZSTD_sf_noBlockDelimiters = 0,
	ZSTD_sf_explicitBlockDelimiters = 1,
} ZSTD_sequenceFormat_e;

struct ZSTD_CCtx_params_s {
	ZSTD_format_e format;
	ZSTD_compressionParameters cParams;
	ZSTD_frameParameters fParams;
	int compressionLevel;
	int forceWindow;
	size_t targetCBlockSize;
	int srcSizeHint;
	ZSTD_dictAttachPref_e attachDictPref;
	ZSTD_literalCompressionMode_e literalCompressionMode;
	int nbWorkers;
	size_t jobSize;
	int overlapLog;
	int rsyncable;
	ldmParams_t ldmParams;
	int enableDedicatedDictSearch;
	ZSTD_bufferMode_e inBufferMode;
	ZSTD_bufferMode_e outBufferMode;
	ZSTD_sequenceFormat_e blockDelimiters;
	int validateSequences;
	ZSTD_customMem customMem;
};

typedef struct ZSTD_CCtx_params_s ZSTD_CCtx_params;

typedef enum {
	ZSTD_cwksp_alloc_objects = 0,
	ZSTD_cwksp_alloc_buffers = 1,
	ZSTD_cwksp_alloc_aligned = 2,
} ZSTD_cwksp_alloc_phase_e;

typedef enum {
	ZSTD_cwksp_dynamic_alloc = 0,
	ZSTD_cwksp_static_alloc = 1,
} ZSTD_cwksp_static_alloc_e;

typedef struct {
	void *workspace;
	void *workspaceEnd;
	void *objectEnd;
	void *tableEnd;
	void *tableValidEnd;
	void *allocStart;
	BYTE allocFailed;
	int workspaceOversizedDuration;
	ZSTD_cwksp_alloc_phase_e phase;
	ZSTD_cwksp_static_alloc_e isStatic;
} ZSTD_cwksp;

struct POOL_ctx_s;

typedef struct POOL_ctx_s ZSTD_threadPool;

typedef struct {
	unsigned int offset;
	unsigned int litLength;
	unsigned int matchLength;
	unsigned int rep;
} ZSTD_Sequence;

typedef struct {
	int collectSequences;
	ZSTD_Sequence *seqStart;
	size_t seqIndex;
	size_t maxSequences;
} SeqCollector;

struct seqDef_s;

typedef struct seqDef_s seqDef;

typedef struct {
	seqDef *sequencesStart;
	seqDef *sequences;
	BYTE *litStart;
	BYTE *lit;
	BYTE *llCode;
	BYTE *mlCode;
	BYTE *ofCode;
	size_t maxNbSeq;
	size_t maxNbLit;
	U32 longLengthID;
	U32 longLengthPos;
} seqStore_t;

typedef struct {
	const BYTE *nextSrc;
	const BYTE *base;
	const BYTE *dictBase;
	U32 dictLimit;
	U32 lowLimit;
} ZSTD_window_t;

typedef struct {
	U32 offset;
	U32 checksum;
} ldmEntry_t;

typedef struct {
	const BYTE *split;
	U32 hash;
	U32 checksum;
	ldmEntry_t *bucket;
} ldmMatchCandidate_t;

typedef struct {
	ZSTD_window_t window;
	ldmEntry_t *hashTable;
	U32 loadedDictEnd;
	BYTE *bucketOffsets;
	size_t splitIndices[64];
	ldmMatchCandidate_t matchCandidates[64];
} ldmState_t;

typedef struct {
	U32 offset;
	U32 litLength;
	U32 matchLength;
} rawSeq;

typedef struct {
	rawSeq *seq;
	size_t pos;
	size_t posInSequence;
	size_t size;
	size_t capacity;
} rawSeqStore_t;

typedef struct {
	HUF_CElt CTable[256];
	HUF_repeat repeatMode;
} ZSTD_hufCTables_t;

typedef struct {
	FSE_CTable offcodeCTable[193];
	FSE_CTable matchlengthCTable[363];
	FSE_CTable litlengthCTable[329];
	FSE_repeat offcode_repeatMode;
	FSE_repeat matchlength_repeatMode;
	FSE_repeat litlength_repeatMode;
} ZSTD_fseCTables_t;

typedef struct {
	ZSTD_hufCTables_t huf;
	ZSTD_fseCTables_t fse;
} ZSTD_entropyCTables_t;

typedef struct {
	ZSTD_entropyCTables_t entropy;
	U32 rep[3];
} ZSTD_compressedBlockState_t;

typedef struct {
	U32 off;
	U32 len;
} ZSTD_match_t;

typedef struct {
	int price;
	U32 off;
	U32 mlen;
	U32 litlen;
	U32 rep[3];
} ZSTD_optimal_t;

typedef enum {
	zop_dynamic = 0,
	zop_predef = 1,
} ZSTD_OptPrice_e;

typedef struct {
	unsigned int *litFreq;
	unsigned int *litLengthFreq;
	unsigned int *matchLengthFreq;
	unsigned int *offCodeFreq;
	ZSTD_match_t *matchTable;
	ZSTD_optimal_t *priceTable;
	U32 litSum;
	U32 litLengthSum;
	U32 matchLengthSum;
	U32 offCodeSum;
	U32 litSumBasePrice;
	U32 litLengthSumBasePrice;
	U32 matchLengthSumBasePrice;
	U32 offCodeSumBasePrice;
	ZSTD_OptPrice_e priceType;
	const ZSTD_entropyCTables_t *symbolCosts;
	ZSTD_literalCompressionMode_e literalCompressionMode;
} optState_t;

struct ZSTD_matchState_t;

typedef struct ZSTD_matchState_t ZSTD_matchState_t;

struct ZSTD_matchState_t {
	ZSTD_window_t window;
	U32 loadedDictEnd;
	U32 nextToUpdate;
	U32 hashLog3;
	U32 *hashTable;
	U32 *hashTable3;
	U32 *chainTable;
	int dedicatedDictSearch;
	optState_t opt;
	const ZSTD_matchState_t *dictMatchState;
	ZSTD_compressionParameters cParams;
	const rawSeqStore_t *ldmSeqStore;
};

typedef struct {
	ZSTD_compressedBlockState_t *prevCBlock;
	ZSTD_compressedBlockState_t *nextCBlock;
	ZSTD_matchState_t matchState;
} ZSTD_blockState_t;

typedef enum {
	ZSTDb_not_buffered = 0,
	ZSTDb_buffered = 1,
} ZSTD_buffered_policy_e;

typedef enum {
	zcss_init = 0,
	zcss_load = 1,
	zcss_flush = 2,
} ZSTD_cStreamStage;

typedef enum {
	ZSTD_dct_auto = 0,
	ZSTD_dct_rawContent = 1,
	ZSTD_dct_fullDict = 2,
} ZSTD_dictContentType_e;

struct ZSTD_CDict_s;

typedef struct ZSTD_CDict_s ZSTD_CDict;

typedef struct {
	void *dictBuffer;
	const void *dict;
	size_t dictSize;
	ZSTD_dictContentType_e dictContentType;
	ZSTD_CDict *cdict;
} ZSTD_localDict;

struct ZSTD_prefixDict_s {
	const void *dict;
	size_t dictSize;
	ZSTD_dictContentType_e dictContentType;
};

typedef struct ZSTD_prefixDict_s ZSTD_prefixDict;

struct ZSTD_CCtx_s {
	ZSTD_compressionStage_e stage;
	int cParamsChanged;
	int bmi2;
	ZSTD_CCtx_params requestedParams;
	ZSTD_CCtx_params appliedParams;
	U32 dictID;
	size_t dictContentSize;
	ZSTD_cwksp workspace;
	size_t blockSize;
	long long unsigned int pledgedSrcSizePlusOne;
	long long unsigned int consumedSrcSize;
	long long unsigned int producedCSize;
	struct xxh64_state xxhState;
	ZSTD_customMem customMem;
	ZSTD_threadPool *pool;
	size_t staticSize;
	SeqCollector seqCollector;
	int isFirstBlock;
	int initialized;
	seqStore_t seqStore;
	ldmState_t ldmState;
	rawSeq *ldmSequences;
	size_t maxNbLdmSequences;
	rawSeqStore_t externSeqStore;
	ZSTD_blockState_t blockState;
	U32 *entropyWorkspace;
	ZSTD_buffered_policy_e bufferedPolicy;
	char *inBuff;
	size_t inBuffSize;
	size_t inToCompress;
	size_t inBuffPos;
	size_t inBuffTarget;
	char *outBuff;
	size_t outBuffSize;
	size_t outBuffContentSize;
	size_t outBuffFlushedSize;
	ZSTD_cStreamStage streamStage;
	U32 frameEnded;
	ZSTD_inBuffer expectedInBuffer;
	size_t expectedOutBufferSize;
	ZSTD_localDict localDict;
	const ZSTD_CDict *cdict;
	ZSTD_prefixDict prefixDict;
	int: 32;
};

typedef struct ZSTD_CCtx_s ZSTD_CCtx___2;

typedef enum {
	ZSTD_c_compressionLevel = 100,
	ZSTD_c_windowLog = 101,
	ZSTD_c_hashLog = 102,
	ZSTD_c_chainLog = 103,
	ZSTD_c_searchLog = 104,
	ZSTD_c_minMatch = 105,
	ZSTD_c_targetLength = 106,
	ZSTD_c_strategy = 107,
	ZSTD_c_enableLongDistanceMatching = 160,
	ZSTD_c_ldmHashLog = 161,
	ZSTD_c_ldmMinMatch = 162,
	ZSTD_c_ldmBucketSizeLog = 163,
	ZSTD_c_ldmHashRateLog = 164,
	ZSTD_c_contentSizeFlag = 200,
	ZSTD_c_checksumFlag = 201,
	ZSTD_c_dictIDFlag = 202,
	ZSTD_c_nbWorkers = 400,
	ZSTD_c_jobSize = 401,
	ZSTD_c_overlapLog = 402,
	ZSTD_c_experimentalParam1 = 500,
	ZSTD_c_experimentalParam2 = 10,
	ZSTD_c_experimentalParam3 = 1000,
	ZSTD_c_experimentalParam4 = 1001,
	ZSTD_c_experimentalParam5 = 1002,
	ZSTD_c_experimentalParam6 = 1003,
	ZSTD_c_experimentalParam7 = 1004,
	ZSTD_c_experimentalParam8 = 1005,
	ZSTD_c_experimentalParam9 = 1006,
	ZSTD_c_experimentalParam10 = 1007,
	ZSTD_c_experimentalParam11 = 1008,
	ZSTD_c_experimentalParam12 = 1009,
} ZSTD_cParameter;

typedef struct {
	size_t error;
	int lowerBound;
	int upperBound;
} ZSTD_bounds;

typedef enum {
	ZSTD_reset_session_only = 1,
	ZSTD_reset_parameters = 2,
	ZSTD_reset_session_and_parameters = 3,
} ZSTD_ResetDirective;

typedef ZSTD_CCtx___2 ZSTD_CStream___2;

typedef enum {
	ZSTD_e_continue = 0,
	ZSTD_e_flush = 1,
	ZSTD_e_end = 2,
} ZSTD_EndDirective;

struct ZSTD_CDict_s {
	const void *dictContent;
	size_t dictContentSize;
	ZSTD_dictContentType_e dictContentType;
	U32 *entropyWorkspace;
	ZSTD_cwksp workspace;
	ZSTD_matchState_t matchState;
	ZSTD_compressedBlockState_t cBlockState;
	ZSTD_customMem customMem;
	U32 dictID;
	int compressionLevel;
};

typedef enum {
	ZSTD_dlm_byCopy = 0,
	ZSTD_dlm_byRef = 1,
} ZSTD_dictLoadMethod_e;

typedef struct {
	long long unsigned int ingested;
	long long unsigned int consumed;
	long long unsigned int produced;
	long long unsigned int flushed;
	unsigned int currentJobID;
	unsigned int nbActiveWorkers;
} ZSTD_frameProgression;

typedef enum {
	set_basic = 0,
	set_rle = 1,
	set_compressed = 2,
	set_repeat = 3,
} symbolEncodingType_e;

typedef enum {
	ZSTD_no_overlap = 0,
	ZSTD_overlap_src_before_dst = 1,
} ZSTD_overlap_e;

struct seqDef_s {
	U32 offset;
	U16 litLength;
	U16 matchLength;
};

typedef enum {
	ZSTD_dtlm_fast = 0,
	ZSTD_dtlm_full = 1,
} ZSTD_dictTableLoadMethod_e;

typedef enum {
	ZSTD_noDict = 0,
	ZSTD_extDict = 1,
	ZSTD_dictMatchState = 2,
	ZSTD_dedicatedDictSearch = 3,
} ZSTD_dictMode_e;

typedef enum {
	ZSTD_cpm_noAttachDict = 0,
	ZSTD_cpm_attachDict = 1,
	ZSTD_cpm_createCDict = 2,
	ZSTD_cpm_unknown = 3,
} ZSTD_cParamMode_e;

typedef size_t (*ZSTD_blockCompressor)(ZSTD_matchState_t *, seqStore_t *, U32 *, const void *, size_t);

struct repcodes_s {
	U32 rep[3];
};

typedef struct repcodes_s repcodes_t;

typedef enum {
	ZSTD_defaultDisallowed = 0,
	ZSTD_defaultAllowed = 1,
} ZSTD_defaultPolicy_e;

typedef enum {
	ZSTDcrp_makeClean = 0,
	ZSTDcrp_leaveDirty = 1,
} ZSTD_compResetPolicy_e;

typedef enum {
	ZSTDirp_continue = 0,
	ZSTDirp_reset = 1,
} ZSTD_indexResetPolicy_e;

typedef enum {
	ZSTD_resetTarget_CDict = 0,
	ZSTD_resetTarget_CCtx = 1,
} ZSTD_resetTarget_e;

enum {
	ZSTDbss_compress = 0,
	ZSTDbss_noCompress = 1,
};

typedef struct {
	U32 idx;
	U32 posInSequence;
	size_t posInSrc;
} ZSTD_sequencePosition;

typedef size_t (*ZSTD_sequenceCopier)(ZSTD_CCtx___2 *, ZSTD_sequencePosition *, const ZSTD_Sequence * const, size_t, const void *, size_t);

typedef struct {
	S16 norm[53];
	U32 wksp[182];
} ZSTD_BuildCTableWksp;

typedef struct {
	U32 litLength;
	U32 matchLength;
} ZSTD_sequenceLength;

typedef struct {
	symbolEncodingType_e hType;
	BYTE hufDesBuffer[128];
	size_t hufDesSize;
} ZSTD_hufCTablesMetadata_t;

typedef struct {
	symbolEncodingType_e llType;
	symbolEncodingType_e ofType;
	symbolEncodingType_e mlType;
	BYTE fseTablesBuffer[133];
	size_t fseTablesSize;
	size_t lastCountSize;
} ZSTD_fseCTablesMetadata_t;

typedef struct {
	ZSTD_hufCTablesMetadata_t hufMetadata;
	ZSTD_fseCTablesMetadata_t fseMetadata;
} ZSTD_entropyCTablesMetadata_t;

typedef enum {
	search_hashChain = 0,
	search_binaryTree = 1,
} searchMethod_e;

typedef size_t (*searchMax_f)(ZSTD_matchState_t *, const BYTE *, const BYTE *, size_t *);

typedef struct {
	U64 rolling;
	U64 stopMask;
} ldmRollingHashState_t;

typedef struct {
	rawSeqStore_t seqStore;
	U32 startPosInBlock;
	U32 endPosInBlock;
	U32 offset;
} ZSTD_optLdm_t;

typedef enum {
	ZSTD_error_no_error = 0,
	ZSTD_error_GENERIC = 1,
	ZSTD_error_prefix_unknown = 10,
	ZSTD_error_version_unsupported = 12,
	ZSTD_error_frameParameter_unsupported = 14,
	ZSTD_error_frameParameter_windowTooLarge = 16,
	ZSTD_error_corruption_detected = 20,
	ZSTD_error_checksum_wrong = 22,
	ZSTD_error_dictionary_corrupted = 30,
	ZSTD_error_dictionary_wrong = 32,
	ZSTD_error_dictionaryCreation_failed = 34,
	ZSTD_error_parameter_unsupported = 40,
	ZSTD_error_parameter_outOfBound = 42,
	ZSTD_error_tableLog_tooLarge = 44,
	ZSTD_error_maxSymbolValue_tooLarge = 46,
	ZSTD_error_maxSymbolValue_tooSmall = 48,
	ZSTD_error_stage_wrong = 60,
	ZSTD_error_init_missing = 62,
	ZSTD_error_memory_allocation = 64,
	ZSTD_error_workSpace_tooSmall = 66,
	ZSTD_error_dstSize_tooSmall = 70,
	ZSTD_error_srcSize_wrong = 72,
	ZSTD_error_dstBuffer_null = 74,
	ZSTD_error_frameIndex_tooLarge = 100,
	ZSTD_error_seekableIO = 102,
	ZSTD_error_dstBuffer_wrong = 104,
	ZSTD_error_srcBuffer_wrong = 105,
	ZSTD_error_maxCode = 120,
} ZSTD_ErrorCode;

typedef ZSTD_DCtx ZSTD_DStream;

typedef enum {
	ZSTD_frame = 0,
	ZSTD_skippableFrame = 1,
} ZSTD_frameType_e;

typedef struct {
	long long unsigned int frameContentSize;
	long long unsigned int windowSize;
	unsigned int blockSizeMax;
	ZSTD_frameType_e frameType;
	unsigned int headerSize;
	unsigned int dictID;
	unsigned int checksumFlag;
	int: 32;
} ZSTD_frameHeader;

typedef ZSTD_ErrorCode zstd_error_code;

typedef ZSTD_DStream zstd_dstream;

typedef ZSTD_frameHeader zstd_frame_header;

typedef struct {
	size_t bitContainer;
	unsigned int bitsConsumed;
	const char *ptr;
	const char *start;
	const char *limitPtr;
} BIT_DStream_t;

typedef enum {
	BIT_DStream_unfinished = 0,
	BIT_DStream_endOfBuffer = 1,
	BIT_DStream_completed = 2,
	BIT_DStream_overflow = 3,
} BIT_DStream_status;

typedef U32 HUF_DTable;

typedef struct {
	BYTE maxTableLog;
	BYTE tableType;
	BYTE tableLog;
	BYTE reserved;
} DTableDesc;

typedef struct {
	BYTE byte;
	BYTE nbBits;
} HUF_DEltX1;

typedef struct {
	U32 rankVal[16];
	U32 rankStart[16];
	U32 statsWksp[218];
	BYTE symbols[256];
	BYTE huffWeight[256];
} HUF_ReadDTableX1_Workspace;

typedef struct {
	U16 sequence;
	BYTE nbBits;
	BYTE length;
} HUF_DEltX2;

typedef struct {
	BYTE symbol;
	BYTE weight;
} sortedSymbol_t;

typedef U32 rankValCol_t[13];

typedef struct {
	U32 rankVal[156];
	U32 rankStats[13];
	U32 rankStart0[14];
	sortedSymbol_t sortedSymbol[256];
	BYTE weightList[256];
	U32 calleeWksp[218];
} HUF_ReadDTableX2_Workspace;

typedef struct {
	U32 tableTime;
	U32 decode256Time;
} algo_time_t;

typedef struct {
	U16 nextState;
	BYTE nbAdditionalBits;
	BYTE nbBits;
	U32 baseValue;
} ZSTD_seqSymbol;

typedef struct {
	ZSTD_seqSymbol LLTable[513];
	ZSTD_seqSymbol OFTable[257];
	ZSTD_seqSymbol MLTable[513];
	HUF_DTable hufTable[4097];
	U32 rep[3];
	U32 workspace[157];
} ZSTD_entropyDTables_t;

typedef enum {
	bt_raw = 0,
	bt_rle = 1,
	bt_compressed = 2,
	bt_reserved = 3,
} blockType_e;

typedef enum {
	ZSTDds_getFrameHeaderSize = 0,
	ZSTDds_decodeFrameHeader = 1,
	ZSTDds_decodeBlockHeader = 2,
	ZSTDds_decompressBlock = 3,
	ZSTDds_decompressLastBlock = 4,
	ZSTDds_checkChecksum = 5,
	ZSTDds_decodeSkippableHeader = 6,
	ZSTDds_skipFrame = 7,
} ZSTD_dStage;

typedef enum {
	ZSTD_d_validateChecksum = 0,
	ZSTD_d_ignoreChecksum = 1,
} ZSTD_forceIgnoreChecksum_e;

typedef enum {
	ZSTD_use_indefinitely = 4294967295,
	ZSTD_dont_use = 0,
	ZSTD_use_once = 1,
} ZSTD_dictUses_e;

struct ZSTD_DDict_s;

typedef struct ZSTD_DDict_s ZSTD_DDict;

typedef struct {
	const ZSTD_DDict **ddictPtrTable;
	size_t ddictPtrTableSize;
	size_t ddictPtrCount;
} ZSTD_DDictHashSet;

typedef enum {
	ZSTD_rmd_refSingleDDict = 0,
	ZSTD_rmd_refMultipleDDicts = 1,
} ZSTD_refMultipleDDicts_e;

typedef enum {
	zdss_init = 0,
	zdss_loadHeader = 1,
	zdss_read = 2,
	zdss_load = 3,
	zdss_flush = 4,
} ZSTD_dStreamStage;

struct ZSTD_DCtx_s {
	const ZSTD_seqSymbol *LLTptr;
	const ZSTD_seqSymbol *MLTptr;
	const ZSTD_seqSymbol *OFTptr;
	const HUF_DTable *HUFptr;
	ZSTD_entropyDTables_t entropy;
	U32 workspace[640];
	const void *previousDstEnd;
	const void *prefixStart;
	const void *virtualStart;
	const void *dictEnd;
	size_t expected;
	ZSTD_frameHeader fParams;
	U64 processedCSize;
	U64 decodedSize;
	blockType_e bType;
	ZSTD_dStage stage;
	U32 litEntropy;
	U32 fseEntropy;
	struct xxh64_state xxhState;
	size_t headerSize;
	ZSTD_format_e format;
	ZSTD_forceIgnoreChecksum_e forceIgnoreChecksum;
	U32 validateChecksum;
	const BYTE *litPtr;
	ZSTD_customMem customMem;
	size_t litSize;
	size_t rleSize;
	size_t staticSize;
	int bmi2;
	ZSTD_DDict *ddictLocal;
	const ZSTD_DDict *ddict;
	U32 dictID;
	int ddictIsCold;
	ZSTD_dictUses_e dictUses;
	ZSTD_DDictHashSet *ddictSet;
	ZSTD_refMultipleDDicts_e refMultipleDDicts;
	ZSTD_dStreamStage streamStage;
	char *inBuff;
	size_t inBuffSize;
	size_t inPos;
	size_t maxWindowSize;
	char *outBuff;
	size_t outBuffSize;
	size_t outStart;
	size_t outEnd;
	size_t lhSize;
	void *legacyContext;
	U32 previousLegacyVersion;
	U32 legacyVersion;
	U32 hostageByte;
	int noForwardProgress;
	ZSTD_bufferMode_e outBufferMode;
	ZSTD_outBuffer expectedOutBuffer;
	BYTE litBuffer[131104];
	BYTE headerBuffer[18];
	size_t oversizedDuration;
};

typedef struct ZSTD_DCtx_s ZSTD_DCtx___2;

struct ZSTD_DDict_s {
	void *dictBuffer;
	const void *dictContent;
	size_t dictSize;
	ZSTD_entropyDTables_t entropy;
	U32 dictID;
	U32 entropyPresent;
	ZSTD_customMem cMem;
};

typedef enum {
	ZSTD_d_windowLogMax = 100,
	ZSTD_d_experimentalParam1 = 1000,
	ZSTD_d_experimentalParam2 = 1001,
	ZSTD_d_experimentalParam3 = 1002,
	ZSTD_d_experimentalParam4 = 1003,
} ZSTD_dParameter;

typedef ZSTD_DCtx___2 ZSTD_DStream___2;

typedef enum {
	ZSTDnit_frameHeader = 0,
	ZSTDnit_blockHeader = 1,
	ZSTDnit_block = 2,
	ZSTDnit_lastBlock = 3,
	ZSTDnit_checksum = 4,
	ZSTDnit_skippableFrame = 5,
} ZSTD_nextInputType_e;

typedef struct {
	size_t compressedSize;
	int: 32;
	long long unsigned int decompressedBound;
} ZSTD_frameSizeInfo;

typedef struct {
	blockType_e blockType;
	U32 lastBlock;
	U32 origSize;
} blockProperties_t;

typedef struct {
	U32 fastMode;
	U32 tableLog;
} ZSTD_seqSymbol_header;

typedef struct {
	size_t litLength;
	size_t matchLength;
	size_t offset;
	const BYTE *match;
} seq_t;

typedef struct {
	size_t state;
	const ZSTD_seqSymbol *table;
} ZSTD_fseState;

typedef struct {
	BIT_DStream_t DStream;
	ZSTD_fseState stateLL;
	ZSTD_fseState stateOffb;
	ZSTD_fseState stateML;
	size_t prevOffset[3];
	const BYTE *prefixStart;
	const BYTE *dictEnd;
	size_t pos;
} seqState_t;

typedef enum {
	ZSTD_lo_isRegularOffset = 0,
	ZSTD_lo_isLongOffset = 1,
} ZSTD_longOffset_e;

typedef enum {
	ZSTD_p_noPrefetch = 0,
	ZSTD_p_prefetch = 1,
} ZSTD_prefetch_e;

typedef ZSTD_ErrorCode ERR_enum;

typedef unsigned int FSE_DTable;

typedef struct {
	size_t state;
	const void *table;
} FSE_DState_t;

typedef struct {
	U16 tableLog;
	U16 fastMode;
} FSE_DTableHeader;

typedef struct {
	short unsigned int newState;
	unsigned char symbol;
	unsigned char nbBits;
} FSE_decode_t;

typedef struct {
	short int ncount[256];
	FSE_DTable dtable[1];
} FSE_DecompressWksp;

enum xz_mode {
	XZ_SINGLE = 0,
	XZ_PREALLOC = 1,
	XZ_DYNALLOC = 2,
};

enum xz_ret {
	XZ_OK = 0,
	XZ_STREAM_END = 1,
	XZ_UNSUPPORTED_CHECK = 2,
	XZ_MEM_ERROR = 3,
	XZ_MEMLIMIT_ERROR = 4,
	XZ_FORMAT_ERROR = 5,
	XZ_OPTIONS_ERROR = 6,
	XZ_DATA_ERROR = 7,
	XZ_BUF_ERROR = 8,
};

struct xz_buf {
	const uint8_t *in;
	size_t in_pos;
	size_t in_size;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
};

typedef uint64_t vli_type;

enum xz_check {
	XZ_CHECK_NONE = 0,
	XZ_CHECK_CRC32 = 1,
	XZ_CHECK_CRC64 = 4,
	XZ_CHECK_SHA256 = 10,
};

struct xz_dec_hash {
	vli_type unpadded;
	vli_type uncompressed;
	uint32_t crc32;
	int: 32;
};

struct xz_dec_lzma2;

struct xz_dec_bcj;

struct xz_dec {
	enum {
		SEQ_STREAM_HEADER = 0,
		SEQ_BLOCK_START = 1,
		SEQ_BLOCK_HEADER = 2,
		SEQ_BLOCK_UNCOMPRESS = 3,
		SEQ_BLOCK_PADDING = 4,
		SEQ_BLOCK_CHECK = 5,
		SEQ_INDEX = 6,
		SEQ_INDEX_PADDING = 7,
		SEQ_INDEX_CRC32 = 8,
		SEQ_STREAM_FOOTER = 9,
	} sequence;
	uint32_t pos;
	vli_type vli;
	size_t in_start;
	size_t out_start;
	uint32_t crc32;
	enum xz_check check_type;
	enum xz_mode mode;
	bool allow_buf_error;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		uint32_t size;
		int: 32;
	} block_header;
	struct {
		vli_type compressed;
		vli_type uncompressed;
		vli_type count;
		struct xz_dec_hash hash;
	} block;
	struct {
		enum {
			SEQ_INDEX_COUNT = 0,
			SEQ_INDEX_UNPADDED = 1,
			SEQ_INDEX_UNCOMPRESSED = 2,
		} sequence;
		int: 32;
		vli_type size;
		vli_type count;
		struct xz_dec_hash hash;
	} index;
	struct {
		size_t pos;
		size_t size;
		uint8_t buf[1024];
	} temp;
	struct xz_dec_lzma2 *lzma2;
	struct xz_dec_bcj *bcj;
	bool bcj_active;
	int: 24;
	int: 32;
};

enum lzma_state {
	STATE_LIT_LIT = 0,
	STATE_MATCH_LIT_LIT = 1,
	STATE_REP_LIT_LIT = 2,
	STATE_SHORTREP_LIT_LIT = 3,
	STATE_MATCH_LIT = 4,
	STATE_REP_LIT = 5,
	STATE_SHORTREP_LIT = 6,
	STATE_LIT_MATCH = 7,
	STATE_LIT_LONGREP = 8,
	STATE_LIT_SHORTREP = 9,
	STATE_NONLIT_MATCH = 10,
	STATE_NONLIT_REP = 11,
};

struct dictionary {
	uint8_t *buf;
	size_t start;
	size_t pos;
	size_t full;
	size_t limit;
	size_t end;
	uint32_t size;
	uint32_t size_max;
	uint32_t allocated;
	enum xz_mode mode;
};

struct rc_dec {
	uint32_t range;
	uint32_t code;
	uint32_t init_bytes_left;
	const uint8_t *in;
	size_t in_pos;
	size_t in_limit;
};

struct lzma_len_dec {
	uint16_t choice;
	uint16_t choice2;
	uint16_t low[128];
	uint16_t mid[128];
	uint16_t high[256];
};

struct lzma_dec {
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
	enum lzma_state state;
	uint32_t len;
	uint32_t lc;
	uint32_t literal_pos_mask;
	uint32_t pos_mask;
	uint16_t is_match[192];
	uint16_t is_rep[12];
	uint16_t is_rep0[12];
	uint16_t is_rep1[12];
	uint16_t is_rep2[12];
	uint16_t is_rep0_long[192];
	uint16_t dist_slot[256];
	uint16_t dist_special[114];
	uint16_t dist_align[16];
	struct lzma_len_dec match_len_dec;
	struct lzma_len_dec rep_len_dec;
	uint16_t literal[12288];
};

enum lzma2_seq {
	SEQ_CONTROL = 0,
	SEQ_UNCOMPRESSED_1 = 1,
	SEQ_UNCOMPRESSED_2 = 2,
	SEQ_COMPRESSED_0 = 3,
	SEQ_COMPRESSED_1 = 4,
	SEQ_PROPERTIES = 5,
	SEQ_LZMA_PREPARE = 6,
	SEQ_LZMA_RUN = 7,
	SEQ_COPY = 8,
};

struct lzma2_dec {
	enum lzma2_seq sequence;
	enum lzma2_seq next_sequence;
	uint32_t uncompressed;
	uint32_t compressed;
	bool need_dict_reset;
	bool need_props;
};

struct xz_dec_lzma2 {
	struct rc_dec rc;
	struct dictionary dict;
	struct lzma2_dec lzma2;
	struct lzma_dec lzma;
	struct {
		uint32_t size;
		uint8_t buf[63];
	} temp;
};

struct xz_dec_bcj {
	enum {
		BCJ_X86 = 4,
		BCJ_POWERPC = 5,
		BCJ_IA64 = 6,
		BCJ_ARM = 7,
		BCJ_ARMTHUMB = 8,
		BCJ_SPARC = 9,
	} type;
	enum xz_ret ret;
	bool single_call;
	uint32_t pos;
	uint32_t x86_prev_mask;
	uint8_t *out;
	size_t out_pos;
	size_t out_size;
	struct {
		size_t filtered;
		size_t size;
		uint8_t buf[16];
	} temp;
};

struct ts_state {
	unsigned int offset;
	char cb[48];
};

struct ts_config;

struct ts_ops {
	const char *name;
	struct ts_config * (*init)(const void *, unsigned int, gfp_t, int);
	unsigned int (*find)(struct ts_config *, struct ts_state *);
	void (*destroy)(struct ts_config *);
	void * (*get_pattern)(struct ts_config *);
	unsigned int (*get_pattern_len)(struct ts_config *);
	struct module *owner;
	struct list_head list;
};

struct ts_config {
	struct ts_ops *ops;
	int flags;
	unsigned int (*get_next_block)(unsigned int, const u8 **, struct ts_config *, struct ts_state *);
	void (*finish)(struct ts_config *, struct ts_state *);
};

struct ts_linear_state {
	unsigned int len;
	const void *data;
};

struct nla_bitfield32 {
	__u32 value;
	__u32 selector;
};

enum nla_policy_validation {
	NLA_VALIDATE_NONE = 0,
	NLA_VALIDATE_RANGE = 1,
	NLA_VALIDATE_RANGE_WARN_TOO_LONG = 2,
	NLA_VALIDATE_MIN = 3,
	NLA_VALIDATE_MAX = 4,
	NLA_VALIDATE_MASK = 5,
	NLA_VALIDATE_RANGE_PTR = 6,
	NLA_VALIDATE_FUNCTION = 7,
};

struct cpu_rmap {
	struct kref refcount;
	u16 size;
	u16 used;
	void **obj;
	struct {
		u16 index;
		u16 dist;
	} near[0];
};

struct irq_glue {
	struct irq_affinity_notify notify;
	struct cpu_rmap *rmap;
	u16 index;
};

typedef mpi_limb_t *mpi_ptr_t;

typedef int mpi_size_t;

typedef unsigned int USItype;

enum gcry_mpi_constants {
	MPI_C_ZERO = 0,
	MPI_C_ONE = 1,
	MPI_C_TWO = 2,
	MPI_C_THREE = 3,
	MPI_C_FOUR = 4,
	MPI_C_EIGHT = 5,
};

struct barrett_ctx_s;

typedef struct barrett_ctx_s *mpi_barrett_t;

struct gcry_mpi_point {
	MPI x;
	MPI y;
	MPI z;
};

typedef struct gcry_mpi_point *MPI_POINT;

enum gcry_mpi_ec_models {
	MPI_EC_WEIERSTRASS = 0,
	MPI_EC_MONTGOMERY = 1,
	MPI_EC_EDWARDS = 2,
};

enum ecc_dialects {
	ECC_DIALECT_STANDARD = 0,
	ECC_DIALECT_ED25519 = 1,
	ECC_DIALECT_SAFECURVE = 2,
};

struct mpi_ec_ctx {
	enum gcry_mpi_ec_models model;
	enum ecc_dialects dialect;
	int flags;
	unsigned int nbits;
	MPI p;
	MPI a;
	MPI b;
	MPI_POINT G;
	MPI n;
	unsigned int h;
	MPI_POINT Q;
	MPI d;
	const char *name;
	struct {
		struct {
			unsigned int a_is_pminus3: 1;
			unsigned int two_inv_p: 1;
		} valid;
		int a_is_pminus3;
		MPI two_inv_p;
		mpi_barrett_t p_barrett;
		MPI scratch[11];
	} t;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
};

struct field_table {
	const char *p;
	void (*addm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*subm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mulm)(MPI, MPI, MPI, struct mpi_ec_ctx *);
	void (*mul2)(MPI, MPI, struct mpi_ec_ctx *);
	void (*pow2)(MPI, const MPI, struct mpi_ec_ctx *);
};

enum gcry_mpi_format {
	GCRYMPI_FMT_NONE = 0,
	GCRYMPI_FMT_STD = 1,
	GCRYMPI_FMT_PGP = 2,
	GCRYMPI_FMT_SSH = 3,
	GCRYMPI_FMT_HEX = 4,
	GCRYMPI_FMT_USG = 5,
	GCRYMPI_FMT_OPAQUE = 8,
};

struct barrett_ctx_s;

typedef struct barrett_ctx_s *mpi_barrett_t___2;

struct barrett_ctx_s {
	MPI m;
	int m_copied;
	int k;
	MPI y;
	MPI r1;
	MPI r2;
	MPI r3;
};

typedef mpi_limb_t UWtype;

struct karatsuba_ctx {
	struct karatsuba_ctx *next;
	mpi_ptr_t tspace;
	mpi_size_t tspace_size;
	mpi_ptr_t tp;
	mpi_size_t tp_size;
};

typedef long int mpi_limb_signed_t;

struct sg_pool {
	size_t size;
	char *name;
	struct kmem_cache *slab;
	mempool_t *pool;
};

struct font_desc {
	int idx;
	const char *name;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	const void *data;
	int pref;
};

struct font_data {
	unsigned int extra[4];
	const unsigned char data[0];
};

enum gic_type {
	GIC_V2 = 0,
	GIC_V3 = 1,
};

struct gic_kvm_info {
	enum gic_type type;
	struct resource vcpu;
	unsigned int maint_irq;
	bool no_maint_irq_mask;
	struct resource vctrl;
	bool has_v4;
	bool has_v4_1;
	bool no_hw_deactivation;
};

struct gic_quirk {
	const char *desc;
	const char *compatible;
	bool (*init)(void *);
	u32 iidr;
	u32 mask;
};

union gic_base {
	void *common_base;
	void **percpu_base;
};

struct gic_chip_data {
	union gic_base dist_base;
	union gic_base cpu_base;
	void *raw_dist_base;
	void *raw_cpu_base;
	u32 percpu_offset;
	u32 saved_spi_enable[32];
	u32 saved_spi_active[32];
	u32 saved_spi_conf[64];
	u32 saved_spi_target[255];
	u32 *saved_ppi_enable;
	u32 *saved_ppi_active;
	u32 *saved_ppi_conf;
	struct irq_domain *domain;
	unsigned int gic_irqs;
};

struct gpcv2_irqchip_data {
	struct raw_spinlock rlock;
	void *gpc_base;
	u32 wakeup_sources[4];
	u32 saved_irq_mask[4];
	u32 cpu2wakeup;
};

enum device_link_state {
	DL_STATE_NONE = 4294967295,
	DL_STATE_DORMANT = 0,
	DL_STATE_AVAILABLE = 1,
	DL_STATE_CONSUMER_PROBE = 2,
	DL_STATE_ACTIVE = 3,
	DL_STATE_SUPPLIER_UNBIND = 4,
};

struct device_link {
	struct device *supplier;
	struct list_head s_node;
	struct device *consumer;
	struct list_head c_node;
	struct device link_dev;
	enum device_link_state status;
	u32 flags;
	refcount_t rpm_active;
	struct kref kref;
	struct work_struct rm_work;
	bool supplier_preactivated;
	int: 24;
	int: 32;
};

struct irqsteer_data {
	void *regs;
	struct clk *ipg_clk;
	int irq[8];
	int irq_count;
	raw_spinlock_t lock;
	int reg_num;
	int channel;
	struct irq_domain *domain;
	u32 *saved_reg;
	struct device *dev;
	struct device *pd_csi;
	struct device *pd_isi;
};

struct intmux_irqchip_data {
	u32 saved_reg;
	int chanidx;
	int irq;
	struct irq_domain *domain;
};

struct intmux_data {
	raw_spinlock_t lock;
	void *regs;
	struct clk *ipg_clk;
	int channum;
	struct intmux_irqchip_data irqchip_data[0];
};

struct of_reconfig_data {
	struct device_node *dn;
	struct property *prop;
	struct property *old_prop;
};

enum of_reconfig_change {
	OF_RECONFIG_NO_CHANGE = 0,
	OF_RECONFIG_CHANGE_ADD = 1,
	OF_RECONFIG_CHANGE_REMOVE = 2,
};

struct imx_weim_devtype {
	unsigned int cs_count;
	unsigned int cs_regs_count;
	unsigned int cs_stride;
	unsigned int wcr_offset;
	unsigned int wcr_bcm;
	unsigned int wcr_cont_bclk;
};

struct cs_timing {
	bool is_applied;
	u32 regs[6];
};

struct cs_timing_state {
	struct cs_timing cs[6];
};

struct weim_priv {
	void *base;
	struct cs_timing_state timing_state;
};

struct of_dev_auxdata {
	char *compatible;
	resource_size_t phys_addr;
	char *name;
	void *platform_data;
};

struct phy_configure_opts_dp {
	unsigned int link_rate;
	unsigned int lanes;
	unsigned int voltage[4];
	unsigned int pre[4];
	u8 ssc: 1;
	u8 set_rate: 1;
	u8 set_lanes: 1;
	u8 set_voltages: 1;
};

struct phy_configure_opts_lvds {
	unsigned int bits_per_lane_and_dclk_cycle;
	long unsigned int differential_clk_rate;
	unsigned int lanes;
	bool is_slave;
};

struct phy_configure_opts_mipi_dphy {
	unsigned int clk_miss;
	unsigned int clk_post;
	unsigned int clk_pre;
	unsigned int clk_prepare;
	unsigned int clk_settle;
	unsigned int clk_term_en;
	unsigned int clk_trail;
	unsigned int clk_zero;
	unsigned int d_term_en;
	unsigned int eot;
	unsigned int hs_exit;
	unsigned int hs_prepare;
	unsigned int hs_settle;
	unsigned int hs_skip;
	unsigned int hs_trail;
	unsigned int hs_zero;
	unsigned int init;
	unsigned int lpx;
	unsigned int ta_get;
	unsigned int ta_go;
	unsigned int ta_sure;
	unsigned int wakeup;
	long unsigned int hs_clk_rate;
	long unsigned int lp_clk_rate;
	unsigned char lanes;
};

enum phy_mode {
	PHY_MODE_INVALID = 0,
	PHY_MODE_USB_HOST = 1,
	PHY_MODE_USB_HOST_LS = 2,
	PHY_MODE_USB_HOST_FS = 3,
	PHY_MODE_USB_HOST_HS = 4,
	PHY_MODE_USB_HOST_SS = 5,
	PHY_MODE_USB_DEVICE = 6,
	PHY_MODE_USB_DEVICE_LS = 7,
	PHY_MODE_USB_DEVICE_FS = 8,
	PHY_MODE_USB_DEVICE_HS = 9,
	PHY_MODE_USB_DEVICE_SS = 10,
	PHY_MODE_USB_OTG = 11,
	PHY_MODE_UFS_HS_A = 12,
	PHY_MODE_UFS_HS_B = 13,
	PHY_MODE_PCIE = 14,
	PHY_MODE_ETHERNET = 15,
	PHY_MODE_MIPI_DPHY = 16,
	PHY_MODE_SATA = 17,
	PHY_MODE_LVDS = 18,
	PHY_MODE_DP = 19,
};

enum phy_media {
	PHY_MEDIA_DEFAULT = 0,
	PHY_MEDIA_SR = 1,
	PHY_MEDIA_DAC = 2,
};

union phy_configure_opts {
	struct phy_configure_opts_mipi_dphy mipi_dphy;
	struct phy_configure_opts_dp dp;
	struct phy_configure_opts_lvds lvds;
};

struct phy;

struct phy_ops {
	int (*init)(struct phy *);
	int (*exit)(struct phy *);
	int (*power_on)(struct phy *);
	int (*power_off)(struct phy *);
	int (*set_mode)(struct phy *, enum phy_mode, int);
	int (*set_media)(struct phy *, enum phy_media);
	int (*set_speed)(struct phy *, int);
	int (*configure)(struct phy *, union phy_configure_opts *);
	int (*validate)(struct phy *, enum phy_mode, int, union phy_configure_opts *);
	int (*reset)(struct phy *);
	int (*calibrate)(struct phy *);
	void (*release)(struct phy *);
	struct module *owner;
};

struct phy_attrs {
	u32 bus_width;
	u32 max_link_rate;
	enum phy_mode mode;
};

struct phy {
	struct device dev;
	int id;
	const struct phy_ops *ops;
	struct mutex mutex;
	int init_count;
	int power_count;
	struct phy_attrs attrs;
	struct regulator *pwr;
	int: 32;
};

struct phy_provider {
	struct device *dev;
	struct device_node *children;
	struct module *owner;
	struct list_head list;
	struct phy * (*of_xlate)(struct device *, struct of_phandle_args *);
};

struct phy_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct phy *phy;
};

struct mixel_lvds_phy {
	struct phy *phy;
	unsigned int id;
};

struct mixel_lvds_phy_priv {
	struct device *dev;
	void *base;
	struct mutex lock;
	struct clk *phy_clk;
	struct mixel_lvds_phy *phys[2];
};

struct mixel_lvds_phy___2 {
	struct device *dev;
	void *csr_base;
	void *ctrl_base;
	struct mutex lock;
	struct phy *phy;
	struct clk *phy_clk;
};

struct radix_tree_iter {
	long unsigned int index;
	long unsigned int next_index;
	long unsigned int tags;
	struct xa_node *node;
};

enum {
	RADIX_TREE_ITER_TAG_MASK = 15,
	RADIX_TREE_ITER_TAGGED = 16,
	RADIX_TREE_ITER_CONTIG = 32,
};

struct pinctrl;

struct pinctrl_state;

struct dev_pin_info {
	struct pinctrl *p;
	struct pinctrl_state *default_state;
	struct pinctrl_state *init_state;
	struct pinctrl_state *sleep_state;
	struct pinctrl_state *idle_state;
};

struct pinctrl {
	struct list_head node;
	struct device *dev;
	struct list_head states;
	struct pinctrl_state *state;
	struct list_head dt_maps;
	struct kref users;
};

struct pinctrl_state {
	struct list_head node;
	const char *name;
	struct list_head settings;
};

struct pinctrl_pin_desc {
	unsigned int number;
	const char *name;
	void *drv_data;
};

struct gpio_chip;

struct pinctrl_gpio_range {
	struct list_head node;
	const char *name;
	unsigned int id;
	unsigned int base;
	unsigned int pin_base;
	unsigned int npins;
	const unsigned int *pins;
	struct gpio_chip *gc;
};

union gpio_irq_fwspec;

struct gpio_irq_chip {
	struct irq_chip *chip;
	struct irq_domain *domain;
	const struct irq_domain_ops *domain_ops;
	struct fwnode_handle *fwnode;
	struct irq_domain *parent_domain;
	int (*child_to_parent_hwirq)(struct gpio_chip *, unsigned int, unsigned int, unsigned int *, unsigned int *);
	int (*populate_parent_alloc_arg)(struct gpio_chip *, union gpio_irq_fwspec *, unsigned int, unsigned int);
	unsigned int (*child_offset_to_irq)(struct gpio_chip *, unsigned int);
	struct irq_domain_ops child_irq_domain_ops;
	irq_flow_handler_t handler;
	unsigned int default_type;
	struct lock_class_key *lock_key;
	struct lock_class_key *request_key;
	irq_flow_handler_t parent_handler;
	union {
		void *parent_handler_data;
		void **parent_handler_data_array;
	};
	unsigned int num_parents;
	unsigned int *parents;
	unsigned int *map;
	bool threaded;
	bool per_parent_data;
	bool initialized;
	int (*init_hw)(struct gpio_chip *);
	void (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	long unsigned int *valid_mask;
	unsigned int first;
	void (*irq_enable)(struct irq_data *);
	void (*irq_disable)(struct irq_data *);
	void (*irq_unmask)(struct irq_data *);
	void (*irq_mask)(struct irq_data *);
};

struct gpio_device;

struct gpio_chip {
	const char *label;
	struct gpio_device *gpiodev;
	struct device *parent;
	struct fwnode_handle *fwnode;
	struct module *owner;
	int (*request)(struct gpio_chip *, unsigned int);
	void (*free)(struct gpio_chip *, unsigned int);
	int (*get_direction)(struct gpio_chip *, unsigned int);
	int (*direction_input)(struct gpio_chip *, unsigned int);
	int (*direction_output)(struct gpio_chip *, unsigned int, int);
	int (*get)(struct gpio_chip *, unsigned int);
	int (*get_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	void (*set)(struct gpio_chip *, unsigned int, int);
	void (*set_multiple)(struct gpio_chip *, long unsigned int *, long unsigned int *);
	int (*set_config)(struct gpio_chip *, unsigned int, long unsigned int);
	int (*to_irq)(struct gpio_chip *, unsigned int);
	void (*dbg_show)(struct seq_file *, struct gpio_chip *);
	int (*init_valid_mask)(struct gpio_chip *, long unsigned int *, unsigned int);
	int (*add_pin_ranges)(struct gpio_chip *);
	int (*en_hw_timestamp)(struct gpio_chip *, u32, long unsigned int);
	int (*dis_hw_timestamp)(struct gpio_chip *, u32, long unsigned int);
	int base;
	u16 ngpio;
	u16 offset;
	const char * const *names;
	bool can_sleep;
	long unsigned int (*read_reg)(void *);
	void (*write_reg)(void *, long unsigned int);
	bool be_bits;
	void *reg_dat;
	void *reg_set;
	void *reg_clr;
	void *reg_dir_out;
	void *reg_dir_in;
	bool bgpio_dir_unreadable;
	int bgpio_bits;
	raw_spinlock_t bgpio_lock;
	long unsigned int bgpio_data;
	long unsigned int bgpio_dir;
	struct gpio_irq_chip irq;
	long unsigned int *valid_mask;
	struct device_node *of_node;
	unsigned int of_gpio_n_cells;
	int (*of_xlate)(struct gpio_chip *, const struct of_phandle_args *, u32 *);
	int (*of_gpio_ranges_fallback)(struct gpio_chip *, struct device_node *);
};

struct pinctrl_dev;

struct pinctrl_map;

struct pinctrl_ops {
	int (*get_groups_count)(struct pinctrl_dev *);
	const char * (*get_group_name)(struct pinctrl_dev *, unsigned int);
	int (*get_group_pins)(struct pinctrl_dev *, unsigned int, const unsigned int **, unsigned int *);
	void (*pin_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	int (*dt_node_to_map)(struct pinctrl_dev *, struct device_node *, struct pinctrl_map **, unsigned int *);
	void (*dt_free_map)(struct pinctrl_dev *, struct pinctrl_map *, unsigned int);
};

struct pinctrl_desc;

struct pinctrl_dev {
	struct list_head node;
	struct pinctrl_desc *desc;
	struct xarray pin_desc_tree;
	struct xarray pin_group_tree;
	unsigned int num_groups;
	struct xarray pin_function_tree;
	unsigned int num_functions;
	struct list_head gpio_ranges;
	struct device *dev;
	struct module *owner;
	void *driver_data;
	struct pinctrl *p;
	struct pinctrl_state *hog_default;
	struct pinctrl_state *hog_sleep;
	struct mutex mutex;
	struct dentry *device_root;
};

enum pinctrl_map_type {
	PIN_MAP_TYPE_INVALID = 0,
	PIN_MAP_TYPE_DUMMY_STATE = 1,
	PIN_MAP_TYPE_MUX_GROUP = 2,
	PIN_MAP_TYPE_CONFIGS_PIN = 3,
	PIN_MAP_TYPE_CONFIGS_GROUP = 4,
};

struct pinctrl_map_mux {
	const char *group;
	const char *function;
};

struct pinctrl_map_configs {
	const char *group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_map {
	const char *dev_name;
	const char *name;
	enum pinctrl_map_type type;
	const char *ctrl_dev_name;
	union {
		struct pinctrl_map_mux mux;
		struct pinctrl_map_configs configs;
	} data;
};

struct pinmux_ops;

struct pinconf_ops;

struct pinconf_generic_params;

struct pin_config_item;

struct pinctrl_desc {
	const char *name;
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	const struct pinctrl_ops *pctlops;
	const struct pinmux_ops *pmxops;
	const struct pinconf_ops *confops;
	struct module *owner;
	unsigned int num_custom_params;
	const struct pinconf_generic_params *custom_params;
	const struct pin_config_item *custom_conf_items;
	bool link_consumers;
};

struct pinmux_ops {
	int (*request)(struct pinctrl_dev *, unsigned int);
	int (*free)(struct pinctrl_dev *, unsigned int);
	int (*get_functions_count)(struct pinctrl_dev *);
	const char * (*get_function_name)(struct pinctrl_dev *, unsigned int);
	int (*get_function_groups)(struct pinctrl_dev *, unsigned int, const char * const **, unsigned int *);
	int (*set_mux)(struct pinctrl_dev *, unsigned int, unsigned int);
	int (*gpio_request_enable)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	void (*gpio_disable_free)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int);
	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
	bool strict;
};

struct pinconf_ops {
	bool is_generic;
	int (*pin_config_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	int (*pin_config_group_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*pin_config_group_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	void (*pin_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_group_dbg_show)(struct pinctrl_dev *, struct seq_file *, unsigned int);
	void (*pin_config_config_dbg_show)(struct pinctrl_dev *, struct seq_file *, long unsigned int);
};

enum pin_config_param {
	PIN_CONFIG_BIAS_BUS_HOLD = 0,
	PIN_CONFIG_BIAS_DISABLE = 1,
	PIN_CONFIG_BIAS_HIGH_IMPEDANCE = 2,
	PIN_CONFIG_BIAS_PULL_DOWN = 3,
	PIN_CONFIG_BIAS_PULL_PIN_DEFAULT = 4,
	PIN_CONFIG_BIAS_PULL_UP = 5,
	PIN_CONFIG_DRIVE_OPEN_DRAIN = 6,
	PIN_CONFIG_DRIVE_OPEN_SOURCE = 7,
	PIN_CONFIG_DRIVE_PUSH_PULL = 8,
	PIN_CONFIG_DRIVE_STRENGTH = 9,
	PIN_CONFIG_DRIVE_STRENGTH_UA = 10,
	PIN_CONFIG_INPUT_DEBOUNCE = 11,
	PIN_CONFIG_INPUT_ENABLE = 12,
	PIN_CONFIG_INPUT_SCHMITT = 13,
	PIN_CONFIG_INPUT_SCHMITT_ENABLE = 14,
	PIN_CONFIG_MODE_LOW_POWER = 15,
	PIN_CONFIG_MODE_PWM = 16,
	PIN_CONFIG_OUTPUT = 17,
	PIN_CONFIG_OUTPUT_ENABLE = 18,
	PIN_CONFIG_OUTPUT_IMPEDANCE_OHMS = 19,
	PIN_CONFIG_PERSIST_STATE = 20,
	PIN_CONFIG_POWER_SOURCE = 21,
	PIN_CONFIG_SKEW_DELAY = 22,
	PIN_CONFIG_SLEEP_HARDWARE_STATE = 23,
	PIN_CONFIG_SLEW_RATE = 24,
	PIN_CONFIG_END = 127,
	PIN_CONFIG_MAX = 255,
};

struct pinconf_generic_params {
	const char * const property;
	enum pin_config_param param;
	u32 default_value;
};

struct pin_config_item {
	const enum pin_config_param param;
	const char * const display;
	const char * const format;
	bool has_arg;
};

union gpio_irq_fwspec {
	struct irq_fwspec fwspec;
	msi_alloc_info_t msiinfo;
};

struct gpio_device {
	int id;
	int: 32;
	struct device dev;
	struct cdev chrdev;
	struct device *mockdev;
	struct module *owner;
	struct gpio_chip *chip;
	struct gpio_desc *descs;
	int base;
	u16 ngpio;
	const char *label;
	void *data;
	struct list_head list;
	struct blocking_notifier_head notifier;
	struct list_head pin_ranges;
};

struct gpio_desc {
	struct gpio_device *gdev;
	long unsigned int flags;
	const char *label;
	const char *name;
	struct device_node *hog;
	unsigned int debounce_period_us;
};

struct pinctrl_setting_mux {
	unsigned int group;
	unsigned int func;
};

struct pinctrl_setting_configs {
	unsigned int group_or_pin;
	long unsigned int *configs;
	unsigned int num_configs;
};

struct pinctrl_setting {
	struct list_head node;
	enum pinctrl_map_type type;
	struct pinctrl_dev *pctldev;
	const char *dev_name;
	union {
		struct pinctrl_setting_mux mux;
		struct pinctrl_setting_configs configs;
	} data;
};

struct pin_desc {
	struct pinctrl_dev *pctldev;
	const char *name;
	bool dynamic_name;
	void *drv_data;
	unsigned int mux_usecount;
	const char *mux_owner;
	const struct pinctrl_setting_mux *mux_setting;
	const char *gpio_owner;
};

struct pinctrl_maps {
	struct list_head node;
	const struct pinctrl_map *maps;
	unsigned int num_maps;
};

struct group_desc {
	const char *name;
	int *pins;
	int num_pins;
	void *data;
};

struct pctldev;

struct function_desc {
	const char *name;
	const char * const *group_names;
	int num_group_names;
	void *data;
};

enum of_gpio_flags {
	OF_GPIO_ACTIVE_LOW = 1,
	OF_GPIO_SINGLE_ENDED = 2,
	OF_GPIO_OPEN_DRAIN = 4,
	OF_GPIO_TRANSITORY = 8,
	OF_GPIO_PULL_UP = 16,
	OF_GPIO_PULL_DOWN = 32,
	OF_GPIO_PULL_DISABLE = 64,
};

struct pinctrl_dt_map {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_map *map;
	unsigned int num_maps;
};

enum regcache_type {
	REGCACHE_NONE = 0,
	REGCACHE_RBTREE = 1,
	REGCACHE_COMPRESSED = 2,
	REGCACHE_FLAT = 3,
};

struct reg_default {
	unsigned int reg;
	unsigned int def;
};

enum regmap_endian {
	REGMAP_ENDIAN_DEFAULT = 0,
	REGMAP_ENDIAN_BIG = 1,
	REGMAP_ENDIAN_LITTLE = 2,
	REGMAP_ENDIAN_NATIVE = 3,
};

struct regmap_range {
	unsigned int range_min;
	unsigned int range_max;
};

struct regmap_access_table {
	const struct regmap_range *yes_ranges;
	unsigned int n_yes_ranges;
	const struct regmap_range *no_ranges;
	unsigned int n_no_ranges;
};

typedef void (*regmap_lock)(void *);

typedef void (*regmap_unlock)(void *);

struct regmap_range_cfg;

struct regmap_config {
	const char *name;
	int reg_bits;
	int reg_stride;
	int reg_downshift;
	unsigned int reg_base;
	int pad_bits;
	int val_bits;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	bool disable_locking;
	bool disable_debugfs;
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	int (*read)(void *, const void *, size_t, void *, size_t);
	int (*write)(void *, const void *, size_t);
	size_t max_raw_read;
	size_t max_raw_write;
	bool fast_io;
	bool io_port;
	unsigned int max_register;
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	const struct reg_default *reg_defaults;
	unsigned int num_reg_defaults;
	enum regcache_type cache_type;
	const void *reg_defaults_raw;
	unsigned int num_reg_defaults_raw;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	bool zero_flag_mask;
	bool use_single_read;
	bool use_single_write;
	bool use_relaxed_mmio;
	bool can_multi_write;
	enum regmap_endian reg_format_endian;
	enum regmap_endian val_format_endian;
	const struct regmap_range_cfg *ranges;
	unsigned int num_ranges;
	bool use_hwlock;
	bool use_raw_spinlock;
	unsigned int hwlock_id;
	unsigned int hwlock_mode;
	bool can_sleep;
};

struct regmap_range_cfg {
	const char *name;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct imx_pin_mmio {
	unsigned int mux_mode;
	u16 input_reg;
	unsigned int input_val;
	long unsigned int config;
};

struct imx_pin_scu {
	unsigned int mux_mode;
	long unsigned int config;
};

struct imx_pin {
	unsigned int pin;
	union {
		struct imx_pin_mmio mmio;
		struct imx_pin_scu scu;
	} conf;
};

struct imx_pin_reg {
	s16 mux_reg;
	s16 conf_reg;
};

struct imx_cfg_params_decode {
	enum pin_config_param param;
	u32 mask;
	u8 shift;
	bool invert;
};

struct imx_pinctrl_soc_info;

struct imx_pinctrl {
	struct device *dev;
	struct pinctrl_dev *pctl;
	void *base;
	void *input_sel_base;
	const struct imx_pinctrl_soc_info *info;
	struct imx_pin_reg *pin_regs;
	unsigned int group_index;
	struct mutex mutex;
};

struct imx_pinctrl_soc_info {
	const struct pinctrl_pin_desc *pins;
	unsigned int npins;
	unsigned int flags;
	const char *gpr_compatible;
	unsigned int mux_mask;
	u8 mux_shift;
	bool generic_pinconf;
	const struct pinconf_generic_params *custom_params;
	unsigned int num_custom_params;
	const struct imx_cfg_params_decode *decodes;
	unsigned int num_decodes;
	void (*fixup)(long unsigned int *, unsigned int, u32 *);
	int (*gpio_set_direction)(struct pinctrl_dev *, struct pinctrl_gpio_range *, unsigned int, bool);
	int (*imx_pinconf_get)(struct pinctrl_dev *, unsigned int, long unsigned int *);
	int (*imx_pinconf_set)(struct pinctrl_dev *, unsigned int, long unsigned int *, unsigned int);
	void (*imx_pinctrl_parse_pin)(struct imx_pinctrl *, unsigned int *, struct imx_pin *, const __be32 **);
};

enum imx6q_pads {
	MX6Q_PAD_RESERVE0 = 0,
	MX6Q_PAD_RESERVE1 = 1,
	MX6Q_PAD_RESERVE2 = 2,
	MX6Q_PAD_RESERVE3 = 3,
	MX6Q_PAD_RESERVE4 = 4,
	MX6Q_PAD_RESERVE5 = 5,
	MX6Q_PAD_RESERVE6 = 6,
	MX6Q_PAD_RESERVE7 = 7,
	MX6Q_PAD_RESERVE8 = 8,
	MX6Q_PAD_RESERVE9 = 9,
	MX6Q_PAD_RESERVE10 = 10,
	MX6Q_PAD_RESERVE11 = 11,
	MX6Q_PAD_RESERVE12 = 12,
	MX6Q_PAD_RESERVE13 = 13,
	MX6Q_PAD_RESERVE14 = 14,
	MX6Q_PAD_RESERVE15 = 15,
	MX6Q_PAD_RESERVE16 = 16,
	MX6Q_PAD_RESERVE17 = 17,
	MX6Q_PAD_RESERVE18 = 18,
	MX6Q_PAD_SD2_DAT1 = 19,
	MX6Q_PAD_SD2_DAT2 = 20,
	MX6Q_PAD_SD2_DAT0 = 21,
	MX6Q_PAD_RGMII_TXC = 22,
	MX6Q_PAD_RGMII_TD0 = 23,
	MX6Q_PAD_RGMII_TD1 = 24,
	MX6Q_PAD_RGMII_TD2 = 25,
	MX6Q_PAD_RGMII_TD3 = 26,
	MX6Q_PAD_RGMII_RX_CTL = 27,
	MX6Q_PAD_RGMII_RD0 = 28,
	MX6Q_PAD_RGMII_TX_CTL = 29,
	MX6Q_PAD_RGMII_RD1 = 30,
	MX6Q_PAD_RGMII_RD2 = 31,
	MX6Q_PAD_RGMII_RD3 = 32,
	MX6Q_PAD_RGMII_RXC = 33,
	MX6Q_PAD_EIM_A25 = 34,
	MX6Q_PAD_EIM_EB2 = 35,
	MX6Q_PAD_EIM_D16 = 36,
	MX6Q_PAD_EIM_D17 = 37,
	MX6Q_PAD_EIM_D18 = 38,
	MX6Q_PAD_EIM_D19 = 39,
	MX6Q_PAD_EIM_D20 = 40,
	MX6Q_PAD_EIM_D21 = 41,
	MX6Q_PAD_EIM_D22 = 42,
	MX6Q_PAD_EIM_D23 = 43,
	MX6Q_PAD_EIM_EB3 = 44,
	MX6Q_PAD_EIM_D24 = 45,
	MX6Q_PAD_EIM_D25 = 46,
	MX6Q_PAD_EIM_D26 = 47,
	MX6Q_PAD_EIM_D27 = 48,
	MX6Q_PAD_EIM_D28 = 49,
	MX6Q_PAD_EIM_D29 = 50,
	MX6Q_PAD_EIM_D30 = 51,
	MX6Q_PAD_EIM_D31 = 52,
	MX6Q_PAD_EIM_A24 = 53,
	MX6Q_PAD_EIM_A23 = 54,
	MX6Q_PAD_EIM_A22 = 55,
	MX6Q_PAD_EIM_A21 = 56,
	MX6Q_PAD_EIM_A20 = 57,
	MX6Q_PAD_EIM_A19 = 58,
	MX6Q_PAD_EIM_A18 = 59,
	MX6Q_PAD_EIM_A17 = 60,
	MX6Q_PAD_EIM_A16 = 61,
	MX6Q_PAD_EIM_CS0 = 62,
	MX6Q_PAD_EIM_CS1 = 63,
	MX6Q_PAD_EIM_OE = 64,
	MX6Q_PAD_EIM_RW = 65,
	MX6Q_PAD_EIM_LBA = 66,
	MX6Q_PAD_EIM_EB0 = 67,
	MX6Q_PAD_EIM_EB1 = 68,
	MX6Q_PAD_EIM_DA0 = 69,
	MX6Q_PAD_EIM_DA1 = 70,
	MX6Q_PAD_EIM_DA2 = 71,
	MX6Q_PAD_EIM_DA3 = 72,
	MX6Q_PAD_EIM_DA4 = 73,
	MX6Q_PAD_EIM_DA5 = 74,
	MX6Q_PAD_EIM_DA6 = 75,
	MX6Q_PAD_EIM_DA7 = 76,
	MX6Q_PAD_EIM_DA8 = 77,
	MX6Q_PAD_EIM_DA9 = 78,
	MX6Q_PAD_EIM_DA10 = 79,
	MX6Q_PAD_EIM_DA11 = 80,
	MX6Q_PAD_EIM_DA12 = 81,
	MX6Q_PAD_EIM_DA13 = 82,
	MX6Q_PAD_EIM_DA14 = 83,
	MX6Q_PAD_EIM_DA15 = 84,
	MX6Q_PAD_EIM_WAIT = 85,
	MX6Q_PAD_EIM_BCLK = 86,
	MX6Q_PAD_DI0_DISP_CLK = 87,
	MX6Q_PAD_DI0_PIN15 = 88,
	MX6Q_PAD_DI0_PIN2 = 89,
	MX6Q_PAD_DI0_PIN3 = 90,
	MX6Q_PAD_DI0_PIN4 = 91,
	MX6Q_PAD_DISP0_DAT0 = 92,
	MX6Q_PAD_DISP0_DAT1 = 93,
	MX6Q_PAD_DISP0_DAT2 = 94,
	MX6Q_PAD_DISP0_DAT3 = 95,
	MX6Q_PAD_DISP0_DAT4 = 96,
	MX6Q_PAD_DISP0_DAT5 = 97,
	MX6Q_PAD_DISP0_DAT6 = 98,
	MX6Q_PAD_DISP0_DAT7 = 99,
	MX6Q_PAD_DISP0_DAT8 = 100,
	MX6Q_PAD_DISP0_DAT9 = 101,
	MX6Q_PAD_DISP0_DAT10 = 102,
	MX6Q_PAD_DISP0_DAT11 = 103,
	MX6Q_PAD_DISP0_DAT12 = 104,
	MX6Q_PAD_DISP0_DAT13 = 105,
	MX6Q_PAD_DISP0_DAT14 = 106,
	MX6Q_PAD_DISP0_DAT15 = 107,
	MX6Q_PAD_DISP0_DAT16 = 108,
	MX6Q_PAD_DISP0_DAT17 = 109,
	MX6Q_PAD_DISP0_DAT18 = 110,
	MX6Q_PAD_DISP0_DAT19 = 111,
	MX6Q_PAD_DISP0_DAT20 = 112,
	MX6Q_PAD_DISP0_DAT21 = 113,
	MX6Q_PAD_DISP0_DAT22 = 114,
	MX6Q_PAD_DISP0_DAT23 = 115,
	MX6Q_PAD_ENET_MDIO = 116,
	MX6Q_PAD_ENET_REF_CLK = 117,
	MX6Q_PAD_ENET_RX_ER = 118,
	MX6Q_PAD_ENET_CRS_DV = 119,
	MX6Q_PAD_ENET_RXD1 = 120,
	MX6Q_PAD_ENET_RXD0 = 121,
	MX6Q_PAD_ENET_TX_EN = 122,
	MX6Q_PAD_ENET_TXD1 = 123,
	MX6Q_PAD_ENET_TXD0 = 124,
	MX6Q_PAD_ENET_MDC = 125,
	MX6Q_PAD_KEY_COL0 = 126,
	MX6Q_PAD_KEY_ROW0 = 127,
	MX6Q_PAD_KEY_COL1 = 128,
	MX6Q_PAD_KEY_ROW1 = 129,
	MX6Q_PAD_KEY_COL2 = 130,
	MX6Q_PAD_KEY_ROW2 = 131,
	MX6Q_PAD_KEY_COL3 = 132,
	MX6Q_PAD_KEY_ROW3 = 133,
	MX6Q_PAD_KEY_COL4 = 134,
	MX6Q_PAD_KEY_ROW4 = 135,
	MX6Q_PAD_GPIO_0 = 136,
	MX6Q_PAD_GPIO_1 = 137,
	MX6Q_PAD_GPIO_9 = 138,
	MX6Q_PAD_GPIO_3 = 139,
	MX6Q_PAD_GPIO_6 = 140,
	MX6Q_PAD_GPIO_2 = 141,
	MX6Q_PAD_GPIO_4 = 142,
	MX6Q_PAD_GPIO_5 = 143,
	MX6Q_PAD_GPIO_7 = 144,
	MX6Q_PAD_GPIO_8 = 145,
	MX6Q_PAD_GPIO_16 = 146,
	MX6Q_PAD_GPIO_17 = 147,
	MX6Q_PAD_GPIO_18 = 148,
	MX6Q_PAD_GPIO_19 = 149,
	MX6Q_PAD_CSI0_PIXCLK = 150,
	MX6Q_PAD_CSI0_MCLK = 151,
	MX6Q_PAD_CSI0_DATA_EN = 152,
	MX6Q_PAD_CSI0_VSYNC = 153,
	MX6Q_PAD_CSI0_DAT4 = 154,
	MX6Q_PAD_CSI0_DAT5 = 155,
	MX6Q_PAD_CSI0_DAT6 = 156,
	MX6Q_PAD_CSI0_DAT7 = 157,
	MX6Q_PAD_CSI0_DAT8 = 158,
	MX6Q_PAD_CSI0_DAT9 = 159,
	MX6Q_PAD_CSI0_DAT10 = 160,
	MX6Q_PAD_CSI0_DAT11 = 161,
	MX6Q_PAD_CSI0_DAT12 = 162,
	MX6Q_PAD_CSI0_DAT13 = 163,
	MX6Q_PAD_CSI0_DAT14 = 164,
	MX6Q_PAD_CSI0_DAT15 = 165,
	MX6Q_PAD_CSI0_DAT16 = 166,
	MX6Q_PAD_CSI0_DAT17 = 167,
	MX6Q_PAD_CSI0_DAT18 = 168,
	MX6Q_PAD_CSI0_DAT19 = 169,
	MX6Q_PAD_SD3_DAT7 = 170,
	MX6Q_PAD_SD3_DAT6 = 171,
	MX6Q_PAD_SD3_DAT5 = 172,
	MX6Q_PAD_SD3_DAT4 = 173,
	MX6Q_PAD_SD3_CMD = 174,
	MX6Q_PAD_SD3_CLK = 175,
	MX6Q_PAD_SD3_DAT0 = 176,
	MX6Q_PAD_SD3_DAT1 = 177,
	MX6Q_PAD_SD3_DAT2 = 178,
	MX6Q_PAD_SD3_DAT3 = 179,
	MX6Q_PAD_SD3_RST = 180,
	MX6Q_PAD_NANDF_CLE = 181,
	MX6Q_PAD_NANDF_ALE = 182,
	MX6Q_PAD_NANDF_WP_B = 183,
	MX6Q_PAD_NANDF_RB0 = 184,
	MX6Q_PAD_NANDF_CS0 = 185,
	MX6Q_PAD_NANDF_CS1 = 186,
	MX6Q_PAD_NANDF_CS2 = 187,
	MX6Q_PAD_NANDF_CS3 = 188,
	MX6Q_PAD_SD4_CMD = 189,
	MX6Q_PAD_SD4_CLK = 190,
	MX6Q_PAD_NANDF_D0 = 191,
	MX6Q_PAD_NANDF_D1 = 192,
	MX6Q_PAD_NANDF_D2 = 193,
	MX6Q_PAD_NANDF_D3 = 194,
	MX6Q_PAD_NANDF_D4 = 195,
	MX6Q_PAD_NANDF_D5 = 196,
	MX6Q_PAD_NANDF_D6 = 197,
	MX6Q_PAD_NANDF_D7 = 198,
	MX6Q_PAD_SD4_DAT0 = 199,
	MX6Q_PAD_SD4_DAT1 = 200,
	MX6Q_PAD_SD4_DAT2 = 201,
	MX6Q_PAD_SD4_DAT3 = 202,
	MX6Q_PAD_SD4_DAT4 = 203,
	MX6Q_PAD_SD4_DAT5 = 204,
	MX6Q_PAD_SD4_DAT6 = 205,
	MX6Q_PAD_SD4_DAT7 = 206,
	MX6Q_PAD_SD1_DAT1 = 207,
	MX6Q_PAD_SD1_DAT0 = 208,
	MX6Q_PAD_SD1_DAT3 = 209,
	MX6Q_PAD_SD1_CMD = 210,
	MX6Q_PAD_SD1_DAT2 = 211,
	MX6Q_PAD_SD1_CLK = 212,
	MX6Q_PAD_SD2_CLK = 213,
	MX6Q_PAD_SD2_CMD = 214,
	MX6Q_PAD_SD2_DAT3 = 215,
};

enum imx6dl_pads {
	MX6DL_PAD_RESERVE0 = 0,
	MX6DL_PAD_RESERVE1 = 1,
	MX6DL_PAD_RESERVE2 = 2,
	MX6DL_PAD_RESERVE3 = 3,
	MX6DL_PAD_RESERVE4 = 4,
	MX6DL_PAD_RESERVE5 = 5,
	MX6DL_PAD_RESERVE6 = 6,
	MX6DL_PAD_RESERVE7 = 7,
	MX6DL_PAD_RESERVE8 = 8,
	MX6DL_PAD_RESERVE9 = 9,
	MX6DL_PAD_RESERVE10 = 10,
	MX6DL_PAD_RESERVE11 = 11,
	MX6DL_PAD_RESERVE12 = 12,
	MX6DL_PAD_RESERVE13 = 13,
	MX6DL_PAD_RESERVE14 = 14,
	MX6DL_PAD_RESERVE15 = 15,
	MX6DL_PAD_RESERVE16 = 16,
	MX6DL_PAD_RESERVE17 = 17,
	MX6DL_PAD_RESERVE18 = 18,
	MX6DL_PAD_CSI0_DAT10 = 19,
	MX6DL_PAD_CSI0_DAT11 = 20,
	MX6DL_PAD_CSI0_DAT12 = 21,
	MX6DL_PAD_CSI0_DAT13 = 22,
	MX6DL_PAD_CSI0_DAT14 = 23,
	MX6DL_PAD_CSI0_DAT15 = 24,
	MX6DL_PAD_CSI0_DAT16 = 25,
	MX6DL_PAD_CSI0_DAT17 = 26,
	MX6DL_PAD_CSI0_DAT18 = 27,
	MX6DL_PAD_CSI0_DAT19 = 28,
	MX6DL_PAD_CSI0_DAT4 = 29,
	MX6DL_PAD_CSI0_DAT5 = 30,
	MX6DL_PAD_CSI0_DAT6 = 31,
	MX6DL_PAD_CSI0_DAT7 = 32,
	MX6DL_PAD_CSI0_DAT8 = 33,
	MX6DL_PAD_CSI0_DAT9 = 34,
	MX6DL_PAD_CSI0_DATA_EN = 35,
	MX6DL_PAD_CSI0_MCLK = 36,
	MX6DL_PAD_CSI0_PIXCLK = 37,
	MX6DL_PAD_CSI0_VSYNC = 38,
	MX6DL_PAD_DI0_DISP_CLK = 39,
	MX6DL_PAD_DI0_PIN15 = 40,
	MX6DL_PAD_DI0_PIN2 = 41,
	MX6DL_PAD_DI0_PIN3 = 42,
	MX6DL_PAD_DI0_PIN4 = 43,
	MX6DL_PAD_DISP0_DAT0 = 44,
	MX6DL_PAD_DISP0_DAT1 = 45,
	MX6DL_PAD_DISP0_DAT10 = 46,
	MX6DL_PAD_DISP0_DAT11 = 47,
	MX6DL_PAD_DISP0_DAT12 = 48,
	MX6DL_PAD_DISP0_DAT13 = 49,
	MX6DL_PAD_DISP0_DAT14 = 50,
	MX6DL_PAD_DISP0_DAT15 = 51,
	MX6DL_PAD_DISP0_DAT16 = 52,
	MX6DL_PAD_DISP0_DAT17 = 53,
	MX6DL_PAD_DISP0_DAT18 = 54,
	MX6DL_PAD_DISP0_DAT19 = 55,
	MX6DL_PAD_DISP0_DAT2 = 56,
	MX6DL_PAD_DISP0_DAT20 = 57,
	MX6DL_PAD_DISP0_DAT21 = 58,
	MX6DL_PAD_DISP0_DAT22 = 59,
	MX6DL_PAD_DISP0_DAT23 = 60,
	MX6DL_PAD_DISP0_DAT3 = 61,
	MX6DL_PAD_DISP0_DAT4 = 62,
	MX6DL_PAD_DISP0_DAT5 = 63,
	MX6DL_PAD_DISP0_DAT6 = 64,
	MX6DL_PAD_DISP0_DAT7 = 65,
	MX6DL_PAD_DISP0_DAT8 = 66,
	MX6DL_PAD_DISP0_DAT9 = 67,
	MX6DL_PAD_EIM_A16 = 68,
	MX6DL_PAD_EIM_A17 = 69,
	MX6DL_PAD_EIM_A18 = 70,
	MX6DL_PAD_EIM_A19 = 71,
	MX6DL_PAD_EIM_A20 = 72,
	MX6DL_PAD_EIM_A21 = 73,
	MX6DL_PAD_EIM_A22 = 74,
	MX6DL_PAD_EIM_A23 = 75,
	MX6DL_PAD_EIM_A24 = 76,
	MX6DL_PAD_EIM_A25 = 77,
	MX6DL_PAD_EIM_BCLK = 78,
	MX6DL_PAD_EIM_CS0 = 79,
	MX6DL_PAD_EIM_CS1 = 80,
	MX6DL_PAD_EIM_D16 = 81,
	MX6DL_PAD_EIM_D17 = 82,
	MX6DL_PAD_EIM_D18 = 83,
	MX6DL_PAD_EIM_D19 = 84,
	MX6DL_PAD_EIM_D20 = 85,
	MX6DL_PAD_EIM_D21 = 86,
	MX6DL_PAD_EIM_D22 = 87,
	MX6DL_PAD_EIM_D23 = 88,
	MX6DL_PAD_EIM_D24 = 89,
	MX6DL_PAD_EIM_D25 = 90,
	MX6DL_PAD_EIM_D26 = 91,
	MX6DL_PAD_EIM_D27 = 92,
	MX6DL_PAD_EIM_D28 = 93,
	MX6DL_PAD_EIM_D29 = 94,
	MX6DL_PAD_EIM_D30 = 95,
	MX6DL_PAD_EIM_D31 = 96,
	MX6DL_PAD_EIM_DA0 = 97,
	MX6DL_PAD_EIM_DA1 = 98,
	MX6DL_PAD_EIM_DA10 = 99,
	MX6DL_PAD_EIM_DA11 = 100,
	MX6DL_PAD_EIM_DA12 = 101,
	MX6DL_PAD_EIM_DA13 = 102,
	MX6DL_PAD_EIM_DA14 = 103,
	MX6DL_PAD_EIM_DA15 = 104,
	MX6DL_PAD_EIM_DA2 = 105,
	MX6DL_PAD_EIM_DA3 = 106,
	MX6DL_PAD_EIM_DA4 = 107,
	MX6DL_PAD_EIM_DA5 = 108,
	MX6DL_PAD_EIM_DA6 = 109,
	MX6DL_PAD_EIM_DA7 = 110,
	MX6DL_PAD_EIM_DA8 = 111,
	MX6DL_PAD_EIM_DA9 = 112,
	MX6DL_PAD_EIM_EB0 = 113,
	MX6DL_PAD_EIM_EB1 = 114,
	MX6DL_PAD_EIM_EB2 = 115,
	MX6DL_PAD_EIM_EB3 = 116,
	MX6DL_PAD_EIM_LBA = 117,
	MX6DL_PAD_EIM_OE = 118,
	MX6DL_PAD_EIM_RW = 119,
	MX6DL_PAD_EIM_WAIT = 120,
	MX6DL_PAD_ENET_CRS_DV = 121,
	MX6DL_PAD_ENET_MDC = 122,
	MX6DL_PAD_ENET_MDIO = 123,
	MX6DL_PAD_ENET_REF_CLK = 124,
	MX6DL_PAD_ENET_RX_ER = 125,
	MX6DL_PAD_ENET_RXD0 = 126,
	MX6DL_PAD_ENET_RXD1 = 127,
	MX6DL_PAD_ENET_TX_EN = 128,
	MX6DL_PAD_ENET_TXD0 = 129,
	MX6DL_PAD_ENET_TXD1 = 130,
	MX6DL_PAD_GPIO_0 = 131,
	MX6DL_PAD_GPIO_1 = 132,
	MX6DL_PAD_GPIO_16 = 133,
	MX6DL_PAD_GPIO_17 = 134,
	MX6DL_PAD_GPIO_18 = 135,
	MX6DL_PAD_GPIO_19 = 136,
	MX6DL_PAD_GPIO_2 = 137,
	MX6DL_PAD_GPIO_3 = 138,
	MX6DL_PAD_GPIO_4 = 139,
	MX6DL_PAD_GPIO_5 = 140,
	MX6DL_PAD_GPIO_6 = 141,
	MX6DL_PAD_GPIO_7 = 142,
	MX6DL_PAD_GPIO_8 = 143,
	MX6DL_PAD_GPIO_9 = 144,
	MX6DL_PAD_KEY_COL0 = 145,
	MX6DL_PAD_KEY_COL1 = 146,
	MX6DL_PAD_KEY_COL2 = 147,
	MX6DL_PAD_KEY_COL3 = 148,
	MX6DL_PAD_KEY_COL4 = 149,
	MX6DL_PAD_KEY_ROW0 = 150,
	MX6DL_PAD_KEY_ROW1 = 151,
	MX6DL_PAD_KEY_ROW2 = 152,
	MX6DL_PAD_KEY_ROW3 = 153,
	MX6DL_PAD_KEY_ROW4 = 154,
	MX6DL_PAD_NANDF_ALE = 155,
	MX6DL_PAD_NANDF_CLE = 156,
	MX6DL_PAD_NANDF_CS0 = 157,
	MX6DL_PAD_NANDF_CS1 = 158,
	MX6DL_PAD_NANDF_CS2 = 159,
	MX6DL_PAD_NANDF_CS3 = 160,
	MX6DL_PAD_NANDF_D0 = 161,
	MX6DL_PAD_NANDF_D1 = 162,
	MX6DL_PAD_NANDF_D2 = 163,
	MX6DL_PAD_NANDF_D3 = 164,
	MX6DL_PAD_NANDF_D4 = 165,
	MX6DL_PAD_NANDF_D5 = 166,
	MX6DL_PAD_NANDF_D6 = 167,
	MX6DL_PAD_NANDF_D7 = 168,
	MX6DL_PAD_NANDF_RB0 = 169,
	MX6DL_PAD_NANDF_WP_B = 170,
	MX6DL_PAD_RGMII_RD0 = 171,
	MX6DL_PAD_RGMII_RD1 = 172,
	MX6DL_PAD_RGMII_RD2 = 173,
	MX6DL_PAD_RGMII_RD3 = 174,
	MX6DL_PAD_RGMII_RX_CTL = 175,
	MX6DL_PAD_RGMII_RXC = 176,
	MX6DL_PAD_RGMII_TD0 = 177,
	MX6DL_PAD_RGMII_TD1 = 178,
	MX6DL_PAD_RGMII_TD2 = 179,
	MX6DL_PAD_RGMII_TD3 = 180,
	MX6DL_PAD_RGMII_TX_CTL = 181,
	MX6DL_PAD_RGMII_TXC = 182,
	MX6DL_PAD_SD1_CLK = 183,
	MX6DL_PAD_SD1_CMD = 184,
	MX6DL_PAD_SD1_DAT0 = 185,
	MX6DL_PAD_SD1_DAT1 = 186,
	MX6DL_PAD_SD1_DAT2 = 187,
	MX6DL_PAD_SD1_DAT3 = 188,
	MX6DL_PAD_SD2_CLK = 189,
	MX6DL_PAD_SD2_CMD = 190,
	MX6DL_PAD_SD2_DAT0 = 191,
	MX6DL_PAD_SD2_DAT1 = 192,
	MX6DL_PAD_SD2_DAT2 = 193,
	MX6DL_PAD_SD2_DAT3 = 194,
	MX6DL_PAD_SD3_CLK = 195,
	MX6DL_PAD_SD3_CMD = 196,
	MX6DL_PAD_SD3_DAT0 = 197,
	MX6DL_PAD_SD3_DAT1 = 198,
	MX6DL_PAD_SD3_DAT2 = 199,
	MX6DL_PAD_SD3_DAT3 = 200,
	MX6DL_PAD_SD3_DAT4 = 201,
	MX6DL_PAD_SD3_DAT5 = 202,
	MX6DL_PAD_SD3_DAT6 = 203,
	MX6DL_PAD_SD3_DAT7 = 204,
	MX6DL_PAD_SD3_RST = 205,
	MX6DL_PAD_SD4_CLK = 206,
	MX6DL_PAD_SD4_CMD = 207,
	MX6DL_PAD_SD4_DAT0 = 208,
	MX6DL_PAD_SD4_DAT1 = 209,
	MX6DL_PAD_SD4_DAT2 = 210,
	MX6DL_PAD_SD4_DAT3 = 211,
	MX6DL_PAD_SD4_DAT4 = 212,
	MX6DL_PAD_SD4_DAT5 = 213,
	MX6DL_PAD_SD4_DAT6 = 214,
	MX6DL_PAD_SD4_DAT7 = 215,
};

enum imx6sl_pads {
	MX6SL_PAD_RESERVE0 = 0,
	MX6SL_PAD_RESERVE1 = 1,
	MX6SL_PAD_RESERVE2 = 2,
	MX6SL_PAD_RESERVE3 = 3,
	MX6SL_PAD_RESERVE4 = 4,
	MX6SL_PAD_RESERVE5 = 5,
	MX6SL_PAD_RESERVE6 = 6,
	MX6SL_PAD_RESERVE7 = 7,
	MX6SL_PAD_RESERVE8 = 8,
	MX6SL_PAD_RESERVE9 = 9,
	MX6SL_PAD_RESERVE10 = 10,
	MX6SL_PAD_RESERVE11 = 11,
	MX6SL_PAD_RESERVE12 = 12,
	MX6SL_PAD_RESERVE13 = 13,
	MX6SL_PAD_RESERVE14 = 14,
	MX6SL_PAD_RESERVE15 = 15,
	MX6SL_PAD_RESERVE16 = 16,
	MX6SL_PAD_RESERVE17 = 17,
	MX6SL_PAD_RESERVE18 = 18,
	MX6SL_PAD_AUD_MCLK = 19,
	MX6SL_PAD_AUD_RXC = 20,
	MX6SL_PAD_AUD_RXD = 21,
	MX6SL_PAD_AUD_RXFS = 22,
	MX6SL_PAD_AUD_TXC = 23,
	MX6SL_PAD_AUD_TXD = 24,
	MX6SL_PAD_AUD_TXFS = 25,
	MX6SL_PAD_ECSPI1_MISO = 26,
	MX6SL_PAD_ECSPI1_MOSI = 27,
	MX6SL_PAD_ECSPI1_SCLK = 28,
	MX6SL_PAD_ECSPI1_SS0 = 29,
	MX6SL_PAD_ECSPI2_MISO = 30,
	MX6SL_PAD_ECSPI2_MOSI = 31,
	MX6SL_PAD_ECSPI2_SCLK = 32,
	MX6SL_PAD_ECSPI2_SS0 = 33,
	MX6SL_PAD_EPDC_BDR0 = 34,
	MX6SL_PAD_EPDC_BDR1 = 35,
	MX6SL_PAD_EPDC_D0 = 36,
	MX6SL_PAD_EPDC_D1 = 37,
	MX6SL_PAD_EPDC_D10 = 38,
	MX6SL_PAD_EPDC_D11 = 39,
	MX6SL_PAD_EPDC_D12 = 40,
	MX6SL_PAD_EPDC_D13 = 41,
	MX6SL_PAD_EPDC_D14 = 42,
	MX6SL_PAD_EPDC_D15 = 43,
	MX6SL_PAD_EPDC_D2 = 44,
	MX6SL_PAD_EPDC_D3 = 45,
	MX6SL_PAD_EPDC_D4 = 46,
	MX6SL_PAD_EPDC_D5 = 47,
	MX6SL_PAD_EPDC_D6 = 48,
	MX6SL_PAD_EPDC_D7 = 49,
	MX6SL_PAD_EPDC_D8 = 50,
	MX6SL_PAD_EPDC_D9 = 51,
	MX6SL_PAD_EPDC_GDCLK = 52,
	MX6SL_PAD_EPDC_GDOE = 53,
	MX6SL_PAD_EPDC_GDRL = 54,
	MX6SL_PAD_EPDC_GDSP = 55,
	MX6SL_PAD_EPDC_PWRCOM = 56,
	MX6SL_PAD_EPDC_PWRCTRL0 = 57,
	MX6SL_PAD_EPDC_PWRCTRL1 = 58,
	MX6SL_PAD_EPDC_PWRCTRL2 = 59,
	MX6SL_PAD_EPDC_PWRCTRL3 = 60,
	MX6SL_PAD_EPDC_PWRINT = 61,
	MX6SL_PAD_EPDC_PWRSTAT = 62,
	MX6SL_PAD_EPDC_PWRWAKEUP = 63,
	MX6SL_PAD_EPDC_SDCE0 = 64,
	MX6SL_PAD_EPDC_SDCE1 = 65,
	MX6SL_PAD_EPDC_SDCE2 = 66,
	MX6SL_PAD_EPDC_SDCE3 = 67,
	MX6SL_PAD_EPDC_SDCLK = 68,
	MX6SL_PAD_EPDC_SDLE = 69,
	MX6SL_PAD_EPDC_SDOE = 70,
	MX6SL_PAD_EPDC_SDSHR = 71,
	MX6SL_PAD_EPDC_VCOM0 = 72,
	MX6SL_PAD_EPDC_VCOM1 = 73,
	MX6SL_PAD_FEC_CRS_DV = 74,
	MX6SL_PAD_FEC_MDC = 75,
	MX6SL_PAD_FEC_MDIO = 76,
	MX6SL_PAD_FEC_REF_CLK = 77,
	MX6SL_PAD_FEC_RX_ER = 78,
	MX6SL_PAD_FEC_RXD0 = 79,
	MX6SL_PAD_FEC_RXD1 = 80,
	MX6SL_PAD_FEC_TX_CLK = 81,
	MX6SL_PAD_FEC_TX_EN = 82,
	MX6SL_PAD_FEC_TXD0 = 83,
	MX6SL_PAD_FEC_TXD1 = 84,
	MX6SL_PAD_HSIC_DAT = 85,
	MX6SL_PAD_HSIC_STROBE = 86,
	MX6SL_PAD_I2C1_SCL = 87,
	MX6SL_PAD_I2C1_SDA = 88,
	MX6SL_PAD_I2C2_SCL = 89,
	MX6SL_PAD_I2C2_SDA = 90,
	MX6SL_PAD_KEY_COL0 = 91,
	MX6SL_PAD_KEY_COL1 = 92,
	MX6SL_PAD_KEY_COL2 = 93,
	MX6SL_PAD_KEY_COL3 = 94,
	MX6SL_PAD_KEY_COL4 = 95,
	MX6SL_PAD_KEY_COL5 = 96,
	MX6SL_PAD_KEY_COL6 = 97,
	MX6SL_PAD_KEY_COL7 = 98,
	MX6SL_PAD_KEY_ROW0 = 99,
	MX6SL_PAD_KEY_ROW1 = 100,
	MX6SL_PAD_KEY_ROW2 = 101,
	MX6SL_PAD_KEY_ROW3 = 102,
	MX6SL_PAD_KEY_ROW4 = 103,
	MX6SL_PAD_KEY_ROW5 = 104,
	MX6SL_PAD_KEY_ROW6 = 105,
	MX6SL_PAD_KEY_ROW7 = 106,
	MX6SL_PAD_LCD_CLK = 107,
	MX6SL_PAD_LCD_DAT0 = 108,
	MX6SL_PAD_LCD_DAT1 = 109,
	MX6SL_PAD_LCD_DAT10 = 110,
	MX6SL_PAD_LCD_DAT11 = 111,
	MX6SL_PAD_LCD_DAT12 = 112,
	MX6SL_PAD_LCD_DAT13 = 113,
	MX6SL_PAD_LCD_DAT14 = 114,
	MX6SL_PAD_LCD_DAT15 = 115,
	MX6SL_PAD_LCD_DAT16 = 116,
	MX6SL_PAD_LCD_DAT17 = 117,
	MX6SL_PAD_LCD_DAT18 = 118,
	MX6SL_PAD_LCD_DAT19 = 119,
	MX6SL_PAD_LCD_DAT2 = 120,
	MX6SL_PAD_LCD_DAT20 = 121,
	MX6SL_PAD_LCD_DAT21 = 122,
	MX6SL_PAD_LCD_DAT22 = 123,
	MX6SL_PAD_LCD_DAT23 = 124,
	MX6SL_PAD_LCD_DAT3 = 125,
	MX6SL_PAD_LCD_DAT4 = 126,
	MX6SL_PAD_LCD_DAT5 = 127,
	MX6SL_PAD_LCD_DAT6 = 128,
	MX6SL_PAD_LCD_DAT7 = 129,
	MX6SL_PAD_LCD_DAT8 = 130,
	MX6SL_PAD_LCD_DAT9 = 131,
	MX6SL_PAD_LCD_ENABLE = 132,
	MX6SL_PAD_LCD_HSYNC = 133,
	MX6SL_PAD_LCD_RESET = 134,
	MX6SL_PAD_LCD_VSYNC = 135,
	MX6SL_PAD_PWM1 = 136,
	MX6SL_PAD_REF_CLK_24M = 137,
	MX6SL_PAD_REF_CLK_32K = 138,
	MX6SL_PAD_SD1_CLK = 139,
	MX6SL_PAD_SD1_CMD = 140,
	MX6SL_PAD_SD1_DAT0 = 141,
	MX6SL_PAD_SD1_DAT1 = 142,
	MX6SL_PAD_SD1_DAT2 = 143,
	MX6SL_PAD_SD1_DAT3 = 144,
	MX6SL_PAD_SD1_DAT4 = 145,
	MX6SL_PAD_SD1_DAT5 = 146,
	MX6SL_PAD_SD1_DAT6 = 147,
	MX6SL_PAD_SD1_DAT7 = 148,
	MX6SL_PAD_SD2_CLK = 149,
	MX6SL_PAD_SD2_CMD = 150,
	MX6SL_PAD_SD2_DAT0 = 151,
	MX6SL_PAD_SD2_DAT1 = 152,
	MX6SL_PAD_SD2_DAT2 = 153,
	MX6SL_PAD_SD2_DAT3 = 154,
	MX6SL_PAD_SD2_DAT4 = 155,
	MX6SL_PAD_SD2_DAT5 = 156,
	MX6SL_PAD_SD2_DAT6 = 157,
	MX6SL_PAD_SD2_DAT7 = 158,
	MX6SL_PAD_SD2_RST = 159,
	MX6SL_PAD_SD3_CLK = 160,
	MX6SL_PAD_SD3_CMD = 161,
	MX6SL_PAD_SD3_DAT0 = 162,
	MX6SL_PAD_SD3_DAT1 = 163,
	MX6SL_PAD_SD3_DAT2 = 164,
	MX6SL_PAD_SD3_DAT3 = 165,
	MX6SL_PAD_UART1_RXD = 166,
	MX6SL_PAD_UART1_TXD = 167,
	MX6SL_PAD_WDOG_B = 168,
};

enum imx6sll_pads {
	MX6SLL_PAD_RESERVE0 = 0,
	MX6SLL_PAD_RESERVE1 = 1,
	MX6SLL_PAD_RESERVE2 = 2,
	MX6SLL_PAD_RESERVE3 = 3,
	MX6SLL_PAD_RESERVE4 = 4,
	MX6SLL_PAD_WDOG_B = 5,
	MX6SLL_PAD_REF_CLK_24M = 6,
	MX6SLL_PAD_REF_CLK_32K = 7,
	MX6SLL_PAD_PWM1 = 8,
	MX6SLL_PAD_KEY_COL0 = 9,
	MX6SLL_PAD_KEY_ROW0 = 10,
	MX6SLL_PAD_KEY_COL1 = 11,
	MX6SLL_PAD_KEY_ROW1 = 12,
	MX6SLL_PAD_KEY_COL2 = 13,
	MX6SLL_PAD_KEY_ROW2 = 14,
	MX6SLL_PAD_KEY_COL3 = 15,
	MX6SLL_PAD_KEY_ROW3 = 16,
	MX6SLL_PAD_KEY_COL4 = 17,
	MX6SLL_PAD_KEY_ROW4 = 18,
	MX6SLL_PAD_KEY_COL5 = 19,
	MX6SLL_PAD_KEY_ROW5 = 20,
	MX6SLL_PAD_KEY_COL6 = 21,
	MX6SLL_PAD_KEY_ROW6 = 22,
	MX6SLL_PAD_KEY_COL7 = 23,
	MX6SLL_PAD_KEY_ROW7 = 24,
	MX6SLL_PAD_EPDC_DATA00 = 25,
	MX6SLL_PAD_EPDC_DATA01 = 26,
	MX6SLL_PAD_EPDC_DATA02 = 27,
	MX6SLL_PAD_EPDC_DATA03 = 28,
	MX6SLL_PAD_EPDC_DATA04 = 29,
	MX6SLL_PAD_EPDC_DATA05 = 30,
	MX6SLL_PAD_EPDC_DATA06 = 31,
	MX6SLL_PAD_EPDC_DATA07 = 32,
	MX6SLL_PAD_EPDC_DATA08 = 33,
	MX6SLL_PAD_EPDC_DATA09 = 34,
	MX6SLL_PAD_EPDC_DATA10 = 35,
	MX6SLL_PAD_EPDC_DATA11 = 36,
	MX6SLL_PAD_EPDC_DATA12 = 37,
	MX6SLL_PAD_EPDC_DATA13 = 38,
	MX6SLL_PAD_EPDC_DATA14 = 39,
	MX6SLL_PAD_EPDC_DATA15 = 40,
	MX6SLL_PAD_EPDC_SDCLK = 41,
	MX6SLL_PAD_EPDC_SDLE = 42,
	MX6SLL_PAD_EPDC_SDOE = 43,
	MX6SLL_PAD_EPDC_SDSHR = 44,
	MX6SLL_PAD_EPDC_SDCE0 = 45,
	MX6SLL_PAD_EPDC_SDCE1 = 46,
	MX6SLL_PAD_EPDC_SDCE2 = 47,
	MX6SLL_PAD_EPDC_SDCE3 = 48,
	MX6SLL_PAD_EPDC_GDCLK = 49,
	MX6SLL_PAD_EPDC_GDOE = 50,
	MX6SLL_PAD_EPDC_GDRL = 51,
	MX6SLL_PAD_EPDC_GDSP = 52,
	MX6SLL_PAD_EPDC_VCOM0 = 53,
	MX6SLL_PAD_EPDC_VCOM1 = 54,
	MX6SLL_PAD_EPDC_BDR0 = 55,
	MX6SLL_PAD_EPDC_BDR1 = 56,
	MX6SLL_PAD_EPDC_PWR_CTRL0 = 57,
	MX6SLL_PAD_EPDC_PWR_CTRL1 = 58,
	MX6SLL_PAD_EPDC_PWR_CTRL2 = 59,
	MX6SLL_PAD_EPDC_PWR_CTRL3 = 60,
	MX6SLL_PAD_EPDC_PWR_COM = 61,
	MX6SLL_PAD_EPDC_PWR_INT = 62,
	MX6SLL_PAD_EPDC_PWR_STAT = 63,
	MX6SLL_PAD_EPDC_PWR_WAKE = 64,
	MX6SLL_PAD_LCD_CLK = 65,
	MX6SLL_PAD_LCD_ENABLE = 66,
	MX6SLL_PAD_LCD_HSYNC = 67,
	MX6SLL_PAD_LCD_VSYNC = 68,
	MX6SLL_PAD_LCD_RESET = 69,
	MX6SLL_PAD_LCD_DATA00 = 70,
	MX6SLL_PAD_LCD_DATA01 = 71,
	MX6SLL_PAD_LCD_DATA02 = 72,
	MX6SLL_PAD_LCD_DATA03 = 73,
	MX6SLL_PAD_LCD_DATA04 = 74,
	MX6SLL_PAD_LCD_DATA05 = 75,
	MX6SLL_PAD_LCD_DATA06 = 76,
	MX6SLL_PAD_LCD_DATA07 = 77,
	MX6SLL_PAD_LCD_DATA08 = 78,
	MX6SLL_PAD_LCD_DATA09 = 79,
	MX6SLL_PAD_LCD_DATA10 = 80,
	MX6SLL_PAD_LCD_DATA11 = 81,
	MX6SLL_PAD_LCD_DATA12 = 82,
	MX6SLL_PAD_LCD_DATA13 = 83,
	MX6SLL_PAD_LCD_DATA14 = 84,
	MX6SLL_PAD_LCD_DATA15 = 85,
	MX6SLL_PAD_LCD_DATA16 = 86,
	MX6SLL_PAD_LCD_DATA17 = 87,
	MX6SLL_PAD_LCD_DATA18 = 88,
	MX6SLL_PAD_LCD_DATA19 = 89,
	MX6SLL_PAD_LCD_DATA20 = 90,
	MX6SLL_PAD_LCD_DATA21 = 91,
	MX6SLL_PAD_LCD_DATA22 = 92,
	MX6SLL_PAD_LCD_DATA23 = 93,
	MX6SLL_PAD_AUD_RXFS = 94,
	MX6SLL_PAD_AUD_RXC = 95,
	MX6SLL_PAD_AUD_RXD = 96,
	MX6SLL_PAD_AUD_TXC = 97,
	MX6SLL_PAD_AUD_TXFS = 98,
	MX6SLL_PAD_AUD_TXD = 99,
	MX6SLL_PAD_AUD_MCLK = 100,
	MX6SLL_PAD_UART1_RXD = 101,
	MX6SLL_PAD_UART1_TXD = 102,
	MX6SLL_PAD_I2C1_SCL = 103,
	MX6SLL_PAD_I2C1_SDA = 104,
	MX6SLL_PAD_I2C2_SCL = 105,
	MX6SLL_PAD_I2C2_SDA = 106,
	MX6SLL_PAD_ECSPI1_SCLK = 107,
	MX6SLL_PAD_ECSPI1_MOSI = 108,
	MX6SLL_PAD_ECSPI1_MISO = 109,
	MX6SLL_PAD_ECSPI1_SS0 = 110,
	MX6SLL_PAD_ECSPI2_SCLK = 111,
	MX6SLL_PAD_ECSPI2_MOSI = 112,
	MX6SLL_PAD_ECSPI2_MISO = 113,
	MX6SLL_PAD_ECSPI2_SS0 = 114,
	MX6SLL_PAD_SD1_CLK = 115,
	MX6SLL_PAD_SD1_CMD = 116,
	MX6SLL_PAD_SD1_DATA0 = 117,
	MX6SLL_PAD_SD1_DATA1 = 118,
	MX6SLL_PAD_SD1_DATA2 = 119,
	MX6SLL_PAD_SD1_DATA3 = 120,
	MX6SLL_PAD_SD1_DATA4 = 121,
	MX6SLL_PAD_SD1_DATA5 = 122,
	MX6SLL_PAD_SD1_DATA6 = 123,
	MX6SLL_PAD_SD1_DATA7 = 124,
	MX6SLL_PAD_SD2_RESET = 125,
	MX6SLL_PAD_SD2_CLK = 126,
	MX6SLL_PAD_SD2_CMD = 127,
	MX6SLL_PAD_SD2_DATA0 = 128,
	MX6SLL_PAD_SD2_DATA1 = 129,
	MX6SLL_PAD_SD2_DATA2 = 130,
	MX6SLL_PAD_SD2_DATA3 = 131,
	MX6SLL_PAD_SD2_DATA4 = 132,
	MX6SLL_PAD_SD2_DATA5 = 133,
	MX6SLL_PAD_SD2_DATA6 = 134,
	MX6SLL_PAD_SD2_DATA7 = 135,
	MX6SLL_PAD_SD3_CLK = 136,
	MX6SLL_PAD_SD3_CMD = 137,
	MX6SLL_PAD_SD3_DATA0 = 138,
	MX6SLL_PAD_SD3_DATA1 = 139,
	MX6SLL_PAD_SD3_DATA2 = 140,
	MX6SLL_PAD_SD3_DATA3 = 141,
	MX6SLL_PAD_GPIO4_IO20 = 142,
	MX6SLL_PAD_GPIO4_IO21 = 143,
	MX6SLL_PAD_GPIO4_IO19 = 144,
	MX6SLL_PAD_GPIO4_IO25 = 145,
	MX6SLL_PAD_GPIO4_IO18 = 146,
	MX6SLL_PAD_GPIO4_IO24 = 147,
	MX6SLL_PAD_GPIO4_IO23 = 148,
	MX6SLL_PAD_GPIO4_IO17 = 149,
	MX6SLL_PAD_GPIO4_IO22 = 150,
	MX6SLL_PAD_GPIO4_IO16 = 151,
	MX6SLL_PAD_GPIO4_IO26 = 152,
};

enum imx6sx_pads {
	MX6Sx_PAD_RESERVE0 = 0,
	MX6Sx_PAD_RESERVE1 = 1,
	MX6Sx_PAD_RESERVE2 = 2,
	MX6Sx_PAD_RESERVE3 = 3,
	MX6Sx_PAD_RESERVE4 = 4,
	MX6SX_PAD_GPIO1_IO00 = 5,
	MX6SX_PAD_GPIO1_IO01 = 6,
	MX6SX_PAD_GPIO1_IO02 = 7,
	MX6SX_PAD_GPIO1_IO03 = 8,
	MX6SX_PAD_GPIO1_IO04 = 9,
	MX6SX_PAD_GPIO1_IO05 = 10,
	MX6SX_PAD_GPIO1_IO06 = 11,
	MX6SX_PAD_GPIO1_IO07 = 12,
	MX6SX_PAD_GPIO1_IO08 = 13,
	MX6SX_PAD_GPIO1_IO09 = 14,
	MX6SX_PAD_GPIO1_IO10 = 15,
	MX6SX_PAD_GPIO1_IO11 = 16,
	MX6SX_PAD_GPIO1_IO12 = 17,
	MX6SX_PAD_GPIO1_IO13 = 18,
	MX6SX_PAD_CSI_DATA00 = 19,
	MX6SX_PAD_CSI_DATA01 = 20,
	MX6SX_PAD_CSI_DATA02 = 21,
	MX6SX_PAD_CSI_DATA03 = 22,
	MX6SX_PAD_CSI_DATA04 = 23,
	MX6SX_PAD_CSI_DATA05 = 24,
	MX6SX_PAD_CSI_DATA06 = 25,
	MX6SX_PAD_CSI_DATA07 = 26,
	MX6SX_PAD_CSI_HSYNC = 27,
	MX6SX_PAD_CSI_MCLK = 28,
	MX6SX_PAD_CSI_PIXCLK = 29,
	MX6SX_PAD_CSI_VSYNC = 30,
	MX6SX_PAD_ENET1_COL = 31,
	MX6SX_PAD_ENET1_CRS = 32,
	MX6SX_PAD_ENET1_MDC = 33,
	MX6SX_PAD_ENET1_MDIO = 34,
	MX6SX_PAD_ENET1_RX_CLK = 35,
	MX6SX_PAD_ENET1_TX_CLK = 36,
	MX6SX_PAD_ENET2_COL = 37,
	MX6SX_PAD_ENET2_CRS = 38,
	MX6SX_PAD_ENET2_RX_CLK = 39,
	MX6SX_PAD_ENET2_TX_CLK = 40,
	MX6SX_PAD_KEY_COL0 = 41,
	MX6SX_PAD_KEY_COL1 = 42,
	MX6SX_PAD_KEY_COL2 = 43,
	MX6SX_PAD_KEY_COL3 = 44,
	MX6SX_PAD_KEY_COL4 = 45,
	MX6SX_PAD_KEY_ROW0 = 46,
	MX6SX_PAD_KEY_ROW1 = 47,
	MX6SX_PAD_KEY_ROW2 = 48,
	MX6SX_PAD_KEY_ROW3 = 49,
	MX6SX_PAD_KEY_ROW4 = 50,
	MX6SX_PAD_LCD1_CLK = 51,
	MX6SX_PAD_LCD1_DATA00 = 52,
	MX6SX_PAD_LCD1_DATA01 = 53,
	MX6SX_PAD_LCD1_DATA02 = 54,
	MX6SX_PAD_LCD1_DATA03 = 55,
	MX6SX_PAD_LCD1_DATA04 = 56,
	MX6SX_PAD_LCD1_DATA05 = 57,
	MX6SX_PAD_LCD1_DATA06 = 58,
	MX6SX_PAD_LCD1_DATA07 = 59,
	MX6SX_PAD_LCD1_DATA08 = 60,
	MX6SX_PAD_LCD1_DATA09 = 61,
	MX6SX_PAD_LCD1_DATA10 = 62,
	MX6SX_PAD_LCD1_DATA11 = 63,
	MX6SX_PAD_LCD1_DATA12 = 64,
	MX6SX_PAD_LCD1_DATA13 = 65,
	MX6SX_PAD_LCD1_DATA14 = 66,
	MX6SX_PAD_LCD1_DATA15 = 67,
	MX6SX_PAD_LCD1_DATA16 = 68,
	MX6SX_PAD_LCD1_DATA17 = 69,
	MX6SX_PAD_LCD1_DATA18 = 70,
	MX6SX_PAD_LCD1_DATA19 = 71,
	MX6SX_PAD_LCD1_DATA20 = 72,
	MX6SX_PAD_LCD1_DATA21 = 73,
	MX6SX_PAD_LCD1_DATA22 = 74,
	MX6SX_PAD_LCD1_DATA23 = 75,
	MX6SX_PAD_LCD1_ENABLE = 76,
	MX6SX_PAD_LCD1_HSYNC = 77,
	MX6SX_PAD_LCD1_RESET = 78,
	MX6SX_PAD_LCD1_VSYNC = 79,
	MX6SX_PAD_NAND_ALE = 80,
	MX6SX_PAD_NAND_CE0_B = 81,
	MX6SX_PAD_NAND_CE1_B = 82,
	MX6SX_PAD_NAND_CLE = 83,
	MX6SX_PAD_NAND_DATA00 = 84,
	MX6SX_PAD_NAND_DATA01 = 85,
	MX6SX_PAD_NAND_DATA02 = 86,
	MX6SX_PAD_NAND_DATA03 = 87,
	MX6SX_PAD_NAND_DATA04 = 88,
	MX6SX_PAD_NAND_DATA05 = 89,
	MX6SX_PAD_NAND_DATA06 = 90,
	MX6SX_PAD_NAND_DATA07 = 91,
	MX6SX_PAD_NAND_RE_B = 92,
	MX6SX_PAD_NAND_READY_B = 93,
	MX6SX_PAD_NAND_WE_B = 94,
	MX6SX_PAD_NAND_WP_B = 95,
	MX6SX_PAD_QSPI1A_DATA0 = 96,
	MX6SX_PAD_QSPI1A_DATA1 = 97,
	MX6SX_PAD_QSPI1A_DATA2 = 98,
	MX6SX_PAD_QSPI1A_DATA3 = 99,
	MX6SX_PAD_QSPI1A_DQS = 100,
	MX6SX_PAD_QSPI1A_SCLK = 101,
	MX6SX_PAD_QSPI1A_SS0_B = 102,
	MX6SX_PAD_QSPI1A_SS1_B = 103,
	MX6SX_PAD_QSPI1B_DATA0 = 104,
	MX6SX_PAD_QSPI1B_DATA1 = 105,
	MX6SX_PAD_QSPI1B_DATA2 = 106,
	MX6SX_PAD_QSPI1B_DATA3 = 107,
	MX6SX_PAD_QSPI1B_DQS = 108,
	MX6SX_PAD_QSPI1B_SCLK = 109,
	MX6SX_PAD_QSPI1B_SS0_B = 110,
	MX6SX_PAD_QSPI1B_SS1_B = 111,
	MX6SX_PAD_RGMII1_RD0 = 112,
	MX6SX_PAD_RGMII1_RD1 = 113,
	MX6SX_PAD_RGMII1_RD2 = 114,
	MX6SX_PAD_RGMII1_RD3 = 115,
	MX6SX_PAD_RGMII1_RX_CTL = 116,
	MX6SX_PAD_RGMII1_RXC = 117,
	MX6SX_PAD_RGMII1_TD0 = 118,
	MX6SX_PAD_RGMII1_TD1 = 119,
	MX6SX_PAD_RGMII1_TD2 = 120,
	MX6SX_PAD_RGMII1_TD3 = 121,
	MX6SX_PAD_RGMII1_TX_CTL = 122,
	MX6SX_PAD_RGMII1_TXC = 123,
	MX6SX_PAD_RGMII2_RD0 = 124,
	MX6SX_PAD_RGMII2_RD1 = 125,
	MX6SX_PAD_RGMII2_RD2 = 126,
	MX6SX_PAD_RGMII2_RD3 = 127,
	MX6SX_PAD_RGMII2_RX_CTL = 128,
	MX6SX_PAD_RGMII2_RXC = 129,
	MX6SX_PAD_RGMII2_TD0 = 130,
	MX6SX_PAD_RGMII2_TD1 = 131,
	MX6SX_PAD_RGMII2_TD2 = 132,
	MX6SX_PAD_RGMII2_TD3 = 133,
	MX6SX_PAD_RGMII2_TX_CTL = 134,
	MX6SX_PAD_RGMII2_TXC = 135,
	MX6SX_PAD_SD1_CLK = 136,
	MX6SX_PAD_SD1_CMD = 137,
	MX6SX_PAD_SD1_DATA0 = 138,
	MX6SX_PAD_SD1_DATA1 = 139,
	MX6SX_PAD_SD1_DATA2 = 140,
	MX6SX_PAD_SD1_DATA3 = 141,
	MX6SX_PAD_SD2_CLK = 142,
	MX6SX_PAD_SD2_CMD = 143,
	MX6SX_PAD_SD2_DATA0 = 144,
	MX6SX_PAD_SD2_DATA1 = 145,
	MX6SX_PAD_SD2_DATA2 = 146,
	MX6SX_PAD_SD2_DATA3 = 147,
	MX6SX_PAD_SD3_CLK = 148,
	MX6SX_PAD_SD3_CMD = 149,
	MX6SX_PAD_SD3_DATA0 = 150,
	MX6SX_PAD_SD3_DATA1 = 151,
	MX6SX_PAD_SD3_DATA2 = 152,
	MX6SX_PAD_SD3_DATA3 = 153,
	MX6SX_PAD_SD3_DATA4 = 154,
	MX6SX_PAD_SD3_DATA5 = 155,
	MX6SX_PAD_SD3_DATA6 = 156,
	MX6SX_PAD_SD3_DATA7 = 157,
	MX6SX_PAD_SD4_CLK = 158,
	MX6SX_PAD_SD4_CMD = 159,
	MX6SX_PAD_SD4_DATA0 = 160,
	MX6SX_PAD_SD4_DATA1 = 161,
	MX6SX_PAD_SD4_DATA2 = 162,
	MX6SX_PAD_SD4_DATA3 = 163,
	MX6SX_PAD_SD4_DATA4 = 164,
	MX6SX_PAD_SD4_DATA5 = 165,
	MX6SX_PAD_SD4_DATA6 = 166,
	MX6SX_PAD_SD4_DATA7 = 167,
	MX6SX_PAD_SD4_RESET_B = 168,
	MX6SX_PAD_USB_H_DATA = 169,
	MX6SX_PAD_USB_H_STROBE = 170,
};

enum imx6ul_pads {
	MX6UL_PAD_RESERVE0 = 0,
	MX6UL_PAD_RESERVE1 = 1,
	MX6UL_PAD_RESERVE2 = 2,
	MX6UL_PAD_RESERVE3 = 3,
	MX6UL_PAD_RESERVE4 = 4,
	MX6UL_PAD_RESERVE5 = 5,
	MX6UL_PAD_RESERVE6 = 6,
	MX6UL_PAD_RESERVE7 = 7,
	MX6UL_PAD_RESERVE8 = 8,
	MX6UL_PAD_RESERVE9 = 9,
	MX6UL_PAD_RESERVE10 = 10,
	MX6UL_PAD_SNVS_TAMPER4 = 11,
	MX6UL_PAD_RESERVE12 = 12,
	MX6UL_PAD_RESERVE13 = 13,
	MX6UL_PAD_RESERVE14 = 14,
	MX6UL_PAD_RESERVE15 = 15,
	MX6UL_PAD_RESERVE16 = 16,
	MX6UL_PAD_JTAG_MOD = 17,
	MX6UL_PAD_JTAG_TMS = 18,
	MX6UL_PAD_JTAG_TDO = 19,
	MX6UL_PAD_JTAG_TDI = 20,
	MX6UL_PAD_JTAG_TCK = 21,
	MX6UL_PAD_JTAG_TRST_B = 22,
	MX6UL_PAD_GPIO1_IO00 = 23,
	MX6UL_PAD_GPIO1_IO01 = 24,
	MX6UL_PAD_GPIO1_IO02 = 25,
	MX6UL_PAD_GPIO1_IO03 = 26,
	MX6UL_PAD_GPIO1_IO04 = 27,
	MX6UL_PAD_GPIO1_IO05 = 28,
	MX6UL_PAD_GPIO1_IO06 = 29,
	MX6UL_PAD_GPIO1_IO07 = 30,
	MX6UL_PAD_GPIO1_IO08 = 31,
	MX6UL_PAD_GPIO1_IO09 = 32,
	MX6UL_PAD_UART1_TX_DATA = 33,
	MX6UL_PAD_UART1_RX_DATA = 34,
	MX6UL_PAD_UART1_CTS_B = 35,
	MX6UL_PAD_UART1_RTS_B = 36,
	MX6UL_PAD_UART2_TX_DATA = 37,
	MX6UL_PAD_UART2_RX_DATA = 38,
	MX6UL_PAD_UART2_CTS_B = 39,
	MX6UL_PAD_UART2_RTS_B = 40,
	MX6UL_PAD_UART3_TX_DATA = 41,
	MX6UL_PAD_UART3_RX_DATA = 42,
	MX6UL_PAD_UART3_CTS_B = 43,
	MX6UL_PAD_UART3_RTS_B = 44,
	MX6UL_PAD_UART4_TX_DATA = 45,
	MX6UL_PAD_UART4_RX_DATA = 46,
	MX6UL_PAD_UART5_TX_DATA = 47,
	MX6UL_PAD_UART5_RX_DATA = 48,
	MX6UL_PAD_ENET1_RX_DATA0 = 49,
	MX6UL_PAD_ENET1_RX_DATA1 = 50,
	MX6UL_PAD_ENET1_RX_EN = 51,
	MX6UL_PAD_ENET1_TX_DATA0 = 52,
	MX6UL_PAD_ENET1_TX_DATA1 = 53,
	MX6UL_PAD_ENET1_TX_EN = 54,
	MX6UL_PAD_ENET1_TX_CLK = 55,
	MX6UL_PAD_ENET1_RX_ER = 56,
	MX6UL_PAD_ENET2_RX_DATA0 = 57,
	MX6UL_PAD_ENET2_RX_DATA1 = 58,
	MX6UL_PAD_ENET2_RX_EN = 59,
	MX6UL_PAD_ENET2_TX_DATA0 = 60,
	MX6UL_PAD_ENET2_TX_DATA1 = 61,
	MX6UL_PAD_ENET2_TX_EN = 62,
	MX6UL_PAD_ENET2_TX_CLK = 63,
	MX6UL_PAD_ENET2_RX_ER = 64,
	MX6UL_PAD_LCD_CLK = 65,
	MX6UL_PAD_LCD_ENABLE = 66,
	MX6UL_PAD_LCD_HSYNC = 67,
	MX6UL_PAD_LCD_VSYNC = 68,
	MX6UL_PAD_LCD_RESET = 69,
	MX6UL_PAD_LCD_DATA00 = 70,
	MX6UL_PAD_LCD_DATA01 = 71,
	MX6UL_PAD_LCD_DATA02 = 72,
	MX6UL_PAD_LCD_DATA03 = 73,
	MX6UL_PAD_LCD_DATA04 = 74,
	MX6UL_PAD_LCD_DATA05 = 75,
	MX6UL_PAD_LCD_DATA06 = 76,
	MX6UL_PAD_LCD_DATA07 = 77,
	MX6UL_PAD_LCD_DATA08 = 78,
	MX6UL_PAD_LCD_DATA09 = 79,
	MX6UL_PAD_LCD_DATA10 = 80,
	MX6UL_PAD_LCD_DATA11 = 81,
	MX6UL_PAD_LCD_DATA12 = 82,
	MX6UL_PAD_LCD_DATA13 = 83,
	MX6UL_PAD_LCD_DATA14 = 84,
	MX6UL_PAD_LCD_DATA15 = 85,
	MX6UL_PAD_LCD_DATA16 = 86,
	MX6UL_PAD_LCD_DATA17 = 87,
	MX6UL_PAD_LCD_DATA18 = 88,
	MX6UL_PAD_LCD_DATA19 = 89,
	MX6UL_PAD_LCD_DATA20 = 90,
	MX6UL_PAD_LCD_DATA21 = 91,
	MX6UL_PAD_LCD_DATA22 = 92,
	MX6UL_PAD_LCD_DATA23 = 93,
	MX6UL_PAD_NAND_RE_B = 94,
	MX6UL_PAD_NAND_WE_B = 95,
	MX6UL_PAD_NAND_DATA00 = 96,
	MX6UL_PAD_NAND_DATA01 = 97,
	MX6UL_PAD_NAND_DATA02 = 98,
	MX6UL_PAD_NAND_DATA03 = 99,
	MX6UL_PAD_NAND_DATA04 = 100,
	MX6UL_PAD_NAND_DATA05 = 101,
	MX6UL_PAD_NAND_DATA06 = 102,
	MX6UL_PAD_NAND_DATA07 = 103,
	MX6UL_PAD_NAND_ALE = 104,
	MX6UL_PAD_NAND_WP_B = 105,
	MX6UL_PAD_NAND_READY_B = 106,
	MX6UL_PAD_NAND_CE0_B = 107,
	MX6UL_PAD_NAND_CE1_B = 108,
	MX6UL_PAD_NAND_CLE = 109,
	MX6UL_PAD_NAND_DQS = 110,
	MX6UL_PAD_SD1_CMD = 111,
	MX6UL_PAD_SD1_CLK = 112,
	MX6UL_PAD_SD1_DATA0 = 113,
	MX6UL_PAD_SD1_DATA1 = 114,
	MX6UL_PAD_SD1_DATA2 = 115,
	MX6UL_PAD_SD1_DATA3 = 116,
	MX6UL_PAD_CSI_MCLK = 117,
	MX6UL_PAD_CSI_PIXCLK = 118,
	MX6UL_PAD_CSI_VSYNC = 119,
	MX6UL_PAD_CSI_HSYNC = 120,
	MX6UL_PAD_CSI_DATA00 = 121,
	MX6UL_PAD_CSI_DATA01 = 122,
	MX6UL_PAD_CSI_DATA02 = 123,
	MX6UL_PAD_CSI_DATA03 = 124,
	MX6UL_PAD_CSI_DATA04 = 125,
	MX6UL_PAD_CSI_DATA05 = 126,
	MX6UL_PAD_CSI_DATA06 = 127,
	MX6UL_PAD_CSI_DATA07 = 128,
};

enum imx6ull_lpsr_pads {
	MX6ULL_PAD_BOOT_MODE0 = 0,
	MX6ULL_PAD_BOOT_MODE1 = 1,
	MX6ULL_PAD_SNVS_TAMPER0 = 2,
	MX6ULL_PAD_SNVS_TAMPER1 = 3,
	MX6ULL_PAD_SNVS_TAMPER2 = 4,
	MX6ULL_PAD_SNVS_TAMPER3 = 5,
	MX6ULL_PAD_SNVS_TAMPER4 = 6,
	MX6ULL_PAD_SNVS_TAMPER5 = 7,
	MX6ULL_PAD_SNVS_TAMPER6 = 8,
	MX6ULL_PAD_SNVS_TAMPER7 = 9,
	MX6ULL_PAD_SNVS_TAMPER8 = 10,
	MX6ULL_PAD_SNVS_TAMPER9 = 11,
};

enum imx7d_pads {
	MX7D_PAD_RESERVE0 = 0,
	MX7D_PAD_RESERVE1 = 1,
	MX7D_PAD_RESERVE2 = 2,
	MX7D_PAD_RESERVE3 = 3,
	MX7D_PAD_RESERVE4 = 4,
	MX7D_PAD_GPIO1_IO08 = 5,
	MX7D_PAD_GPIO1_IO09 = 6,
	MX7D_PAD_GPIO1_IO10 = 7,
	MX7D_PAD_GPIO1_IO11 = 8,
	MX7D_PAD_GPIO1_IO12 = 9,
	MX7D_PAD_GPIO1_IO13 = 10,
	MX7D_PAD_GPIO1_IO14 = 11,
	MX7D_PAD_GPIO1_IO15 = 12,
	MX7D_PAD_EPDC_DATA00 = 13,
	MX7D_PAD_EPDC_DATA01 = 14,
	MX7D_PAD_EPDC_DATA02 = 15,
	MX7D_PAD_EPDC_DATA03 = 16,
	MX7D_PAD_EPDC_DATA04 = 17,
	MX7D_PAD_EPDC_DATA05 = 18,
	MX7D_PAD_EPDC_DATA06 = 19,
	MX7D_PAD_EPDC_DATA07 = 20,
	MX7D_PAD_EPDC_DATA08 = 21,
	MX7D_PAD_EPDC_DATA09 = 22,
	MX7D_PAD_EPDC_DATA10 = 23,
	MX7D_PAD_EPDC_DATA11 = 24,
	MX7D_PAD_EPDC_DATA12 = 25,
	MX7D_PAD_EPDC_DATA13 = 26,
	MX7D_PAD_EPDC_DATA14 = 27,
	MX7D_PAD_EPDC_DATA15 = 28,
	MX7D_PAD_EPDC_SDCLK = 29,
	MX7D_PAD_EPDC_SDLE = 30,
	MX7D_PAD_EPDC_SDOE = 31,
	MX7D_PAD_EPDC_SDSHR = 32,
	MX7D_PAD_EPDC_SDCE0 = 33,
	MX7D_PAD_EPDC_SDCE1 = 34,
	MX7D_PAD_EPDC_SDCE2 = 35,
	MX7D_PAD_EPDC_SDCE3 = 36,
	MX7D_PAD_EPDC_GDCLK = 37,
	MX7D_PAD_EPDC_GDOE = 38,
	MX7D_PAD_EPDC_GDRL = 39,
	MX7D_PAD_EPDC_GDSP = 40,
	MX7D_PAD_EPDC_BDR0 = 41,
	MX7D_PAD_EPDC_BDR1 = 42,
	MX7D_PAD_EPDC_PWR_COM = 43,
	MX7D_PAD_EPDC_PWR_STAT = 44,
	MX7D_PAD_LCD_CLK = 45,
	MX7D_PAD_LCD_ENABLE = 46,
	MX7D_PAD_LCD_HSYNC = 47,
	MX7D_PAD_LCD_VSYNC = 48,
	MX7D_PAD_LCD_RESET = 49,
	MX7D_PAD_LCD_DATA00 = 50,
	MX7D_PAD_LCD_DATA01 = 51,
	MX7D_PAD_LCD_DATA02 = 52,
	MX7D_PAD_LCD_DATA03 = 53,
	MX7D_PAD_LCD_DATA04 = 54,
	MX7D_PAD_LCD_DATA05 = 55,
	MX7D_PAD_LCD_DATA06 = 56,
	MX7D_PAD_LCD_DATA07 = 57,
	MX7D_PAD_LCD_DATA08 = 58,
	MX7D_PAD_LCD_DATA09 = 59,
	MX7D_PAD_LCD_DATA10 = 60,
	MX7D_PAD_LCD_DATA11 = 61,
	MX7D_PAD_LCD_DATA12 = 62,
	MX7D_PAD_LCD_DATA13 = 63,
	MX7D_PAD_LCD_DATA14 = 64,
	MX7D_PAD_LCD_DATA15 = 65,
	MX7D_PAD_LCD_DATA16 = 66,
	MX7D_PAD_LCD_DATA17 = 67,
	MX7D_PAD_LCD_DATA18 = 68,
	MX7D_PAD_LCD_DATA19 = 69,
	MX7D_PAD_LCD_DATA20 = 70,
	MX7D_PAD_LCD_DATA21 = 71,
	MX7D_PAD_LCD_DATA22 = 72,
	MX7D_PAD_LCD_DATA23 = 73,
	MX7D_PAD_UART1_RX_DATA = 74,
	MX7D_PAD_UART1_TX_DATA = 75,
	MX7D_PAD_UART2_RX_DATA = 76,
	MX7D_PAD_UART2_TX_DATA = 77,
	MX7D_PAD_UART3_RX_DATA = 78,
	MX7D_PAD_UART3_TX_DATA = 79,
	MX7D_PAD_UART3_RTS_B = 80,
	MX7D_PAD_UART3_CTS_B = 81,
	MX7D_PAD_I2C1_SCL = 82,
	MX7D_PAD_I2C1_SDA = 83,
	MX7D_PAD_I2C2_SCL = 84,
	MX7D_PAD_I2C2_SDA = 85,
	MX7D_PAD_I2C3_SCL = 86,
	MX7D_PAD_I2C3_SDA = 87,
	MX7D_PAD_I2C4_SCL = 88,
	MX7D_PAD_I2C4_SDA = 89,
	MX7D_PAD_ECSPI1_SCLK = 90,
	MX7D_PAD_ECSPI1_MOSI = 91,
	MX7D_PAD_ECSPI1_MISO = 92,
	MX7D_PAD_ECSPI1_SS0 = 93,
	MX7D_PAD_ECSPI2_SCLK = 94,
	MX7D_PAD_ECSPI2_MOSI = 95,
	MX7D_PAD_ECSPI2_MISO = 96,
	MX7D_PAD_ECSPI2_SS0 = 97,
	MX7D_PAD_SD1_CD_B = 98,
	MX7D_PAD_SD1_WP = 99,
	MX7D_PAD_SD1_RESET_B = 100,
	MX7D_PAD_SD1_CLK = 101,
	MX7D_PAD_SD1_CMD = 102,
	MX7D_PAD_SD1_DATA0 = 103,
	MX7D_PAD_SD1_DATA1 = 104,
	MX7D_PAD_SD1_DATA2 = 105,
	MX7D_PAD_SD1_DATA3 = 106,
	MX7D_PAD_SD2_CD_B = 107,
	MX7D_PAD_SD2_WP = 108,
	MX7D_PAD_SD2_RESET_B = 109,
	MX7D_PAD_SD2_CLK = 110,
	MX7D_PAD_SD2_CMD = 111,
	MX7D_PAD_SD2_DATA0 = 112,
	MX7D_PAD_SD2_DATA1 = 113,
	MX7D_PAD_SD2_DATA2 = 114,
	MX7D_PAD_SD2_DATA3 = 115,
	MX7D_PAD_SD3_CLK = 116,
	MX7D_PAD_SD3_CMD = 117,
	MX7D_PAD_SD3_DATA0 = 118,
	MX7D_PAD_SD3_DATA1 = 119,
	MX7D_PAD_SD3_DATA2 = 120,
	MX7D_PAD_SD3_DATA3 = 121,
	MX7D_PAD_SD3_DATA4 = 122,
	MX7D_PAD_SD3_DATA5 = 123,
	MX7D_PAD_SD3_DATA6 = 124,
	MX7D_PAD_SD3_DATA7 = 125,
	MX7D_PAD_SD3_STROBE = 126,
	MX7D_PAD_SD3_RESET_B = 127,
	MX7D_PAD_SAI1_RX_DATA = 128,
	MX7D_PAD_SAI1_TX_BCLK = 129,
	MX7D_PAD_SAI1_TX_SYNC = 130,
	MX7D_PAD_SAI1_TX_DATA = 131,
	MX7D_PAD_SAI1_RX_SYNC = 132,
	MX7D_PAD_SAI1_RX_BCLK = 133,
	MX7D_PAD_SAI1_MCLK = 134,
	MX7D_PAD_SAI2_TX_SYNC = 135,
	MX7D_PAD_SAI2_TX_BCLK = 136,
	MX7D_PAD_SAI2_RX_DATA = 137,
	MX7D_PAD_SAI2_TX_DATA = 138,
	MX7D_PAD_ENET1_RGMII_RD0 = 139,
	MX7D_PAD_ENET1_RGMII_RD1 = 140,
	MX7D_PAD_ENET1_RGMII_RD2 = 141,
	MX7D_PAD_ENET1_RGMII_RD3 = 142,
	MX7D_PAD_ENET1_RGMII_RX_CTL = 143,
	MX7D_PAD_ENET1_RGMII_RXC = 144,
	MX7D_PAD_ENET1_RGMII_TD0 = 145,
	MX7D_PAD_ENET1_RGMII_TD1 = 146,
	MX7D_PAD_ENET1_RGMII_TD2 = 147,
	MX7D_PAD_ENET1_RGMII_TD3 = 148,
	MX7D_PAD_ENET1_RGMII_TX_CTL = 149,
	MX7D_PAD_ENET1_RGMII_TXC = 150,
	MX7D_PAD_ENET1_TX_CLK = 151,
	MX7D_PAD_ENET1_RX_CLK = 152,
	MX7D_PAD_ENET1_CRS = 153,
	MX7D_PAD_ENET1_COL = 154,
};

enum imx7d_lpsr_pads {
	MX7D_PAD_GPIO1_IO00 = 0,
	MX7D_PAD_GPIO1_IO01 = 1,
	MX7D_PAD_GPIO1_IO02 = 2,
	MX7D_PAD_GPIO1_IO03 = 3,
	MX7D_PAD_GPIO1_IO04 = 4,
	MX7D_PAD_GPIO1_IO05 = 5,
	MX7D_PAD_GPIO1_IO06 = 6,
	MX7D_PAD_GPIO1_IO07 = 7,
};

enum imx7ulp_pads {
	IMX7ULP_PAD_PTC0 = 0,
	IMX7ULP_PAD_PTC1 = 1,
	IMX7ULP_PAD_PTC2 = 2,
	IMX7ULP_PAD_PTC3 = 3,
	IMX7ULP_PAD_PTC4 = 4,
	IMX7ULP_PAD_PTC5 = 5,
	IMX7ULP_PAD_PTC6 = 6,
	IMX7ULP_PAD_PTC7 = 7,
	IMX7ULP_PAD_PTC8 = 8,
	IMX7ULP_PAD_PTC9 = 9,
	IMX7ULP_PAD_PTC10 = 10,
	IMX7ULP_PAD_PTC11 = 11,
	IMX7ULP_PAD_PTC12 = 12,
	IMX7ULP_PAD_PTC13 = 13,
	IMX7ULP_PAD_PTC14 = 14,
	IMX7ULP_PAD_PTC15 = 15,
	IMX7ULP_PAD_PTC16 = 16,
	IMX7ULP_PAD_PTC17 = 17,
	IMX7ULP_PAD_PTC18 = 18,
	IMX7ULP_PAD_PTC19 = 19,
	IMX7ULP_PAD_RESERVE0 = 20,
	IMX7ULP_PAD_RESERVE1 = 21,
	IMX7ULP_PAD_RESERVE2 = 22,
	IMX7ULP_PAD_RESERVE3 = 23,
	IMX7ULP_PAD_RESERVE4 = 24,
	IMX7ULP_PAD_RESERVE5 = 25,
	IMX7ULP_PAD_RESERVE6 = 26,
	IMX7ULP_PAD_RESERVE7 = 27,
	IMX7ULP_PAD_RESERVE8 = 28,
	IMX7ULP_PAD_RESERVE9 = 29,
	IMX7ULP_PAD_RESERVE10 = 30,
	IMX7ULP_PAD_RESERVE11 = 31,
	IMX7ULP_PAD_PTD0 = 32,
	IMX7ULP_PAD_PTD1 = 33,
	IMX7ULP_PAD_PTD2 = 34,
	IMX7ULP_PAD_PTD3 = 35,
	IMX7ULP_PAD_PTD4 = 36,
	IMX7ULP_PAD_PTD5 = 37,
	IMX7ULP_PAD_PTD6 = 38,
	IMX7ULP_PAD_PTD7 = 39,
	IMX7ULP_PAD_PTD8 = 40,
	IMX7ULP_PAD_PTD9 = 41,
	IMX7ULP_PAD_PTD10 = 42,
	IMX7ULP_PAD_PTD11 = 43,
	IMX7ULP_PAD_RESERVE12 = 44,
	IMX7ULP_PAD_RESERVE13 = 45,
	IMX7ULP_PAD_RESERVE14 = 46,
	IMX7ULP_PAD_RESERVE15 = 47,
	IMX7ULP_PAD_RESERVE16 = 48,
	IMX7ULP_PAD_RESERVE17 = 49,
	IMX7ULP_PAD_RESERVE18 = 50,
	IMX7ULP_PAD_RESERVE19 = 51,
	IMX7ULP_PAD_RESERVE20 = 52,
	IMX7ULP_PAD_RESERVE21 = 53,
	IMX7ULP_PAD_RESERVE22 = 54,
	IMX7ULP_PAD_RESERVE23 = 55,
	IMX7ULP_PAD_RESERVE24 = 56,
	IMX7ULP_PAD_RESERVE25 = 57,
	IMX7ULP_PAD_RESERVE26 = 58,
	IMX7ULP_PAD_RESERVE27 = 59,
	IMX7ULP_PAD_RESERVE28 = 60,
	IMX7ULP_PAD_RESERVE29 = 61,
	IMX7ULP_PAD_RESERVE30 = 62,
	IMX7ULP_PAD_RESERVE31 = 63,
	IMX7ULP_PAD_PTE0 = 64,
	IMX7ULP_PAD_PTE1 = 65,
	IMX7ULP_PAD_PTE2 = 66,
	IMX7ULP_PAD_PTE3 = 67,
	IMX7ULP_PAD_PTE4 = 68,
	IMX7ULP_PAD_PTE5 = 69,
	IMX7ULP_PAD_PTE6 = 70,
	IMX7ULP_PAD_PTE7 = 71,
	IMX7ULP_PAD_PTE8 = 72,
	IMX7ULP_PAD_PTE9 = 73,
	IMX7ULP_PAD_PTE10 = 74,
	IMX7ULP_PAD_PTE11 = 75,
	IMX7ULP_PAD_PTE12 = 76,
	IMX7ULP_PAD_PTE13 = 77,
	IMX7ULP_PAD_PTE14 = 78,
	IMX7ULP_PAD_PTE15 = 79,
	IMX7ULP_PAD_RESERVE32 = 80,
	IMX7ULP_PAD_RESERVE33 = 81,
	IMX7ULP_PAD_RESERVE34 = 82,
	IMX7ULP_PAD_RESERVE35 = 83,
	IMX7ULP_PAD_RESERVE36 = 84,
	IMX7ULP_PAD_RESERVE37 = 85,
	IMX7ULP_PAD_RESERVE38 = 86,
	IMX7ULP_PAD_RESERVE39 = 87,
	IMX7ULP_PAD_RESERVE40 = 88,
	IMX7ULP_PAD_RESERVE41 = 89,
	IMX7ULP_PAD_RESERVE42 = 90,
	IMX7ULP_PAD_RESERVE43 = 91,
	IMX7ULP_PAD_RESERVE44 = 92,
	IMX7ULP_PAD_RESERVE45 = 93,
	IMX7ULP_PAD_RESERVE46 = 94,
	IMX7ULP_PAD_RESERVE47 = 95,
	IMX7ULP_PAD_PTF0 = 96,
	IMX7ULP_PAD_PTF1 = 97,
	IMX7ULP_PAD_PTF2 = 98,
	IMX7ULP_PAD_PTF3 = 99,
	IMX7ULP_PAD_PTF4 = 100,
	IMX7ULP_PAD_PTF5 = 101,
	IMX7ULP_PAD_PTF6 = 102,
	IMX7ULP_PAD_PTF7 = 103,
	IMX7ULP_PAD_PTF8 = 104,
	IMX7ULP_PAD_PTF9 = 105,
	IMX7ULP_PAD_PTF10 = 106,
	IMX7ULP_PAD_PTF11 = 107,
	IMX7ULP_PAD_PTF12 = 108,
	IMX7ULP_PAD_PTF13 = 109,
	IMX7ULP_PAD_PTF14 = 110,
	IMX7ULP_PAD_PTF15 = 111,
	IMX7ULP_PAD_PTF16 = 112,
	IMX7ULP_PAD_PTF17 = 113,
	IMX7ULP_PAD_PTF18 = 114,
	IMX7ULP_PAD_PTF19 = 115,
};

struct gpio_pin_range {
	struct list_head node;
	struct pinctrl_dev *pctldev;
	struct pinctrl_gpio_range range;
};

struct gpio_array;

struct gpio_descs {
	struct gpio_array *info;
	unsigned int ndescs;
	struct gpio_desc *desc[0];
};

struct gpio_array {
	struct gpio_desc **desc;
	unsigned int size;
	struct gpio_chip *chip;
	long unsigned int *get_mask;
	long unsigned int *set_mask;
	long unsigned int invert_mask[0];
};

enum gpiod_flags {
	GPIOD_ASIS = 0,
	GPIOD_IN = 1,
	GPIOD_OUT_LOW = 3,
	GPIOD_OUT_HIGH = 7,
	GPIOD_OUT_LOW_OPEN_DRAIN = 11,
	GPIOD_OUT_HIGH_OPEN_DRAIN = 15,
};

enum gpio_lookup_flags {
	GPIO_ACTIVE_HIGH = 0,
	GPIO_ACTIVE_LOW = 1,
	GPIO_OPEN_DRAIN = 2,
	GPIO_OPEN_SOURCE = 4,
	GPIO_PERSISTENT = 0,
	GPIO_TRANSITORY = 8,
	GPIO_PULL_UP = 16,
	GPIO_PULL_DOWN = 32,
	GPIO_PULL_DISABLE = 64,
	GPIO_LOOKUP_FLAGS_DEFAULT = 0,
};

struct gpiod_lookup {
	const char *key;
	u16 chip_hwnum;
	const char *con_id;
	unsigned int idx;
	long unsigned int flags;
};

struct gpiod_lookup_table {
	struct list_head list;
	const char *dev_id;
	struct gpiod_lookup table[0];
};

struct gpiod_hog {
	struct list_head list;
	const char *chip_label;
	u16 chip_hwnum;
	const char *line_name;
	long unsigned int lflags;
	int dflags;
};

enum {
	GPIOLINE_CHANGED_REQUESTED = 1,
	GPIOLINE_CHANGED_RELEASED = 2,
	GPIOLINE_CHANGED_CONFIG = 3,
};

struct acpi_device;

struct acpi_gpio_info {
	struct acpi_device *adev;
	enum gpiod_flags flags;
	bool gpioint;
	int pin_config;
	int polarity;
	int triggering;
	bool wake_capable;
	unsigned int debounce;
	unsigned int quirks;
};

struct trace_event_raw_gpio_direction {
	struct trace_entry ent;
	unsigned int gpio;
	int in;
	int err;
	char __data[0];
};

struct trace_event_raw_gpio_value {
	struct trace_entry ent;
	unsigned int gpio;
	int get;
	int value;
	char __data[0];
};

struct trace_event_data_offsets_gpio_direction {};

struct trace_event_data_offsets_gpio_value {};

typedef void (*btf_trace_gpio_direction)(void *, unsigned int, int, int);

typedef void (*btf_trace_gpio_value)(void *, unsigned int, int, int);

struct devres;

struct gpio {
	unsigned int gpio;
	long unsigned int flags;
	const char *label;
};

struct of_mm_gpio_chip {
	struct gpio_chip gc;
	void (*save_regs)(struct of_mm_gpio_chip *);
	void *regs;
};

typedef struct gpio_desc * (*of_find_gpio_quirk)(struct device_node *, const char *, unsigned int, enum of_gpio_flags *);

struct gpiochip_info {
	char name[32];
	char label[32];
	__u32 lines;
};

enum gpio_v2_line_flag {
	GPIO_V2_LINE_FLAG_USED = 1,
	GPIO_V2_LINE_FLAG_ACTIVE_LOW = 2,
	GPIO_V2_LINE_FLAG_INPUT = 4,
	GPIO_V2_LINE_FLAG_OUTPUT = 8,
	GPIO_V2_LINE_FLAG_EDGE_RISING = 16,
	GPIO_V2_LINE_FLAG_EDGE_FALLING = 32,
	GPIO_V2_LINE_FLAG_OPEN_DRAIN = 64,
	GPIO_V2_LINE_FLAG_OPEN_SOURCE = 128,
	GPIO_V2_LINE_FLAG_BIAS_PULL_UP = 256,
	GPIO_V2_LINE_FLAG_BIAS_PULL_DOWN = 512,
	GPIO_V2_LINE_FLAG_BIAS_DISABLED = 1024,
	GPIO_V2_LINE_FLAG_EVENT_CLOCK_REALTIME = 2048,
	GPIO_V2_LINE_FLAG_EVENT_CLOCK_HTE = 4096,
};

struct gpio_v2_line_values {
	__u64 bits;
	__u64 mask;
};

enum gpio_v2_line_attr_id {
	GPIO_V2_LINE_ATTR_ID_FLAGS = 1,
	GPIO_V2_LINE_ATTR_ID_OUTPUT_VALUES = 2,
	GPIO_V2_LINE_ATTR_ID_DEBOUNCE = 3,
};

struct gpio_v2_line_attribute {
	__u32 id;
	__u32 padding;
	union {
		__u64 flags;
		__u64 values;
		__u32 debounce_period_us;
	};
};

struct gpio_v2_line_config_attribute {
	struct gpio_v2_line_attribute attr;
	__u64 mask;
};

struct gpio_v2_line_config {
	__u64 flags;
	__u32 num_attrs;
	__u32 padding[5];
	struct gpio_v2_line_config_attribute attrs[10];
};

struct gpio_v2_line_request {
	__u32 offsets[64];
	char consumer[32];
	struct gpio_v2_line_config config;
	__u32 num_lines;
	__u32 event_buffer_size;
	__u32 padding[5];
	__s32 fd;
};

struct gpio_v2_line_info {
	char name[32];
	char consumer[32];
	__u32 offset;
	__u32 num_attrs;
	__u64 flags;
	struct gpio_v2_line_attribute attrs[10];
	__u32 padding[4];
};

enum gpio_v2_line_changed_type {
	GPIO_V2_LINE_CHANGED_REQUESTED = 1,
	GPIO_V2_LINE_CHANGED_RELEASED = 2,
	GPIO_V2_LINE_CHANGED_CONFIG = 3,
};

struct gpio_v2_line_info_changed {
	struct gpio_v2_line_info info;
	__u64 timestamp_ns;
	__u32 event_type;
	__u32 padding[5];
};

enum gpio_v2_line_event_id {
	GPIO_V2_LINE_EVENT_RISING_EDGE = 1,
	GPIO_V2_LINE_EVENT_FALLING_EDGE = 2,
};

struct gpio_v2_line_event {
	__u64 timestamp_ns;
	__u32 id;
	__u32 offset;
	__u32 seqno;
	__u32 line_seqno;
	__u32 padding[6];
};

struct gpioline_info {
	__u32 line_offset;
	__u32 flags;
	char name[32];
	char consumer[32];
};

struct gpioline_info_changed {
	struct gpioline_info info;
	__u64 timestamp;
	__u32 event_type;
	__u32 padding[5];
};

struct gpiohandle_request {
	__u32 lineoffsets[64];
	__u32 flags;
	__u8 default_values[64];
	char consumer_label[32];
	__u32 lines;
	int fd;
};

struct gpiohandle_config {
	__u32 flags;
	__u8 default_values[64];
	__u32 padding[4];
};

struct gpiohandle_data {
	__u8 values[64];
};

struct gpioevent_request {
	__u32 lineoffset;
	__u32 handleflags;
	__u32 eventflags;
	char consumer_label[32];
	int fd;
};

struct gpioevent_data {
	__u64 timestamp;
	__u32 id;
	int: 32;
};

struct linehandle_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *descs[64];
	u32 num_descs;
};

struct linereq;

struct line {
	struct gpio_desc *desc;
	struct linereq *req;
	unsigned int irq;
	int: 32;
	u64 edflags;
	u64 timestamp_ns;
	u32 req_seqno;
	u32 line_seqno;
	struct delayed_work work;
	unsigned int sw_debounced;
	unsigned int level;
	int: 32;
};

struct linereq {
	struct gpio_device *gdev;
	const char *label;
	u32 num_lines;
	wait_queue_head_t wait;
	u32 event_buffer_size;
	int: 32;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_event *type;
			const struct gpio_v2_line_event *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_event *ptr;
			const struct gpio_v2_line_event *ptr_const;
		};
		int: 32;
		struct gpio_v2_line_event buf[0];
	} events;
	atomic_t seqno;
	struct mutex config_mutex;
	struct line lines[0];
};

struct lineevent_state {
	struct gpio_device *gdev;
	const char *label;
	struct gpio_desc *desc;
	u32 eflags;
	int irq;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpioevent_data *type;
			const struct gpioevent_data *const_type;
			char (*rectype)[0];
			struct gpioevent_data *ptr;
			const struct gpioevent_data *ptr_const;
		};
		int: 32;
		struct gpioevent_data buf[16];
	} events;
	u64 timestamp;
};

struct gpio_chardev_data {
	struct gpio_device *gdev;
	wait_queue_head_t wait;
	struct {
		union {
			struct __kfifo kfifo;
			struct gpio_v2_line_info_changed *type;
			const struct gpio_v2_line_info_changed *const_type;
			char (*rectype)[0];
			struct gpio_v2_line_info_changed *ptr;
			const struct gpio_v2_line_info_changed *ptr_const;
		};
		int: 32;
		struct gpio_v2_line_info_changed buf[32];
	} events;
	struct notifier_block lineinfo_changed_nb;
	long unsigned int *watched_lines;
	atomic_t watch_abi_version;
	int: 32;
};

struct class_attribute {
	struct attribute attr;
	ssize_t (*show)(struct class *, struct class_attribute *, char *);
	ssize_t (*store)(struct class *, struct class_attribute *, const char *, size_t);
};

struct gpiod_data {
	struct gpio_desc *desc;
	struct mutex mutex;
	struct kernfs_node *value_kn;
	int irq;
	unsigned char irq_flags;
	bool direction_can_change;
};

struct spi_device_id {
	char name[32];
	kernel_ulong_t driver_data;
};

struct spi_statistics {
	struct u64_stats_sync syncp;
	int: 32;
	u64_stats_t messages;
	u64_stats_t transfers;
	u64_stats_t errors;
	u64_stats_t timedout;
	u64_stats_t spi_sync;
	u64_stats_t spi_sync_immediate;
	u64_stats_t spi_async;
	u64_stats_t bytes;
	u64_stats_t bytes_rx;
	u64_stats_t bytes_tx;
	u64_stats_t transfer_bytes_histo[17];
	u64_stats_t transfers_split_maxsize;
};

struct spi_delay {
	u16 value;
	u8 unit;
};

struct spi_controller;

struct spi_device {
	struct device dev;
	struct spi_controller *controller;
	struct spi_controller *master;
	u32 max_speed_hz;
	u8 chip_select;
	u8 bits_per_word;
	bool rt;
	u32 mode;
	int irq;
	void *controller_state;
	void *controller_data;
	char modalias[32];
	const char *driver_override;
	struct gpio_desc *cs_gpiod;
	struct spi_delay word_delay;
	struct spi_delay cs_setup;
	struct spi_delay cs_hold;
	struct spi_delay cs_inactive;
	struct spi_statistics *pcpu_statistics;
	int: 32;
};

struct spi_message;

struct spi_transfer;

struct spi_controller_mem_ops;

struct spi_controller_mem_caps;

struct dma_chan;

struct spi_controller {
	struct device dev;
	struct list_head list;
	s16 bus_num;
	u16 num_chipselect;
	u16 dma_alignment;
	u32 mode_bits;
	u32 buswidth_override_bits;
	u32 bits_per_word_mask;
	u32 min_speed_hz;
	u32 max_speed_hz;
	u16 flags;
	bool devm_allocated;
	bool slave;
	size_t (*max_transfer_size)(struct spi_device *);
	size_t (*max_message_size)(struct spi_device *);
	struct mutex io_mutex;
	struct mutex add_lock;
	spinlock_t bus_lock_spinlock;
	struct mutex bus_lock_mutex;
	bool bus_lock_flag;
	int (*setup)(struct spi_device *);
	int (*set_cs_timing)(struct spi_device *);
	int (*transfer)(struct spi_device *, struct spi_message *);
	void (*cleanup)(struct spi_device *);
	bool (*can_dma)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	struct device *dma_map_dev;
	struct device *cur_rx_dma_dev;
	struct device *cur_tx_dma_dev;
	bool queued;
	struct kthread_worker *kworker;
	struct kthread_work pump_messages;
	spinlock_t queue_lock;
	struct list_head queue;
	struct spi_message *cur_msg;
	struct completion cur_msg_completion;
	bool cur_msg_incomplete;
	bool cur_msg_need_completion;
	bool busy;
	bool running;
	bool rt;
	bool auto_runtime_pm;
	bool cur_msg_mapped;
	char last_cs;
	bool last_cs_mode_high;
	bool fallback;
	struct completion xfer_completion;
	size_t max_dma_len;
	int (*prepare_transfer_hardware)(struct spi_controller *);
	int (*transfer_one_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_transfer_hardware)(struct spi_controller *);
	int (*prepare_message)(struct spi_controller *, struct spi_message *);
	int (*unprepare_message)(struct spi_controller *, struct spi_message *);
	int (*slave_abort)(struct spi_controller *);
	void (*set_cs)(struct spi_device *, bool);
	int (*transfer_one)(struct spi_controller *, struct spi_device *, struct spi_transfer *);
	void (*handle_err)(struct spi_controller *, struct spi_message *);
	const struct spi_controller_mem_ops *mem_ops;
	const struct spi_controller_mem_caps *mem_caps;
	struct gpio_desc **cs_gpiods;
	bool use_gpio_descriptors;
	s8 unused_native_cs;
	s8 max_native_cs;
	struct spi_statistics *pcpu_statistics;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	void *dummy_rx;
	void *dummy_tx;
	int (*fw_translate_cs)(struct spi_controller *, unsigned int);
	bool ptp_sts_supported;
	long unsigned int irq_flags;
	bool queue_empty;
	bool must_async;
};

struct spi_driver {
	const struct spi_device_id *id_table;
	int (*probe)(struct spi_device *);
	void (*remove)(struct spi_device *);
	void (*shutdown)(struct spi_device *);
	struct device_driver driver;
};

struct spi_message {
	struct list_head transfers;
	struct spi_device *spi;
	unsigned int is_dma_mapped: 1;
	void (*complete)(void *);
	void *context;
	unsigned int frame_length;
	unsigned int actual_length;
	int status;
	struct list_head queue;
	void *state;
	struct list_head resources;
	bool prepared;
};

struct ptp_system_timestamp;

struct spi_transfer {
	const void *tx_buf;
	void *rx_buf;
	unsigned int len;
	dma_addr_t tx_dma;
	dma_addr_t rx_dma;
	struct sg_table tx_sg;
	struct sg_table rx_sg;
	unsigned int dummy_data: 1;
	unsigned int cs_off: 1;
	unsigned int cs_change: 1;
	unsigned int tx_nbits: 3;
	unsigned int rx_nbits: 3;
	u8 bits_per_word;
	struct spi_delay delay;
	struct spi_delay cs_change_delay;
	struct spi_delay word_delay;
	u32 speed_hz;
	u32 effective_speed_hz;
	unsigned int ptp_sts_word_pre;
	unsigned int ptp_sts_word_post;
	struct ptp_system_timestamp *ptp_sts;
	bool timestamped;
	struct list_head transfer_list;
	u16 error;
};

struct spi_mem;

struct spi_mem_op;

struct spi_mem_dirmap_desc;

struct spi_controller_mem_ops {
	int (*adjust_op_size)(struct spi_mem *, struct spi_mem_op *);
	bool (*supports_op)(struct spi_mem *, const struct spi_mem_op *);
	int (*exec_op)(struct spi_mem *, const struct spi_mem_op *);
	const char * (*get_name)(struct spi_mem *);
	int (*dirmap_create)(struct spi_mem_dirmap_desc *);
	void (*dirmap_destroy)(struct spi_mem_dirmap_desc *);
	ssize_t (*dirmap_read)(struct spi_mem_dirmap_desc *, u64, size_t, void *);
	ssize_t (*dirmap_write)(struct spi_mem_dirmap_desc *, u64, size_t, const void *);
	int (*poll_status)(struct spi_mem *, const struct spi_mem_op *, u16, u16, long unsigned int, long unsigned int, long unsigned int);
};

struct spi_controller_mem_caps {
	bool dtr;
	bool ecc;
};

struct gen_74x164_chip {
	struct gpio_chip gpio_chip;
	struct mutex lock;
	struct gpio_desc *gpiod_oe;
	u32 registers;
	u8 buffer[0];
};

struct i2c_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

struct software_node {
	const char *name;
	const struct software_node *parent;
	const struct property_entry *properties;
};

struct i2c_msg {
	__u16 addr;
	__u16 flags;
	__u16 len;
	__u8 *buf;
};

union i2c_smbus_data {
	__u8 byte;
	__u16 word;
	__u8 block[34];
};

enum i2c_slave_event {
	I2C_SLAVE_READ_REQUESTED = 0,
	I2C_SLAVE_WRITE_REQUESTED = 1,
	I2C_SLAVE_READ_PROCESSED = 2,
	I2C_SLAVE_WRITE_RECEIVED = 3,
	I2C_SLAVE_STOP = 4,
};

struct i2c_client;

typedef int (*i2c_slave_cb_t)(struct i2c_client *, enum i2c_slave_event, u8 *);

struct i2c_adapter;

struct i2c_client {
	short unsigned int flags;
	short unsigned int addr;
	char name[20];
	struct i2c_adapter *adapter;
	int: 32;
	struct device dev;
	int init_irq;
	int irq;
	struct list_head detected;
	i2c_slave_cb_t slave_cb;
	void *devres_group_id;
};

enum i2c_alert_protocol {
	I2C_PROTOCOL_SMBUS_ALERT = 0,
	I2C_PROTOCOL_SMBUS_HOST_NOTIFY = 1,
};

struct i2c_board_info;

struct i2c_driver {
	unsigned int class;
	int (*probe)(struct i2c_client *, const struct i2c_device_id *);
	void (*remove)(struct i2c_client *);
	int (*probe_new)(struct i2c_client *);
	void (*shutdown)(struct i2c_client *);
	void (*alert)(struct i2c_client *, enum i2c_alert_protocol, unsigned int);
	int (*command)(struct i2c_client *, unsigned int, void *);
	struct device_driver driver;
	const struct i2c_device_id *id_table;
	int (*detect)(struct i2c_client *, struct i2c_board_info *);
	const short unsigned int *address_list;
	struct list_head clients;
	u32 flags;
};

struct i2c_board_info {
	char type[20];
	short unsigned int flags;
	short unsigned int addr;
	const char *dev_name;
	void *platform_data;
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	const struct software_node *swnode;
	const struct resource *resources;
	unsigned int num_resources;
	int irq;
};

struct i2c_algorithm;

struct i2c_lock_operations;

struct i2c_bus_recovery_info;

struct i2c_adapter_quirks;

struct i2c_adapter {
	struct module *owner;
	unsigned int class;
	const struct i2c_algorithm *algo;
	void *algo_data;
	const struct i2c_lock_operations *lock_ops;
	struct rt_mutex bus_lock;
	struct rt_mutex mux_lock;
	int timeout;
	int retries;
	int: 32;
	struct device dev;
	long unsigned int locked_flags;
	int nr;
	char name[48];
	struct completion dev_released;
	struct mutex userspace_clients_lock;
	struct list_head userspace_clients;
	struct i2c_bus_recovery_info *bus_recovery_info;
	const struct i2c_adapter_quirks *quirks;
	struct irq_domain *host_notify_domain;
	struct regulator *bus_regulator;
	int: 32;
};

struct i2c_algorithm {
	int (*master_xfer)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*master_xfer_atomic)(struct i2c_adapter *, struct i2c_msg *, int);
	int (*smbus_xfer)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	int (*smbus_xfer_atomic)(struct i2c_adapter *, u16, short unsigned int, char, u8, int, union i2c_smbus_data *);
	u32 (*functionality)(struct i2c_adapter *);
	int (*reg_slave)(struct i2c_client *);
	int (*unreg_slave)(struct i2c_client *);
};

struct i2c_lock_operations {
	void (*lock_bus)(struct i2c_adapter *, unsigned int);
	int (*trylock_bus)(struct i2c_adapter *, unsigned int);
	void (*unlock_bus)(struct i2c_adapter *, unsigned int);
};

struct i2c_bus_recovery_info {
	int (*recover_bus)(struct i2c_adapter *);
	int (*get_scl)(struct i2c_adapter *);
	void (*set_scl)(struct i2c_adapter *, int);
	int (*get_sda)(struct i2c_adapter *);
	void (*set_sda)(struct i2c_adapter *, int);
	int (*get_bus_free)(struct i2c_adapter *);
	void (*prepare_recovery)(struct i2c_adapter *);
	void (*unprepare_recovery)(struct i2c_adapter *);
	struct gpio_desc *scl_gpiod;
	struct gpio_desc *sda_gpiod;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_gpio;
};

struct i2c_adapter_quirks {
	u64 flags;
	int max_num_msgs;
	u16 max_write_len;
	u16 max_read_len;
	u16 max_comb_1st_msg_len;
	u16 max_comb_2nd_msg_len;
	int: 32;
};

struct max732x_platform_data {
	unsigned int gpio_base;
};

enum {
	OUTPUT_MASK = 0,
	OUTPUT_VAL = 1,
	OUTPUT_NUM = 2,
};

enum {
	MAX7319 = 0,
	MAX7320 = 1,
	MAX7321 = 2,
	MAX7322 = 3,
	MAX7323 = 4,
	MAX7324 = 5,
	MAX7325 = 6,
	MAX7326 = 7,
	MAX7327 = 8,
};

struct max732x_chip {
	struct gpio_chip gpio_chip;
	struct i2c_client *client;
	struct i2c_client *client_dummy;
	struct i2c_client *client_group_a;
	struct i2c_client *client_group_b;
	unsigned int mask_group_a;
	unsigned int dir_input;
	unsigned int dir_output;
	struct mutex lock;
	uint8_t reg_out[2];
};

struct mxc_gpio_hwdata {
	unsigned int dr_reg;
	unsigned int gdir_reg;
	unsigned int psr_reg;
	unsigned int icr1_reg;
	unsigned int icr2_reg;
	unsigned int imr_reg;
	unsigned int isr_reg;
	int edge_sel_reg;
	unsigned int low_level;
	unsigned int high_level;
	unsigned int rise_edge;
	unsigned int fall_edge;
};

struct mxc_gpio_reg_saved {
	u32 icr1;
	u32 icr2;
	u32 imr;
	u32 gdir;
	u32 edge_sel;
	u32 dr;
};

struct mxc_gpio_port {
	struct list_head node;
	void *base;
	struct clk *clk;
	int irq;
	int irq_high;
	struct irq_domain *domain;
	struct gpio_chip gc;
	struct device *dev;
	u32 both_edges;
	struct mxc_gpio_reg_saved gpio_saved_reg;
	bool power_off;
	u32 wakeup_pads;
	u32 wakeup_pads_save;
	bool is_pad_wakeup;
	u32 pad_type[32];
	const struct mxc_gpio_hwdata *hwdata;
	bool gpio_ranges;
};

struct pca953x_platform_data {
	unsigned int gpio_base;
	u32 invert;
	int irq_base;
	void *context;
	int (*setup)(struct i2c_client *, unsigned int, unsigned int, void *);
	void (*teardown)(struct i2c_client *, unsigned int, unsigned int, void *);
	const char * const *names;
};

struct pca953x_reg_config {
	int direction;
	int output;
	int input;
	int invert;
};

struct pca953x_chip {
	unsigned int gpio_start;
	struct mutex i2c_lock;
	struct regmap *regmap;
	atomic_t wakeup_path;
	struct i2c_client *client;
	struct gpio_chip gpio_chip;
	const char * const *names;
	long unsigned int driver_data;
	struct regulator *regulator;
	const struct pca953x_reg_config *regs;
	u8 (*recalc_addr)(struct pca953x_chip *, int, int);
	bool (*check_reg)(struct pca953x_chip *, unsigned int, u32);
};

struct pcf857x_platform_data {
	unsigned int gpio_base;
	unsigned int n_latch;
	int (*setup)(struct i2c_client *, int, unsigned int, void *);
	void (*teardown)(struct i2c_client *, int, unsigned int, void *);
	void *context;
};

struct pcf857x {
	struct gpio_chip chip;
	struct i2c_client *client;
	struct mutex lock;
	unsigned int out;
	unsigned int status;
	unsigned int irq_enabled;
	int (*write)(struct i2c_client *, unsigned int);
	int (*read)(struct i2c_client *);
};

enum stmpe_block {
	STMPE_BLOCK_GPIO = 1,
	STMPE_BLOCK_KEYPAD = 2,
	STMPE_BLOCK_TOUCHSCREEN = 4,
	STMPE_BLOCK_ADC = 8,
	STMPE_BLOCK_PWM = 16,
	STMPE_BLOCK_ROTATOR = 32,
};

enum stmpe_partnum {
	STMPE610 = 0,
	STMPE801 = 1,
	STMPE811 = 2,
	STMPE1600 = 3,
	STMPE1601 = 4,
	STMPE1801 = 5,
	STMPE2401 = 6,
	STMPE2403 = 7,
	STMPE_NBR_PARTS = 8,
};

enum {
	STMPE_IDX_CHIP_ID = 0,
	STMPE_IDX_SYS_CTRL = 1,
	STMPE_IDX_SYS_CTRL2 = 2,
	STMPE_IDX_ICR_LSB = 3,
	STMPE_IDX_IER_LSB = 4,
	STMPE_IDX_IER_MSB = 5,
	STMPE_IDX_ISR_LSB = 6,
	STMPE_IDX_ISR_MSB = 7,
	STMPE_IDX_GPMR_LSB = 8,
	STMPE_IDX_GPMR_CSB = 9,
	STMPE_IDX_GPMR_MSB = 10,
	STMPE_IDX_GPSR_LSB = 11,
	STMPE_IDX_GPSR_CSB = 12,
	STMPE_IDX_GPSR_MSB = 13,
	STMPE_IDX_GPCR_LSB = 14,
	STMPE_IDX_GPCR_CSB = 15,
	STMPE_IDX_GPCR_MSB = 16,
	STMPE_IDX_GPDR_LSB = 17,
	STMPE_IDX_GPDR_CSB = 18,
	STMPE_IDX_GPDR_MSB = 19,
	STMPE_IDX_GPEDR_LSB = 20,
	STMPE_IDX_GPEDR_CSB = 21,
	STMPE_IDX_GPEDR_MSB = 22,
	STMPE_IDX_GPRER_LSB = 23,
	STMPE_IDX_GPRER_CSB = 24,
	STMPE_IDX_GPRER_MSB = 25,
	STMPE_IDX_GPFER_LSB = 26,
	STMPE_IDX_GPFER_CSB = 27,
	STMPE_IDX_GPFER_MSB = 28,
	STMPE_IDX_GPPUR_LSB = 29,
	STMPE_IDX_GPPDR_LSB = 30,
	STMPE_IDX_GPAFR_U_MSB = 31,
	STMPE_IDX_IEGPIOR_LSB = 32,
	STMPE_IDX_IEGPIOR_CSB = 33,
	STMPE_IDX_IEGPIOR_MSB = 34,
	STMPE_IDX_ISGPIOR_LSB = 35,
	STMPE_IDX_ISGPIOR_CSB = 36,
	STMPE_IDX_ISGPIOR_MSB = 37,
	STMPE_IDX_MAX = 38,
};

struct stmpe_client_info;

struct stmpe_variant_info;

struct stmpe_platform_data;

struct stmpe {
	struct regulator *vcc;
	struct regulator *vio;
	struct mutex lock;
	struct mutex irq_lock;
	struct device *dev;
	struct irq_domain *domain;
	void *client;
	struct stmpe_client_info *ci;
	enum stmpe_partnum partnum;
	struct stmpe_variant_info *variant;
	const u8 *regs;
	int irq;
	int num_gpios;
	u8 ier[2];
	u8 oldier[2];
	struct stmpe_platform_data *pdata;
	u8 sample_time;
	u8 mod_12b;
	u8 ref_sel;
	u8 adc_freq;
};

enum {
	REG_RE = 0,
	REG_FE = 1,
	REG_IE = 2,
};

enum {
	LSB = 0,
	CSB = 1,
	MSB = 2,
};

struct stmpe_gpio {
	struct gpio_chip chip;
	struct stmpe *stmpe;
	struct device *dev;
	struct mutex irq_lock;
	u32 norequest_mask;
	u8 regs[9];
	u8 oldregs[9];
};

struct fsl_gpio_soc_data {
	bool have_paddr;
};

struct vf610_gpio_port {
	struct gpio_chip gc;
	struct irq_chip ic;
	void *base;
	void *gpio_base;
	const struct fsl_gpio_soc_data *sdata;
	u8 irqc[32];
	struct clk *clk_port;
	struct clk *clk_gpio;
	int irq;
};

enum gpio_input_trigger_type {
	GPIO_RPMSG_TRI_IGNORE = 0,
	GPIO_RPMSG_TRI_RISING = 1,
	GPIO_RPMSG_TRI_FALLING = 2,
	GPIO_RPMSG_TRI_BOTH_EDGE = 3,
	GPIO_RPMSG_TRI_LOW_LEVEL = 4,
	GPIO_RPMSG_TRI_HIGH_LEVEL = 5,
};

enum gpio_rpmsg_header_type {
	GPIO_RPMSG_SETUP = 0,
	GPIO_RPMSG_REPLY = 1,
	GPIO_RPMSG_NOTIFY = 2,
};

enum gpio_rpmsg_header_cmd {
	GPIO_RPMSG_INPUT_INIT = 0,
	GPIO_RPMSG_OUTPUT_INIT = 1,
	GPIO_RPMSG_INPUT_GET = 2,
};

struct gpio_rpmsg_data {
	struct imx_rpmsg_head header;
	u8 pin_idx;
	u8 port_idx;
	union {
		u8 event;
		u8 retcode;
		u8 value;
	} out;
	union {
		u8 wakeup;
		u8 value;
	} in;
	short: 16;
};

struct imx_rpmsg_gpio_pin {
	u32 irq_type;
	int: 32;
	struct gpio_rpmsg_data msg;
};

struct imx_rpmsg_gpio_port {
	struct gpio_chip gc;
	struct irq_chip chip;
	struct irq_domain *domain;
	int: 32;
	struct imx_rpmsg_gpio_pin gpio_pins[32];
	int idx;
	int: 32;
};

struct imx_gpio_rpmsg_info {
	struct rpmsg_device *rpdev;
	struct gpio_rpmsg_data *notify_msg;
	struct gpio_rpmsg_data *reply_msg;
	struct pm_qos_request pm_qos_req;
	struct completion cmd_complete;
	struct imx_rpmsg_gpio_port *port_store[10];
	struct mutex lock;
};

struct imx_rpmsg_gpio_work {
	struct gpio_rpmsg_data *msg;
	struct imx_rpmsg_gpio_port *port;
	struct work_struct rpmsg_send_wq;
};

enum pwm_polarity {
	PWM_POLARITY_NORMAL = 0,
	PWM_POLARITY_INVERSED = 1,
};

struct pwm_args {
	u64 period;
	enum pwm_polarity polarity;
	int: 32;
};

enum {
	PWMF_REQUESTED = 1,
	PWMF_EXPORTED = 2,
};

struct pwm_state {
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
	bool usage_power;
};

struct pwm_chip;

struct pwm_device {
	const char *label;
	long unsigned int flags;
	unsigned int hwpwm;
	unsigned int pwm;
	struct pwm_chip *chip;
	void *chip_data;
	struct pwm_args args;
	struct pwm_state state;
	struct pwm_state last;
};

struct pwm_ops;

struct pwm_chip {
	struct device *dev;
	const struct pwm_ops *ops;
	int base;
	unsigned int npwm;
	struct pwm_device * (*of_xlate)(struct pwm_chip *, const struct of_phandle_args *);
	unsigned int of_pwm_n_cells;
	struct list_head list;
	struct pwm_device *pwms;
};

struct pwm_capture {
	unsigned int period;
	unsigned int duty_cycle;
};

struct pwm_ops {
	int (*request)(struct pwm_chip *, struct pwm_device *);
	void (*free)(struct pwm_chip *, struct pwm_device *);
	int (*capture)(struct pwm_chip *, struct pwm_device *, struct pwm_capture *, long unsigned int);
	int (*apply)(struct pwm_chip *, struct pwm_device *, const struct pwm_state *);
	void (*get_state)(struct pwm_chip *, struct pwm_device *, struct pwm_state *);
	struct module *owner;
};

struct pwm_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
	unsigned int period;
	enum pwm_polarity polarity;
	const char *module;
};

struct trace_event_raw_pwm {
	struct trace_entry ent;
	struct pwm_device *pwm;
	int: 32;
	u64 period;
	u64 duty_cycle;
	enum pwm_polarity polarity;
	bool enabled;
	char __data[0];
};

struct trace_event_data_offsets_pwm {};

typedef void (*btf_trace_pwm_apply)(void *, struct pwm_device *, const struct pwm_state *);

typedef void (*btf_trace_pwm_get)(void *, struct pwm_device *, const struct pwm_state *);

struct pwm_export {
	struct device child;
	struct pwm_device *pwm;
	struct mutex lock;
	struct pwm_state suspend;
};

enum fsl_pwm_clk {
	FSL_PWM_CLK_SYS = 0,
	FSL_PWM_CLK_FIX = 1,
	FSL_PWM_CLK_EXT = 2,
	FSL_PWM_CLK_CNTEN = 3,
	FSL_PWM_CLK_MAX = 4,
};

struct fsl_ftm_soc {
	bool has_enable_bits;
};

struct fsl_pwm_periodcfg {
	enum fsl_pwm_clk clk_select;
	unsigned int clk_ps;
	unsigned int mod_period;
};

struct fsl_pwm_chip {
	struct pwm_chip chip;
	struct mutex lock;
	struct regmap *regmap;
	struct fsl_pwm_periodcfg period;
	struct clk *ipg_clk;
	struct clk *clk[4];
	const struct fsl_ftm_soc *soc;
};

struct pwm_imx27_chip {
	struct clk *clk_ipg;
	struct clk *clk_per;
	struct clk *clk_32k;
	void *mmio_base;
	struct pwm_chip chip;
	unsigned int duty_cycle;
	spinlock_t lock;
};

struct imx_tpm_pwm_chip {
	struct pwm_chip chip;
	struct clk *clk;
	void *base;
	struct mutex lock;
	u32 user_count;
	u32 enable_count;
	u32 real_period;
};

struct imx_tpm_pwm_param {
	u8 prescale;
	u32 mod;
	u32 val;
};

enum {
	pci_channel_io_normal = 1,
	pci_channel_io_frozen = 2,
	pci_channel_io_perm_failure = 3,
};

struct pci_bus_resource {
	struct list_head list;
	struct resource *res;
	unsigned int flags;
};

typedef u32 pci_bus_addr_t;

struct pci_bus_region {
	pci_bus_addr_t start;
	pci_bus_addr_t end;
};

enum pci_fixup_pass {
	pci_fixup_early = 0,
	pci_fixup_header = 1,
	pci_fixup_final = 2,
	pci_fixup_enable = 3,
	pci_fixup_resume = 4,
	pci_fixup_suspend = 5,
	pci_fixup_resume_early = 6,
	pci_fixup_suspend_late = 7,
};

struct hotplug_slot_ops;

struct hotplug_slot {
	const struct hotplug_slot_ops *ops;
	struct list_head slot_list;
	struct pci_slot *pci_slot;
	struct module *owner;
	const char *mod_name;
};

enum pci_dev_flags {
	PCI_DEV_FLAGS_MSI_INTX_DISABLE_BUG = 1,
	PCI_DEV_FLAGS_NO_D3 = 2,
	PCI_DEV_FLAGS_ASSIGNED = 4,
	PCI_DEV_FLAGS_ACS_ENABLED_QUIRK = 8,
	PCI_DEV_FLAG_PCIE_BRIDGE_ALIAS = 32,
	PCI_DEV_FLAGS_NO_BUS_RESET = 64,
	PCI_DEV_FLAGS_NO_PM_RESET = 128,
	PCI_DEV_FLAGS_VPD_REF_F0 = 256,
	PCI_DEV_FLAGS_BRIDGE_XLATE_ROOT = 512,
	PCI_DEV_FLAGS_NO_FLR_RESET = 1024,
	PCI_DEV_FLAGS_NO_RELAXED_ORDERING = 2048,
	PCI_DEV_FLAGS_HAS_MSI_MASKING = 4096,
};

enum pci_bus_flags {
	PCI_BUS_FLAGS_NO_MSI = 1,
	PCI_BUS_FLAGS_NO_MMRBC = 2,
	PCI_BUS_FLAGS_NO_AERSID = 4,
	PCI_BUS_FLAGS_NO_EXTCFG = 8,
};

enum pci_bus_speed {
	PCI_SPEED_33MHz = 0,
	PCI_SPEED_66MHz = 1,
	PCI_SPEED_66MHz_PCIX = 2,
	PCI_SPEED_100MHz_PCIX = 3,
	PCI_SPEED_133MHz_PCIX = 4,
	PCI_SPEED_66MHz_PCIX_ECC = 5,
	PCI_SPEED_100MHz_PCIX_ECC = 6,
	PCI_SPEED_133MHz_PCIX_ECC = 7,
	PCI_SPEED_66MHz_PCIX_266 = 9,
	PCI_SPEED_100MHz_PCIX_266 = 10,
	PCI_SPEED_133MHz_PCIX_266 = 11,
	AGP_UNKNOWN = 12,
	AGP_1X = 13,
	AGP_2X = 14,
	AGP_4X = 15,
	AGP_8X = 16,
	PCI_SPEED_66MHz_PCIX_533 = 17,
	PCI_SPEED_100MHz_PCIX_533 = 18,
	PCI_SPEED_133MHz_PCIX_533 = 19,
	PCIE_SPEED_2_5GT = 20,
	PCIE_SPEED_5_0GT = 21,
	PCIE_SPEED_8_0GT = 22,
	PCIE_SPEED_16_0GT = 23,
	PCIE_SPEED_32_0GT = 24,
	PCIE_SPEED_64_0GT = 25,
	PCI_SPEED_UNKNOWN = 255,
};

enum pcie_bus_config_types {
	PCIE_BUS_TUNE_OFF = 0,
	PCIE_BUS_DEFAULT = 1,
	PCIE_BUS_SAFE = 2,
	PCIE_BUS_PERFORMANCE = 3,
	PCIE_BUS_PEER2PEER = 4,
};

struct hotplug_slot_ops {
	int (*enable_slot)(struct hotplug_slot *);
	int (*disable_slot)(struct hotplug_slot *);
	int (*set_attention_status)(struct hotplug_slot *, u8);
	int (*hardware_test)(struct hotplug_slot *, u32);
	int (*get_power_status)(struct hotplug_slot *, u8 *);
	int (*get_attention_status)(struct hotplug_slot *, u8 *);
	int (*get_latch_status)(struct hotplug_slot *, u8 *);
	int (*get_adapter_status)(struct hotplug_slot *, u8 *);
	int (*reset_slot)(struct hotplug_slot *, bool);
};

enum pci_bar_type {
	pci_bar_unknown = 0,
	pci_bar_io = 1,
	pci_bar_mem32 = 2,
	pci_bar_mem64 = 3,
};

struct pci_domain_busn_res {
	struct list_head list;
	struct resource res;
	int domain_nr;
};

struct dmi_strmatch {
	unsigned char slot: 7;
	unsigned char exact_match: 1;
	char substr[79];
};

struct dmi_system_id {
	int (*callback)(const struct dmi_system_id *);
	const char *ident;
	struct dmi_strmatch matches[4];
	void *driver_data;
};

struct bus_attribute {
	struct attribute attr;
	ssize_t (*show)(struct bus_type *, char *);
	ssize_t (*store)(struct bus_type *, const char *, size_t);
};

enum {
	LOGIC_PIO_INDIRECT = 0,
	LOGIC_PIO_CPU_MMIO = 1,
};

struct logic_pio_host_ops;

struct logic_pio_hwaddr {
	struct list_head list;
	struct fwnode_handle *fwnode;
	resource_size_t hw_start;
	resource_size_t io_start;
	resource_size_t size;
	long unsigned int flags;
	void *hostdata;
	const struct logic_pio_host_ops *ops;
};

struct logic_pio_host_ops {
	u32 (*in)(void *, long unsigned int, size_t);
	void (*out)(void *, long unsigned int, u32, size_t);
	u32 (*ins)(void *, long unsigned int, void *, size_t, unsigned int);
	void (*outs)(void *, long unsigned int, const void *, size_t, unsigned int);
};

enum pcie_reset_state {
	pcie_deassert_reset = 1,
	pcie_warm_reset = 2,
	pcie_hot_reset = 3,
};

enum pcie_link_width {
	PCIE_LNK_WIDTH_RESRV = 0,
	PCIE_LNK_X1 = 1,
	PCIE_LNK_X2 = 2,
	PCIE_LNK_X4 = 4,
	PCIE_LNK_X8 = 8,
	PCIE_LNK_X12 = 12,
	PCIE_LNK_X16 = 16,
	PCIE_LNK_X32 = 32,
	PCIE_LNK_WIDTH_UNKNOWN = 255,
};

typedef int (*arch_set_vga_state_t)(struct pci_dev *, bool, unsigned int, u32);

struct pci_cap_saved_data {
	u16 cap_nr;
	bool cap_extended;
	unsigned int size;
	u32 data[0];
};

struct pci_cap_saved_state {
	struct hlist_node next;
	struct pci_cap_saved_data cap;
};

struct pci_reset_fn_method {
	int (*reset_fn)(struct pci_dev *, bool);
	char *name;
};

struct pci_pme_device {
	struct list_head list;
	struct pci_dev *dev;
};

struct pci_saved_state {
	u32 config_space[16];
	struct pci_cap_saved_data cap[0];
};

struct pci_devres {
	unsigned int enabled: 1;
	unsigned int pinned: 1;
	unsigned int orig_intx: 1;
	unsigned int restore_intx: 1;
	unsigned int mwi: 1;
	u32 region_mask;
};

struct driver_attribute {
	struct attribute attr;
	ssize_t (*show)(struct device_driver *, char *);
	ssize_t (*store)(struct device_driver *, const char *, size_t);
};

struct pci_dynid {
	struct list_head node;
	struct pci_device_id id;
};

struct drv_dev_and_id {
	struct pci_driver *drv;
	struct pci_dev *dev;
	const struct pci_device_id *id;
};

enum pci_mmap_state {
	pci_mmap_io = 0,
	pci_mmap_mem = 1,
};

enum pci_mmap_api {
	PCI_MMAP_SYSFS = 0,
	PCI_MMAP_PROCFS = 1,
};

struct pci_dev_resource {
	struct list_head list;
	struct resource *res;
	struct pci_dev *dev;
	resource_size_t start;
	resource_size_t end;
	resource_size_t add_size;
	resource_size_t min_align;
	long unsigned int flags;
};

enum release_type {
	leaf_only = 0,
	whole_subtree = 1,
};

enum enable_type {
	undefined = 4294967295,
	user_disabled = 0,
	auto_disabled = 1,
	user_enabled = 2,
	auto_enabled = 3,
};

struct msix_entry {
	u32 vector;
	u16 entry;
};

struct pcie_link_state {
	struct pci_dev *pdev;
	struct pci_dev *downstream;
	struct pcie_link_state *root;
	struct pcie_link_state *parent;
	struct list_head sibling;
	u32 aspm_support: 7;
	u32 aspm_enabled: 7;
	u32 aspm_capable: 7;
	u32 aspm_default: 7;
	char: 4;
	u32 aspm_disable: 7;
	u32 clkpm_capable: 1;
	u32 clkpm_enabled: 1;
	u32 clkpm_default: 1;
	u32 clkpm_disable: 1;
};

struct pci_filp_private {
	enum pci_mmap_state mmap_state;
	int write_combine;
};

struct pci_slot_attribute {
	struct attribute attr;
	ssize_t (*show)(struct pci_slot *, char *);
	ssize_t (*store)(struct pci_slot *, const char *, size_t);
};

struct of_bus;

struct of_pci_range_parser {
	struct device_node *node;
	struct of_bus *bus;
	const __be32 *range;
	const __be32 *end;
	int na;
	int ns;
	int pna;
	bool dma;
};

struct of_pci_range {
	union {
		u64 pci_addr;
		u64 bus_addr;
	};
	u64 cpu_addr;
	u64 size;
	u32 flags;
	int: 32;
};

enum dmi_field {
	DMI_NONE = 0,
	DMI_BIOS_VENDOR = 1,
	DMI_BIOS_VERSION = 2,
	DMI_BIOS_DATE = 3,
	DMI_BIOS_RELEASE = 4,
	DMI_EC_FIRMWARE_RELEASE = 5,
	DMI_SYS_VENDOR = 6,
	DMI_PRODUCT_NAME = 7,
	DMI_PRODUCT_VERSION = 8,
	DMI_PRODUCT_SERIAL = 9,
	DMI_PRODUCT_UUID = 10,
	DMI_PRODUCT_SKU = 11,
	DMI_PRODUCT_FAMILY = 12,
	DMI_BOARD_VENDOR = 13,
	DMI_BOARD_NAME = 14,
	DMI_BOARD_VERSION = 15,
	DMI_BOARD_SERIAL = 16,
	DMI_BOARD_ASSET_TAG = 17,
	DMI_CHASSIS_VENDOR = 18,
	DMI_CHASSIS_TYPE = 19,
	DMI_CHASSIS_VERSION = 20,
	DMI_CHASSIS_SERIAL = 21,
	DMI_CHASSIS_ASSET_TAG = 22,
	DMI_STRING_MAX = 23,
	DMI_OEM_STRING = 24,
};

enum {
	NVME_REG_CAP = 0,
	NVME_REG_VS = 8,
	NVME_REG_INTMS = 12,
	NVME_REG_INTMC = 16,
	NVME_REG_CC = 20,
	NVME_REG_CSTS = 28,
	NVME_REG_NSSR = 32,
	NVME_REG_AQA = 36,
	NVME_REG_ASQ = 40,
	NVME_REG_ACQ = 48,
	NVME_REG_CMBLOC = 56,
	NVME_REG_CMBSZ = 60,
	NVME_REG_BPINFO = 64,
	NVME_REG_BPRSEL = 68,
	NVME_REG_BPMBL = 72,
	NVME_REG_CMBMSC = 80,
	NVME_REG_CRTO = 104,
	NVME_REG_PMRCAP = 3584,
	NVME_REG_PMRCTL = 3588,
	NVME_REG_PMRSTS = 3592,
	NVME_REG_PMREBS = 3596,
	NVME_REG_PMRSWTP = 3600,
	NVME_REG_DBS = 4096,
};

enum {
	NVME_CC_ENABLE = 1,
	NVME_CC_EN_SHIFT = 0,
	NVME_CC_CSS_SHIFT = 4,
	NVME_CC_MPS_SHIFT = 7,
	NVME_CC_AMS_SHIFT = 11,
	NVME_CC_SHN_SHIFT = 14,
	NVME_CC_IOSQES_SHIFT = 16,
	NVME_CC_IOCQES_SHIFT = 20,
	NVME_CC_CSS_NVM = 0,
	NVME_CC_CSS_CSI = 96,
	NVME_CC_CSS_MASK = 112,
	NVME_CC_AMS_RR = 0,
	NVME_CC_AMS_WRRU = 2048,
	NVME_CC_AMS_VS = 14336,
	NVME_CC_SHN_NONE = 0,
	NVME_CC_SHN_NORMAL = 16384,
	NVME_CC_SHN_ABRUPT = 32768,
	NVME_CC_SHN_MASK = 49152,
	NVME_CC_IOSQES = 393216,
	NVME_CC_IOCQES = 4194304,
	NVME_CC_CRIME = 16777216,
};

enum {
	NVME_CSTS_RDY = 1,
	NVME_CSTS_CFS = 2,
	NVME_CSTS_NSSRO = 16,
	NVME_CSTS_PP = 32,
	NVME_CSTS_SHST_NORMAL = 0,
	NVME_CSTS_SHST_OCCUR = 4,
	NVME_CSTS_SHST_CMPLT = 8,
	NVME_CSTS_SHST_MASK = 12,
};

enum {
	SWITCHTEC_GAS_MRPC_OFFSET = 0,
	SWITCHTEC_GAS_TOP_CFG_OFFSET = 4096,
	SWITCHTEC_GAS_SW_EVENT_OFFSET = 6144,
	SWITCHTEC_GAS_SYS_INFO_OFFSET = 8192,
	SWITCHTEC_GAS_FLASH_INFO_OFFSET = 8704,
	SWITCHTEC_GAS_PART_CFG_OFFSET = 16384,
	SWITCHTEC_GAS_NTB_OFFSET = 65536,
	SWITCHTEC_GAS_PFF_CSR_OFFSET = 1261568,
};

enum {
	SWITCHTEC_NTB_REG_INFO_OFFSET = 0,
	SWITCHTEC_NTB_REG_CTRL_OFFSET = 16384,
	SWITCHTEC_NTB_REG_DBMSG_OFFSET = 409600,
};

struct nt_partition_info {
	u32 xlink_enabled;
	u32 target_part_low;
	u32 target_part_high;
	u32 reserved;
};

struct ntb_info_regs {
	u8 partition_count;
	u8 partition_id;
	u16 reserved1;
	u64 ep_map;
	u16 requester_id;
	u16 reserved2;
	u32 reserved3[4];
	struct nt_partition_info ntp_info[48];
};

struct ntb_ctrl_regs {
	u32 partition_status;
	u32 partition_op;
	u32 partition_ctrl;
	u32 bar_setup;
	u32 bar_error;
	u16 lut_table_entries;
	u16 lut_table_offset;
	u32 lut_error;
	u16 req_id_table_size;
	u16 req_id_table_offset;
	u32 req_id_error;
	u32 reserved1[7];
	struct {
		u32 ctl;
		u32 win_size;
		u64 xlate_addr;
	} bar_entry[6];
	struct {
		u32 win_size;
		u32 reserved[3];
	} bar_ext_entry[6];
	u32 reserved2[192];
	u32 req_id_table[512];
	u32 reserved3[256];
	u64 lut_entry[512];
};

struct pci_dev_reset_methods {
	u16 vendor;
	u16 device;
	int (*reset)(struct pci_dev *, bool);
};

struct pci_dev_acs_enabled {
	u16 vendor;
	u16 device;
	int (*acs_enabled)(struct pci_dev *, u16);
};

struct pci_dev_acs_ops {
	u16 vendor;
	u16 device;
	int (*enable_acs)(struct pci_dev *);
	int (*disable_acs_redir)(struct pci_dev *);
};

struct vga_device {
	struct list_head list;
	struct pci_dev *pdev;
	unsigned int decodes;
	unsigned int owns;
	unsigned int locks;
	unsigned int io_lock_cnt;
	unsigned int mem_lock_cnt;
	unsigned int io_norm_cnt;
	unsigned int mem_norm_cnt;
	bool bridge_has_one_vga;
	bool is_firmware_default;
	unsigned int (*set_decode)(struct pci_dev *, bool);
};

struct vga_arb_user_card {
	struct pci_dev *pdev;
	unsigned int mem_cnt;
	unsigned int io_cnt;
};

struct vga_arb_private {
	struct list_head list;
	struct pci_dev *target;
	struct vga_arb_user_card cards[16];
	spinlock_t lock;
};

struct pci_epf_device_id {
	char name[20];
	kernel_ulong_t driver_data;
};

enum pci_interrupt_pin {
	PCI_INTERRUPT_UNKNOWN = 0,
	PCI_INTERRUPT_INTA = 1,
	PCI_INTERRUPT_INTB = 2,
	PCI_INTERRUPT_INTC = 3,
	PCI_INTERRUPT_INTD = 4,
};

enum pci_barno {
	NO_BAR = 4294967295,
	BAR_0 = 0,
	BAR_1 = 1,
	BAR_2 = 2,
	BAR_3 = 3,
	BAR_4 = 4,
	BAR_5 = 5,
};

struct pci_epf_header {
	u16 vendorid;
	u16 deviceid;
	u8 revid;
	u8 progif_code;
	u8 subclass_code;
	u8 baseclass_code;
	u8 cache_line_size;
	u16 subsys_vendor_id;
	u16 subsys_id;
	enum pci_interrupt_pin interrupt_pin;
};

struct pci_epf;

struct pci_epf_ops {
	int (*bind)(struct pci_epf *);
	void (*unbind)(struct pci_epf *);
	struct config_group * (*add_cfs)(struct pci_epf *, struct config_group *);
};

struct pci_epf_bar {
	dma_addr_t phys_addr;
	void *addr;
	size_t size;
	enum pci_barno barno;
	int flags;
};

struct pci_epc;

struct pci_epf_driver;

struct pci_epf {
	struct device dev;
	const char *name;
	struct pci_epf_header *header;
	struct pci_epf_bar bar[6];
	u8 msi_interrupts;
	u16 msix_interrupts;
	u8 func_no;
	u8 vfunc_no;
	struct pci_epc *epc;
	struct pci_epf *epf_pf;
	struct pci_epf_driver *driver;
	struct list_head list;
	struct notifier_block nb;
	struct mutex lock;
	struct pci_epc *sec_epc;
	struct list_head sec_epc_list;
	struct pci_epf_bar sec_epc_bar[6];
	u8 sec_epc_func_no;
	struct config_group *group;
	unsigned int is_bound;
	unsigned int is_vf;
	long unsigned int vfunction_num_map;
	struct list_head pci_vepf;
	int: 32;
};

struct pci_epf_driver {
	int (*probe)(struct pci_epf *);
	void (*remove)(struct pci_epf *);
	struct device_driver driver;
	struct pci_epf_ops *ops;
	struct module *owner;
	struct list_head epf_group;
	const struct pci_epf_device_id *id_table;
};

struct pci_epc_ops;

struct pci_epc_mem;

struct pci_epc {
	struct device dev;
	struct list_head pci_epf;
	const struct pci_epc_ops *ops;
	struct pci_epc_mem **windows;
	struct pci_epc_mem *mem;
	unsigned int num_windows;
	u8 max_functions;
	u8 *max_vfs;
	struct config_group *group;
	struct mutex lock;
	long unsigned int function_num_map;
	struct atomic_notifier_head notifier;
	int: 32;
};

enum pci_epc_interface_type {
	UNKNOWN_INTERFACE = 4294967295,
	PRIMARY_INTERFACE = 0,
	SECONDARY_INTERFACE = 1,
};

enum pci_epc_irq_type {
	PCI_EPC_IRQ_UNKNOWN = 0,
	PCI_EPC_IRQ_LEGACY = 1,
	PCI_EPC_IRQ_MSI = 2,
	PCI_EPC_IRQ_MSIX = 3,
};

struct pci_epc_features;

struct pci_epc_ops {
	int (*write_header)(struct pci_epc *, u8, u8, struct pci_epf_header *);
	int (*set_bar)(struct pci_epc *, u8, u8, struct pci_epf_bar *);
	void (*clear_bar)(struct pci_epc *, u8, u8, struct pci_epf_bar *);
	int (*map_addr)(struct pci_epc *, u8, u8, phys_addr_t, u64, size_t);
	void (*unmap_addr)(struct pci_epc *, u8, u8, phys_addr_t);
	int (*set_msi)(struct pci_epc *, u8, u8, u8);
	int (*get_msi)(struct pci_epc *, u8, u8);
	int (*set_msix)(struct pci_epc *, u8, u8, u16, enum pci_barno, u32);
	int (*get_msix)(struct pci_epc *, u8, u8);
	int (*raise_irq)(struct pci_epc *, u8, u8, enum pci_epc_irq_type, u16);
	int (*map_msi_irq)(struct pci_epc *, u8, u8, phys_addr_t, u8, u32, u32 *, u32 *);
	int (*start)(struct pci_epc *);
	void (*stop)(struct pci_epc *);
	const struct pci_epc_features * (*get_features)(struct pci_epc *, u8, u8);
	struct module *owner;
};

struct pci_epc_features {
	unsigned int linkup_notifier: 1;
	unsigned int core_init_notifier: 1;
	unsigned int msi_capable: 1;
	unsigned int msix_capable: 1;
	u8 reserved_bar;
	u8 bar_fixed_64bit;
	int: 8;
	int: 32;
	u64 bar_fixed_size[6];
	size_t align;
	int: 32;
};

struct pci_epc_mem_window {
	phys_addr_t phys_base;
	size_t size;
	size_t page_size;
};

struct pci_epc_mem {
	struct pci_epc_mem_window window;
	long unsigned int *bitmap;
	int pages;
	struct mutex lock;
};

struct pci_epf_group {
	struct config_group group;
	struct config_group primary_epc_group;
	struct config_group secondary_epc_group;
	struct delayed_work cfs_work;
	struct pci_epf *epf;
	int index;
};

struct pci_epc_group {
	struct config_group group;
	struct pci_epc *epc;
	bool start;
};

enum pci_notify_event {
	CORE_INIT = 0,
	LINK_UP = 1,
};

typedef s32 dma_cookie_t;

enum dma_status {
	DMA_COMPLETE = 0,
	DMA_IN_PROGRESS = 1,
	DMA_PAUSED = 2,
	DMA_ERROR = 3,
	DMA_OUT_OF_ORDER = 4,
};

enum dma_transaction_type {
	DMA_MEMCPY = 0,
	DMA_XOR = 1,
	DMA_PQ = 2,
	DMA_XOR_VAL = 3,
	DMA_PQ_VAL = 4,
	DMA_MEMSET = 5,
	DMA_MEMSET_SG = 6,
	DMA_INTERRUPT = 7,
	DMA_PRIVATE = 8,
	DMA_ASYNC_TX = 9,
	DMA_SLAVE = 10,
	DMA_CYCLIC = 11,
	DMA_INTERLEAVE = 12,
	DMA_COMPLETION_NO_ORDER = 13,
	DMA_REPEAT = 14,
	DMA_LOAD_EOT = 15,
	DMA_TX_TYPE_END = 16,
};

enum dma_transfer_direction {
	DMA_MEM_TO_MEM = 0,
	DMA_MEM_TO_DEV = 1,
	DMA_DEV_TO_MEM = 2,
	DMA_DEV_TO_DEV = 3,
	DMA_TRANS_NONE = 4,
};

struct data_chunk {
	size_t size;
	size_t icg;
	size_t dst_icg;
	size_t src_icg;
};

struct dma_interleaved_template {
	dma_addr_t src_start;
	dma_addr_t dst_start;
	enum dma_transfer_direction dir;
	bool src_inc;
	bool dst_inc;
	bool src_sgl;
	bool dst_sgl;
	size_t numf;
	size_t frame_size;
	struct data_chunk sgl[0];
};

enum dma_ctrl_flags {
	DMA_PREP_INTERRUPT = 1,
	DMA_CTRL_ACK = 2,
	DMA_PREP_PQ_DISABLE_P = 4,
	DMA_PREP_PQ_DISABLE_Q = 8,
	DMA_PREP_CONTINUE = 16,
	DMA_PREP_FENCE = 32,
	DMA_CTRL_REUSE = 64,
	DMA_PREP_CMD = 128,
	DMA_PREP_REPEAT = 256,
	DMA_PREP_LOAD_EOT = 512,
};

enum sum_check_bits {
	SUM_CHECK_P = 0,
	SUM_CHECK_Q = 1,
};

enum sum_check_flags {
	SUM_CHECK_P_RESULT = 1,
	SUM_CHECK_Q_RESULT = 2,
};

typedef struct {
	long unsigned int bits[1];
} dma_cap_mask_t;

enum dma_desc_metadata_mode {
	DESC_METADATA_NONE = 0,
	DESC_METADATA_CLIENT = 1,
	DESC_METADATA_ENGINE = 2,
};

struct dma_chan_percpu {
	long unsigned int memcpy_count;
	long unsigned int bytes_transferred;
};

struct dma_router {
	struct device *dev;
	void (*route_free)(struct device *, void *);
};

struct dma_device;

struct dma_chan_dev;

struct dma_chan {
	struct dma_device *device;
	struct device *slave;
	dma_cookie_t cookie;
	dma_cookie_t completed_cookie;
	int chan_id;
	struct dma_chan_dev *dev;
	const char *name;
	char *dbg_client_name;
	struct list_head device_node;
	struct dma_chan_percpu *local;
	int client_count;
	int table_count;
	struct dma_router *router;
	void *route_data;
	void *private;
};

typedef bool (*dma_filter_fn)(struct dma_chan *, void *);

struct dma_slave_map;

struct dma_filter {
	dma_filter_fn fn;
	int mapcnt;
	const struct dma_slave_map *map;
};

enum dmaengine_alignment {
	DMAENGINE_ALIGN_1_BYTE = 0,
	DMAENGINE_ALIGN_2_BYTES = 1,
	DMAENGINE_ALIGN_4_BYTES = 2,
	DMAENGINE_ALIGN_8_BYTES = 3,
	DMAENGINE_ALIGN_16_BYTES = 4,
	DMAENGINE_ALIGN_32_BYTES = 5,
	DMAENGINE_ALIGN_64_BYTES = 6,
	DMAENGINE_ALIGN_128_BYTES = 7,
	DMAENGINE_ALIGN_256_BYTES = 8,
};

enum dma_residue_granularity {
	DMA_RESIDUE_GRANULARITY_DESCRIPTOR = 0,
	DMA_RESIDUE_GRANULARITY_SEGMENT = 1,
	DMA_RESIDUE_GRANULARITY_BURST = 2,
};

struct dma_async_tx_descriptor;

struct dma_slave_caps;

struct dma_slave_config;

struct dma_tx_state;

struct dma_device {
	struct kref ref;
	unsigned int chancnt;
	unsigned int privatecnt;
	struct list_head channels;
	struct list_head global_node;
	struct dma_filter filter;
	dma_cap_mask_t cap_mask;
	enum dma_desc_metadata_mode desc_metadata_modes;
	short unsigned int max_xor;
	short unsigned int max_pq;
	enum dmaengine_alignment copy_align;
	enum dmaengine_alignment xor_align;
	enum dmaengine_alignment pq_align;
	enum dmaengine_alignment fill_align;
	int dev_id;
	struct device *dev;
	struct module *owner;
	struct ida chan_ida;
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool descriptor_reuse;
	enum dma_residue_granularity residue_granularity;
	int (*device_alloc_chan_resources)(struct dma_chan *);
	int (*device_router_config)(struct dma_chan *);
	void (*device_free_chan_resources)(struct dma_chan *);
	struct dma_async_tx_descriptor * (*device_prep_dma_memcpy)(struct dma_chan *, dma_addr_t, dma_addr_t, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor)(struct dma_chan *, dma_addr_t, dma_addr_t *, unsigned int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_xor_val)(struct dma_chan *, dma_addr_t *, unsigned int, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_pq_val)(struct dma_chan *, dma_addr_t *, dma_addr_t *, unsigned int, const unsigned char *, size_t, enum sum_check_flags *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset)(struct dma_chan *, dma_addr_t, int, size_t, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_memset_sg)(struct dma_chan *, struct scatterlist *, unsigned int, int, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_interrupt)(struct dma_chan *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_slave_sg)(struct dma_chan *, struct scatterlist *, unsigned int, enum dma_transfer_direction, long unsigned int, void *);
	struct dma_async_tx_descriptor * (*device_prep_dma_cyclic)(struct dma_chan *, dma_addr_t, size_t, size_t, enum dma_transfer_direction, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_interleaved_dma)(struct dma_chan *, struct dma_interleaved_template *, long unsigned int);
	struct dma_async_tx_descriptor * (*device_prep_dma_imm_data)(struct dma_chan *, dma_addr_t, u64, long unsigned int);
	void (*device_caps)(struct dma_chan *, struct dma_slave_caps *);
	int (*device_config)(struct dma_chan *, struct dma_slave_config *);
	int (*device_pause)(struct dma_chan *);
	int (*device_resume)(struct dma_chan *);
	int (*device_terminate_all)(struct dma_chan *);
	void (*device_synchronize)(struct dma_chan *);
	enum dma_status (*device_tx_status)(struct dma_chan *, dma_cookie_t, struct dma_tx_state *);
	void (*device_issue_pending)(struct dma_chan *);
	void (*device_release)(struct dma_device *);
	void (*dbg_summary_show)(struct seq_file *, struct dma_device *);
	struct dentry *dbg_dev_root;
};

struct dma_chan_dev {
	struct dma_chan *chan;
	int: 32;
	struct device device;
	int dev_id;
	bool chan_dma_dev;
};

enum dma_slave_buswidth {
	DMA_SLAVE_BUSWIDTH_UNDEFINED = 0,
	DMA_SLAVE_BUSWIDTH_1_BYTE = 1,
	DMA_SLAVE_BUSWIDTH_2_BYTES = 2,
	DMA_SLAVE_BUSWIDTH_3_BYTES = 3,
	DMA_SLAVE_BUSWIDTH_4_BYTES = 4,
	DMA_SLAVE_BUSWIDTH_8_BYTES = 8,
	DMA_SLAVE_BUSWIDTH_16_BYTES = 16,
	DMA_SLAVE_BUSWIDTH_32_BYTES = 32,
	DMA_SLAVE_BUSWIDTH_64_BYTES = 64,
	DMA_SLAVE_BUSWIDTH_128_BYTES = 128,
};

struct dma_slave_config {
	enum dma_transfer_direction direction;
	phys_addr_t src_addr;
	phys_addr_t dst_addr;
	enum dma_slave_buswidth src_addr_width;
	enum dma_slave_buswidth dst_addr_width;
	u32 src_maxburst;
	u32 dst_maxburst;
	u32 src_port_window_size;
	u32 dst_port_window_size;
	bool device_fc;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dma_slave_caps {
	u32 src_addr_widths;
	u32 dst_addr_widths;
	u32 directions;
	u32 min_burst;
	u32 max_burst;
	u32 max_sg_burst;
	bool cmd_pause;
	bool cmd_resume;
	bool cmd_terminate;
	enum dma_residue_granularity residue_granularity;
	bool descriptor_reuse;
};

typedef void (*dma_async_tx_callback)(void *);

enum dmaengine_tx_result {
	DMA_TRANS_NOERROR = 0,
	DMA_TRANS_READ_FAILED = 1,
	DMA_TRANS_WRITE_FAILED = 2,
	DMA_TRANS_ABORTED = 3,
};

struct dmaengine_result {
	enum dmaengine_tx_result result;
	u32 residue;
};

typedef void (*dma_async_tx_callback_result)(void *, const struct dmaengine_result *);

struct dmaengine_unmap_data {
	u16 map_cnt;
	u8 to_cnt;
	u8 from_cnt;
	u8 bidi_cnt;
	struct device *dev;
	struct kref kref;
	size_t len;
	dma_addr_t addr[0];
};

struct dma_descriptor_metadata_ops {
	int (*attach)(struct dma_async_tx_descriptor *, void *, size_t);
	void * (*get_ptr)(struct dma_async_tx_descriptor *, size_t *, size_t *);
	int (*set_len)(struct dma_async_tx_descriptor *, size_t);
};

struct dma_async_tx_descriptor {
	dma_cookie_t cookie;
	enum dma_ctrl_flags flags;
	dma_addr_t phys;
	struct dma_chan *chan;
	dma_cookie_t (*tx_submit)(struct dma_async_tx_descriptor *);
	int (*desc_free)(struct dma_async_tx_descriptor *);
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
	struct dmaengine_unmap_data *unmap;
	enum dma_desc_metadata_mode desc_metadata_mode;
	struct dma_descriptor_metadata_ops *metadata_ops;
};

struct dma_tx_state {
	dma_cookie_t last;
	dma_cookie_t used;
	u32 residue;
	u32 in_flight_bytes;
};

struct dma_slave_map {
	const char *devname;
	const char *slave;
	void *param;
};

struct pci_epf_test {
	void *reg[6];
	struct pci_epf *epf;
	enum pci_barno test_reg_bar;
	size_t msix_table_offset;
	struct delayed_work cmd_handler;
	struct dma_chan *dma_chan_tx;
	struct dma_chan *dma_chan_rx;
	struct completion transfer_complete;
	bool dma_supported;
	bool dma_private;
	const struct pci_epc_features *epc_features;
};

struct pci_epf_test_reg {
	u32 magic;
	u32 command;
	u32 status;
	u64 src_addr;
	u64 dst_addr;
	u32 size;
	u32 checksum;
	u32 irq_type;
	u32 irq_number;
	u32 flags;
};

struct epf_dma_filter {
	struct device *dev;
	u32 dma_mask;
};

struct dw_pcie_rp;

struct dw_pcie_host_ops {
	int (*host_init)(struct dw_pcie_rp *);
	void (*host_deinit)(struct dw_pcie_rp *);
	int (*msi_host_init)(struct dw_pcie_rp *);
};

struct dw_pcie_rp {
	bool has_msi_ctrl: 1;
	bool cfg0_io_shared: 1;
	int: 30;
	int: 32;
	u64 cfg0_base;
	void *va_cfg0_base;
	u32 cfg0_size;
	resource_size_t io_base;
	phys_addr_t io_bus_addr;
	u32 io_size;
	int irq;
	const struct dw_pcie_host_ops *ops;
	int msi_irq[8];
	struct irq_domain *irq_domain;
	struct irq_domain *msi_domain;
	dma_addr_t msi_data;
	struct irq_chip *msi_irq_chip;
	u32 num_vectors;
	u32 irq_mask[8];
	struct pci_host_bridge *bridge;
	raw_spinlock_t lock;
	long unsigned int msi_irq_in_use[8];
};

struct dw_pcie_ep;

struct dw_pcie_ep_ops {
	void (*ep_init)(struct dw_pcie_ep *);
	int (*raise_irq)(struct dw_pcie_ep *, u8, enum pci_epc_irq_type, u16);
	const struct pci_epc_features * (*get_features)(struct dw_pcie_ep *);
	unsigned int (*func_conf_select)(struct dw_pcie_ep *, u8);
};

struct dw_pcie_ep {
	struct pci_epc *epc;
	struct list_head func_list;
	const struct dw_pcie_ep_ops *ops;
	phys_addr_t phys_base;
	size_t addr_size;
	size_t page_size;
	u8 bar_to_atu[6];
	phys_addr_t *outbound_addr;
	long unsigned int *ib_window_map;
	long unsigned int *ob_window_map;
	void *msi_mem;
	phys_addr_t msi_mem_phys;
	struct pci_epf_bar *epf_bar[6];
};

struct dw_pcie;

struct dw_pcie_ops {
	u64 (*cpu_addr_fixup)(struct dw_pcie *, u64);
	u32 (*read_dbi)(struct dw_pcie *, void *, u32, size_t);
	void (*write_dbi)(struct dw_pcie *, void *, u32, size_t, u32);
	void (*write_dbi2)(struct dw_pcie *, void *, u32, size_t, u32);
	int (*link_up)(struct dw_pcie *);
	int (*start_link)(struct dw_pcie *);
	void (*stop_link)(struct dw_pcie *);
};

struct dw_pcie {
	struct device *dev;
	void *dbi_base;
	void *dbi_base2;
	void *atu_base;
	size_t atu_size;
	u32 num_ib_windows;
	u32 num_ob_windows;
	u32 region_align;
	u64 region_limit;
	struct dw_pcie_rp pp;
	struct dw_pcie_ep ep;
	const struct dw_pcie_ops *ops;
	u32 version;
	u32 type;
	int num_lanes;
	int link_gen;
	u8 n_fts[2];
	bool iatu_unroll_enabled: 1;
};

struct pci_epf_msix_tbl {
	u64 msg_addr;
	u32 msg_data;
	u32 vector_ctrl;
};

struct dw_pcie_ep_func {
	struct list_head list;
	u8 func_no;
	u8 msi_cap;
	u8 msix_cap;
};

enum dw_pcie_device_mode {
	DW_PCIE_UNKNOWN_TYPE = 0,
	DW_PCIE_EP_TYPE = 1,
	DW_PCIE_LEG_EP_TYPE = 2,
	DW_PCIE_RC_TYPE = 3,
};

enum imx6_pcie_variants {
	IMX6Q = 0,
	IMX6Q_EP = 1,
	IMX6SX = 2,
	IMX6SX_EP = 3,
	IMX6QP = 4,
	IMX6QP_EP = 5,
	IMX7D = 6,
	IMX7D_EP = 7,
	IMX8MQ = 8,
	IMX8MQ_EP = 9,
	IMX8MM = 10,
	IMX8MM_EP = 11,
	IMX8MP = 12,
	IMX8MP_EP = 13,
	IMX8QM = 14,
	IMX8QM_EP = 15,
	IMX8QXP = 16,
	IMX8QXP_EP = 17,
};

struct imx6_pcie_drvdata {
	enum imx6_pcie_variants variant;
	enum dw_pcie_device_mode mode;
	u32 flags;
	int dbi_length;
	const char *gpr;
};

struct imx6_pcie {
	struct dw_pcie *pci;
	int reset_gpio;
	bool gpio_active_high;
	bool link_is_up;
	struct clk *pcie_bus;
	struct clk *pcie_phy;
	struct clk *pcie_inbound_axi;
	struct clk *pcie;
	struct clk *pcie_aux;
	struct clk *pcie_per;
	struct clk *pcie_phy_pclk;
	struct clk *pciex2_per;
	struct clk *phy_per;
	struct clk *misc_per;
	struct regmap *hsiomix;
	struct regmap *iomuxc_gpr;
	u32 controller_id;
	struct reset_control *pciephy_reset;
	struct reset_control *apps_reset;
	struct reset_control *turnoff_reset;
	u32 tx_deemph_gen1;
	u32 tx_deemph_gen2_3p5db;
	u32 tx_deemph_gen2_6db;
	u32 tx_swing_full;
	u32 tx_swing_low;
	u32 hsio_cfg;
	u32 ext_osc;
	u32 local_addr;
	struct regulator *vpcie;
	struct regulator *vph;
	void *phy_base;
	struct device *pd_pcie;
	struct device *pd_pcie_phy;
	struct phy *phy;
	struct device *pd_hsio_gpio;
	struct device *pd_pcie_per;
	const struct imx6_pcie_drvdata *drvdata;
};

struct dp_sdp_header {
	u8 HB0;
	u8 HB1;
	u8 HB2;
	u8 HB3;
};

struct dp_sdp {
	struct dp_sdp_header sdp_header;
	u8 db[32];
};

enum hdmi_infoframe_type {
	HDMI_INFOFRAME_TYPE_VENDOR = 129,
	HDMI_INFOFRAME_TYPE_AVI = 130,
	HDMI_INFOFRAME_TYPE_SPD = 131,
	HDMI_INFOFRAME_TYPE_AUDIO = 132,
	HDMI_INFOFRAME_TYPE_DRM = 135,
};

struct hdmi_any_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
};

enum hdmi_colorspace {
	HDMI_COLORSPACE_RGB = 0,
	HDMI_COLORSPACE_YUV422 = 1,
	HDMI_COLORSPACE_YUV444 = 2,
	HDMI_COLORSPACE_YUV420 = 3,
	HDMI_COLORSPACE_RESERVED4 = 4,
	HDMI_COLORSPACE_RESERVED5 = 5,
	HDMI_COLORSPACE_RESERVED6 = 6,
	HDMI_COLORSPACE_IDO_DEFINED = 7,
};

enum hdmi_scan_mode {
	HDMI_SCAN_MODE_NONE = 0,
	HDMI_SCAN_MODE_OVERSCAN = 1,
	HDMI_SCAN_MODE_UNDERSCAN = 2,
	HDMI_SCAN_MODE_RESERVED = 3,
};

enum hdmi_colorimetry {
	HDMI_COLORIMETRY_NONE = 0,
	HDMI_COLORIMETRY_ITU_601 = 1,
	HDMI_COLORIMETRY_ITU_709 = 2,
	HDMI_COLORIMETRY_EXTENDED = 3,
};

enum hdmi_picture_aspect {
	HDMI_PICTURE_ASPECT_NONE = 0,
	HDMI_PICTURE_ASPECT_4_3 = 1,
	HDMI_PICTURE_ASPECT_16_9 = 2,
	HDMI_PICTURE_ASPECT_64_27 = 3,
	HDMI_PICTURE_ASPECT_256_135 = 4,
	HDMI_PICTURE_ASPECT_RESERVED = 5,
};

enum hdmi_active_aspect {
	HDMI_ACTIVE_ASPECT_16_9_TOP = 2,
	HDMI_ACTIVE_ASPECT_14_9_TOP = 3,
	HDMI_ACTIVE_ASPECT_16_9_CENTER = 4,
	HDMI_ACTIVE_ASPECT_PICTURE = 8,
	HDMI_ACTIVE_ASPECT_4_3 = 9,
	HDMI_ACTIVE_ASPECT_16_9 = 10,
	HDMI_ACTIVE_ASPECT_14_9 = 11,
	HDMI_ACTIVE_ASPECT_4_3_SP_14_9 = 13,
	HDMI_ACTIVE_ASPECT_16_9_SP_14_9 = 14,
	HDMI_ACTIVE_ASPECT_16_9_SP_4_3 = 15,
};

enum hdmi_extended_colorimetry {
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_601 = 0,
	HDMI_EXTENDED_COLORIMETRY_XV_YCC_709 = 1,
	HDMI_EXTENDED_COLORIMETRY_S_YCC_601 = 2,
	HDMI_EXTENDED_COLORIMETRY_OPYCC_601 = 3,
	HDMI_EXTENDED_COLORIMETRY_OPRGB = 4,
	HDMI_EXTENDED_COLORIMETRY_BT2020_CONST_LUM = 5,
	HDMI_EXTENDED_COLORIMETRY_BT2020 = 6,
	HDMI_EXTENDED_COLORIMETRY_RESERVED = 7,
};

enum hdmi_quantization_range {
	HDMI_QUANTIZATION_RANGE_DEFAULT = 0,
	HDMI_QUANTIZATION_RANGE_LIMITED = 1,
	HDMI_QUANTIZATION_RANGE_FULL = 2,
	HDMI_QUANTIZATION_RANGE_RESERVED = 3,
};

enum hdmi_nups {
	HDMI_NUPS_UNKNOWN = 0,
	HDMI_NUPS_HORIZONTAL = 1,
	HDMI_NUPS_VERTICAL = 2,
	HDMI_NUPS_BOTH = 3,
};

enum hdmi_ycc_quantization_range {
	HDMI_YCC_QUANTIZATION_RANGE_LIMITED = 0,
	HDMI_YCC_QUANTIZATION_RANGE_FULL = 1,
};

enum hdmi_content_type {
	HDMI_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_CONTENT_TYPE_PHOTO = 1,
	HDMI_CONTENT_TYPE_CINEMA = 2,
	HDMI_CONTENT_TYPE_GAME = 3,
};

enum hdmi_metadata_type {
	HDMI_STATIC_METADATA_TYPE1 = 0,
};

enum hdmi_eotf {
	HDMI_EOTF_TRADITIONAL_GAMMA_SDR = 0,
	HDMI_EOTF_TRADITIONAL_GAMMA_HDR = 1,
	HDMI_EOTF_SMPTE_ST2084 = 2,
	HDMI_EOTF_BT_2100_HLG = 3,
};

struct hdmi_avi_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_colorspace colorspace;
	enum hdmi_scan_mode scan_mode;
	enum hdmi_colorimetry colorimetry;
	enum hdmi_picture_aspect picture_aspect;
	enum hdmi_active_aspect active_aspect;
	bool itc;
	enum hdmi_extended_colorimetry extended_colorimetry;
	enum hdmi_quantization_range quantization_range;
	enum hdmi_nups nups;
	unsigned char video_code;
	enum hdmi_ycc_quantization_range ycc_quantization_range;
	enum hdmi_content_type content_type;
	unsigned char pixel_repeat;
	short unsigned int top_bar;
	short unsigned int bottom_bar;
	short unsigned int left_bar;
	short unsigned int right_bar;
};

struct hdmi_drm_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	enum hdmi_eotf eotf;
	enum hdmi_metadata_type metadata_type;
	struct {
		u16 x;
		u16 y;
	} display_primaries[3];
	struct {
		u16 x;
		u16 y;
	} white_point;
	u16 max_display_mastering_luminance;
	u16 min_display_mastering_luminance;
	u16 max_cll;
	u16 max_fall;
};

enum hdmi_spd_sdi {
	HDMI_SPD_SDI_UNKNOWN = 0,
	HDMI_SPD_SDI_DSTB = 1,
	HDMI_SPD_SDI_DVDP = 2,
	HDMI_SPD_SDI_DVHS = 3,
	HDMI_SPD_SDI_HDDVR = 4,
	HDMI_SPD_SDI_DVC = 5,
	HDMI_SPD_SDI_DSC = 6,
	HDMI_SPD_SDI_VCD = 7,
	HDMI_SPD_SDI_GAME = 8,
	HDMI_SPD_SDI_PC = 9,
	HDMI_SPD_SDI_BD = 10,
	HDMI_SPD_SDI_SACD = 11,
	HDMI_SPD_SDI_HDDVD = 12,
	HDMI_SPD_SDI_PMP = 13,
};

struct hdmi_spd_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	char vendor[8];
	char product[16];
	enum hdmi_spd_sdi sdi;
};

enum hdmi_audio_coding_type {
	HDMI_AUDIO_CODING_TYPE_STREAM = 0,
	HDMI_AUDIO_CODING_TYPE_PCM = 1,
	HDMI_AUDIO_CODING_TYPE_AC3 = 2,
	HDMI_AUDIO_CODING_TYPE_MPEG1 = 3,
	HDMI_AUDIO_CODING_TYPE_MP3 = 4,
	HDMI_AUDIO_CODING_TYPE_MPEG2 = 5,
	HDMI_AUDIO_CODING_TYPE_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_DTS = 7,
	HDMI_AUDIO_CODING_TYPE_ATRAC = 8,
	HDMI_AUDIO_CODING_TYPE_DSD = 9,
	HDMI_AUDIO_CODING_TYPE_EAC3 = 10,
	HDMI_AUDIO_CODING_TYPE_DTS_HD = 11,
	HDMI_AUDIO_CODING_TYPE_MLP = 12,
	HDMI_AUDIO_CODING_TYPE_DST = 13,
	HDMI_AUDIO_CODING_TYPE_WMA_PRO = 14,
	HDMI_AUDIO_CODING_TYPE_CXT = 15,
};

enum hdmi_audio_sample_size {
	HDMI_AUDIO_SAMPLE_SIZE_STREAM = 0,
	HDMI_AUDIO_SAMPLE_SIZE_16 = 1,
	HDMI_AUDIO_SAMPLE_SIZE_20 = 2,
	HDMI_AUDIO_SAMPLE_SIZE_24 = 3,
};

enum hdmi_audio_sample_frequency {
	HDMI_AUDIO_SAMPLE_FREQUENCY_STREAM = 0,
	HDMI_AUDIO_SAMPLE_FREQUENCY_32000 = 1,
	HDMI_AUDIO_SAMPLE_FREQUENCY_44100 = 2,
	HDMI_AUDIO_SAMPLE_FREQUENCY_48000 = 3,
	HDMI_AUDIO_SAMPLE_FREQUENCY_88200 = 4,
	HDMI_AUDIO_SAMPLE_FREQUENCY_96000 = 5,
	HDMI_AUDIO_SAMPLE_FREQUENCY_176400 = 6,
	HDMI_AUDIO_SAMPLE_FREQUENCY_192000 = 7,
};

enum hdmi_audio_coding_type_ext {
	HDMI_AUDIO_CODING_TYPE_EXT_CT = 0,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC = 1,
	HDMI_AUDIO_CODING_TYPE_EXT_HE_AAC_V2 = 2,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG_SURROUND = 3,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC = 4,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_V2 = 5,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC = 6,
	HDMI_AUDIO_CODING_TYPE_EXT_DRA = 7,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_HE_AAC_SURROUND = 8,
	HDMI_AUDIO_CODING_TYPE_EXT_MPEG4_AAC_LC_SURROUND = 10,
};

struct hdmi_audio_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned char channels;
	enum hdmi_audio_coding_type coding_type;
	enum hdmi_audio_sample_size sample_size;
	enum hdmi_audio_sample_frequency sample_frequency;
	enum hdmi_audio_coding_type_ext coding_type_ext;
	unsigned char channel_allocation;
	unsigned char level_shift_value;
	bool downmix_inhibit;
};

enum hdmi_3d_structure {
	HDMI_3D_STRUCTURE_INVALID = 4294967295,
	HDMI_3D_STRUCTURE_FRAME_PACKING = 0,
	HDMI_3D_STRUCTURE_FIELD_ALTERNATIVE = 1,
	HDMI_3D_STRUCTURE_LINE_ALTERNATIVE = 2,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_FULL = 3,
	HDMI_3D_STRUCTURE_L_DEPTH = 4,
	HDMI_3D_STRUCTURE_L_DEPTH_GFX_GFX_DEPTH = 5,
	HDMI_3D_STRUCTURE_TOP_AND_BOTTOM = 6,
	HDMI_3D_STRUCTURE_SIDE_BY_SIDE_HALF = 8,
};

struct hdmi_vendor_infoframe {
	enum hdmi_infoframe_type type;
	unsigned char version;
	unsigned char length;
	unsigned int oui;
	u8 vic;
	enum hdmi_3d_structure s3d_struct;
	unsigned int s3d_ext_data;
};

union hdmi_vendor_any_infoframe {
	struct {
		enum hdmi_infoframe_type type;
		unsigned char version;
		unsigned char length;
		unsigned int oui;
	} any;
	struct hdmi_vendor_infoframe hdmi;
};

union hdmi_infoframe {
	struct hdmi_any_infoframe any;
	struct hdmi_avi_infoframe avi;
	struct hdmi_spd_infoframe spd;
	union hdmi_vendor_any_infoframe vendor;
	struct hdmi_audio_infoframe audio;
	struct hdmi_drm_infoframe drm;
};

enum con_scroll {
	SM_UP = 0,
	SM_DOWN = 1,
};

enum vc_intensity {
	VCI_HALF_BRIGHT = 0,
	VCI_NORMAL = 1,
	VCI_BOLD = 2,
	VCI_MASK = 3,
};

struct vc_data;

struct console_font;

struct consw {
	struct module *owner;
	const char * (*con_startup)();
	void (*con_init)(struct vc_data *, int);
	void (*con_deinit)(struct vc_data *);
	void (*con_clear)(struct vc_data *, int, int, int, int);
	void (*con_putc)(struct vc_data *, int, int, int);
	void (*con_putcs)(struct vc_data *, const short unsigned int *, int, int, int);
	void (*con_cursor)(struct vc_data *, int);
	bool (*con_scroll)(struct vc_data *, unsigned int, unsigned int, enum con_scroll, unsigned int);
	int (*con_switch)(struct vc_data *);
	int (*con_blank)(struct vc_data *, int, int);
	int (*con_font_set)(struct vc_data *, struct console_font *, unsigned int);
	int (*con_font_get)(struct vc_data *, struct console_font *);
	int (*con_font_default)(struct vc_data *, struct console_font *, char *);
	int (*con_resize)(struct vc_data *, unsigned int, unsigned int, unsigned int);
	void (*con_set_palette)(struct vc_data *, const unsigned char *);
	void (*con_scrolldelta)(struct vc_data *, int);
	int (*con_set_origin)(struct vc_data *);
	void (*con_save_screen)(struct vc_data *);
	u8 (*con_build_attr)(struct vc_data *, u8, enum vc_intensity, bool, bool, bool, bool);
	void (*con_invert_region)(struct vc_data *, u16 *, int);
	u16 * (*con_screen_pos)(const struct vc_data *, int);
	long unsigned int (*con_getxy)(struct vc_data *, long unsigned int, int *, int *);
	void (*con_flush_scrollback)(struct vc_data *);
	int (*con_debug_enter)(struct vc_data *);
	int (*con_debug_leave)(struct vc_data *);
};

struct vc_state {
	unsigned int x;
	unsigned int y;
	unsigned char color;
	unsigned char Gx_charset[2];
	unsigned int charset: 1;
	enum vc_intensity intensity;
	bool italic;
	bool underline;
	bool blink;
	bool reverse;
};

struct console_font {
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_mode {
	char mode;
	char waitv;
	short int relsig;
	short int acqsig;
	short int frsig;
};

struct uni_pagedict;

struct uni_screen;

struct vc_data {
	struct tty_port port;
	struct vc_state state;
	struct vc_state saved_state;
	short unsigned int vc_num;
	unsigned int vc_cols;
	unsigned int vc_rows;
	unsigned int vc_size_row;
	unsigned int vc_scan_lines;
	unsigned int vc_cell_height;
	long unsigned int vc_origin;
	long unsigned int vc_scr_end;
	long unsigned int vc_visible_origin;
	unsigned int vc_top;
	unsigned int vc_bottom;
	const struct consw *vc_sw;
	short unsigned int *vc_screenbuf;
	unsigned int vc_screenbuf_size;
	unsigned char vc_mode;
	unsigned char vc_attr;
	unsigned char vc_def_color;
	unsigned char vc_ulcolor;
	unsigned char vc_itcolor;
	unsigned char vc_halfcolor;
	unsigned int vc_cursor_type;
	short unsigned int vc_complement_mask;
	short unsigned int vc_s_complement_mask;
	long unsigned int vc_pos;
	short unsigned int vc_hi_font_mask;
	struct console_font vc_font;
	short unsigned int vc_video_erase_char;
	unsigned int vc_state;
	unsigned int vc_npar;
	unsigned int vc_par[16];
	struct vt_mode vt_mode;
	struct pid *vt_pid;
	int vt_newvt;
	wait_queue_head_t paste_wait;
	unsigned int vc_disp_ctrl: 1;
	unsigned int vc_toggle_meta: 1;
	unsigned int vc_decscnm: 1;
	unsigned int vc_decom: 1;
	unsigned int vc_decawm: 1;
	unsigned int vc_deccm: 1;
	unsigned int vc_decim: 1;
	unsigned int vc_priv: 3;
	unsigned int vc_need_wrap: 1;
	unsigned int vc_can_do_color: 1;
	unsigned int vc_report_mouse: 2;
	unsigned char vc_utf: 1;
	unsigned char vc_utf_count;
	int vc_utf_char;
	long unsigned int vc_tab_stop[8];
	unsigned char vc_palette[48];
	short unsigned int *vc_translate;
	unsigned int vc_resize_user;
	unsigned int vc_bell_pitch;
	unsigned int vc_bell_duration;
	short unsigned int vc_cur_blink_ms;
	struct vc_data **vc_display_fg;
	struct uni_pagedict *uni_pagedict;
	struct uni_pagedict **uni_pagedict_loc;
	struct uni_screen *vc_uni_screen;
};

struct fb_fix_screeninfo {
	char id[16];
	long unsigned int smem_start;
	__u32 smem_len;
	__u32 type;
	__u32 type_aux;
	__u32 visual;
	__u16 xpanstep;
	__u16 ypanstep;
	__u16 ywrapstep;
	__u32 line_length;
	long unsigned int mmio_start;
	__u32 mmio_len;
	__u32 accel;
	__u16 capabilities;
	__u16 reserved[2];
};

struct fb_bitfield {
	__u32 offset;
	__u32 length;
	__u32 msb_right;
};

struct fb_var_screeninfo {
	__u32 xres;
	__u32 yres;
	__u32 xres_virtual;
	__u32 yres_virtual;
	__u32 xoffset;
	__u32 yoffset;
	__u32 bits_per_pixel;
	__u32 grayscale;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	__u32 nonstd;
	__u32 activate;
	__u32 height;
	__u32 width;
	__u32 accel_flags;
	__u32 pixclock;
	__u32 left_margin;
	__u32 right_margin;
	__u32 upper_margin;
	__u32 lower_margin;
	__u32 hsync_len;
	__u32 vsync_len;
	__u32 sync;
	__u32 vmode;
	__u32 rotate;
	__u32 colorspace;
	__u32 reserved[4];
};

struct fb_cmap {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_copyarea {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 sx;
	__u32 sy;
};

struct fb_fillrect {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 color;
	__u32 rop;
};

struct fb_image {
	__u32 dx;
	__u32 dy;
	__u32 width;
	__u32 height;
	__u32 fg_color;
	__u32 bg_color;
	__u8 depth;
	const char *data;
	struct fb_cmap cmap;
};

struct fbcurpos {
	__u16 x;
	__u16 y;
};

struct fb_cursor {
	__u16 set;
	__u16 enable;
	__u16 rop;
	const char *mask;
	struct fbcurpos hot;
	struct fb_image image;
};

struct fb_chroma {
	__u32 redx;
	__u32 greenx;
	__u32 bluex;
	__u32 whitex;
	__u32 redy;
	__u32 greeny;
	__u32 bluey;
	__u32 whitey;
};

struct fb_videomode;

struct fb_monspecs {
	struct fb_chroma chroma;
	struct fb_videomode *modedb;
	__u8 manufacturer[4];
	__u8 monitor[14];
	__u8 serial_no[14];
	__u8 ascii[14];
	__u32 modedb_len;
	__u32 model;
	__u32 serial;
	__u32 year;
	__u32 week;
	__u32 hfmin;
	__u32 hfmax;
	__u32 dclkmin;
	__u32 dclkmax;
	__u16 input;
	__u16 dpms;
	__u16 signal;
	__u16 vfmin;
	__u16 vfmax;
	__u16 gamma;
	__u16 gtf: 1;
	__u16 misc;
	__u8 version;
	__u8 revision;
	__u8 max_x;
	__u8 max_y;
};

struct fb_info;

struct fb_pixmap {
	u8 *addr;
	u32 size;
	u32 offset;
	u32 buf_align;
	u32 scan_align;
	u32 access_align;
	u32 flags;
	u32 blit_x;
	u32 blit_y;
	void (*writeio)(struct fb_info *, void *, void *, unsigned int);
	void (*readio)(struct fb_info *, void *, void *, unsigned int);
};

struct fb_deferred_io_pageref;

struct fb_deferred_io;

struct fb_ops;

struct apertures_struct;

struct fb_info {
	refcount_t count;
	int node;
	int flags;
	int fbcon_rotate_hint;
	struct mutex lock;
	struct mutex mm_lock;
	struct fb_var_screeninfo var;
	struct fb_fix_screeninfo fix;
	struct fb_monspecs monspecs;
	struct fb_pixmap pixmap;
	struct fb_pixmap sprite;
	struct fb_cmap cmap;
	struct list_head modelist;
	struct fb_videomode *mode;
	struct delayed_work deferred_work;
	long unsigned int npagerefs;
	struct fb_deferred_io_pageref *pagerefs;
	struct fb_deferred_io *fbdefio;
	const struct fb_ops *fbops;
	struct device *device;
	struct device *dev;
	int class_flag;
	union {
		char *screen_base;
		char *screen_buffer;
	};
	long unsigned int screen_size;
	void *pseudo_palette;
	u32 state;
	void *fbcon_par;
	void *par;
	struct apertures_struct *apertures;
	bool skip_vt_switch;
};

struct fb_videomode {
	const char *name;
	u32 refresh;
	u32 xres;
	u32 yres;
	u32 pixclock;
	u32 left_margin;
	u32 right_margin;
	u32 upper_margin;
	u32 lower_margin;
	u32 hsync_len;
	u32 vsync_len;
	u32 sync;
	u32 vmode;
	u32 flag;
};

struct fb_event {
	struct fb_info *info;
	void *data;
};

struct fb_blit_caps {
	u32 x;
	u32 y;
	u32 len;
	u32 flags;
};

struct fb_deferred_io_pageref {
	struct page *page;
	long unsigned int offset;
	struct list_head list;
};

struct fb_deferred_io {
	long unsigned int delay;
	bool sort_pagereflist;
	struct mutex lock;
	struct list_head pagereflist;
	void (*first_io)(struct fb_info *);
	void (*deferred_io)(struct fb_info *, struct list_head *);
};

struct fb_ops {
	struct module *owner;
	int (*fb_open)(struct fb_info *, int);
	int (*fb_release)(struct fb_info *, int);
	ssize_t (*fb_read)(struct fb_info *, char *, size_t, loff_t *);
	ssize_t (*fb_write)(struct fb_info *, const char *, size_t, loff_t *);
	int (*fb_check_var)(struct fb_var_screeninfo *, struct fb_info *);
	int (*fb_set_par)(struct fb_info *);
	int (*fb_setcolreg)(unsigned int, unsigned int, unsigned int, unsigned int, unsigned int, struct fb_info *);
	int (*fb_setcmap)(struct fb_cmap *, struct fb_info *);
	int (*fb_blank)(int, struct fb_info *);
	int (*fb_pan_display)(struct fb_var_screeninfo *, struct fb_info *);
	void (*fb_fillrect)(struct fb_info *, const struct fb_fillrect *);
	void (*fb_copyarea)(struct fb_info *, const struct fb_copyarea *);
	void (*fb_imageblit)(struct fb_info *, const struct fb_image *);
	int (*fb_cursor)(struct fb_info *, struct fb_cursor *);
	int (*fb_sync)(struct fb_info *);
	int (*fb_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_compat_ioctl)(struct fb_info *, unsigned int, long unsigned int);
	int (*fb_mmap)(struct fb_info *, struct vm_area_struct *);
	void (*fb_get_caps)(struct fb_info *, struct fb_blit_caps *, struct fb_var_screeninfo *);
	void (*fb_destroy)(struct fb_info *);
	int (*fb_debug_enter)(struct fb_info *);
	int (*fb_debug_leave)(struct fb_info *);
};

struct aperture {
	resource_size_t base;
	resource_size_t size;
};

struct apertures_struct {
	unsigned int count;
	struct aperture ranges[0];
};

struct lcd_properties {
	int max_contrast;
};

struct lcd_device;

struct lcd_ops {
	int (*get_power)(struct lcd_device *);
	int (*set_power)(struct lcd_device *, int);
	int (*get_contrast)(struct lcd_device *);
	int (*set_contrast)(struct lcd_device *, int);
	int (*set_mode)(struct lcd_device *, struct fb_videomode *);
	int (*check_fb)(struct lcd_device *, struct fb_info *);
};

struct lcd_device {
	struct lcd_properties props;
	struct mutex ops_lock;
	struct lcd_ops *ops;
	struct mutex update_lock;
	struct notifier_block fb_notif;
	int: 32;
	struct device dev;
};

enum {
	FB_BLANK_UNBLANK = 0,
	FB_BLANK_NORMAL = 1,
	FB_BLANK_VSYNC_SUSPEND = 2,
	FB_BLANK_HSYNC_SUSPEND = 3,
	FB_BLANK_POWERDOWN = 4,
};

struct l4f00242t03_priv {
	struct spi_device *spi;
	struct lcd_device *ld;
	int lcd_state;
	struct regulator *io_reg;
	struct regulator *core_reg;
	struct gpio_desc *reset;
	struct gpio_desc *enable;
};

struct plat_lcd_data {
	int (*probe)(struct plat_lcd_data *);
	void (*set_power)(struct plat_lcd_data *, unsigned int);
	int (*match_fb)(struct plat_lcd_data *, struct fb_info *);
};

struct platform_lcd {
	struct device *us;
	struct lcd_device *lcd;
	struct plat_lcd_data *pdata;
	unsigned int power;
	unsigned int suspended: 1;
};

enum backlight_update_reason {
	BACKLIGHT_UPDATE_HOTKEY = 0,
	BACKLIGHT_UPDATE_SYSFS = 1,
};

enum backlight_type {
	BACKLIGHT_RAW = 1,
	BACKLIGHT_PLATFORM = 2,
	BACKLIGHT_FIRMWARE = 3,
	BACKLIGHT_TYPE_MAX = 4,
};

enum backlight_notification {
	BACKLIGHT_REGISTERED = 0,
	BACKLIGHT_UNREGISTERED = 1,
};

enum backlight_scale {
	BACKLIGHT_SCALE_UNKNOWN = 0,
	BACKLIGHT_SCALE_LINEAR = 1,
	BACKLIGHT_SCALE_NON_LINEAR = 2,
};

struct backlight_device;

struct backlight_ops {
	unsigned int options;
	int (*update_status)(struct backlight_device *);
	int (*get_brightness)(struct backlight_device *);
	int (*check_fb)(struct backlight_device *, struct fb_info *);
};

struct backlight_properties {
	int brightness;
	int max_brightness;
	int power;
	int fb_blank;
	enum backlight_type type;
	unsigned int state;
	enum backlight_scale scale;
};

struct backlight_device {
	struct backlight_properties props;
	struct mutex update_lock;
	struct mutex ops_lock;
	const struct backlight_ops *ops;
	struct notifier_block fb_notif;
	struct list_head entry;
	int: 32;
	struct device dev;
	bool fb_bl_on[32];
	int use_count;
	int: 32;
};

struct gpio_backlight_platform_data {
	struct device *fbdev;
};

struct gpio_backlight {
	struct device *fbdev;
	struct gpio_desc *gpiod;
};

struct platform_pwm_backlight_data {
	int pwm_id;
	unsigned int max_brightness;
	unsigned int dft_brightness;
	unsigned int lth_brightness;
	unsigned int pwm_period_ns;
	unsigned int *levels;
	unsigned int post_pwm_on_delay;
	unsigned int pwm_off_delay;
	int (*init)(struct device *);
	int (*notify)(struct device *, int);
	void (*notify_after)(struct device *, int);
	void (*exit)(struct device *);
	int (*check_fb)(struct device *, struct fb_info *);
	char fb_id[16];
};

struct pwm_bl_data {
	struct pwm_device *pwm;
	struct device *dev;
	unsigned int lth_brightness;
	unsigned int *levels;
	bool enabled;
	struct regulator *power_supply;
	struct gpio_desc *enable_gpio;
	unsigned int scale;
	bool legacy;
	unsigned int post_pwm_on_delay;
	unsigned int pwm_off_delay;
	int (*notify)(struct device *, int);
	void (*notify_after)(struct device *, int);
	int (*check_fb)(struct device *, struct fb_info *);
	void (*exit)(struct device *);
	char fb_id[16];
};

struct fb_cmap_user {
	__u32 start;
	__u32 len;
	__u16 *red;
	__u16 *green;
	__u16 *blue;
	__u16 *transp;
};

struct fb_modelist {
	struct list_head list;
	struct fb_videomode mode;
};

struct dmt_videomode {
	u32 dmt_id;
	u32 std_2byte_code;
	u32 cvt_3byte_code;
	const struct fb_videomode *mode;
};

enum display_flags {
	DISPLAY_FLAGS_HSYNC_LOW = 1,
	DISPLAY_FLAGS_HSYNC_HIGH = 2,
	DISPLAY_FLAGS_VSYNC_LOW = 4,
	DISPLAY_FLAGS_VSYNC_HIGH = 8,
	DISPLAY_FLAGS_DE_LOW = 16,
	DISPLAY_FLAGS_DE_HIGH = 32,
	DISPLAY_FLAGS_PIXDATA_POSEDGE = 64,
	DISPLAY_FLAGS_PIXDATA_NEGEDGE = 128,
	DISPLAY_FLAGS_INTERLACED = 256,
	DISPLAY_FLAGS_DOUBLESCAN = 512,
	DISPLAY_FLAGS_DOUBLECLK = 1024,
	DISPLAY_FLAGS_SYNC_POSEDGE = 2048,
	DISPLAY_FLAGS_SYNC_NEGEDGE = 4096,
};

struct videomode {
	long unsigned int pixelclock;
	u32 hactive;
	u32 hfront_porch;
	u32 hback_porch;
	u32 hsync_len;
	u32 vactive;
	u32 vfront_porch;
	u32 vback_porch;
	u32 vsync_len;
	enum display_flags flags;
};

struct broken_edid {
	u8 manufacturer[4];
	u32 model;
	u32 fix;
};

struct __fb_timings {
	u32 dclk;
	u32 hfreq;
	u32 vfreq;
	u32 hactive;
	u32 vactive;
	u32 hblank;
	u32 vblank;
	u32 htotal;
	u32 vtotal;
};

struct fb_cvt_data {
	u32 xres;
	u32 yres;
	u32 refresh;
	u32 f_refresh;
	u32 pixclock;
	u32 hperiod;
	u32 hblank;
	u32 hfreq;
	u32 htotal;
	u32 vtotal;
	u32 vsync;
	u32 hsync;
	u32 h_front_porch;
	u32 h_back_porch;
	u32 v_front_porch;
	u32 v_back_porch;
	u32 h_margin;
	u32 v_margin;
	u32 interlace;
	u32 aspect_ratio;
	u32 active_pixels;
	u32 flags;
	u32 status;
};

typedef short unsigned int u_short;

struct fb_con2fbmap {
	__u32 console;
	__u32 framebuffer;
};

struct vc {
	struct vc_data *d;
	struct work_struct SAK_work;
};

struct fbcon_display {
	const u_char *fontdata;
	int userfont;
	u_short inverse;
	short int yscroll;
	int vrows;
	int cursor_shape;
	int con_rotate;
	u32 xres_virtual;
	u32 yres_virtual;
	u32 height;
	u32 width;
	u32 bits_per_pixel;
	u32 grayscale;
	u32 nonstd;
	u32 accel_flags;
	u32 rotate;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
	const struct fb_videomode *mode;
};

struct fbcon_ops {
	void (*bmove)(struct vc_data *, struct fb_info *, int, int, int, int, int, int);
	void (*clear)(struct vc_data *, struct fb_info *, int, int, int, int);
	void (*putcs)(struct vc_data *, struct fb_info *, const short unsigned int *, int, int, int, int, int);
	void (*clear_margins)(struct vc_data *, struct fb_info *, int, int);
	void (*cursor)(struct vc_data *, struct fb_info *, int, int, int);
	int (*update_start)(struct fb_info *);
	int (*rotate_font)(struct fb_info *, struct vc_data *);
	struct fb_var_screeninfo var;
	struct delayed_work cursor_work;
	struct fb_cursor cursor_state;
	struct fbcon_display *p;
	struct fb_info *info;
	int currcon;
	int cur_blink_jiffies;
	int cursor_flash;
	int cursor_reset;
	int blank_state;
	int graphics;
	int save_graphics;
	bool initialized;
	int rotate;
	int cur_rotate;
	char *cursor_data;
	u8 *fontbuffer;
	u8 *fontdata;
	u8 *cursor_src;
	u32 cursor_size;
	u32 fd_size;
};

enum {
	FBCON_LOGO_CANSHOW = 4294967295,
	FBCON_LOGO_DRAW = 4294967294,
	FBCON_LOGO_DONTSHOW = 4294967293,
};

enum crtc {
	CRTC_IPU_DI0 = 0,
	CRTC_IPU_DI1 = 1,
	CRTC_IPU1_DI0 = 2,
	CRTC_IPU1_DI1 = 3,
	CRTC_IPU2_DI0 = 4,
	CRTC_IPU2_DI1 = 5,
	CRTC_LCDIF = 6,
	CRTC_LCDIF1 = 7,
	CRTC_LCDIF2 = 8,
	CRTC_MAX = 9,
};

struct ipu_di_crtc_map {
	enum crtc crtc;
	int ipu_id;
	int ipu_di;
};

struct mxc_dispdrv_driver;

struct mxc_dispdrv_handle {
	struct mxc_dispdrv_driver *drv;
};

struct mxc_dispdrv_setting;

struct mxc_dispdrv_driver {
	const char *name;
	int (*init)(struct mxc_dispdrv_handle *, struct mxc_dispdrv_setting *);
	void (*deinit)(struct mxc_dispdrv_handle *);
	int (*enable)(struct mxc_dispdrv_handle *, struct fb_info *);
	void (*disable)(struct mxc_dispdrv_handle *, struct fb_info *);
	int (*setup)(struct mxc_dispdrv_handle *, struct fb_info *);
};

struct mxc_dispdrv_setting {
	struct fb_info *fbi;
	int if_fmt;
	int default_bpp;
	char *dft_mode_str;
	enum crtc crtc;
};

struct mxc_dispdrv_entry {
	struct mxc_dispdrv_driver *drv;
	bool active;
	void *priv;
	struct list_head list;
};

enum {
	MIPI_DSI_V_SYNC_START = 1,
	MIPI_DSI_V_SYNC_END = 17,
	MIPI_DSI_H_SYNC_START = 33,
	MIPI_DSI_H_SYNC_END = 49,
	MIPI_DSI_COMPRESSION_MODE = 7,
	MIPI_DSI_END_OF_TRANSMISSION = 8,
	MIPI_DSI_COLOR_MODE_OFF = 2,
	MIPI_DSI_COLOR_MODE_ON = 18,
	MIPI_DSI_SHUTDOWN_PERIPHERAL = 34,
	MIPI_DSI_TURN_ON_PERIPHERAL = 50,
	MIPI_DSI_GENERIC_SHORT_WRITE_0_PARAM = 3,
	MIPI_DSI_GENERIC_SHORT_WRITE_1_PARAM = 19,
	MIPI_DSI_GENERIC_SHORT_WRITE_2_PARAM = 35,
	MIPI_DSI_GENERIC_READ_REQUEST_0_PARAM = 4,
	MIPI_DSI_GENERIC_READ_REQUEST_1_PARAM = 20,
	MIPI_DSI_GENERIC_READ_REQUEST_2_PARAM = 36,
	MIPI_DSI_DCS_SHORT_WRITE = 5,
	MIPI_DSI_DCS_SHORT_WRITE_PARAM = 21,
	MIPI_DSI_DCS_READ = 6,
	MIPI_DSI_EXECUTE_QUEUE = 22,
	MIPI_DSI_SET_MAXIMUM_RETURN_PACKET_SIZE = 55,
	MIPI_DSI_NULL_PACKET = 9,
	MIPI_DSI_BLANKING_PACKET = 25,
	MIPI_DSI_GENERIC_LONG_WRITE = 41,
	MIPI_DSI_DCS_LONG_WRITE = 57,
	MIPI_DSI_PICTURE_PARAMETER_SET = 10,
	MIPI_DSI_COMPRESSED_PIXEL_STREAM = 11,
	MIPI_DSI_LOOSELY_PACKED_PIXEL_STREAM_YCBCR20 = 12,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR24 = 28,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR16 = 44,
	MIPI_DSI_PACKED_PIXEL_STREAM_30 = 13,
	MIPI_DSI_PACKED_PIXEL_STREAM_36 = 29,
	MIPI_DSI_PACKED_PIXEL_STREAM_YCBCR12 = 61,
	MIPI_DSI_PACKED_PIXEL_STREAM_16 = 14,
	MIPI_DSI_PACKED_PIXEL_STREAM_18 = 30,
	MIPI_DSI_PIXEL_STREAM_3BYTE_18 = 46,
	MIPI_DSI_PACKED_PIXEL_STREAM_24 = 62,
};

enum {
	MIPI_DCS_NOP = 0,
	MIPI_DCS_SOFT_RESET = 1,
	MIPI_DCS_GET_COMPRESSION_MODE = 3,
	MIPI_DCS_GET_DISPLAY_ID = 4,
	MIPI_DCS_GET_ERROR_COUNT_ON_DSI = 5,
	MIPI_DCS_GET_RED_CHANNEL = 6,
	MIPI_DCS_GET_GREEN_CHANNEL = 7,
	MIPI_DCS_GET_BLUE_CHANNEL = 8,
	MIPI_DCS_GET_DISPLAY_STATUS = 9,
	MIPI_DCS_GET_POWER_MODE = 10,
	MIPI_DCS_GET_ADDRESS_MODE = 11,
	MIPI_DCS_GET_PIXEL_FORMAT = 12,
	MIPI_DCS_GET_DISPLAY_MODE = 13,
	MIPI_DCS_GET_SIGNAL_MODE = 14,
	MIPI_DCS_GET_DIAGNOSTIC_RESULT = 15,
	MIPI_DCS_ENTER_SLEEP_MODE = 16,
	MIPI_DCS_EXIT_SLEEP_MODE = 17,
	MIPI_DCS_ENTER_PARTIAL_MODE = 18,
	MIPI_DCS_ENTER_NORMAL_MODE = 19,
	MIPI_DCS_GET_IMAGE_CHECKSUM_RGB = 20,
	MIPI_DCS_GET_IMAGE_CHECKSUM_CT = 21,
	MIPI_DCS_EXIT_INVERT_MODE = 32,
	MIPI_DCS_ENTER_INVERT_MODE = 33,
	MIPI_DCS_SET_GAMMA_CURVE = 38,
	MIPI_DCS_SET_DISPLAY_OFF = 40,
	MIPI_DCS_SET_DISPLAY_ON = 41,
	MIPI_DCS_SET_COLUMN_ADDRESS = 42,
	MIPI_DCS_SET_PAGE_ADDRESS = 43,
	MIPI_DCS_WRITE_MEMORY_START = 44,
	MIPI_DCS_WRITE_LUT = 45,
	MIPI_DCS_READ_MEMORY_START = 46,
	MIPI_DCS_SET_PARTIAL_ROWS = 48,
	MIPI_DCS_SET_PARTIAL_COLUMNS = 49,
	MIPI_DCS_SET_SCROLL_AREA = 51,
	MIPI_DCS_SET_TEAR_OFF = 52,
	MIPI_DCS_SET_TEAR_ON = 53,
	MIPI_DCS_SET_ADDRESS_MODE = 54,
	MIPI_DCS_SET_SCROLL_START = 55,
	MIPI_DCS_EXIT_IDLE_MODE = 56,
	MIPI_DCS_ENTER_IDLE_MODE = 57,
	MIPI_DCS_SET_PIXEL_FORMAT = 58,
	MIPI_DCS_WRITE_MEMORY_CONTINUE = 60,
	MIPI_DCS_SET_3D_CONTROL = 61,
	MIPI_DCS_READ_MEMORY_CONTINUE = 62,
	MIPI_DCS_GET_3D_CONTROL = 63,
	MIPI_DCS_SET_VSYNC_TIMING = 64,
	MIPI_DCS_SET_TEAR_SCANLINE = 68,
	MIPI_DCS_GET_SCANLINE = 69,
	MIPI_DCS_SET_DISPLAY_BRIGHTNESS = 81,
	MIPI_DCS_GET_DISPLAY_BRIGHTNESS = 82,
	MIPI_DCS_WRITE_CONTROL_DISPLAY = 83,
	MIPI_DCS_GET_CONTROL_DISPLAY = 84,
	MIPI_DCS_WRITE_POWER_SAVE = 85,
	MIPI_DCS_GET_POWER_SAVE = 86,
	MIPI_DCS_SET_CABC_MIN_BRIGHTNESS = 94,
	MIPI_DCS_GET_CABC_MIN_BRIGHTNESS = 95,
	MIPI_DCS_READ_DDB_START = 161,
	MIPI_DCS_READ_PPS_START = 162,
	MIPI_DCS_READ_DDB_CONTINUE = 168,
	MIPI_DCS_READ_PPS_CONTINUE = 169,
};

enum mipi_dsi_dpi_fmt {
	MIPI_RGB565_PACKED = 0,
	MIPI_RGB565_LOOSELY = 1,
	MIPI_RGB565_CONFIG3 = 2,
	MIPI_RGB666_PACKED = 3,
	MIPI_RGB666_LOOSELY = 4,
	MIPI_RGB888 = 5,
};

struct mipi_lcd_config {
	u32 virtual_ch;
	u32 data_lane_num;
	u32 max_phy_clk;
	enum mipi_dsi_dpi_fmt dpi_fmt;
};

struct mipi_dsi_info;

struct mipi_dsi_lcd_callback {
	void (*get_mipi_lcd_videomode)(struct fb_videomode **, int *, struct mipi_lcd_config **);
	int (*mipi_lcd_setup)(struct mipi_dsi_info *);
};

struct mipi_dsi_bus_mux;

struct mipi_dsi_info {
	struct platform_device *pdev;
	void *mmio_base;
	void *phy_base;
	struct regmap *regmap;
	struct regmap *mux_sel;
	const struct mipi_dsi_bus_mux *bus_mux;
	int dsi_power_on;
	int lcd_inited;
	int encoder;
	int traffic_mode;
	u32 dphy_pll_config;
	int dev_id;
	int disp_id;
	char *lcd_panel;
	int irq;
	uint32_t phy_ref_clkfreq;
	struct clk *dphy_clk;
	struct clk *cfg_clk;
	struct clk *esc_clk;
	struct mxc_dispdrv_handle *disp_mipi;
	int vmode_index;
	struct fb_videomode *mode;
	struct regulator *disp_power_on;
	struct mipi_lcd_config *lcd_config;
	struct backlight_device *bl;
	struct mipi_dsi_lcd_callback *lcd_callback;
	int (*mipi_dsi_pkt_read)(struct mipi_dsi_info *, u8, u32 *, int);
	int (*mipi_dsi_pkt_write)(struct mipi_dsi_info *, u8, const u32 *, int);
	int (*mipi_dsi_dcs_cmd)(struct mipi_dsi_info *, u8, const u32 *, int);
};

struct mipi_dsi_match_lcd {
	char *lcd_panel;
	struct mipi_dsi_lcd_callback lcd_callback;
};

struct mipi_dsi_bus_mux {
	int reg;
	int mask;
	int (*get_mux)(int, int);
};

struct pll_divider {
	unsigned int cm;
	unsigned int cn;
	unsigned int co;
};

enum cea_audio_coding_types {
	AUDIO_CODING_TYPE_REF_STREAM_HEADER = 0,
	AUDIO_CODING_TYPE_LPCM = 1,
	AUDIO_CODING_TYPE_AC3 = 2,
	AUDIO_CODING_TYPE_MPEG1 = 3,
	AUDIO_CODING_TYPE_MP3 = 4,
	AUDIO_CODING_TYPE_MPEG2 = 5,
	AUDIO_CODING_TYPE_AACLC = 6,
	AUDIO_CODING_TYPE_DTS = 7,
	AUDIO_CODING_TYPE_ATRAC = 8,
	AUDIO_CODING_TYPE_SACD = 9,
	AUDIO_CODING_TYPE_EAC3 = 10,
	AUDIO_CODING_TYPE_DTS_HD = 11,
	AUDIO_CODING_TYPE_MLP = 12,
	AUDIO_CODING_TYPE_DST = 13,
	AUDIO_CODING_TYPE_WMAPRO = 14,
	AUDIO_CODING_TYPE_RESERVED = 15,
};

struct mxc_hdmi_3d_format {
	unsigned char vic_order_2d;
	unsigned char struct_3d;
	unsigned char detail_3d;
	unsigned char reserved;
};

struct mxc_edid_cfg {
	bool cea_underscan;
	bool cea_basicaudio;
	bool cea_ycbcr444;
	bool cea_ycbcr422;
	bool hdmi_cap;
	bool vsd_support_ai;
	bool vsd_dc_48bit;
	bool vsd_dc_36bit;
	bool vsd_dc_30bit;
	bool vsd_dc_y444;
	bool vsd_dvi_dual;
	bool vsd_cnc0;
	bool vsd_cnc1;
	bool vsd_cnc2;
	bool vsd_cnc3;
	u8 vsd_video_latency;
	u8 vsd_audio_latency;
	u8 vsd_I_video_latency;
	u8 vsd_I_audio_latency;
	u8 physical_address[4];
	u8 hdmi_vic[64];
	struct mxc_hdmi_3d_format hdmi_3d_format[64];
	u16 hdmi_3d_mask_all;
	u16 hdmi_3d_struct_all;
	u32 vsd_max_tmdsclk_rate;
	u8 max_channels;
	u8 sample_sizes;
	u8 sample_rates;
	u8 speaker_alloc;
};

struct adv7535_info {
	int rev;
	struct device *dev;
	struct i2c_client *i2c_main;
	struct i2c_client *i2c_dsi_cec;
	struct fb_videomode *fb_vmode;
	unsigned int bpp;
};

enum mipi_dsi_trans_mode {
	DSI_LP_MODE = 0,
	DSI_HS_MODE = 1,
};

struct _mipi_dsi_phy_pll_clk {
	u32 max_phy_clk;
	u32 config;
};

struct crtc_mux {
	enum crtc crtc;
	u32 val;
};

struct bus_mux {
	int reg;
	int shift;
	int mask;
	int crtc_mux_num;
	const struct crtc_mux *crtcs;
};

struct ldb_info {
	bool split_cap;
	bool dual_cap;
	bool ext_bgref_cap;
	bool clk_fixup;
	int ctrl_reg;
	int bus_mux_num;
	const struct bus_mux *buses;
};

struct ldb_data;

struct ldb_chan {
	struct ldb_data *ldb;
	struct fb_info *fbi;
	struct videomode vm;
	enum crtc crtc;
	int chno;
	bool is_used;
	bool online;
};

struct ldb_data {
	struct regmap *regmap;
	struct device *dev;
	struct mxc_dispdrv_handle *mddh;
	struct ldb_chan chan[2];
	int bus_mux_num;
	const struct bus_mux *buses;
	int primary_chno;
	int ctrl_reg;
	u32 ctrl;
	bool spl_mode;
	bool dual_mode;
	bool clk_fixup;
	struct clk *di_clk[4];
	struct clk *ldb_di_clk[2];
	struct clk *div_3_5_clk[2];
	struct clk *div_7_clk[2];
	struct clk *div_sel_clk[2];
};

enum {
	LVDS_BIT_MAP_SPWG = 0,
	LVDS_BIT_MAP_JEIDA = 1,
};

struct sii902x_data {
	struct i2c_client *client;
	struct delayed_work det_work;
	struct fb_info *fbi;
	struct mxc_edid_cfg edid_cfg;
	u8 cable_plugin;
	u8 edid[512];
	bool dft_mode_set;
	const char *mode_str;
	int bits_per_pixel;
};

struct est_timings {
	u8 t1;
	u8 t2;
	u8 mfg_rsvd;
};

struct std_timing {
	u8 hsize;
	u8 vfreq_aspect;
};

struct detailed_pixel_timing {
	u8 hactive_lo;
	u8 hblank_lo;
	u8 hactive_hblank_hi;
	u8 vactive_lo;
	u8 vblank_lo;
	u8 vactive_vblank_hi;
	u8 hsync_offset_lo;
	u8 hsync_pulse_width_lo;
	u8 vsync_offset_pulse_width_lo;
	u8 hsync_vsync_offset_pulse_width_hi;
	u8 width_mm_lo;
	u8 height_mm_lo;
	u8 width_height_mm_hi;
	u8 hborder;
	u8 vborder;
	u8 misc;
};

struct detailed_data_string {
	u8 str[13];
};

struct detailed_data_monitor_range {
	u8 min_vfreq;
	u8 max_vfreq;
	u8 min_hfreq_khz;
	u8 max_hfreq_khz;
	u8 pixel_clock_mhz;
	u8 flags;
	union {
		struct {
			u8 reserved;
			u8 hfreq_start_khz;
			u8 c;
			__le16 m;
			u8 k;
			u8 j;
		} __attribute__((packed)) gtf2;
		struct {
			u8 version;
			u8 data1;
			u8 data2;
			u8 supported_aspects;
			u8 flags;
			u8 supported_scalings;
			u8 preferred_refresh;
		} cvt;
	} formula;
} __attribute__((packed));

struct detailed_data_wpindex {
	u8 white_yx_lo;
	u8 white_x_hi;
	u8 white_y_hi;
	u8 gamma;
};

struct cvt_timing {
	u8 code[3];
};

struct detailed_non_pixel {
	u8 pad1;
	u8 type;
	u8 pad2;
	union {
		struct detailed_data_string str;
		struct detailed_data_monitor_range range;
		struct detailed_data_wpindex color;
		struct std_timing timings[6];
		struct cvt_timing cvt[4];
	} data;
} __attribute__((packed));

struct detailed_timing {
	__le16 pixel_clock;
	union {
		struct detailed_pixel_timing pixel_data;
		struct detailed_non_pixel other_data;
	} data;
};

struct edid {
	u8 header[8];
	u8 mfg_id[2];
	u8 prod_code[2];
	u32 serial;
	u8 mfg_week;
	u8 mfg_year;
	u8 version;
	u8 revision;
	u8 input;
	u8 width_cm;
	u8 height_cm;
	u8 gamma;
	u8 features;
	u8 red_green_lo;
	u8 blue_white_lo;
	u8 red_x;
	u8 red_y;
	u8 green_x;
	u8 green_y;
	u8 blue_x;
	u8 blue_y;
	u8 white_x;
	u8 white_y;
	struct est_timings established_timings;
	struct std_timing standard_timings[8];
	struct detailed_timing detailed_timings[4];
	u8 extensions;
	u8 checksum;
};

struct snd_shutdown_f_ops;

struct snd_info_entry;

struct snd_card {
	int number;
	char id[16];
	char driver[16];
	char shortname[32];
	char longname[80];
	char irq_descr[32];
	char mixername[80];
	char components[128];
	struct module *module;
	void *private_data;
	void (*private_free)(struct snd_card *);
	struct list_head devices;
	struct device ctl_dev;
	unsigned int last_numid;
	struct rw_semaphore controls_rwsem;
	rwlock_t ctl_files_rwlock;
	int controls_count;
	size_t user_ctl_alloc_size;
	struct list_head controls;
	struct list_head ctl_files;
	struct xarray ctl_numids;
	struct xarray ctl_hash;
	bool ctl_hash_collision;
	struct snd_info_entry *proc_root;
	struct proc_dir_entry *proc_root_link;
	struct list_head files_list;
	struct snd_shutdown_f_ops *s_f_ops;
	spinlock_t files_lock;
	int shutdown;
	struct completion *release_completion;
	struct device *dev;
	struct device card_dev;
	const struct attribute_group *dev_groups[4];
	bool registered;
	bool managed;
	bool releasing;
	int sync_irq;
	wait_queue_head_t remove_sleep;
	size_t total_pcm_alloc_bytes;
	struct mutex memory_mutex;
	unsigned int power_state;
	atomic_t power_ref;
	wait_queue_head_t power_sleep;
	wait_queue_head_t power_ref_sleep;
	int: 32;
};

struct snd_info_buffer;

struct snd_info_entry_text {
	void (*read)(struct snd_info_entry *, struct snd_info_buffer *);
	void (*write)(struct snd_info_entry *, struct snd_info_buffer *);
};

struct snd_info_entry_ops;

struct snd_info_entry {
	const char *name;
	umode_t mode;
	long int size;
	short unsigned int content;
	union {
		struct snd_info_entry_text text;
		const struct snd_info_entry_ops *ops;
	} c;
	struct snd_info_entry *parent;
	struct module *module;
	void *private_data;
	void (*private_free)(struct snd_info_entry *);
	struct proc_dir_entry *p;
	struct mutex access;
	struct list_head children;
	struct list_head list;
};

struct snd_aes_iec958 {
	unsigned char status[24];
	unsigned char subcode[147];
	unsigned char pad;
	unsigned char dig_subframe[4];
};

typedef long unsigned int snd_pcm_uframes_t;

typedef long int snd_pcm_sframes_t;

typedef int snd_pcm_access_t;

typedef int snd_pcm_format_t;

typedef int snd_pcm_subformat_t;

typedef int snd_pcm_state_t;

union snd_pcm_sync_id {
	unsigned char id[16];
	short unsigned int id16[8];
	unsigned int id32[4];
};

struct snd_interval {
	unsigned int min;
	unsigned int max;
	unsigned int openmin: 1;
	unsigned int openmax: 1;
	unsigned int integer: 1;
	unsigned int empty: 1;
};

struct snd_mask {
	__u32 bits[8];
};

struct snd_pcm_hw_params {
	unsigned int flags;
	struct snd_mask masks[3];
	struct snd_mask mres[5];
	struct snd_interval intervals[12];
	struct snd_interval ires[9];
	unsigned int rmask;
	unsigned int cmask;
	unsigned int info;
	unsigned int msbits;
	unsigned int rate_num;
	unsigned int rate_den;
	snd_pcm_uframes_t fifo_size;
	unsigned char reserved[64];
};

typedef char __pad_before_uframe[0];

typedef char __pad_after_uframe[4];

struct snd_pcm_mmap_status {
	snd_pcm_state_t state;
	__u32 pad1;
	__pad_before_uframe __pad1;
	snd_pcm_uframes_t hw_ptr;
	__pad_after_uframe __pad2;
	struct __kernel_timespec tstamp;
	snd_pcm_state_t suspended_state;
	__u32 pad3;
	struct __kernel_timespec audio_tstamp;
};

struct snd_pcm_mmap_control {
	__pad_before_uframe __pad1;
	snd_pcm_uframes_t appl_ptr;
	__pad_before_uframe __pad2;
	__pad_before_uframe __pad3;
	snd_pcm_uframes_t avail_min;
	__pad_after_uframe __pad4;
};

typedef int snd_ctl_elem_type_t;

typedef int snd_ctl_elem_iface_t;

struct snd_ctl_elem_id {
	unsigned int numid;
	snd_ctl_elem_iface_t iface;
	unsigned int device;
	unsigned int subdevice;
	unsigned char name[44];
	unsigned int index;
};

struct snd_ctl_elem_info {
	struct snd_ctl_elem_id id;
	snd_ctl_elem_type_t type;
	unsigned int access;
	unsigned int count;
	__kernel_pid_t owner;
	union {
		struct {
			long int min;
			long int max;
			long int step;
		} integer;
		struct {
			long long int min;
			long long int max;
			long long int step;
		} integer64;
		struct {
			unsigned int items;
			unsigned int item;
			char name[64];
			__u64 names_ptr;
			unsigned int names_length;
			int: 32;
		} enumerated;
		unsigned char reserved[128];
	} value;
	unsigned char reserved[64];
};

struct snd_ctl_elem_value {
	struct snd_ctl_elem_id id;
	unsigned int indirect: 1;
	int: 31;
	int: 32;
	union {
		union {
			long int value[128];
			long int *value_ptr;
		} integer;
		union {
			long long int value[64];
			long long int *value_ptr;
		} integer64;
		union {
			unsigned int item[128];
			unsigned int *item_ptr;
		} enumerated;
		union {
			unsigned char data[512];
			unsigned char *data_ptr;
		} bytes;
		struct snd_aes_iec958 iec958;
	} value;
	unsigned char reserved[128];
};

struct snd_dma_device {
	int type;
	enum dma_data_direction dir;
	bool need_sync;
	struct device *dev;
};

struct snd_dma_buffer {
	struct snd_dma_device dev;
	unsigned char *area;
	dma_addr_t addr;
	size_t bytes;
	void *private_data;
};

struct snd_pcm_hardware {
	unsigned int info;
	int: 32;
	u64 formats;
	unsigned int rates;
	unsigned int rate_min;
	unsigned int rate_max;
	unsigned int channels_min;
	unsigned int channels_max;
	size_t buffer_bytes_max;
	size_t period_bytes_min;
	size_t period_bytes_max;
	unsigned int periods_min;
	unsigned int periods_max;
	size_t fifo_size;
	int: 32;
};

struct snd_pcm_substream;

struct snd_pcm_audio_tstamp_config;

struct snd_pcm_audio_tstamp_report;

struct snd_pcm_ops {
	int (*open)(struct snd_pcm_substream *);
	int (*close)(struct snd_pcm_substream *);
	int (*ioctl)(struct snd_pcm_substream *, unsigned int, void *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_pcm_substream *);
	int (*prepare)(struct snd_pcm_substream *);
	int (*trigger)(struct snd_pcm_substream *, int);
	int (*sync_stop)(struct snd_pcm_substream *);
	snd_pcm_uframes_t (*pointer)(struct snd_pcm_substream *);
	int (*get_time_info)(struct snd_pcm_substream *, struct timespec64 *, struct timespec64 *, struct snd_pcm_audio_tstamp_config *, struct snd_pcm_audio_tstamp_report *);
	int (*fill_silence)(struct snd_pcm_substream *, int, long unsigned int, long unsigned int);
	int (*copy_user)(struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);
	int (*copy_kernel)(struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);
	struct page * (*page)(struct snd_pcm_substream *, long unsigned int);
	int (*mmap)(struct snd_pcm_substream *, struct vm_area_struct *);
	int (*ack)(struct snd_pcm_substream *);
};

struct snd_pcm_group {
	spinlock_t lock;
	struct mutex mutex;
	struct list_head substreams;
	refcount_t refs;
};

struct snd_pcm;

struct snd_pcm_str;

struct snd_pcm_runtime;

struct snd_timer;

struct snd_pcm_substream {
	struct snd_pcm *pcm;
	struct snd_pcm_str *pstr;
	void *private_data;
	int number;
	char name[32];
	int stream;
	struct pm_qos_request latency_pm_qos_req;
	size_t buffer_bytes_max;
	struct snd_dma_buffer dma_buffer;
	size_t dma_max;
	const struct snd_pcm_ops *ops;
	struct snd_pcm_runtime *runtime;
	struct snd_timer *timer;
	unsigned int timer_running: 1;
	long int wait_time;
	struct snd_pcm_substream *next;
	struct list_head link_list;
	struct snd_pcm_group self_group;
	struct snd_pcm_group *group;
	int ref_count;
	atomic_t mmap_count;
	unsigned int f_flags;
	void (*pcm_release)(struct snd_pcm_substream *);
	struct pid *pid;
	struct snd_info_entry *proc_root;
	unsigned int hw_opened: 1;
	unsigned int managed_buffer_alloc: 1;
};

struct snd_pcm_audio_tstamp_config {
	u32 type_requested: 4;
	u32 report_delay: 1;
};

struct snd_pcm_audio_tstamp_report {
	u32 valid: 1;
	u32 actual_type: 4;
	u32 accuracy_report: 1;
	u32 accuracy;
};

struct snd_pcm_hw_rule;

typedef int (*snd_pcm_hw_rule_func_t)(struct snd_pcm_hw_params *, struct snd_pcm_hw_rule *);

struct snd_pcm_hw_rule {
	unsigned int cond;
	int var;
	int deps[5];
	snd_pcm_hw_rule_func_t func;
	void *private;
};

struct snd_pcm_hw_constraints {
	struct snd_mask masks[3];
	struct snd_interval intervals[12];
	unsigned int rules_num;
	unsigned int rules_all;
	struct snd_pcm_hw_rule *rules;
};

struct snd_fasync;

struct snd_pcm_runtime {
	snd_pcm_state_t state;
	snd_pcm_state_t suspended_state;
	struct snd_pcm_substream *trigger_master;
	int: 32;
	struct timespec64 trigger_tstamp;
	bool trigger_tstamp_latched;
	int overrange;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t hw_ptr_base;
	snd_pcm_uframes_t hw_ptr_interrupt;
	long unsigned int hw_ptr_jiffies;
	long unsigned int hw_ptr_buffer_jiffies;
	snd_pcm_sframes_t delay;
	u64 hw_ptr_wrap;
	snd_pcm_access_t access;
	snd_pcm_format_t format;
	snd_pcm_subformat_t subformat;
	unsigned int rate;
	unsigned int channels;
	snd_pcm_uframes_t period_size;
	unsigned int periods;
	snd_pcm_uframes_t buffer_size;
	snd_pcm_uframes_t min_align;
	size_t byte_align;
	unsigned int frame_bits;
	unsigned int sample_bits;
	unsigned int info;
	unsigned int rate_num;
	unsigned int rate_den;
	unsigned int no_period_wakeup: 1;
	int tstamp_mode;
	unsigned int period_step;
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold;
	snd_pcm_uframes_t silence_size;
	snd_pcm_uframes_t boundary;
	snd_pcm_uframes_t silence_start;
	snd_pcm_uframes_t silence_filled;
	union snd_pcm_sync_id sync;
	struct snd_pcm_mmap_status *status;
	struct snd_pcm_mmap_control *control;
	snd_pcm_uframes_t twake;
	wait_queue_head_t sleep;
	wait_queue_head_t tsleep;
	struct snd_fasync *fasync;
	bool stop_operating;
	struct mutex buffer_mutex;
	atomic_t buffer_accessing;
	void *private_data;
	void (*private_free)(struct snd_pcm_runtime *);
	struct snd_pcm_hardware hw;
	struct snd_pcm_hw_constraints hw_constraints;
	unsigned int timer_resolution;
	int tstamp_type;
	unsigned char *dma_area;
	dma_addr_t dma_addr;
	size_t dma_bytes;
	struct snd_dma_buffer *dma_buffer_p;
	unsigned int buffer_changed: 1;
	struct snd_pcm_audio_tstamp_config audio_tstamp_config;
	struct snd_pcm_audio_tstamp_report audio_tstamp_report;
	int: 32;
	struct timespec64 driver_tstamp;
};

struct snd_kcontrol;

struct snd_pcm_str {
	int stream;
	struct snd_pcm *pcm;
	unsigned int substream_count;
	unsigned int substream_opened;
	struct snd_pcm_substream *substream;
	struct snd_info_entry *proc_root;
	struct snd_kcontrol *chmap_kctl;
	int: 32;
	struct device dev;
};

struct snd_pcm {
	struct snd_card *card;
	struct list_head list;
	int device;
	unsigned int info_flags;
	short unsigned int dev_class;
	short unsigned int dev_subclass;
	char id[64];
	char name[80];
	struct snd_pcm_str streams[2];
	struct mutex open_mutex;
	wait_queue_head_t open_wait;
	void *private_data;
	void (*private_free)(struct snd_pcm *);
	bool internal;
	bool nonatomic;
	bool no_device_suspend;
	int: 8;
	int: 32;
};

typedef int snd_kcontrol_info_t(struct snd_kcontrol *, struct snd_ctl_elem_info *);

typedef int snd_kcontrol_get_t(struct snd_kcontrol *, struct snd_ctl_elem_value *);

typedef int snd_kcontrol_put_t(struct snd_kcontrol *, struct snd_ctl_elem_value *);

typedef int snd_kcontrol_tlv_rw_t(struct snd_kcontrol *, int, unsigned int, unsigned int *);

struct snd_ctl_file;

struct snd_kcontrol_volatile {
	struct snd_ctl_file *owner;
	unsigned int access;
};

struct snd_kcontrol {
	struct list_head list;
	struct snd_ctl_elem_id id;
	unsigned int count;
	snd_kcontrol_info_t *info;
	snd_kcontrol_get_t *get;
	snd_kcontrol_put_t *put;
	union {
		snd_kcontrol_tlv_rw_t *c;
		const unsigned int *p;
	} tlv;
	long unsigned int private_value;
	void *private_data;
	void (*private_free)(struct snd_kcontrol *);
	struct snd_kcontrol_volatile vd[0];
};

struct snd_enc_wma {
	__u32 super_block_align;
};

struct snd_enc_vorbis {
	__s32 quality;
	__u32 managed;
	__u32 max_bit_rate;
	__u32 min_bit_rate;
	__u32 downmix;
};

struct snd_enc_real {
	__u32 quant_bits;
	__u32 start_region;
	__u32 num_regions;
};

struct snd_enc_flac {
	__u32 num;
	__u32 gain;
};

struct snd_enc_generic {
	__u32 bw;
	__s32 reserved[15];
};

struct snd_dec_flac {
	__u16 sample_size;
	__u16 min_blk_size;
	__u16 max_blk_size;
	__u16 min_frame_size;
	__u16 max_frame_size;
	__u16 reserved;
};

struct snd_dec_wma {
	__u32 encoder_option;
	__u32 adv_encoder_option;
	__u32 adv_encoder_option2;
	__u32 reserved;
};

struct snd_dec_alac {
	__u32 frame_length;
	__u8 compatible_version;
	__u8 pb;
	__u8 mb;
	__u8 kb;
	__u32 max_run;
	__u32 max_frame_bytes;
};

struct snd_dec_ape {
	__u16 compatible_version;
	__u16 compression_level;
	__u32 format_flags;
	__u32 blocks_per_frame;
	__u32 final_frame_blocks;
	__u32 total_frames;
	__u32 seek_table_present;
};

union snd_codec_options {
	struct snd_enc_wma wma;
	struct snd_enc_vorbis vorbis;
	struct snd_enc_real real;
	struct snd_enc_flac flac;
	struct snd_enc_generic generic;
	struct snd_dec_flac flac_d;
	struct snd_dec_wma wma_d;
	struct snd_dec_alac alac_d;
	struct snd_dec_ape ape_d;
};

struct snd_codec_desc {
	__u32 max_ch;
	__u32 sample_rates[32];
	__u32 num_sample_rates;
	__u32 bit_rate[32];
	__u32 num_bitrates;
	__u32 rate_control;
	__u32 profiles;
	__u32 modes;
	__u32 formats;
	__u32 min_buffer;
	__u32 reserved[15];
};

struct snd_codec {
	__u32 id;
	__u32 ch_in;
	__u32 ch_out;
	__u32 sample_rate;
	__u32 bit_rate;
	__u32 rate_control;
	__u32 profile;
	__u32 level;
	__u32 ch_mode;
	__u32 format;
	__u32 align;
	union snd_codec_options options;
	__u32 reserved[3];
};

struct snd_compressed_buffer {
	__u32 fragment_size;
	__u32 fragments;
};

struct snd_compr_params {
	struct snd_compressed_buffer buffer;
	struct snd_codec codec;
	__u8 no_wake_mode;
};

struct snd_compr_tstamp {
	__u32 byte_offset;
	__u32 copied_total;
	__u32 pcm_frames;
	__u32 pcm_io_frames;
	__u32 sampling_rate;
};

enum snd_compr_direction {
	SND_COMPRESS_PLAYBACK = 0,
	SND_COMPRESS_CAPTURE = 1,
};

struct snd_compr_caps {
	__u32 num_codecs;
	__u32 direction;
	__u32 min_fragment_size;
	__u32 max_fragment_size;
	__u32 min_fragments;
	__u32 max_fragments;
	__u32 codecs[32];
	__u32 reserved[11];
};

struct snd_compr_codec_caps {
	__u32 codec;
	__u32 num_descriptors;
	struct snd_codec_desc descriptor[32];
};

struct snd_compr_metadata {
	__u32 key;
	__u32 value[8];
};

struct snd_compr_ops;

struct snd_compr_runtime {
	snd_pcm_state_t state;
	struct snd_compr_ops *ops;
	void *buffer;
	int: 32;
	u64 buffer_size;
	u32 fragment_size;
	u32 fragments;
	u64 total_bytes_available;
	u64 total_bytes_transferred;
	wait_queue_head_t sleep;
	void *private_data;
	unsigned char *dma_area;
	dma_addr_t dma_addr;
	size_t dma_bytes;
	struct snd_dma_buffer *dma_buffer_p;
};

struct snd_compr_stream;

struct snd_compr_ops {
	int (*open)(struct snd_compr_stream *);
	int (*free)(struct snd_compr_stream *);
	int (*set_params)(struct snd_compr_stream *, struct snd_compr_params *);
	int (*get_params)(struct snd_compr_stream *, struct snd_codec *);
	int (*set_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*get_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*trigger)(struct snd_compr_stream *, int);
	int (*pointer)(struct snd_compr_stream *, struct snd_compr_tstamp *);
	int (*copy)(struct snd_compr_stream *, char *, size_t);
	int (*mmap)(struct snd_compr_stream *, struct vm_area_struct *);
	int (*ack)(struct snd_compr_stream *, size_t);
	int (*get_caps)(struct snd_compr_stream *, struct snd_compr_caps *);
	int (*get_codec_caps)(struct snd_compr_stream *, struct snd_compr_codec_caps *);
};

struct snd_compr;

struct snd_compr_stream {
	const char *name;
	struct snd_compr_ops *ops;
	struct snd_compr_runtime *runtime;
	struct snd_compr *device;
	struct delayed_work error_work;
	enum snd_compr_direction direction;
	bool metadata_set;
	bool next_track;
	bool partial_drain;
	bool pause_in_draining;
	void *private_data;
	struct snd_dma_buffer dma_buffer;
};

struct snd_compr {
	const char *name;
	int: 32;
	struct device dev;
	struct snd_compr_ops *ops;
	void *private_data;
	struct snd_card *card;
	unsigned int direction;
	struct mutex lock;
	int device;
	bool use_pause_in_draining;
	char id[64];
	struct snd_info_entry *proc_root;
	struct snd_info_entry *proc_info_entry;
	int: 32;
};

struct snd_kcontrol_new {
	snd_ctl_elem_iface_t iface;
	unsigned int device;
	unsigned int subdevice;
	const char *name;
	unsigned int index;
	unsigned int access;
	unsigned int count;
	snd_kcontrol_info_t *info;
	snd_kcontrol_get_t *get;
	snd_kcontrol_put_t *put;
	union {
		snd_kcontrol_tlv_rw_t *c;
		const unsigned int *p;
	} tlv;
	long unsigned int private_value;
};

struct snd_ctl_file {
	struct list_head list;
	struct snd_card *card;
	struct pid *pid;
	int preferred_subdevice[2];
	wait_queue_head_t change_sleep;
	spinlock_t read_lock;
	struct snd_fasync *fasync;
	int subscribed;
	struct list_head events;
};

struct snd_info_buffer {
	char *buffer;
	unsigned int curr;
	unsigned int size;
	unsigned int len;
	int stop;
	int error;
};

struct snd_info_entry_ops {
	int (*open)(struct snd_info_entry *, short unsigned int, void **);
	int (*release)(struct snd_info_entry *, short unsigned int, void *);
	ssize_t (*read)(struct snd_info_entry *, void *, struct file *, char *, size_t, loff_t);
	ssize_t (*write)(struct snd_info_entry *, void *, struct file *, const char *, size_t, loff_t);
	loff_t (*llseek)(struct snd_info_entry *, void *, struct file *, loff_t, int);
	__poll_t (*poll)(struct snd_info_entry *, void *, struct file *, poll_table *);
	int (*ioctl)(struct snd_info_entry *, void *, struct file *, unsigned int, long unsigned int);
	int (*mmap)(struct snd_info_entry *, void *, struct inode *, struct file *, struct vm_area_struct *);
};

struct snd_soc_tplg_hdr {
	__le32 magic;
	__le32 abi;
	__le32 version;
	__le32 type;
	__le32 size;
	__le32 vendor_type;
	__le32 payload_size;
	__le32 index;
	__le32 count;
};

struct snd_soc_tplg_vendor_uuid_elem {
	__le32 token;
	char uuid[16];
};

struct snd_soc_tplg_vendor_value_elem {
	__le32 token;
	__le32 value;
};

struct snd_soc_tplg_vendor_string_elem {
	__le32 token;
	char string[44];
};

struct snd_soc_tplg_vendor_array {
	__le32 size;
	__le32 type;
	__le32 num_elems;
	union {
		struct snd_soc_tplg_vendor_uuid_elem uuid[0];
		struct snd_soc_tplg_vendor_value_elem value[0];
		struct snd_soc_tplg_vendor_string_elem string[0];
	};
};

struct snd_soc_tplg_private {
	__le32 size;
	union {
		struct {
			struct {			} __empty_data;
			char data[0];
		};
		struct {
			struct {			} __empty_array;
			struct snd_soc_tplg_vendor_array array[0];
		};
	};
};

struct snd_soc_tplg_tlv_dbscale {
	__le32 min;
	__le32 step;
	__le32 mute;
};

struct snd_soc_tplg_ctl_tlv {
	__le32 size;
	__le32 type;
	union {
		__le32 data[32];
		struct snd_soc_tplg_tlv_dbscale scale;
	};
};

struct snd_soc_tplg_io_ops {
	__le32 get;
	__le32 put;
	__le32 info;
};

struct snd_soc_tplg_ctl_hdr {
	__le32 size;
	__le32 type;
	char name[44];
	__le32 access;
	struct snd_soc_tplg_io_ops ops;
	struct snd_soc_tplg_ctl_tlv tlv;
};

struct snd_soc_tplg_stream_caps {
	__le32 size;
	char name[44];
	__le64 formats;
	__le32 rates;
	__le32 rate_min;
	__le32 rate_max;
	__le32 channels_min;
	__le32 channels_max;
	__le32 periods_min;
	__le32 periods_max;
	__le32 period_size_min;
	__le32 period_size_max;
	__le32 buffer_size_min;
	__le32 buffer_size_max;
	__le32 sig_bits;
};

struct snd_soc_tplg_stream {
	__le32 size;
	char name[44];
	__le64 format;
	__le32 rate;
	__le32 period_bytes;
	__le32 buffer_bytes;
	__le32 channels;
};

struct snd_soc_tplg_hw_config {
	__le32 size;
	__le32 id;
	__le32 fmt;
	__u8 clock_gated;
	__u8 invert_bclk;
	__u8 invert_fsync;
	__u8 bclk_provider;
	__u8 fsync_provider;
	__u8 mclk_direction;
	__le16 reserved;
	__le32 mclk_rate;
	__le32 bclk_rate;
	__le32 fsync_rate;
	__le32 tdm_slots;
	__le32 tdm_slot_width;
	__le32 tx_slots;
	__le32 rx_slots;
	__le32 tx_channels;
	__le32 tx_chanmap[8];
	__le32 rx_channels;
	__le32 rx_chanmap[8];
};

struct snd_soc_tplg_manifest {
	__le32 size;
	__le32 control_elems;
	__le32 widget_elems;
	__le32 graph_elems;
	__le32 pcm_elems;
	__le32 dai_link_elems;
	__le32 dai_elems;
	__le32 reserved[20];
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_dapm_widget {
	__le32 size;
	__le32 id;
	char name[44];
	char sname[44];
	__le32 reg;
	__le32 shift;
	__le32 mask;
	__le32 subseq;
	__le32 invert;
	__le32 ignore_suspend;
	__le16 event_flags;
	__le16 event_type;
	__le32 num_kcontrols;
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_pcm {
	__le32 size;
	char pcm_name[44];
	char dai_name[44];
	__le32 pcm_id;
	__le32 dai_id;
	__le32 playback;
	__le32 capture;
	__le32 compress;
	struct snd_soc_tplg_stream stream[8];
	__le32 num_streams;
	struct snd_soc_tplg_stream_caps caps[2];
	__le32 flag_mask;
	__le32 flags;
	struct snd_soc_tplg_private priv;
};

struct snd_soc_tplg_link_config {
	__le32 size;
	__le32 id;
	char name[44];
	char stream_name[44];
	struct snd_soc_tplg_stream stream[8];
	__le32 num_streams;
	struct snd_soc_tplg_hw_config hw_config[8];
	__le32 num_hw_configs;
	__le32 default_hw_config_id;
	__le32 flag_mask;
	__le32 flags;
	struct snd_soc_tplg_private priv;
};

enum snd_soc_dobj_type {
	SND_SOC_DOBJ_NONE = 0,
	SND_SOC_DOBJ_MIXER = 1,
	SND_SOC_DOBJ_BYTES = 2,
	SND_SOC_DOBJ_ENUM = 3,
	SND_SOC_DOBJ_GRAPH = 4,
	SND_SOC_DOBJ_WIDGET = 5,
	SND_SOC_DOBJ_DAI_LINK = 6,
	SND_SOC_DOBJ_PCM = 7,
	SND_SOC_DOBJ_CODEC_LINK = 8,
	SND_SOC_DOBJ_BACKEND_LINK = 9,
};

struct snd_soc_dobj_control {
	struct snd_kcontrol *kcontrol;
	char **dtexts;
	long unsigned int *dvalues;
};

struct snd_soc_dobj_widget {
	unsigned int *kcontrol_type;
};

struct snd_soc_tplg_ops;

struct snd_soc_dobj {
	enum snd_soc_dobj_type type;
	unsigned int index;
	struct list_head list;
	struct snd_soc_tplg_ops *ops;
	union {
		struct snd_soc_dobj_control control;
		struct snd_soc_dobj_widget widget;
	};
	void *private;
};

struct snd_soc_component;

struct snd_soc_dapm_route;

struct snd_soc_dapm_widget;

struct snd_soc_dai_driver;

struct snd_soc_dai;

struct snd_soc_dai_link;

struct snd_soc_tplg_kcontrol_ops;

struct snd_soc_tplg_bytes_ext_ops;

struct snd_soc_tplg_ops {
	int (*control_load)(struct snd_soc_component *, int, struct snd_kcontrol_new *, struct snd_soc_tplg_ctl_hdr *);
	int (*control_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*dapm_route_load)(struct snd_soc_component *, int, struct snd_soc_dapm_route *);
	int (*dapm_route_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*widget_load)(struct snd_soc_component *, int, struct snd_soc_dapm_widget *, struct snd_soc_tplg_dapm_widget *);
	int (*widget_ready)(struct snd_soc_component *, int, struct snd_soc_dapm_widget *, struct snd_soc_tplg_dapm_widget *);
	int (*widget_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*dai_load)(struct snd_soc_component *, int, struct snd_soc_dai_driver *, struct snd_soc_tplg_pcm *, struct snd_soc_dai *);
	int (*dai_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*link_load)(struct snd_soc_component *, int, struct snd_soc_dai_link *, struct snd_soc_tplg_link_config *);
	int (*link_unload)(struct snd_soc_component *, struct snd_soc_dobj *);
	int (*vendor_load)(struct snd_soc_component *, int, struct snd_soc_tplg_hdr *);
	int (*vendor_unload)(struct snd_soc_component *, struct snd_soc_tplg_hdr *);
	int (*complete)(struct snd_soc_component *);
	int (*manifest)(struct snd_soc_component *, int, struct snd_soc_tplg_manifest *);
	const struct snd_soc_tplg_kcontrol_ops *io_ops;
	int io_ops_count;
	const struct snd_soc_tplg_bytes_ext_ops *bytes_ext_ops;
	int bytes_ext_ops_count;
};

struct snd_soc_tplg_kcontrol_ops {
	u32 id;
	int (*get)(struct snd_kcontrol *, struct snd_ctl_elem_value *);
	int (*put)(struct snd_kcontrol *, struct snd_ctl_elem_value *);
	int (*info)(struct snd_kcontrol *, struct snd_ctl_elem_info *);
};

struct snd_soc_tplg_bytes_ext_ops {
	u32 id;
	int (*get)(struct snd_kcontrol *, unsigned int *, unsigned int);
	int (*put)(struct snd_kcontrol *, const unsigned int *, unsigned int);
};

enum snd_soc_dapm_type {
	snd_soc_dapm_input = 0,
	snd_soc_dapm_output = 1,
	snd_soc_dapm_mux = 2,
	snd_soc_dapm_demux = 3,
	snd_soc_dapm_mixer = 4,
	snd_soc_dapm_mixer_named_ctl = 5,
	snd_soc_dapm_pga = 6,
	snd_soc_dapm_out_drv = 7,
	snd_soc_dapm_adc = 8,
	snd_soc_dapm_dac = 9,
	snd_soc_dapm_micbias = 10,
	snd_soc_dapm_mic = 11,
	snd_soc_dapm_hp = 12,
	snd_soc_dapm_spk = 13,
	snd_soc_dapm_line = 14,
	snd_soc_dapm_switch = 15,
	snd_soc_dapm_vmid = 16,
	snd_soc_dapm_pre = 17,
	snd_soc_dapm_post = 18,
	snd_soc_dapm_supply = 19,
	snd_soc_dapm_pinctrl = 20,
	snd_soc_dapm_regulator_supply = 21,
	snd_soc_dapm_clock_supply = 22,
	snd_soc_dapm_aif_in = 23,
	snd_soc_dapm_aif_out = 24,
	snd_soc_dapm_siggen = 25,
	snd_soc_dapm_sink = 26,
	snd_soc_dapm_dai_in = 27,
	snd_soc_dapm_dai_out = 28,
	snd_soc_dapm_dai_link = 29,
	snd_soc_dapm_kcontrol = 30,
	snd_soc_dapm_buffer = 31,
	snd_soc_dapm_scheduler = 32,
	snd_soc_dapm_effect = 33,
	snd_soc_dapm_src = 34,
	snd_soc_dapm_asrc = 35,
	snd_soc_dapm_encoder = 36,
	snd_soc_dapm_decoder = 37,
	SND_SOC_DAPM_TYPE_COUNT = 38,
};

struct snd_soc_dapm_context;

struct snd_soc_dapm_widget {
	enum snd_soc_dapm_type id;
	const char *name;
	const char *sname;
	struct list_head list;
	struct snd_soc_dapm_context *dapm;
	void *priv;
	struct regulator *regulator;
	struct pinctrl *pinctrl;
	int reg;
	unsigned char shift;
	unsigned int mask;
	unsigned int on_val;
	unsigned int off_val;
	unsigned char power: 1;
	unsigned char active: 1;
	unsigned char connected: 1;
	unsigned char new: 1;
	unsigned char force: 1;
	unsigned char ignore_suspend: 1;
	unsigned char new_power: 1;
	unsigned char power_checked: 1;
	unsigned char is_supply: 1;
	unsigned char is_ep: 2;
	int subseq;
	int (*power_check)(struct snd_soc_dapm_widget *);
	short unsigned int event_flags;
	int (*event)(struct snd_soc_dapm_widget *, struct snd_kcontrol *, int);
	int num_kcontrols;
	const struct snd_kcontrol_new *kcontrol_news;
	struct snd_kcontrol **kcontrols;
	struct snd_soc_dobj dobj;
	struct list_head edges[2];
	struct list_head work_list;
	struct list_head power_list;
	struct list_head dirty;
	int endpoints[2];
	struct clk *clk;
	int channel;
};

enum snd_soc_bias_level {
	SND_SOC_BIAS_OFF = 0,
	SND_SOC_BIAS_STANDBY = 1,
	SND_SOC_BIAS_PREPARE = 2,
	SND_SOC_BIAS_ON = 3,
};

struct snd_soc_dapm_wcache {
	struct snd_soc_dapm_widget *widget;
};

struct snd_soc_card;

struct snd_soc_dapm_context {
	enum snd_soc_bias_level bias_level;
	unsigned int idle_bias_off: 1;
	unsigned int suspend_bias_off: 1;
	struct device *dev;
	struct snd_soc_component *component;
	struct snd_soc_card *card;
	enum snd_soc_bias_level target_bias_level;
	struct list_head list;
	struct snd_soc_dapm_wcache path_sink_cache;
	struct snd_soc_dapm_wcache path_source_cache;
	struct dentry *debugfs_dapm;
};

struct snd_soc_component_driver;

struct snd_soc_component {
	const char *name;
	int id;
	const char *name_prefix;
	struct device *dev;
	struct snd_soc_card *card;
	unsigned int active;
	unsigned int suspended: 1;
	struct list_head list;
	struct list_head card_aux_list;
	struct list_head card_list;
	const struct snd_soc_component_driver *driver;
	struct list_head dai_list;
	int num_dai;
	struct regmap *regmap;
	int val_bytes;
	struct mutex io_mutex;
	struct list_head dobj_list;
	struct snd_soc_dapm_context dapm;
	int (*init)(struct snd_soc_component *);
	void *mark_module;
	struct snd_pcm_substream *mark_open;
	struct snd_pcm_substream *mark_hw_params;
	struct snd_pcm_substream *mark_trigger;
	struct snd_compr_stream *mark_compr_open;
	void *mark_pm;
	struct dentry *debugfs_root;
	const char *debugfs_prefix;
};

struct snd_soc_dapm_route {
	const char *sink;
	const char *control;
	const char *source;
	int (*connected)(struct snd_soc_dapm_widget *, struct snd_soc_dapm_widget *);
	struct snd_soc_dobj dobj;
};

struct snd_soc_pcm_stream {
	const char *stream_name;
	int: 32;
	u64 formats;
	unsigned int rates;
	unsigned int rate_min;
	unsigned int rate_max;
	unsigned int channels_min;
	unsigned int channels_max;
	unsigned int sig_bits;
};

struct snd_soc_pcm_runtime;

struct snd_soc_dai_ops;

struct snd_soc_cdai_ops;

struct snd_soc_dai_driver {
	const char *name;
	unsigned int id;
	unsigned int base;
	struct snd_soc_dobj dobj;
	int (*probe)(struct snd_soc_dai *);
	int (*remove)(struct snd_soc_dai *);
	int (*compress_new)(struct snd_soc_pcm_runtime *, int);
	int (*pcm_new)(struct snd_soc_pcm_runtime *, struct snd_soc_dai *);
	const struct snd_soc_dai_ops *ops;
	const struct snd_soc_cdai_ops *cops;
	struct snd_soc_pcm_stream capture;
	struct snd_soc_pcm_stream playback;
	unsigned int symmetric_rate: 1;
	unsigned int symmetric_channels: 1;
	unsigned int symmetric_sample_bits: 1;
	int probe_order;
	int remove_order;
	int: 32;
};

struct snd_soc_dai {
	const char *name;
	int id;
	struct device *dev;
	struct snd_soc_dai_driver *driver;
	unsigned int stream_active[2];
	struct snd_soc_dapm_widget *playback_widget;
	struct snd_soc_dapm_widget *capture_widget;
	void *playback_dma_data;
	void *capture_dma_data;
	unsigned int rate;
	unsigned int channels;
	unsigned int sample_bits;
	struct snd_soc_component *component;
	unsigned int tx_mask;
	unsigned int rx_mask;
	struct list_head list;
	struct snd_pcm_substream *mark_startup;
	struct snd_pcm_substream *mark_hw_params;
	struct snd_pcm_substream *mark_trigger;
	struct snd_compr_stream *mark_compr_startup;
	unsigned int probed: 1;
};

enum snd_soc_dpcm_trigger {
	SND_SOC_DPCM_TRIGGER_PRE = 0,
	SND_SOC_DPCM_TRIGGER_POST = 1,
	SND_SOC_DPCM_TRIGGER_BESPOKE = 2,
};

struct snd_soc_dai_link_component;

struct snd_soc_ops;

struct snd_soc_compr_ops;

struct snd_soc_dai_link {
	const char *name;
	const char *stream_name;
	struct snd_soc_dai_link_component *cpus;
	unsigned int num_cpus;
	struct snd_soc_dai_link_component *codecs;
	unsigned int num_codecs;
	struct snd_soc_dai_link_component *platforms;
	unsigned int num_platforms;
	int id;
	const struct snd_soc_pcm_stream *params;
	unsigned int num_params;
	unsigned int dai_fmt;
	enum snd_soc_dpcm_trigger trigger[2];
	int (*init)(struct snd_soc_pcm_runtime *);
	void (*exit)(struct snd_soc_pcm_runtime *);
	int (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *, struct snd_pcm_hw_params *);
	const struct snd_soc_ops *ops;
	const struct snd_soc_compr_ops *compr_ops;
	unsigned int nonatomic: 1;
	unsigned int playback_only: 1;
	unsigned int capture_only: 1;
	unsigned int ignore_suspend: 1;
	unsigned int symmetric_rate: 1;
	unsigned int symmetric_channels: 1;
	unsigned int symmetric_sample_bits: 1;
	unsigned int no_pcm: 1;
	unsigned int dynamic: 1;
	unsigned int dpcm_capture: 1;
	unsigned int dpcm_playback: 1;
	unsigned int dpcm_merged_format: 1;
	unsigned int dpcm_merged_chan: 1;
	unsigned int dpcm_merged_rate: 1;
	unsigned int ignore_pmdown_time: 1;
	unsigned int ignore: 1;
	unsigned int stop_dma_first: 1;
};

struct snd_soc_dapm_update {
	struct snd_kcontrol *kcontrol;
	int reg;
	int mask;
	int val;
	int reg2;
	int mask2;
	int val2;
	bool has_second_set;
};

enum snd_soc_pcm_subclass {
	SND_SOC_PCM_CLASS_PCM = 0,
	SND_SOC_PCM_CLASS_BE = 1,
};

struct snd_soc_dapm_stats {
	int power_checks;
	int path_checks;
	int neighbour_checks;
};

struct snd_soc_codec_conf;

struct snd_soc_aux_dev;

struct snd_soc_card {
	const char *name;
	const char *long_name;
	const char *driver_name;
	const char *components;
	char topology_shortname[32];
	struct device *dev;
	struct snd_card *snd_card;
	struct module *owner;
	struct mutex mutex;
	struct mutex dapm_mutex;
	struct mutex pcm_mutex;
	enum snd_soc_pcm_subclass pcm_subclass;
	int (*probe)(struct snd_soc_card *);
	int (*late_probe)(struct snd_soc_card *);
	void (*fixup_controls)(struct snd_soc_card *);
	int (*remove)(struct snd_soc_card *);
	int (*suspend_pre)(struct snd_soc_card *);
	int (*suspend_post)(struct snd_soc_card *);
	int (*resume_pre)(struct snd_soc_card *);
	int (*resume_post)(struct snd_soc_card *);
	int (*set_bias_level)(struct snd_soc_card *, struct snd_soc_dapm_context *, enum snd_soc_bias_level);
	int (*set_bias_level_post)(struct snd_soc_card *, struct snd_soc_dapm_context *, enum snd_soc_bias_level);
	int (*add_dai_link)(struct snd_soc_card *, struct snd_soc_dai_link *);
	void (*remove_dai_link)(struct snd_soc_card *, struct snd_soc_dai_link *);
	long int pmdown_time;
	struct snd_soc_dai_link *dai_link;
	int num_links;
	struct list_head rtd_list;
	int num_rtd;
	struct snd_soc_codec_conf *codec_conf;
	int num_configs;
	struct snd_soc_aux_dev *aux_dev;
	int num_aux_devs;
	struct list_head aux_comp_list;
	const struct snd_kcontrol_new *controls;
	int num_controls;
	const struct snd_soc_dapm_widget *dapm_widgets;
	int num_dapm_widgets;
	const struct snd_soc_dapm_route *dapm_routes;
	int num_dapm_routes;
	const struct snd_soc_dapm_widget *of_dapm_widgets;
	int num_of_dapm_widgets;
	const struct snd_soc_dapm_route *of_dapm_routes;
	int num_of_dapm_routes;
	struct list_head component_dev_list;
	struct list_head list;
	struct list_head widgets;
	struct list_head paths;
	struct list_head dapm_list;
	struct list_head dapm_dirty;
	struct list_head dobj_list;
	struct snd_soc_dapm_context dapm;
	struct snd_soc_dapm_stats dapm_stats;
	struct snd_soc_dapm_update *update;
	struct dentry *debugfs_card_root;
	struct work_struct deferred_resume_work;
	u32 pop_time;
	unsigned int instantiated: 1;
	unsigned int topology_shortname_created: 1;
	unsigned int fully_routed: 1;
	unsigned int disable_route_checks: 1;
	unsigned int probed: 1;
	unsigned int component_chaining: 1;
	void *drvdata;
};

enum snd_soc_dpcm_update {
	SND_SOC_DPCM_UPDATE_NO = 0,
	SND_SOC_DPCM_UPDATE_BE = 1,
	SND_SOC_DPCM_UPDATE_FE = 2,
};

enum snd_soc_dpcm_state {
	SND_SOC_DPCM_STATE_NEW = 0,
	SND_SOC_DPCM_STATE_OPEN = 1,
	SND_SOC_DPCM_STATE_HW_PARAMS = 2,
	SND_SOC_DPCM_STATE_PREPARE = 3,
	SND_SOC_DPCM_STATE_START = 4,
	SND_SOC_DPCM_STATE_STOP = 5,
	SND_SOC_DPCM_STATE_PAUSED = 6,
	SND_SOC_DPCM_STATE_SUSPEND = 7,
	SND_SOC_DPCM_STATE_HW_FREE = 8,
	SND_SOC_DPCM_STATE_CLOSE = 9,
};

struct snd_soc_dpcm_runtime {
	struct list_head be_clients;
	struct list_head fe_clients;
	int users;
	struct snd_pcm_runtime *runtime;
	struct snd_pcm_hw_params hw_params;
	enum snd_soc_dpcm_update runtime_update;
	enum snd_soc_dpcm_state state;
	int trigger_pending;
	int be_start;
	int be_pause;
	bool fe_pause;
};

struct snd_soc_pcm_runtime {
	struct device *dev;
	struct snd_soc_card *card;
	struct snd_soc_dai_link *dai_link;
	struct snd_pcm_ops ops;
	unsigned int params_select;
	struct snd_soc_dpcm_runtime dpcm[2];
	struct snd_soc_dapm_widget *c2c_widget[2];
	long int pmdown_time;
	struct snd_pcm *pcm;
	struct snd_compr *compr;
	struct snd_soc_dai **dais;
	struct delayed_work delayed_work;
	void (*close_delayed_work_func)(struct snd_soc_pcm_runtime *);
	struct dentry *debugfs_dpcm_root;
	unsigned int num;
	struct list_head list;
	struct snd_pcm_substream *mark_startup;
	struct snd_pcm_substream *mark_hw_params;
	struct snd_pcm_substream *mark_trigger;
	struct snd_compr_stream *mark_compr_startup;
	unsigned int pop_wait: 1;
	unsigned int fe_compr: 1;
	int num_components;
	struct snd_soc_component *components[0];
};

struct snd_soc_ops {
	int (*startup)(struct snd_pcm_substream *);
	void (*shutdown)(struct snd_pcm_substream *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_pcm_substream *);
	int (*prepare)(struct snd_pcm_substream *);
	int (*trigger)(struct snd_pcm_substream *, int);
};

struct snd_soc_compr_ops {
	int (*startup)(struct snd_compr_stream *);
	void (*shutdown)(struct snd_compr_stream *);
	int (*set_params)(struct snd_compr_stream *);
	int (*trigger)(struct snd_compr_stream *);
};

struct snd_soc_dai_link_component {
	const char *name;
	struct device_node *of_node;
	const char *dai_name;
};

struct snd_soc_codec_conf {
	struct snd_soc_dai_link_component dlc;
	const char *name_prefix;
};

struct snd_soc_aux_dev {
	struct snd_soc_dai_link_component dlc;
	int (*init)(struct snd_soc_component *);
};

struct snd_soc_dai_ops {
	int (*set_sysclk)(struct snd_soc_dai *, int, unsigned int, int);
	int (*set_pll)(struct snd_soc_dai *, int, int, unsigned int, unsigned int);
	int (*set_clkdiv)(struct snd_soc_dai *, int, int);
	int (*set_bclk_ratio)(struct snd_soc_dai *, unsigned int);
	int (*set_fmt)(struct snd_soc_dai *, unsigned int);
	int (*xlate_tdm_slot_mask)(unsigned int, unsigned int *, unsigned int *);
	int (*set_tdm_slot)(struct snd_soc_dai *, unsigned int, unsigned int, int, int);
	int (*set_channel_map)(struct snd_soc_dai *, unsigned int, unsigned int *, unsigned int, unsigned int *);
	int (*get_channel_map)(struct snd_soc_dai *, unsigned int *, unsigned int *, unsigned int *, unsigned int *);
	int (*set_tristate)(struct snd_soc_dai *, int);
	int (*set_stream)(struct snd_soc_dai *, void *, int);
	void * (*get_stream)(struct snd_soc_dai *, int);
	int (*mute_stream)(struct snd_soc_dai *, int, int);
	int (*startup)(struct snd_pcm_substream *, struct snd_soc_dai *);
	void (*shutdown)(struct snd_pcm_substream *, struct snd_soc_dai *);
	int (*hw_params)(struct snd_pcm_substream *, struct snd_pcm_hw_params *, struct snd_soc_dai *);
	int (*hw_free)(struct snd_pcm_substream *, struct snd_soc_dai *);
	int (*prepare)(struct snd_pcm_substream *, struct snd_soc_dai *);
	int (*trigger)(struct snd_pcm_substream *, int, struct snd_soc_dai *);
	int (*bespoke_trigger)(struct snd_pcm_substream *, int, struct snd_soc_dai *);
	snd_pcm_sframes_t (*delay)(struct snd_pcm_substream *, struct snd_soc_dai *);
	u64 *auto_selectable_formats;
	int num_auto_selectable_formats;
	unsigned int no_capture_mute: 1;
};

struct snd_soc_cdai_ops {
	int (*startup)(struct snd_compr_stream *, struct snd_soc_dai *);
	int (*shutdown)(struct snd_compr_stream *, struct snd_soc_dai *);
	int (*set_params)(struct snd_compr_stream *, struct snd_compr_params *, struct snd_soc_dai *);
	int (*get_params)(struct snd_compr_stream *, struct snd_codec *, struct snd_soc_dai *);
	int (*set_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *, struct snd_soc_dai *);
	int (*get_metadata)(struct snd_compr_stream *, struct snd_compr_metadata *, struct snd_soc_dai *);
	int (*trigger)(struct snd_compr_stream *, int, struct snd_soc_dai *);
	int (*pointer)(struct snd_compr_stream *, struct snd_compr_tstamp *, struct snd_soc_dai *);
	int (*ack)(struct snd_compr_stream *, size_t, struct snd_soc_dai *);
};

struct snd_compress_ops {
	int (*open)(struct snd_soc_component *, struct snd_compr_stream *);
	int (*free)(struct snd_soc_component *, struct snd_compr_stream *);
	int (*set_params)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_params *);
	int (*get_params)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_codec *);
	int (*set_metadata)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*get_metadata)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_metadata *);
	int (*trigger)(struct snd_soc_component *, struct snd_compr_stream *, int);
	int (*pointer)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_tstamp *);
	int (*copy)(struct snd_soc_component *, struct snd_compr_stream *, char *, size_t);
	int (*mmap)(struct snd_soc_component *, struct snd_compr_stream *, struct vm_area_struct *);
	int (*ack)(struct snd_soc_component *, struct snd_compr_stream *, size_t);
	int (*get_caps)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_caps *);
	int (*get_codec_caps)(struct snd_soc_component *, struct snd_compr_stream *, struct snd_compr_codec_caps *);
};

struct snd_soc_jack;

struct snd_soc_component_driver {
	const char *name;
	const struct snd_kcontrol_new *controls;
	unsigned int num_controls;
	const struct snd_soc_dapm_widget *dapm_widgets;
	unsigned int num_dapm_widgets;
	const struct snd_soc_dapm_route *dapm_routes;
	unsigned int num_dapm_routes;
	int (*probe)(struct snd_soc_component *);
	void (*remove)(struct snd_soc_component *);
	int (*suspend)(struct snd_soc_component *);
	int (*resume)(struct snd_soc_component *);
	unsigned int (*read)(struct snd_soc_component *, unsigned int);
	int (*write)(struct snd_soc_component *, unsigned int, unsigned int);
	int (*pcm_construct)(struct snd_soc_component *, struct snd_soc_pcm_runtime *);
	void (*pcm_destruct)(struct snd_soc_component *, struct snd_pcm *);
	int (*set_sysclk)(struct snd_soc_component *, int, int, unsigned int, int);
	int (*set_pll)(struct snd_soc_component *, int, int, unsigned int, unsigned int);
	int (*set_jack)(struct snd_soc_component *, struct snd_soc_jack *, void *);
	int (*of_xlate_dai_name)(struct snd_soc_component *, const struct of_phandle_args *, const char **);
	int (*of_xlate_dai_id)(struct snd_soc_component *, struct device_node *);
	void (*seq_notifier)(struct snd_soc_component *, enum snd_soc_dapm_type, int);
	int (*stream_event)(struct snd_soc_component *, int);
	int (*set_bias_level)(struct snd_soc_component *, enum snd_soc_bias_level);
	int (*open)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*close)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*ioctl)(struct snd_soc_component *, struct snd_pcm_substream *, unsigned int, void *);
	int (*hw_params)(struct snd_soc_component *, struct snd_pcm_substream *, struct snd_pcm_hw_params *);
	int (*hw_free)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*prepare)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*trigger)(struct snd_soc_component *, struct snd_pcm_substream *, int);
	int (*sync_stop)(struct snd_soc_component *, struct snd_pcm_substream *);
	snd_pcm_uframes_t (*pointer)(struct snd_soc_component *, struct snd_pcm_substream *);
	int (*get_time_info)(struct snd_soc_component *, struct snd_pcm_substream *, struct timespec64 *, struct timespec64 *, struct snd_pcm_audio_tstamp_config *, struct snd_pcm_audio_tstamp_report *);
	int (*copy_user)(struct snd_soc_component *, struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);
	struct page * (*page)(struct snd_soc_component *, struct snd_pcm_substream *, long unsigned int);
	int (*mmap)(struct snd_soc_component *, struct snd_pcm_substream *, struct vm_area_struct *);
	int (*ack)(struct snd_soc_component *, struct snd_pcm_substream *);
	snd_pcm_sframes_t (*delay)(struct snd_soc_component *, struct snd_pcm_substream *);
	const struct snd_compress_ops *compress_ops;
	int probe_order;
	int remove_order;
	unsigned int module_get_upon_open: 1;
	unsigned int idle_bias_on: 1;
	unsigned int suspend_bias_off: 1;
	unsigned int use_pmdown_time: 1;
	unsigned int endianness: 1;
	unsigned int legacy_dai_naming: 1;
	const char *ignore_machine;
	const char *topology_name_prefix;
	int (*be_hw_params_fixup)(struct snd_soc_pcm_runtime *, struct snd_pcm_hw_params *);
	bool use_dai_pcm_id;
	int be_pcm_base;
	const char *debugfs_prefix;
};

struct snd_jack;

struct snd_soc_jack {
	struct mutex mutex;
	struct snd_jack *jack;
	struct snd_soc_card *card;
	struct list_head pins;
	int status;
	struct blocking_notifier_head notifier;
	struct list_head jack_zones;
};

struct hdmi_codec_daifmt {
	enum {
		HDMI_I2S = 0,
		HDMI_RIGHT_J = 1,
		HDMI_LEFT_J = 2,
		HDMI_DSP_A = 3,
		HDMI_DSP_B = 4,
		HDMI_AC97 = 5,
		HDMI_SPDIF = 6,
	} fmt;
	unsigned int bit_clk_inv: 1;
	unsigned int frame_clk_inv: 1;
	unsigned int bit_clk_provider: 1;
	unsigned int frame_clk_provider: 1;
	snd_pcm_format_t bit_fmt;
};

struct hdmi_codec_params {
	struct hdmi_audio_infoframe cea;
	struct snd_aes_iec958 iec;
	int sample_rate;
	int sample_width;
	int channels;
};

typedef void (*hdmi_codec_plugged_cb)(struct device *, bool);

struct hdmi_codec_ops {
	int (*audio_startup)(struct device *, void *);
	int (*hw_params)(struct device *, void *, struct hdmi_codec_daifmt *, struct hdmi_codec_params *);
	int (*prepare)(struct device *, void *, struct hdmi_codec_daifmt *, struct hdmi_codec_params *);
	void (*audio_shutdown)(struct device *, void *);
	int (*mute_stream)(struct device *, void *, bool, int);
	int (*get_eld)(struct device *, void *, uint8_t *, size_t);
	int (*get_dai_id)(struct snd_soc_component *, struct device_node *);
	int (*hook_plugged_cb)(struct device *, void *, hdmi_codec_plugged_cb, struct device *);
	unsigned int no_capture_mute: 1;
};

struct hdmi_codec_pdata {
	const struct hdmi_codec_ops *ops;
	uint i2s: 1;
	uint spdif: 1;
	int max_i2s_channels;
	void *data;
};

typedef void detailed_cb(struct detailed_timing *, void *);

enum v4l2_preemphasis {
	V4L2_PREEMPHASIS_DISABLED = 0,
	V4L2_PREEMPHASIS_50_uS = 1,
	V4L2_PREEMPHASIS_75_uS = 2,
};

enum {
	HDMI_IH_FC_INT2_OVERFLOW_MASK = 3,
	HDMI_IH_FC_INT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_IH_FC_INT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_IH_FC_STAT2_OVERFLOW_MASK = 3,
	HDMI_IH_FC_STAT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_IH_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_IH_PHY_STAT0_RX_SENSE3 = 32,
	HDMI_IH_PHY_STAT0_RX_SENSE2 = 16,
	HDMI_IH_PHY_STAT0_RX_SENSE1 = 8,
	HDMI_IH_PHY_STAT0_RX_SENSE0 = 4,
	HDMI_IH_PHY_STAT0_TX_PHY_LOCK = 2,
	HDMI_IH_PHY_STAT0_HPD = 1,
	HDMI_IH_CEC_STAT0_WAKEUP = 64,
	HDMI_IH_CEC_STAT0_ERROR_FOLL = 32,
	HDMI_IH_CEC_STAT0_ERROR_INIT = 16,
	HDMI_IH_CEC_STAT0_ARB_LOST = 8,
	HDMI_IH_CEC_STAT0_NACK = 4,
	HDMI_IH_CEC_STAT0_EOM = 2,
	HDMI_IH_CEC_STAT0_DONE = 1,
	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYDONE = 2,
	HDMI_IH_MUTE_I2CMPHY_STAT0_I2CMPHYERROR = 1,
	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE3 = 32,
	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE2 = 16,
	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE1 = 8,
	HDMI_IH_MUTE_PHY_STAT0_RX_SENSE0 = 4,
	HDMI_IH_MUTE_PHY_STAT0_TX_PHY_LOCK = 2,
	HDMI_IH_MUTE_PHY_STAT0_HPD = 1,
	HDMI_IH_AHBDMAAUD_STAT0_ERROR = 32,
	HDMI_IH_AHBDMAAUD_STAT0_LOST = 16,
	HDMI_IH_AHBDMAAUD_STAT0_RETRY = 8,
	HDMI_IH_AHBDMAAUD_STAT0_DONE = 4,
	HDMI_IH_AHBDMAAUD_STAT0_BUFFFULL = 2,
	HDMI_IH_AHBDMAAUD_STAT0_BUFFEMPTY = 1,
	HDMI_IH_MUTE_FC_STAT2_OVERFLOW_MASK = 3,
	HDMI_IH_MUTE_FC_STAT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_IH_MUTE_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_ERROR = 32,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_LOST = 16,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_RETRY = 8,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_DONE = 4,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFFULL = 2,
	HDMI_IH_MUTE_AHBDMAAUD_STAT0_BUFFEMPTY = 1,
	HDMI_IH_MUTE_MUTE_WAKEUP_INTERRUPT = 2,
	HDMI_IH_MUTE_MUTE_ALL_INTERRUPT = 1,
	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_MASK = 128,
	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_ENABLE = 128,
	HDMI_TX_INVID0_INTERNAL_DE_GENERATOR_DISABLE = 0,
	HDMI_TX_INVID0_VIDEO_MAPPING_MASK = 31,
	HDMI_TX_INVID0_VIDEO_MAPPING_OFFSET = 0,
	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_MASK = 4,
	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_ENABLE = 4,
	HDMI_TX_INSTUFFING_BDBDATA_STUFFING_DISABLE = 0,
	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_MASK = 2,
	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_ENABLE = 2,
	HDMI_TX_INSTUFFING_RCRDATA_STUFFING_DISABLE = 0,
	HDMI_TX_INSTUFFING_GYDATA_STUFFING_MASK = 1,
	HDMI_TX_INSTUFFING_GYDATA_STUFFING_ENABLE = 1,
	HDMI_TX_INSTUFFING_GYDATA_STUFFING_DISABLE = 0,
	HDMI_VP_PR_CD_COLOR_DEPTH_MASK = 240,
	HDMI_VP_PR_CD_COLOR_DEPTH_OFFSET = 4,
	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_MASK = 15,
	HDMI_VP_PR_CD_DESIRED_PR_FACTOR_OFFSET = 0,
	HDMI_VP_STUFF_IDEFAULT_PHASE_MASK = 32,
	HDMI_VP_STUFF_IDEFAULT_PHASE_OFFSET = 5,
	HDMI_VP_STUFF_IFIX_PP_TO_LAST_MASK = 16,
	HDMI_VP_STUFF_IFIX_PP_TO_LAST_OFFSET = 4,
	HDMI_VP_STUFF_ICX_GOTO_P0_ST_MASK = 8,
	HDMI_VP_STUFF_ICX_GOTO_P0_ST_OFFSET = 3,
	HDMI_VP_STUFF_YCC422_STUFFING_MASK = 4,
	HDMI_VP_STUFF_YCC422_STUFFING_STUFFING_MODE = 4,
	HDMI_VP_STUFF_YCC422_STUFFING_DIRECT_MODE = 0,
	HDMI_VP_STUFF_PP_STUFFING_MASK = 2,
	HDMI_VP_STUFF_PP_STUFFING_STUFFING_MODE = 2,
	HDMI_VP_STUFF_PP_STUFFING_DIRECT_MODE = 0,
	HDMI_VP_STUFF_PR_STUFFING_MASK = 1,
	HDMI_VP_STUFF_PR_STUFFING_STUFFING_MODE = 1,
	HDMI_VP_STUFF_PR_STUFFING_DIRECT_MODE = 0,
	HDMI_VP_CONF_BYPASS_EN_MASK = 64,
	HDMI_VP_CONF_BYPASS_EN_ENABLE = 64,
	HDMI_VP_CONF_BYPASS_EN_DISABLE = 0,
	HDMI_VP_CONF_PP_EN_ENMASK = 32,
	HDMI_VP_CONF_PP_EN_ENABLE = 32,
	HDMI_VP_CONF_PP_EN_DISABLE = 0,
	HDMI_VP_CONF_PR_EN_MASK = 16,
	HDMI_VP_CONF_PR_EN_ENABLE = 16,
	HDMI_VP_CONF_PR_EN_DISABLE = 0,
	HDMI_VP_CONF_YCC422_EN_MASK = 8,
	HDMI_VP_CONF_YCC422_EN_ENABLE = 8,
	HDMI_VP_CONF_YCC422_EN_DISABLE = 0,
	HDMI_VP_CONF_BYPASS_SELECT_MASK = 4,
	HDMI_VP_CONF_BYPASS_SELECT_VID_PACKETIZER = 4,
	HDMI_VP_CONF_BYPASS_SELECT_PIX_REPEATER = 0,
	HDMI_VP_CONF_OUTPUT_SELECTOR_MASK = 3,
	HDMI_VP_CONF_OUTPUT_SELECTOR_BYPASS = 3,
	HDMI_VP_CONF_OUTPUT_SELECTOR_YCC422 = 1,
	HDMI_VP_CONF_OUTPUT_SELECTOR_PP = 0,
	HDMI_VP_REMAP_MASK = 3,
	HDMI_VP_REMAP_YCC422_24bit = 2,
	HDMI_VP_REMAP_YCC422_20bit = 1,
	HDMI_VP_REMAP_YCC422_16bit = 0,
	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_MASK = 128,
	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_ACTIVE = 128,
	HDMI_FC_INVIDCONF_HDCP_KEEPOUT_INACTIVE = 0,
	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_MASK = 64,
	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_HIGH = 64,
	HDMI_FC_INVIDCONF_VSYNC_IN_POLARITY_ACTIVE_LOW = 0,
	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_MASK = 32,
	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_HIGH = 32,
	HDMI_FC_INVIDCONF_HSYNC_IN_POLARITY_ACTIVE_LOW = 0,
	HDMI_FC_INVIDCONF_DE_IN_POLARITY_MASK = 16,
	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_HIGH = 16,
	HDMI_FC_INVIDCONF_DE_IN_POLARITY_ACTIVE_LOW = 0,
	HDMI_FC_INVIDCONF_DVI_MODEZ_MASK = 8,
	HDMI_FC_INVIDCONF_DVI_MODEZ_HDMI_MODE = 8,
	HDMI_FC_INVIDCONF_DVI_MODEZ_DVI_MODE = 0,
	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_MASK = 2,
	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_HIGH = 2,
	HDMI_FC_INVIDCONF_R_V_BLANK_IN_OSC_ACTIVE_LOW = 0,
	HDMI_FC_INVIDCONF_IN_I_P_MASK = 1,
	HDMI_FC_INVIDCONF_IN_I_P_INTERLACED = 1,
	HDMI_FC_INVIDCONF_IN_I_P_PROGRESSIVE = 0,
	HDMI_FC_AUDICONF0_CC_OFFSET = 4,
	HDMI_FC_AUDICONF0_CC_MASK = 112,
	HDMI_FC_AUDICONF0_CT_OFFSET = 0,
	HDMI_FC_AUDICONF0_CT_MASK = 15,
	HDMI_FC_AUDICONF1_SS_OFFSET = 3,
	HDMI_FC_AUDICONF1_SS_MASK = 24,
	HDMI_FC_AUDICONF1_SF_OFFSET = 0,
	HDMI_FC_AUDICONF1_SF_MASK = 7,
	HDMI_FC_AUDICONF3_LFEPBL_OFFSET = 5,
	HDMI_FC_AUDICONF3_LFEPBL_MASK = 96,
	HDMI_FC_AUDICONF3_DM_INH_OFFSET = 4,
	HDMI_FC_AUDICONF3_DM_INH_MASK = 16,
	HDMI_FC_AUDICONF3_LSV_OFFSET = 0,
	HDMI_FC_AUDICONF3_LSV_MASK = 15,
	HDMI_FC_AUDSCHNLS0_CGMSA_OFFSET = 4,
	HDMI_FC_AUDSCHNLS0_CGMSA_MASK = 48,
	HDMI_FC_AUDSCHNLS0_COPYRIGHT_OFFSET = 0,
	HDMI_FC_AUDSCHNLS0_COPYRIGHT_MASK = 1,
	HDMI_FC_AUDSCHNLS3_OIEC_CH0_OFFSET = 0,
	HDMI_FC_AUDSCHNLS3_OIEC_CH0_MASK = 15,
	HDMI_FC_AUDSCHNLS3_OIEC_CH1_OFFSET = 4,
	HDMI_FC_AUDSCHNLS3_OIEC_CH1_MASK = 240,
	HDMI_FC_AUDSCHNLS4_OIEC_CH2_OFFSET = 0,
	HDMI_FC_AUDSCHNLS4_OIEC_CH2_MASK = 15,
	HDMI_FC_AUDSCHNLS4_OIEC_CH3_OFFSET = 4,
	HDMI_FC_AUDSCHNLS4_OIEC_CH3_MASK = 240,
	HDMI_FC_AUDSCHNLS5_OIEC_CH0_OFFSET = 0,
	HDMI_FC_AUDSCHNLS5_OIEC_CH0_MASK = 15,
	HDMI_FC_AUDSCHNLS5_OIEC_CH1_OFFSET = 4,
	HDMI_FC_AUDSCHNLS5_OIEC_CH1_MASK = 240,
	HDMI_FC_AUDSCHNLS6_OIEC_CH2_OFFSET = 0,
	HDMI_FC_AUDSCHNLS6_OIEC_CH2_MASK = 15,
	HDMI_FC_AUDSCHNLS6_OIEC_CH3_OFFSET = 4,
	HDMI_FC_AUDSCHNLS6_OIEC_CH3_MASK = 240,
	HDMI_FC_AUDSCHNLS7_ACCURACY_OFFSET = 4,
	HDMI_FC_AUDSCHNLS7_ACCURACY_MASK = 48,
	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_MASK = 240,
	HDMI_FC_AUDSCHNLS8_ORIGSAMPFREQ_OFFSET = 4,
	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_MASK = 15,
	HDMI_FC_AUDSCHNLS8_WORDLEGNTH_OFFSET = 0,
	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_MASK = 240,
	HDMI_FC_AUDSCONF_AUD_PACKET_SAMPFIT_OFFSET = 4,
	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_MASK = 1,
	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_OFFSET = 0,
	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT1 = 1,
	HDMI_FC_AUDSCONF_AUD_PACKET_LAYOUT_LAYOUT0 = 0,
	HDMI_FC_STAT2_OVERFLOW_MASK = 3,
	HDMI_FC_STAT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_FC_STAT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_FC_INT2_OVERFLOW_MASK = 3,
	HDMI_FC_INT2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_FC_INT2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_FC_MASK2_OVERFLOW_MASK = 3,
	HDMI_FC_MASK2_LOW_PRIORITY_OVERFLOW = 2,
	HDMI_FC_MASK2_HIGH_PRIORITY_OVERFLOW = 1,
	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_MASK = 240,
	HDMI_FC_PRCONF_INCOMING_PR_FACTOR_OFFSET = 4,
	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_MASK = 15,
	HDMI_FC_PRCONF_OUTPUT_PR_FACTOR_OFFSET = 0,
	HDMI_FC_AVICONF0_PIX_FMT_MASK = 3,
	HDMI_FC_AVICONF0_PIX_FMT_RGB = 0,
	HDMI_FC_AVICONF0_PIX_FMT_YCBCR422 = 1,
	HDMI_FC_AVICONF0_PIX_FMT_YCBCR444 = 2,
	HDMI_FC_AVICONF0_ACTIVE_FMT_MASK = 64,
	HDMI_FC_AVICONF0_ACTIVE_FMT_INFO_PRESENT = 64,
	HDMI_FC_AVICONF0_ACTIVE_FMT_NO_INFO = 0,
	HDMI_FC_AVICONF0_BAR_DATA_MASK = 12,
	HDMI_FC_AVICONF0_BAR_DATA_NO_DATA = 0,
	HDMI_FC_AVICONF0_BAR_DATA_VERT_BAR = 4,
	HDMI_FC_AVICONF0_BAR_DATA_HORIZ_BAR = 8,
	HDMI_FC_AVICONF0_BAR_DATA_VERT_HORIZ_BAR = 12,
	HDMI_FC_AVICONF0_SCAN_INFO_MASK = 48,
	HDMI_FC_AVICONF0_SCAN_INFO_OVERSCAN = 16,
	HDMI_FC_AVICONF0_SCAN_INFO_UNDERSCAN = 32,
	HDMI_FC_AVICONF0_SCAN_INFO_NODATA = 0,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_MASK = 15,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_USE_CODED = 8,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_4_3 = 9,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_16_9 = 10,
	HDMI_FC_AVICONF1_ACTIVE_ASPECT_RATIO_14_9 = 11,
	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_MASK = 48,
	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_NO_DATA = 0,
	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_4_3 = 16,
	HDMI_FC_AVICONF1_CODED_ASPECT_RATIO_16_9 = 32,
	HDMI_FC_AVICONF1_COLORIMETRY_MASK = 192,
	HDMI_FC_AVICONF1_COLORIMETRY_NO_DATA = 0,
	HDMI_FC_AVICONF1_COLORIMETRY_SMPTE = 64,
	HDMI_FC_AVICONF1_COLORIMETRY_ITUR = 128,
	HDMI_FC_AVICONF1_COLORIMETRY_EXTENDED_INFO = 192,
	HDMI_FC_AVICONF2_SCALING_MASK = 3,
	HDMI_FC_AVICONF2_SCALING_NONE = 0,
	HDMI_FC_AVICONF2_SCALING_HORIZ = 1,
	HDMI_FC_AVICONF2_SCALING_VERT = 2,
	HDMI_FC_AVICONF2_SCALING_HORIZ_VERT = 3,
	HDMI_FC_AVICONF2_RGB_QUANT_MASK = 12,
	HDMI_FC_AVICONF2_RGB_QUANT_DEFAULT = 0,
	HDMI_FC_AVICONF2_RGB_QUANT_LIMITED_RANGE = 4,
	HDMI_FC_AVICONF2_RGB_QUANT_FULL_RANGE = 8,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_MASK = 112,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC601 = 0,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_XVYCC709 = 16,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_SYCC601 = 32,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_YCC601 = 48,
	HDMI_FC_AVICONF2_EXT_COLORIMETRY_ADOBE_RGB = 64,
	HDMI_FC_AVICONF2_IT_CONTENT_MASK = 128,
	HDMI_FC_AVICONF2_IT_CONTENT_NO_DATA = 0,
	HDMI_FC_AVICONF2_IT_CONTENT_VALID = 128,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_MASK = 3,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GRAPHICS = 0,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_PHOTO = 1,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_CINEMA = 2,
	HDMI_FC_AVICONF3_IT_CONTENT_TYPE_GAME = 3,
	HDMI_FC_AVICONF3_QUANT_RANGE_MASK = 12,
	HDMI_FC_AVICONF3_QUANT_RANGE_LIMITED = 0,
	HDMI_FC_AVICONF3_QUANT_RANGE_FULL = 4,
	HDMI_FC_DBGFORCE_FORCEAUDIO = 16,
	HDMI_FC_DBGFORCE_FORCEVIDEO = 1,
	HDMI_PHY_CONF0_PDZ_MASK = 128,
	HDMI_PHY_CONF0_PDZ_OFFSET = 7,
	HDMI_PHY_CONF0_ENTMDS_MASK = 64,
	HDMI_PHY_CONF0_ENTMDS_OFFSET = 6,
	HDMI_PHY_CONF0_SPARECTRL = 32,
	HDMI_PHY_CONF0_GEN2_PDDQ_MASK = 16,
	HDMI_PHY_CONF0_GEN2_PDDQ_OFFSET = 4,
	HDMI_PHY_CONF0_GEN2_TXPWRON_MASK = 8,
	HDMI_PHY_CONF0_GEN2_TXPWRON_OFFSET = 3,
	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_MASK = 4,
	HDMI_PHY_CONF0_GEN2_ENHPDRXSENSE_OFFSET = 2,
	HDMI_PHY_CONF0_SELDATAENPOL_MASK = 2,
	HDMI_PHY_CONF0_SELDATAENPOL_OFFSET = 1,
	HDMI_PHY_CONF0_SELDIPIF_MASK = 1,
	HDMI_PHY_CONF0_SELDIPIF_OFFSET = 0,
	HDMI_PHY_TST0_TSTCLR_MASK = 32,
	HDMI_PHY_TST0_TSTCLR_OFFSET = 5,
	HDMI_PHY_TST0_TSTEN_MASK = 16,
	HDMI_PHY_TST0_TSTEN_OFFSET = 4,
	HDMI_PHY_TST0_TSTCLK_MASK = 1,
	HDMI_PHY_TST0_TSTCLK_OFFSET = 0,
	HDMI_PHY_RX_SENSE3 = 128,
	HDMI_PHY_RX_SENSE2 = 64,
	HDMI_PHY_RX_SENSE1 = 32,
	HDMI_PHY_RX_SENSE0 = 16,
	HDMI_PHY_HPD = 2,
	HDMI_PHY_TX_PHY_LOCK = 1,
	HDMI_PHY_I2CM_SLAVE_ADDR_PHY_GEN2 = 105,
	HDMI_PHY_I2CM_SLAVE_ADDR_HEAC_PHY = 73,
	HDMI_PHY_I2CM_OPERATION_ADDR_WRITE = 16,
	HDMI_PHY_I2CM_OPERATION_ADDR_READ = 1,
	HDMI_PHY_I2CM_INT_ADDR_DONE_POL = 8,
	HDMI_PHY_I2CM_INT_ADDR_DONE_MASK = 4,
	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_POL = 128,
	HDMI_PHY_I2CM_CTLINT_ADDR_NAC_MASK = 64,
	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_POL = 8,
	HDMI_PHY_I2CM_CTLINT_ADDR_ARBITRATION_MASK = 4,
	HDMI_AUD_CTS3_N_SHIFT_OFFSET = 5,
	HDMI_AUD_CTS3_N_SHIFT_MASK = 224,
	HDMI_AUD_CTS3_N_SHIFT_1 = 0,
	HDMI_AUD_CTS3_N_SHIFT_16 = 32,
	HDMI_AUD_CTS3_N_SHIFT_32 = 64,
	HDMI_AUD_CTS3_N_SHIFT_64 = 96,
	HDMI_AUD_CTS3_N_SHIFT_128 = 128,
	HDMI_AUD_CTS3_N_SHIFT_256 = 160,
	HDMI_AUD_CTS3_CTS_MANUAL = 16,
	HDMI_AUD_CTS3_AUDCTS19_16_MASK = 15,
	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_OFFSET = 7,
	HDMI_AHB_DMA_CONF0_SW_FIFO_RST_MASK = 128,
	HDMI_AHB_DMA_CONF0_HBR = 16,
	HDMI_AHB_DMA_CONF0_EN_HLOCK_OFFSET = 3,
	HDMI_AHB_DMA_CONF0_EN_HLOCK_MASK = 8,
	HDMI_AHB_DMA_CONF0_INCR_TYPE_OFFSET = 1,
	HDMI_AHB_DMA_CONF0_INCR_TYPE_MASK = 6,
	HDMI_AHB_DMA_CONF0_INCR4 = 0,
	HDMI_AHB_DMA_CONF0_INCR8 = 2,
	HDMI_AHB_DMA_CONF0_INCR16 = 4,
	HDMI_AHB_DMA_CONF0_BURST_MODE = 1,
	HDMI_AHB_DMA_START_START_OFFSET = 0,
	HDMI_AHB_DMA_START_START_MASK = 1,
	HDMI_AHB_DMA_STOP_STOP_OFFSET = 0,
	HDMI_AHB_DMA_STOP_STOP_MASK = 1,
	HDMI_AHB_DMA_DONE = 128,
	HDMI_AHB_DMA_RETRY_SPLIT = 64,
	HDMI_AHB_DMA_LOSTOWNERSHIP = 32,
	HDMI_AHB_DMA_ERROR = 16,
	HDMI_AHB_DMA_FIFO_THREMPTY = 4,
	HDMI_AHB_DMA_FIFO_FULL = 2,
	HDMI_AHB_DMA_FIFO_EMPTY = 1,
	HDMI_AHB_DMA_BUFFSTAT_FULL = 2,
	HDMI_AHB_DMA_BUFFSTAT_EMPTY = 1,
	HDMI_MC_CLKDIS_HDCPCLK_DISABLE = 64,
	HDMI_MC_CLKDIS_CECCLK_DISABLE = 32,
	HDMI_MC_CLKDIS_CSCCLK_DISABLE = 16,
	HDMI_MC_CLKDIS_AUDCLK_DISABLE = 8,
	HDMI_MC_CLKDIS_PREPCLK_DISABLE = 4,
	HDMI_MC_CLKDIS_TMDSCLK_DISABLE = 2,
	HDMI_MC_CLKDIS_PIXELCLK_DISABLE = 1,
	HDMI_MC_SWRSTZ_TMDSSWRST_REQ = 2,
	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_MASK = 1,
	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_IN_PATH = 1,
	HDMI_MC_FLOWCTRL_FEED_THROUGH_OFF_CSC_BYPASS = 0,
	HDMI_MC_PHYRSTZ_ASSERT = 0,
	HDMI_MC_PHYRSTZ_DEASSERT = 1,
	HDMI_MC_HEACPHY_RST_ASSERT = 1,
	HDMI_MC_HEACPHY_RST_DEASSERT = 0,
	HDMI_CSC_CFG_INTMODE_MASK = 48,
	HDMI_CSC_CFG_INTMODE_OFFSET = 4,
	HDMI_CSC_CFG_INTMODE_DISABLE = 0,
	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA1 = 16,
	HDMI_CSC_CFG_INTMODE_CHROMA_INT_FORMULA2 = 32,
	HDMI_CSC_CFG_DECMODE_MASK = 3,
	HDMI_CSC_CFG_DECMODE_OFFSET = 0,
	HDMI_CSC_CFG_DECMODE_DISABLE = 0,
	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA1 = 1,
	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA2 = 2,
	HDMI_CSC_CFG_DECMODE_CHROMA_INT_FORMULA3 = 3,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_MASK = 240,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_24BPP = 0,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_30BPP = 80,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_36BPP = 96,
	HDMI_CSC_SCALE_CSC_COLORDE_PTH_48BPP = 112,
	HDMI_CSC_SCALE_CSCSCALE_MASK = 3,
	HDMI_I2CM_OPERATION_WRITE = 16,
	HDMI_I2CM_OPERATION_READ_EXT = 2,
	HDMI_I2CM_OPERATION_READ = 1,
	HDMI_I2CM_INT_DONE_POL = 8,
	HDMI_I2CM_INT_DONE_MASK = 4,
	HDMI_I2CM_CTLINT_NAC_POL = 128,
	HDMI_I2CM_CTLINT_NAC_MASK = 64,
	HDMI_I2CM_CTLINT_ARBITRATION_POL = 8,
	HDMI_I2CM_CTLINT_ARBITRATION_MASK = 4,
};

enum imx_hdmi_type {
	IMX6DL_HDMI = 0,
	IMX6Q_HDMI = 1,
};

enum {
	SNDRV_PCM_STREAM_PLAYBACK = 0,
	SNDRV_PCM_STREAM_CAPTURE = 1,
	SNDRV_PCM_STREAM_LAST = 1,
};

enum {
	SND_CTL_SUBDEV_PCM = 0,
	SND_CTL_SUBDEV_RAWMIDI = 1,
	SND_CTL_SUBDEV_ITEMS = 2,
};

enum hdmi_colorimetry___2 {
	eITU601 = 0,
	eITU709 = 1,
};

struct hdmi_vmode {
	bool mDVI;
	bool mHSyncPolarity;
	bool mVSyncPolarity;
	bool mInterlaced;
	bool mDataEnablePolarity;
	unsigned int mPixelClock;
	unsigned int mPixelRepetitionInput;
	unsigned int mPixelRepetitionOutput;
};

struct hdmi_data_info {
	unsigned int enc_in_format;
	unsigned int enc_out_format;
	unsigned int enc_color_depth;
	unsigned int colorimetry;
	unsigned int pix_repet_factor;
	unsigned int hdcp_enable;
	unsigned int rgb_out_enable;
	struct hdmi_vmode video_mode;
};

struct hdmi_phy_reg_config {
	u16 reg_vlev;
	u16 reg_cksymtx;
};

struct mxc_hdmi {
	struct platform_device *pdev;
	struct platform_device *core_pdev;
	struct mxc_dispdrv_handle *disp_mxc_hdmi;
	struct fb_info *fbi;
	struct clk *hdmi_isfr_clk;
	struct clk *hdmi_iahb_clk;
	struct clk *mipi_core_clk;
	struct delayed_work hotplug_work;
	struct delayed_work hdcp_hdp_work;
	struct notifier_block nb;
	struct hdmi_data_info hdmi_data;
	int vic;
	struct mxc_edid_cfg edid_cfg;
	u8 edid[512];
	bool fb_reg;
	bool cable_plugin;
	u8 blank;
	bool dft_mode_set;
	char *dft_mode_str;
	int default_bpp;
	u8 latest_intr_stat;
	bool irq_enabled;
	spinlock_t irq_lock;
	bool phy_enabled;
	struct fb_videomode default_mode;
	struct fb_videomode previous_non_vga_mode;
	bool requesting_vga_for_initialization;
	int *gpr_base;
	int *gpr_hdmi_base;
	int *gpr_sdma_base;
	int cpu_type;
	int cpu_version;
	struct hdmi_phy_reg_config phy_config;
	struct pinctrl *pinctrl;
};

struct roi_params {
	unsigned int roi_n;
	unsigned int ref_sig;
	unsigned int start_y;
	unsigned int start_x;
	unsigned int end_y;
	unsigned int end_x;
	char freeze;
};

struct roi_regs {
	u32 dcicrc;
	u32 dcicrs;
	u32 dcicrrs;
	u32 dcicrcs;
};

struct dcic_regs {
	u32 dcicc;
	u32 dcicic;
	u32 dcics;
	u32 dcic_reserved;
	struct roi_regs ROI[16];
};

struct dcic_mux {
	char dcic[16];
	u32 val;
};

struct bus_mux___2 {
	char name[16];
	int reg;
	int shift;
	int mask;
	int dcic_mux_num;
	const struct dcic_mux *dcics;
};

struct dcic_info {
	int bus_mux_num;
	const struct bus_mux___2 *buses;
};

struct dcic_data {
	struct regmap *regmap;
	struct device *dev;
	struct dcic_regs *regs;
	const struct bus_mux___2 *buses;
	u32 bus_n;
	u32 mux_n;
	struct clk *disp_axi_clk;
	struct clk *dcic_clk;
	struct mutex lock;
	struct completion roi_crc_comp;
	struct class *class;
	int major;
	struct cdev cdev;
	dev_t devt;
	unsigned int result;
};

struct mxc_lcd_platform_data {
	u32 default_ifmt;
	u32 ipu_id;
	u32 disp_id;
};

struct mxc_lcdif_data {
	struct platform_device *pdev;
	struct mxc_dispdrv_handle *disp_lcdif;
};

enum v4l2_field {
	V4L2_FIELD_ANY = 0,
	V4L2_FIELD_NONE = 1,
	V4L2_FIELD_TOP = 2,
	V4L2_FIELD_BOTTOM = 3,
	V4L2_FIELD_INTERLACED = 4,
	V4L2_FIELD_SEQ_TB = 5,
	V4L2_FIELD_SEQ_BT = 6,
	V4L2_FIELD_ALTERNATE = 7,
	V4L2_FIELD_INTERLACED_TB = 8,
	V4L2_FIELD_INTERLACED_BT = 9,
};

typedef enum {
	MED_MOTION = 0,
	LOW_MOTION = 1,
	HIGH_MOTION = 2,
} ipu_motion_sel;

typedef enum {
	DISP0 = 0,
	DISP1 = 1,
	DISP2 = 2,
	DISP3 = 3,
} display_port_t;

typedef enum {
	CHAN_NONE = 4294967295,
	MEM_ROT_ENC_MEM = 28835824,
	MEM_ROT_VF_MEM = 45875185,
	MEM_ROT_PP_MEM = 62914546,
	MEM_PRP_ENC_MEM = 70313044,
	MEM_PRP_VF_MEM = 87090261,
	MEM_PP_MEM = 103609494,
	MEM_DC_SYNC = 125042687,
	MEM_DC_ASYNC = 145227775,
	MEM_BG_SYNC = 157285631,
	MEM_FG_SYNC = 175110143,
	MEM_BG_ASYNC0 = 191102271,
	MEM_FG_ASYNC0 = 209188991,
	MEM_BG_ASYNC1 = 727973183,
	MEM_FG_ASYNC1 = 746059903,
	DIRECT_ASYNC0 = 234881023,
	DIRECT_ASYNC1 = 251658239,
	CSI_MEM0 = 268435392,
	CSI_MEM1 = 285212609,
	CSI_MEM2 = 301989826,
	CSI_MEM3 = 318767043,
	CSI_MEM = 268435392,
	CSI_PRP_ENC_MEM = 335544276,
	CSI_PRP_VF_MEM = 352321493,
	MEM_VDI_PRP_VF_MEM_P = 354477141,
	MEM_VDI_PRP_VF_MEM = 371516501,
	MEM_VDI_PRP_VF_MEM_N = 388555861,
	MEM_VDI_MEM_P = 405012421,
	MEM_VDI_MEM = 422051781,
	MEM_VDI_MEM_N = 439091141,
	MEM_VDOA_MEM = 469762047,
	MEM_PP_ADC = 4294967295,
	ADC_SYS2 = 4294967295,
} ipu_channel_t;

typedef enum {
	Disable = 0,
	WriteTemplateNonSeq = 1,
	ReadTemplateNonSeq = 2,
	WriteTemplateUnCon = 3,
	ReadTemplateUnCon = 4,
	WriteDataWithRS = 5,
	WriteDataWoRS = 6,
	WriteCmd = 7,
} mcu_mode_t;

typedef union {
	struct {
		uint32_t csi;
		uint32_t mipi_id;
		uint32_t mipi_vc;
		bool mipi_en;
		bool interlaced;
	} csi_mem;
	struct {
		uint32_t in_width;
		uint32_t in_height;
		uint32_t in_pixel_fmt;
		uint32_t out_width;
		uint32_t out_height;
		uint32_t out_pixel_fmt;
		uint32_t outh_resize_ratio;
		uint32_t outv_resize_ratio;
		uint32_t csi;
		uint32_t mipi_id;
		uint32_t mipi_vc;
		bool mipi_en;
	} csi_prp_enc_mem;
	struct {
		uint32_t in_width;
		uint32_t in_height;
		uint32_t in_pixel_fmt;
		uint32_t out_width;
		uint32_t out_height;
		uint32_t out_pixel_fmt;
		uint32_t outh_resize_ratio;
		uint32_t outv_resize_ratio;
	} mem_prp_enc_mem;
	struct {
		uint32_t in_width;
		uint32_t in_height;
		uint32_t in_pixel_fmt;
		uint32_t out_width;
		uint32_t out_height;
		uint32_t out_pixel_fmt;
	} mem_rot_enc_mem;
	struct {
		uint32_t in_width;
		uint32_t in_height;
		uint32_t in_pixel_fmt;
		uint32_t out_width;
		uint32_t out_height;
		uint32_t out_pixel_fmt;
		uint32_t outh_resize_ratio;
		uint32_t outv_resize_ratio;
		bool graphics_combine_en;
		bool global_alpha_en;
		bool key_color_en;
		uint32_t in_g_pixel_fmt;
		uint8_t alpha;
		uint32_t key_color;
		bool alpha_chan_en;
		ipu_motion_sel motion_sel;
		enum v4l2_field field_fmt;
		uint32_t csi;
		uint32_t mipi_id;
		uint32_t mipi_vc;
		bool mipi_en;
	} csi_prp_vf_mem;
	struct {
		uint32_t in_width;
		uint32_t in_height;
		uint32_t in_pixel_fmt;
		uint32_t out_width;
		uint32_t out_height;
		uint32_t out_pixel_fmt;
		bool graphics_combine_en;
		bool global_alpha_en;
		bool key_color_en;
		display_port_t disp;
		uint32_t out_left;
		uint32_t out_top;
	} csi_prp_vf_adc;
	struct {
		uint32_t in_width;
		uint32_t in_height;
		uint32_t in_pixel_fmt;
		uint32_t out_width;
		uint32_t out_height;
		uint32_t out_pixel_fmt;
		uint32_t outh_resize_ratio;
		uint32_t outv_resize_ratio;
		bool graphics_combine_en;
		bool global_alpha_en;
		bool key_color_en;
		uint32_t in_g_pixel_fmt;
		uint8_t alpha;
		uint32_t key_color;
		bool alpha_chan_en;
		ipu_motion_sel motion_sel;
		enum v4l2_field field_fmt;
	} mem_prp_vf_mem;
	struct {
		uint32_t temp;
	} mem_prp_vf_adc;
	struct {
		uint32_t temp;
	} mem_rot_vf_mem;
	struct {
		uint32_t in_width;
		uint32_t in_height;
		uint32_t in_pixel_fmt;
		uint32_t out_width;
		uint32_t out_height;
		uint32_t out_pixel_fmt;
		uint32_t outh_resize_ratio;
		uint32_t outv_resize_ratio;
		bool graphics_combine_en;
		bool global_alpha_en;
		bool key_color_en;
		uint32_t in_g_pixel_fmt;
		uint8_t alpha;
		uint32_t key_color;
		bool alpha_chan_en;
	} mem_pp_mem;
	struct {
		uint32_t temp;
	} mem_rot_mem;
	struct {
		uint32_t in_width;
		uint32_t in_height;
		uint32_t in_pixel_fmt;
		uint32_t out_width;
		uint32_t out_height;
		uint32_t out_pixel_fmt;
		bool graphics_combine_en;
		bool global_alpha_en;
		bool key_color_en;
		display_port_t disp;
		uint32_t out_left;
		uint32_t out_top;
	} mem_pp_adc;
	struct {
		uint32_t di;
		bool interlaced;
		uint32_t in_pixel_fmt;
		uint32_t out_pixel_fmt;
	} mem_dc_sync;
	struct {
		uint32_t temp;
	} mem_sdc_fg;
	struct {
		uint32_t di;
		bool interlaced;
		uint32_t in_pixel_fmt;
		uint32_t out_pixel_fmt;
		bool alpha_chan_en;
	} mem_dp_bg_sync;
	struct {
		uint32_t temp;
	} mem_sdc_bg;
	struct {
		uint32_t di;
		bool interlaced;
		uint32_t in_pixel_fmt;
		uint32_t out_pixel_fmt;
		bool alpha_chan_en;
	} mem_dp_fg_sync;
	struct {
		uint32_t di;
	} direct_async;
	struct {
		display_port_t disp;
		mcu_mode_t ch_mode;
		uint32_t out_left;
		uint32_t out_top;
	} adc_sys1;
	struct {
		display_port_t disp;
		mcu_mode_t ch_mode;
		uint32_t out_left;
		uint32_t out_top;
	} adc_sys2;
} ipu_channel_params_t;

enum ipu_irq_line {
	IPU_IRQ_CSI0_OUT_EOF = 0,
	IPU_IRQ_CSI1_OUT_EOF = 1,
	IPU_IRQ_CSI2_OUT_EOF = 2,
	IPU_IRQ_CSI3_OUT_EOF = 3,
	IPU_IRQ_VDIC_OUT_EOF = 5,
	IPU_IRQ_VDI_P_IN_EOF = 8,
	IPU_IRQ_VDI_C_IN_EOF = 9,
	IPU_IRQ_VDI_N_IN_EOF = 10,
	IPU_IRQ_PP_IN_EOF = 11,
	IPU_IRQ_PRP_IN_EOF = 12,
	IPU_IRQ_PRP_GRAPH_IN_EOF = 14,
	IPU_IRQ_PP_GRAPH_IN_EOF = 15,
	IPU_IRQ_PRP_ALPHA_IN_EOF = 17,
	IPU_IRQ_PP_ALPHA_IN_EOF = 18,
	IPU_IRQ_PRP_ENC_OUT_EOF = 20,
	IPU_IRQ_PRP_VF_OUT_EOF = 21,
	IPU_IRQ_PP_OUT_EOF = 22,
	IPU_IRQ_BG_SYNC_EOF = 23,
	IPU_IRQ_BG_ASYNC_EOF = 24,
	IPU_IRQ_FG_SYNC_EOF = 27,
	IPU_IRQ_DC_SYNC_EOF = 28,
	IPU_IRQ_FG_ASYNC_EOF = 29,
	IPU_IRQ_FG_ALPHA_SYNC_EOF = 31,
	IPU_IRQ_FG_ALPHA_ASYNC_EOF = 33,
	IPU_IRQ_DC_READ_EOF = 40,
	IPU_IRQ_DC_ASYNC_EOF = 41,
	IPU_IRQ_DC_CMD1_EOF = 42,
	IPU_IRQ_DC_CMD2_EOF = 43,
	IPU_IRQ_DC_MASK_EOF = 44,
	IPU_IRQ_PRP_ENC_ROT_IN_EOF = 45,
	IPU_IRQ_PRP_VF_ROT_IN_EOF = 46,
	IPU_IRQ_PP_ROT_IN_EOF = 47,
	IPU_IRQ_PRP_ENC_ROT_OUT_EOF = 48,
	IPU_IRQ_PRP_VF_ROT_OUT_EOF = 49,
	IPU_IRQ_PP_ROT_OUT_EOF = 50,
	IPU_IRQ_BG_ALPHA_SYNC_EOF = 51,
	IPU_IRQ_BG_ALPHA_ASYNC_EOF = 52,
	IPU_IRQ_BG_SYNC_NFACK = 87,
	IPU_IRQ_FG_SYNC_NFACK = 91,
	IPU_IRQ_DC_SYNC_NFACK = 92,
	IPU_IRQ_DP_SF_START = 450,
	IPU_IRQ_DP_SF_END = 451,
	IPU_IRQ_BG_SF_END = 451,
	IPU_IRQ_DC_FC_0 = 456,
	IPU_IRQ_DC_FC_1 = 457,
	IPU_IRQ_DC_FC_2 = 458,
	IPU_IRQ_DC_FC_3 = 459,
	IPU_IRQ_DC_FC_4 = 460,
	IPU_IRQ_DC_FC_6 = 461,
	IPU_IRQ_VSYNC_PRE_0 = 462,
	IPU_IRQ_VSYNC_PRE_1 = 463,
	IPU_IRQ_COUNT = 464,
};

typedef struct {
	unsigned int datamask_en: 1;
	unsigned int int_clk: 1;
	unsigned int interlaced: 1;
	unsigned int odd_field_first: 1;
	unsigned int clksel_en: 1;
	unsigned int clkidle_en: 1;
	unsigned int data_pol: 1;
	unsigned int clk_pol: 1;
	unsigned int enable_pol: 1;
	unsigned int Hsync_pol: 1;
	unsigned int Vsync_pol: 1;
} ipu_di_signal_cfg_t;

typedef enum {
	RGB = 0,
	YCbCr = 1,
	YUV = 2,
} ipu_color_space_t;

struct ipuv3_fb_platform_data {
	char disp_dev[32];
	u32 interface_pix_fmt;
	char *mode_str;
	int default_bpp;
	bool int_clk;
	resource_size_t res_base[2];
	resource_size_t res_size[2];
	bool late_init;
	bool prefetch;
	bool resolve;
};

struct ipu_rect {
	int left;
	int top;
	int width;
	int height;
};

struct ipu_pre_context {
	bool repeat;
	bool vflip;
	bool handshake_en;
	bool hsk_abort_en;
	unsigned int hsk_line_num;
	bool sdw_update;
	unsigned int block_size;
	unsigned int interlaced;
	unsigned int prefetch_mode;
	long unsigned int cur_buf;
	long unsigned int next_buf;
	unsigned int tile_fmt;
	unsigned int read_burst;
	unsigned int prefetch_input_bpp;
	unsigned int prefetch_input_pixel_fmt;
	unsigned int prefetch_shift_offset;
	unsigned int prefetch_shift_width;
	bool shift_bypass;
	bool field_inverse;
	bool tpr_coor_offset_en;
	struct ipu_rect prefetch_output_size;
	unsigned int prefetch_input_active_width;
	unsigned int prefetch_input_width;
	unsigned int prefetch_input_height;
	unsigned int store_pitch;
	int interlace_offset;
	bool store_en;
	unsigned int write_burst;
	unsigned int store_output_bpp;
	unsigned int sec_buf_off;
	unsigned int trd_buf_off;
	long unsigned int store_addr;
};

struct ipu_prg_config {
	unsigned int id;
	unsigned int pre_num;
	ipu_channel_t ipu_ch;
	unsigned int stride;
	unsigned int height;
	unsigned int ipu_height;
	unsigned int crop_line;
	unsigned int so;
	unsigned int ilo;
	unsigned int block_mode;
	bool vflip;
	u32 baddr;
	u32 offset;
};

struct mxcfb_gbl_alpha {
	int enable;
	int alpha;
};

struct mxcfb_loc_alpha {
	int enable;
	int alpha_in_pixel;
	long unsigned int alpha_phy_addr0;
	long unsigned int alpha_phy_addr1;
};

struct mxcfb_color_key {
	int enable;
	__u32 color_key;
};

struct mxcfb_pos {
	__u16 x;
	__u16 y;
};

struct mxcfb_gamma {
	int enable;
	int constk[16];
	int slopek[16];
};

struct mxcfb_gpu_split_fmt {
	struct fb_var_screeninfo var;
	long unsigned int offset;
};

struct mxcfb_csc_matrix {
	int param[15];
};

struct mxcfb_info {
	int default_bpp;
	int cur_blank;
	int next_blank;
	ipu_channel_t ipu_ch;
	int ipu_id;
	int ipu_di;
	int pre_num;
	u32 ipu_di_pix_fmt;
	bool ipu_int_clk;
	bool overlay;
	bool alpha_chan_en;
	bool late_init;
	bool first_set_par;
	bool resolve;
	bool prefetch;
	bool on_the_fly;
	uint32_t final_pfmt;
	long unsigned int gpu_sec_buf_off;
	long unsigned int base;
	uint32_t x_crop;
	uint32_t y_crop;
	unsigned int sec_buf_off;
	unsigned int trd_buf_off;
	dma_addr_t store_addr;
	dma_addr_t alpha_phy_addr0;
	dma_addr_t alpha_phy_addr1;
	void *alpha_virt_addr0;
	void *alpha_virt_addr1;
	uint32_t alpha_mem_len;
	uint32_t ipu_ch_irq;
	uint32_t ipu_ch_nf_irq;
	uint32_t ipu_alp_ch_irq;
	uint32_t cur_ipu_buf;
	uint32_t cur_ipu_alpha_buf;
	u32 pseudo_palette[16];
	bool mode_found;
	struct completion flip_complete;
	struct completion alpha_flip_complete;
	struct completion vsync_complete;
	struct completion otf_complete;
	void *ipu;
	struct fb_info *ovfbi;
	struct mxc_dispdrv_handle *dispdrv;
	struct fb_var_screeninfo cur_var;
	uint32_t cur_ipu_pfmt;
	uint32_t cur_fb_pfmt;
	bool cur_prefetch;
	spinlock_t spin_lock;
	struct ipu_pre_context *pre_config;
};

struct mxcfb_pfmt {
	u32 fb_pix_fmt;
	int bpp;
	struct fb_bitfield red;
	struct fb_bitfield green;
	struct fb_bitfield blue;
	struct fb_bitfield transp;
};

struct mxcfb_tile_block {
	u32 fb_pix_fmt;
	int bw;
	int bh;
};

struct mxcfb_alloc_list {
	struct list_head list;
	dma_addr_t phy_addr;
	void *cpu_addr;
	u32 size;
};

enum {
	BOTH_ON = 0,
	SRC_ON = 1,
	TGT_ON = 2,
	BOTH_OFF = 3,
};

enum input_clock_type {
	INPUT_CLK_REAL = 0,
	INPUT_CLK_MONO = 1,
	INPUT_CLK_BOOT = 2,
	INPUT_CLK_MAX = 3,
};

struct firmware {
	size_t size;
	const u8 *data;
	void *priv;
};

enum pxp_channel_status {
	PXP_CHANNEL_FREE = 0,
	PXP_CHANNEL_INITIALIZED = 1,
	PXP_CHANNEL_READY = 2,
};

enum pxp_working_mode {
	PXP_MODE_LEGACY = 1,
	PXP_MODE_STANDARD = 2,
	PXP_MODE_ADVANCED = 4,
};

enum pxp_engine_ctrl {
	PXP_ENABLE_ROTATE0 = 1,
	PXP_ENABLE_ROTATE1 = 2,
	PXP_ENABLE_LUT = 4,
	PXP_ENABLE_CSC2 = 8,
	PXP_ENABLE_ALPHA_B = 16,
	PXP_ENABLE_INPUT_FETCH_SOTRE = 32,
	PXP_ENABLE_WFE_B = 64,
	PXP_ENABLE_WFE_A = 128,
	PXP_ENABLE_DITHER = 256,
	PXP_ENABLE_PS_AS_OUT = 512,
	PXP_ENABLE_COLLISION_DETECT = 1024,
	PXP_ENABLE_HANDSHAKE = 4096,
	PXP_ENABLE_DITHER_BYPASS = 8192,
};

enum pxp_op_type {
	PXP_OP_2D = 1,
	PXP_OP_DITHER = 2,
	PXP_OP_WFE_A = 4,
	PXP_OP_WFE_B = 8,
};

struct rect {
	int top;
	int left;
	int width;
	int height;
};

struct pxp_alpha {
	unsigned int alpha_mode;
	unsigned int global_alpha_mode;
	unsigned int global_alpha_value;
	unsigned int factor_mode;
	unsigned int color_mode;
};

struct pxp_layer_param {
	short unsigned int left;
	short unsigned int top;
	short unsigned int width;
	short unsigned int height;
	short unsigned int stride;
	unsigned int pixel_fmt;
	unsigned int flag;
	bool combine_enable;
	unsigned int color_key_enable;
	unsigned int color_key;
	bool global_alpha_enable;
	bool global_override;
	unsigned char global_alpha;
	bool alpha_invert;
	bool local_alpha_enable;
	int comp_mask;
	struct pxp_alpha alpha;
	struct rect crop;
	dma_addr_t paddr;
	dma_addr_t paddr_u;
	dma_addr_t paddr_v;
};

struct pxp_proc_data {
	int scaling;
	int hflip;
	int vflip;
	int rotate;
	int rot_pos;
	int yuv;
	unsigned int alpha_mode;
	struct rect srect;
	struct rect drect;
	unsigned int bgcolor;
	unsigned char fill_en;
	int overlay_state;
	int lut_transform;
	unsigned char *lut_map;
	bool lut_map_updated;
	bool combine_enable;
	enum pxp_op_type op_type;
	__u64 lut_sels;
	enum pxp_working_mode working_mode;
	enum pxp_engine_ctrl engine_enable;
	bool partial_update;
	bool alpha_en;
	bool lut_update;
	bool reagl_en;
	bool reagl_d_en;
	bool detection_only;
	bool pxp_legacy;
	int lut;
	bool lut_cleanup;
	unsigned int lut_status_1;
	unsigned int lut_status_2;
	int dither_mode;
	unsigned int quant_bit;
};

struct pxp_config_data {
	struct pxp_layer_param s0_param;
	struct pxp_layer_param ol_param[1];
	struct pxp_layer_param out_param;
	struct pxp_layer_param wfe_a_fetch_param[2];
	struct pxp_layer_param wfe_a_store_param[2];
	struct pxp_layer_param wfe_b_fetch_param[2];
	struct pxp_layer_param wfe_b_store_param[2];
	struct pxp_layer_param dither_fetch_param[2];
	struct pxp_layer_param dither_store_param[2];
	int: 32;
	struct pxp_proc_data proc_data;
	int layer_nr;
	int handle;
};

struct pxp_tx_desc {
	struct dma_async_tx_descriptor txd;
	struct list_head tx_list;
	struct list_head list;
	int len;
	union {
		struct pxp_layer_param s0_param;
		struct pxp_layer_param out_param;
		struct pxp_layer_param ol_param;
		struct pxp_layer_param processing_param;
	} layer_param;
	struct pxp_proc_data proc_data;
	u32 hist_status;
	struct pxp_tx_desc *next;
};

struct pxp_channel {
	struct dma_chan dma_chan;
	dma_cookie_t completed;
	enum pxp_channel_status status;
	void *client;
	unsigned int n_tx_desc;
	struct pxp_tx_desc *desc;
	struct list_head active_list;
	struct list_head free_list;
	struct list_head queue;
	struct list_head list;
	spinlock_t lock;
	struct mutex chan_mutex;
	int active_buffer;
	unsigned int eof_irq;
	char eof_name[16];
};

struct mxcfb_rect {
	__u32 top;
	__u32 left;
	__u32 width;
	__u32 height;
};

struct mxcfb_alt_buffer_data {
	__u32 phys_addr;
	__u32 width;
	__u32 height;
	struct mxcfb_rect alt_update_region;
};

struct mxcfb_update_data {
	struct mxcfb_rect update_region;
	__u32 waveform_mode;
	__u32 update_mode;
	__u32 update_marker;
	int temp;
	unsigned int flags;
	int dither_mode;
	int quant_bit;
	struct mxcfb_alt_buffer_data alt_buffer_data;
};

struct mxcfb_update_marker_data {
	__u32 update_marker;
	__u32 collision_test;
};

struct mxcfb_waveform_modes {
	int mode_init;
	int mode_du;
	int mode_gc4;
	int mode_gc8;
	int mode_gc16;
	int mode_gc32;
};

struct imx_epdc_fb_mode {
	struct fb_videomode *vmode;
	int vscan_holdoff;
	int sdoed_width;
	int sdoed_delay;
	int sdoez_width;
	int sdoez_delay;
	int gdclk_hp_offs;
	int gdsp_offs;
	int gdoe_offs;
	int gdclk_offs;
	int num_ce;
};

struct imx_epdc_fb_platform_data {
	struct imx_epdc_fb_mode *epdc_mode;
	int num_modes;
	int (*get_pins)();
	void (*put_pins)();
	void (*enable_pins)();
	void (*disable_pins)();
};

enum {
	EPDC_CTRL_SFTRST = 2147483648,
	EPDC_CTRL_CLKGATE = 1073741824,
	EPDC_CTRL_SRAM_POWERDOWN = 256,
	EPDC_CTRL_UPD_DATA_SWIZZLE_MASK = 192,
	EPDC_CTRL_UPD_DATA_SWIZZLE_NO_SWAP = 0,
	EPDC_CTRL_UPD_DATA_SWIZZLE_ALL_BYTES_SWAP = 64,
	EPDC_CTRL_UPD_DATA_SWIZZLE_HWD_SWAP = 128,
	EPDC_CTRL_UPD_DATA_SWIZZLE_HWD_BYTE_SWAP = 192,
	EPDC_CTRL_LUT_DATA_SWIZZLE_MASK = 48,
	EPDC_CTRL_LUT_DATA_SWIZZLE_NO_SWAP = 0,
	EPDC_CTRL_LUT_DATA_SWIZZLE_ALL_BYTES_SWAP = 16,
	EPDC_CTRL_LUT_DATA_SWIZZLE_HWD_SWAP = 32,
	EPDC_CTRL_LUT_DATA_SWIZZLE_HWD_BYTE_SWAP = 48,
	EPDC_CTRL_BURST_LEN_8_8 = 1,
	EPDC_CTRL_BURST_LEN_8_16 = 0,
	EPDC_RES_VERTICAL_MASK = 536805376,
	EPDC_RES_VERTICAL_OFFSET = 16,
	EPDC_RES_HORIZONTAL_MASK = 8191,
	EPDC_RES_HORIZONTAL_OFFSET = 0,
	EPDC_FORMAT_BUF_PIXEL_SCALE_ROUND = 16777216,
	EPDC_FORMAT_DEFAULT_TFT_PIXEL_MASK = 16711680,
	EPDC_FORMAT_DEFAULT_TFT_PIXEL_OFFSET = 16,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_MASK = 1792,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_P2N = 512,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_P3N = 768,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_P4N = 1024,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_P5N = 1280,
	EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT = 0,
	EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT_VCOM = 1,
	EPDC_FORMAT_TFT_PIXEL_FORMAT_4BIT = 2,
	EPDC_FORMAT_TFT_PIXEL_FORMAT_4BIT_VCOM = 3,
	EPDC_FIFOCTRL_ENABLE_PRIORITY = 2147483648,
	EPDC_FIFOCTRL_FIFO_INIT_LEVEL_MASK = 16711680,
	EPDC_FIFOCTRL_FIFO_INIT_LEVEL_OFFSET = 16,
	EPDC_FIFOCTRL_FIFO_H_LEVEL_MASK = 65280,
	EPDC_FIFOCTRL_FIFO_H_LEVEL_OFFSET = 8,
	EPDC_FIFOCTRL_FIFO_L_LEVEL_MASK = 255,
	EPDC_FIFOCTRL_FIFO_L_LEVEL_OFFSET = 0,
	EPDC_UPD_CORD_YCORD_MASK = 536805376,
	EPDC_UPD_CORD_YCORD_OFFSET = 16,
	EPDC_UPD_CORD_XCORD_MASK = 8191,
	EPDC_UPD_CORD_XCORD_OFFSET = 0,
	EPDC_UPD_SIZE_HEIGHT_MASK = 536805376,
	EPDC_UPD_SIZE_HEIGHT_OFFSET = 16,
	EPDC_UPD_SIZE_WIDTH_MASK = 8191,
	EPDC_UPD_SIZE_WIDTH_OFFSET = 0,
	EPDC_UPD_CTRL_USE_FIXED = 2147483648,
	EPDC_UPD_CTRL_LUT_SEL_MASK = 4128768,
	EPDC_UPD_CTRL_LUT_SEL_OFFSET = 16,
	EPDC_UPD_CTRL_WAVEFORM_MODE_MASK = 65280,
	EPDC_UPD_CTRL_WAVEFORM_MODE_OFFSET = 8,
	EPDC_UPD_CTRL_AUTOWV_PAUSE = 8,
	EPDC_UPD_CTRL_AUTOWV = 4,
	EPDC_UPD_CTRL_DRY_RUN = 2,
	EPDC_UPD_CTRL_UPDATE_MODE_FULL = 1,
	EPDC_UPD_FIXED_FIXNP_EN = 2147483648,
	EPDC_UPD_FIXED_FIXCP_EN = 1073741824,
	EPDC_UPD_FIXED_FIXNP_MASK = 65280,
	EPDC_UPD_FIXED_FIXNP_OFFSET = 8,
	EPDC_UPD_FIXED_FIXCP_MASK = 255,
	EPDC_UPD_FIXED_FIXCP_OFFSET = 0,
	EPDC_AUTOWV_LUT_DATA_MASK = 16711680,
	EPDC_AUTOWV_LUT_DATA_OFFSET = 16,
	EPDC_AUTOWV_LUT_ADDR_MASK = 255,
	EPDC_AUTOWV_LUT_ADDR_OFFSET = 0,
	EPDC_TCE_CTRL_VSCAN_HOLDOFF_MASK = 33488896,
	EPDC_TCE_CTRL_VSCAN_HOLDOFF_OFFSET = 16,
	EPDC_TCE_CTRL_VCOM_VAL_MASK = 3072,
	EPDC_TCE_CTRL_VCOM_VAL_OFFSET = 10,
	EPDC_TCE_CTRL_VCOM_MODE_AUTO = 512,
	EPDC_TCE_CTRL_VCOM_MODE_MANUAL = 0,
	EPDC_TCE_CTRL_DDR_MODE_ENABLE = 256,
	EPDC_TCE_CTRL_LVDS_MODE_CE_ENABLE = 128,
	EPDC_TCE_CTRL_LVDS_MODE_ENABLE = 64,
	EPDC_TCE_CTRL_SCAN_DIR_1_UP = 32,
	EPDC_TCE_CTRL_SCAN_DIR_0_UP = 16,
	EPDC_TCE_CTRL_DUAL_SCAN_ENABLE = 8,
	EPDC_TCE_CTRL_SDDO_WIDTH_16BIT = 4,
	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_2 = 1,
	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_4 = 2,
	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_8 = 3,
	EPDC_TCE_SDCFG_SDCLK_HOLD = 2097152,
	EPDC_TCE_SDCFG_SDSHR = 1048576,
	EPDC_TCE_SDCFG_NUM_CE_MASK = 983040,
	EPDC_TCE_SDCFG_NUM_CE_OFFSET = 16,
	EPDC_TCE_SDCFG_SDDO_REFORMAT_STANDARD = 0,
	EPDC_TCE_SDCFG_SDDO_REFORMAT_FLIP_PIXELS = 16384,
	EPDC_TCE_SDCFG_SDDO_INVERT_ENABLE = 8192,
	EPDC_TCE_SDCFG_PIXELS_PER_CE_MASK = 8191,
	EPDC_TCE_SDCFG_PIXELS_PER_CE_OFFSET = 0,
	EPDC_TCE_SDCFG_GDRL = 16,
	EPDC_TCE_SDCFG_GDOE_MODE_DELAYED_GDCLK = 2,
	EPDC_TCE_SDCFG_GDSP_MODE_FRAME_SYNC = 1,
	EPDC_TCE_SDCFG_GDSP_MODE_ONE_LINE = 0,
	EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_MASK = 268369920,
	EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_OFFSET = 16,
	EPDC_TCE_HSCAN1_LINE_SYNC_MASK = 4095,
	EPDC_TCE_HSCAN1_LINE_SYNC_OFFSET = 0,
	EPDC_TCE_HSCAN2_LINE_END_MASK = 268369920,
	EPDC_TCE_HSCAN2_LINE_END_OFFSET = 16,
	EPDC_TCE_HSCAN2_LINE_BEGIN_MASK = 4095,
	EPDC_TCE_HSCAN2_LINE_BEGIN_OFFSET = 0,
	EPDC_TCE_VSCAN_FRAME_END_MASK = 16711680,
	EPDC_TCE_VSCAN_FRAME_END_OFFSET = 16,
	EPDC_TCE_VSCAN_FRAME_BEGIN_MASK = 65280,
	EPDC_TCE_VSCAN_FRAME_BEGIN_OFFSET = 8,
	EPDC_TCE_VSCAN_FRAME_SYNC_MASK = 255,
	EPDC_TCE_VSCAN_FRAME_SYNC_OFFSET = 0,
	EPDC_TCE_OE_SDOED_WIDTH_MASK = 4278190080,
	EPDC_TCE_OE_SDOED_WIDTH_OFFSET = 24,
	EPDC_TCE_OE_SDOED_DLY_MASK = 16711680,
	EPDC_TCE_OE_SDOED_DLY_OFFSET = 16,
	EPDC_TCE_OE_SDOEZ_WIDTH_MASK = 65280,
	EPDC_TCE_OE_SDOEZ_WIDTH_OFFSET = 8,
	EPDC_TCE_OE_SDOEZ_DLY_MASK = 255,
	EPDC_TCE_OE_SDOEZ_DLY_OFFSET = 0,
	EPDC_TCE_POLARITY_GDSP_POL_ACTIVE_HIGH = 16,
	EPDC_TCE_POLARITY_GDOE_POL_ACTIVE_HIGH = 8,
	EPDC_TCE_POLARITY_SDOE_POL_ACTIVE_HIGH = 4,
	EPDC_TCE_POLARITY_SDLE_POL_ACTIVE_HIGH = 2,
	EPDC_TCE_POLARITY_SDCE_POL_ACTIVE_HIGH = 1,
	EPDC_TCE_TIMING1_SDLE_SHIFT_NONE = 0,
	EPDC_TCE_TIMING1_SDLE_SHIFT_1 = 16,
	EPDC_TCE_TIMING1_SDLE_SHIFT_2 = 32,
	EPDC_TCE_TIMING1_SDLE_SHIFT_3 = 48,
	EPDC_TCE_TIMING1_SDCLK_INVERT = 8,
	EPDC_TCE_TIMING1_SDCLK_SHIFT_NONE = 0,
	EPDC_TCE_TIMING1_SDCLK_SHIFT_1CYCLE = 1,
	EPDC_TCE_TIMING1_SDCLK_SHIFT_2CYCLES = 2,
	EPDC_TCE_TIMING1_SDCLK_SHIFT_3CYCLES = 3,
	EPDC_TCE_TIMING2_GDCLK_HP_MASK = 4294901760,
	EPDC_TCE_TIMING2_GDCLK_HP_OFFSET = 16,
	EPDC_TCE_TIMING2_GDSP_OFFSET_MASK = 65535,
	EPDC_TCE_TIMING2_GDSP_OFFSET_OFFSET = 0,
	EPDC_TCE_TIMING3_GDOE_OFFSET_MASK = 4294901760,
	EPDC_TCE_TIMING3_GDOE_OFFSET_OFFSET = 16,
	EPDC_TCE_TIMING3_GDCLK_OFFSET_MASK = 65535,
	EPDC_TCE_TIMING3_GDCLK_OFFSET_OFFSET = 0,
	EPDC_IRQ_WB_CMPLT_IRQ = 65536,
	EPDC_IRQ_LUT_COL_IRQ = 131072,
	EPDC_IRQ_TCE_UNDERRUN_IRQ = 262144,
	EPDC_IRQ_FRAME_END_IRQ = 524288,
	EPDC_IRQ_BUS_ERROR_IRQ = 1048576,
	EPDC_IRQ_TCE_IDLE_IRQ = 2097152,
	EPDC_IRQ_UPD_DONE_IRQ = 4194304,
	EPDC_IRQ_PWR_IRQ = 8388608,
	EPDC_STATUS_NEXTLUT_NEXT_LUT_VALID = 256,
	EPDC_STATUS_NEXTLUT_NEXT_LUT_MASK = 63,
	EPDC_STATUS_NEXTLUT_NEXT_LUT_OFFSET = 0,
	EPDC_STATUS_HISTOGRAM_CP_MASK = 2031616,
	EPDC_STATUS_HISTOGRAM_CP_OFFSET = 16,
	EPDC_STATUS_HISTOGRAM_NP_MASK = 7936,
	EPDC_STATUS_HISTOGRAM_NP_OFFSET = 8,
	EPDC_STATUS_UPD_VOID = 8,
	EPDC_STATUS_LUTS_UNDERRUN = 4,
	EPDC_STATUS_LUTS_BUSY = 2,
	EPDC_STATUS_WB_BUSY = 1,
	EPDC_UPD_COL_CORD_YCORD_MASK = 536805376,
	EPDC_UPD_COL_CORD_YCORD_OFFSET = 16,
	EPDC_UPD_COL_CORD_XCORD_MASK = 8191,
	EPDC_UPD_COL_CORD_XCORD_OFFSET = 0,
	EPDC_UPD_COL_SIZE_HEIGHT_MASK = 536805376,
	EPDC_UPD_COL_SIZE_HEIGHT_OFFSET = 16,
	EPDC_UPD_COL_SIZE_WIDTH_MASK = 8191,
	EPDC_UPD_COL_SIZE_WIDTH_OFFSET = 0,
	EPDC_DEBUG_UNDERRUN_RECOVER = 2,
	EPDC_DEBUG_COLLISION_OFF = 1,
	EPDC_HIST_PARAM_VALUE0_MASK = 31,
	EPDC_HIST_PARAM_VALUE0_OFFSET = 0,
	EPDC_HIST_PARAM_VALUE1_MASK = 7936,
	EPDC_HIST_PARAM_VALUE1_OFFSET = 8,
	EPDC_HIST_PARAM_VALUE2_MASK = 2031616,
	EPDC_HIST_PARAM_VALUE2_OFFSET = 16,
	EPDC_HIST_PARAM_VALUE3_MASK = 520093696,
	EPDC_HIST_PARAM_VALUE3_OFFSET = 24,
	EPDC_HIST_PARAM_VALUE4_MASK = 31,
	EPDC_HIST_PARAM_VALUE4_OFFSET = 0,
	EPDC_HIST_PARAM_VALUE5_MASK = 7936,
	EPDC_HIST_PARAM_VALUE5_OFFSET = 8,
	EPDC_HIST_PARAM_VALUE6_MASK = 2031616,
	EPDC_HIST_PARAM_VALUE6_OFFSET = 16,
	EPDC_HIST_PARAM_VALUE7_MASK = 520093696,
	EPDC_HIST_PARAM_VALUE7_OFFSET = 24,
	EPDC_HIST_PARAM_VALUE8_MASK = 31,
	EPDC_HIST_PARAM_VALUE8_OFFSET = 0,
	EPDC_HIST_PARAM_VALUE9_MASK = 7936,
	EPDC_HIST_PARAM_VALUE9_OFFSET = 8,
	EPDC_HIST_PARAM_VALUE10_MASK = 2031616,
	EPDC_HIST_PARAM_VALUE10_OFFSET = 16,
	EPDC_HIST_PARAM_VALUE11_MASK = 520093696,
	EPDC_HIST_PARAM_VALUE11_OFFSET = 24,
	EPDC_HIST_PARAM_VALUE12_MASK = 31,
	EPDC_HIST_PARAM_VALUE12_OFFSET = 0,
	EPDC_HIST_PARAM_VALUE13_MASK = 7936,
	EPDC_HIST_PARAM_VALUE13_OFFSET = 8,
	EPDC_HIST_PARAM_VALUE14_MASK = 2031616,
	EPDC_HIST_PARAM_VALUE14_OFFSET = 16,
	EPDC_HIST_PARAM_VALUE15_MASK = 520093696,
	EPDC_HIST_PARAM_VALUE15_OFFSET = 24,
	EPDC_GPIO_PWRCOM = 64,
	EPDC_GPIO_PWRCTRL_MASK = 60,
	EPDC_GPIO_PWRCTRL_OFFSET = 2,
	EPDC_GPIO_BDR_MASK = 3,
	EPDC_GPIO_BDR_OFFSET = 0,
	EPDC_VERSION_MAJOR_MASK = 4278190080,
	EPDC_VERSION_MAJOR_OFFSET = 24,
	EPDC_VERSION_MINOR_MASK = 16711680,
	EPDC_VERSION_MINOR_OFFSET = 16,
	EPDC_VERSION_STEP_MASK = 65535,
	EPDC_VERSION_STEP_OFFSET = 0,
};

struct update_marker_data {
	struct list_head full_list;
	struct list_head upd_list;
	u32 update_marker;
	struct completion update_completion;
	int lut_num;
	bool collision_test;
	bool waiting;
};

struct update_desc_list {
	struct list_head list;
	struct mxcfb_update_data upd_data;
	u32 epdc_offs;
	u32 epdc_stride;
	struct list_head upd_marker_list;
	u32 update_order;
};

struct update_data_list {
	struct list_head list;
	dma_addr_t phys_addr;
	void *virt_addr;
	struct update_desc_list *update_desc;
	int lut_num;
	u64 collision_mask;
};

struct mxc_epdc_fb_data {
	struct fb_info info;
	struct fb_var_screeninfo epdc_fb_var;
	u32 pseudo_palette[16];
	char fw_str[32];
	struct list_head list;
	struct imx_epdc_fb_mode *cur_mode;
	struct imx_epdc_fb_platform_data *pdata;
	int blank;
	u32 max_pix_size;
	ssize_t map_size;
	dma_addr_t phys_start;
	u32 fb_offset;
	int default_bpp;
	int native_width;
	int native_height;
	int num_screens;
	int epdc_irq;
	struct device *dev;
	int power_state;
	int wait_for_powerdown;
	struct completion powerdown_compl;
	struct clk *epdc_clk_axi;
	struct clk *epdc_clk_pix;
	struct regulator *display_regulator;
	struct regulator *vcom_regulator;
	struct regulator *v3p3_regulator;
	bool fw_default_load;
	int rev;
	int num_luts;
	int max_num_updates;
	bool in_init;
	bool hw_ready;
	bool hw_initializing;
	bool waiting_for_idle;
	u32 auto_mode;
	u32 upd_scheme;
	struct list_head upd_pending_list;
	struct list_head upd_buf_queue;
	struct list_head upd_buf_free_list;
	struct list_head upd_buf_collision_list;
	struct update_data_list *cur_update;
	struct mutex queue_mutex;
	int trt_entries;
	int temp_index;
	u8 *temp_range_bounds;
	struct mxcfb_waveform_modes wv_modes;
	bool wv_modes_update;
	u32 *waveform_buffer_virt;
	u32 waveform_buffer_phys;
	u32 waveform_buffer_size;
	u32 *working_buffer_virt;
	u32 working_buffer_phys;
	u32 working_buffer_size;
	dma_addr_t *phys_addr_updbuf;
	void **virt_addr_updbuf;
	u32 upd_buffer_num;
	u32 max_num_buffers;
	dma_addr_t phys_addr_copybuf;
	void *virt_addr_copybuf;
	u32 order_cnt;
	struct list_head full_marker_list;
	u32 *lut_update_order;
	u64 epdc_colliding_luts;
	u64 luts_complete_wb;
	struct completion updates_done;
	struct delayed_work epdc_done_work;
	struct workqueue_struct *epdc_submit_workqueue;
	struct work_struct epdc_submit_work;
	struct workqueue_struct *epdc_intr_workqueue;
	struct work_struct epdc_intr_work;
	bool waiting_for_wb;
	bool waiting_for_lut;
	bool waiting_for_lut15;
	struct completion update_res_free;
	struct completion lut15_free;
	struct completion eof_event;
	int eof_sync_period;
	struct mutex power_mutex;
	bool powering_down;
	bool updates_active;
	int pwrdown_delay;
	long unsigned int tce_prevent;
	bool restrict_width;
	struct completion pxp_tx_cmpl;
	struct pxp_channel *pxp_chan;
	int: 32;
	struct pxp_config_data pxp_conf;
	struct dma_async_tx_descriptor *txd;
	dma_cookie_t cookie;
	struct scatterlist sg[2];
	struct mutex pxp_mutex;
	int: 32;
};

struct waveform_data_header {
	unsigned int wi0;
	unsigned int wi1;
	unsigned int wi2;
	unsigned int wi3;
	unsigned int wi4;
	unsigned int wi5;
	unsigned int wi6;
	unsigned int xwia: 24;
	unsigned int cs1: 8;
	unsigned int wmta: 24;
	unsigned int fvsn: 8;
	unsigned int luts: 8;
	unsigned int mc: 8;
	unsigned int trc: 8;
	unsigned int reserved0_0: 8;
	unsigned int eb: 8;
	unsigned int sb: 8;
	unsigned int reserved0_1: 8;
	unsigned int reserved0_2: 8;
	unsigned int reserved0_3: 8;
	unsigned int reserved0_4: 8;
	unsigned int reserved0_5: 8;
	unsigned int cs2: 8;
};

struct mxcfb_waveform_data_file {
	struct waveform_data_header wdh;
	u32 *data;
};

enum pxp_buffer_flag {
	PXP_BUF_FLAG_WFE_A_FETCH0 = 1,
	PXP_BUF_FLAG_WFE_A_FETCH1 = 2,
	PXP_BUF_FLAG_WFE_A_STORE0 = 4,
	PXP_BUF_FLAG_WFE_A_STORE1 = 8,
	PXP_BUF_FLAG_WFE_B_FETCH0 = 16,
	PXP_BUF_FLAG_WFE_B_FETCH1 = 32,
	PXP_BUF_FLAG_WFE_B_STORE0 = 64,
	PXP_BUF_FLAG_WFE_B_STORE1 = 128,
	PXP_BUF_FLAG_DITHER_FETCH0 = 256,
	PXP_BUF_FLAG_DITHER_FETCH1 = 512,
	PXP_BUF_FLAG_DITHER_STORE0 = 1024,
	PXP_BUF_FLAG_DITHER_STORE1 = 2048,
};

struct pxp_collision_info {
	unsigned int pixel_cnt;
	unsigned int rect_min_x;
	unsigned int rect_min_y;
	unsigned int rect_max_x;
	unsigned int rect_max_y;
	unsigned int victim_luts[2];
};

enum mxcfb_dithering_mode {
	EPDC_FLAG_USE_DITHERING_PASSTHROUGH = 0,
	EPDC_FLAG_USE_DITHERING_FLOYD_STEINBERG = 1,
	EPDC_FLAG_USE_DITHERING_ATKINSON = 2,
	EPDC_FLAG_USE_DITHERING_ORDERED = 3,
	EPDC_FLAG_USE_DITHERING_QUANT_ONLY = 4,
	EPDC_FLAG_USE_DITHERING_MAX = 5,
};

enum {
	EPDC_CTRL_SFTRST___2 = 2147483648,
	EPDC_CTRL_CLKGATE___2 = 1073741824,
	EPDC_CTRL_SRAM_POWERDOWN___2 = 256,
	EPDC_CTRL_UPD_DATA_SWIZZLE_MASK___2 = 192,
	EPDC_CTRL_UPD_DATA_SWIZZLE_NO_SWAP___2 = 0,
	EPDC_CTRL_UPD_DATA_SWIZZLE_ALL_BYTES_SWAP___2 = 64,
	EPDC_CTRL_UPD_DATA_SWIZZLE_HWD_SWAP___2 = 128,
	EPDC_CTRL_UPD_DATA_SWIZZLE_HWD_BYTE_SWAP___2 = 192,
	EPDC_CTRL_LUT_DATA_SWIZZLE_MASK___2 = 48,
	EPDC_CTRL_LUT_DATA_SWIZZLE_NO_SWAP___2 = 0,
	EPDC_CTRL_LUT_DATA_SWIZZLE_ALL_BYTES_SWAP___2 = 16,
	EPDC_CTRL_LUT_DATA_SWIZZLE_HWD_SWAP___2 = 32,
	EPDC_CTRL_LUT_DATA_SWIZZLE_HWD_BYTE_SWAP___2 = 48,
	EPDC_CTRL_BURST_LEN_8_8___2 = 1,
	EPDC_CTRL_BURST_LEN_8_16___2 = 0,
	EPDC_RES_VERTICAL_MASK___2 = 536805376,
	EPDC_RES_VERTICAL_OFFSET___2 = 16,
	EPDC_RES_HORIZONTAL_MASK___2 = 8191,
	EPDC_RES_HORIZONTAL_OFFSET___2 = 0,
	EPDC_FORMAT_BUF_PIXEL_SCALE_ROUND___2 = 16777216,
	EPDC_FORMAT_DEFAULT_TFT_PIXEL_MASK___2 = 16711680,
	EPDC_FORMAT_DEFAULT_TFT_PIXEL_OFFSET___2 = 16,
	EPDC_FORMAT_WB_ADDR_NO_COPY = 16384,
	EPDC_FORMAT_WB_TYPE_MASK = 12288,
	EPDC_FORMAT_WB_TYPE_OFFSET = 12,
	EPDC_FORMAT_WB_TYPE_WB_INTERNAL = 0,
	EPDC_FORMAT_WB_TYPE_WB_WAVEFORM = 4096,
	EPDC_FORMAT_WB_TYPE_WB_EXTERNAL16 = 8192,
	EPDC_FORMAT_WB_TYPE_WB_EXTERNAL32 = 12288,
	EPDC_FORMAT_WB_COMPRESS = 2048,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_MASK___2 = 1792,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_P2N___2 = 512,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_P3N___2 = 768,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_P4N___2 = 1024,
	EPDC_FORMAT_BUF_PIXEL_FORMAT_P5N___2 = 1280,
	EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT___2 = 0,
	EPDC_FORMAT_TFT_PIXEL_FORMAT_2BIT_VCOM___2 = 1,
	EPDC_FORMAT_TFT_PIXEL_FORMAT_4BIT___2 = 2,
	EPDC_FORMAT_TFT_PIXEL_FORMAT_4BIT_VCOM___2 = 3,
	EPDC_WB_FIELD_FIXED_MASK = 4278190080,
	EPDC_WB_FIELD_FIXED_OFFSET = 24,
	EPDC_WB_FIELD_USE_FIXED_MASK = 196608,
	EPDC_WB_FIELD_USE_FIXED_OFFSET = 16,
	EPDC_WB_FIELD_USE_FIXED_NO_FIXED = 0,
	EPDC_WB_FIELD_USE_FIXED_USE_FIXED = 1,
	EPDC_WB_FIELD_USE_FIXED_NE_FIXED = 2,
	EPDC_WB_FIELD_USE_FIXED_EQ_FIXED = 3,
	EPDC_WB_FIELD_USAGE_MASK = 57344,
	EPDC_WB_FIELD_USAGE_OFFSET = 13,
	EPDC_WB_FIELD_USAGE_NOT_USED = 0,
	EPDC_WB_FIELD_USAGE_PARTIAL = 3,
	EPDC_WB_FIELD_USAGE_LUT = 4,
	EPDC_WB_FIELD_USAGE_CP = 5,
	EPDC_WB_FIELD_USAGE_NP = 6,
	EPDC_WB_FIELD_USAGE_PTS = 7,
	EPDC_WB_FIELD_FROM_MASK = 7936,
	EPDC_WB_FIELD_FROM_OFFSET = 8,
	EPDC_WB_FIELD_TO_MASK = 240,
	EPDC_WB_FIELD_TO_OFFSET = 4,
	EPDC_WB_FIELD_LEN_MASK = 15,
	EPDC_WB_FIELD_LEN_OFFSET = 0,
	EPDC_FIFOCTRL_ENABLE_PRIORITY___2 = 2147483648,
	EPDC_FIFOCTRL_FIFO_INIT_LEVEL_MASK___2 = 16711680,
	EPDC_FIFOCTRL_FIFO_INIT_LEVEL_OFFSET___2 = 16,
	EPDC_FIFOCTRL_FIFO_H_LEVEL_MASK___2 = 65280,
	EPDC_FIFOCTRL_FIFO_H_LEVEL_OFFSET___2 = 8,
	EPDC_FIFOCTRL_FIFO_L_LEVEL_MASK___2 = 255,
	EPDC_FIFOCTRL_FIFO_L_LEVEL_OFFSET___2 = 0,
	EPDC_UPD_CORD_YCORD_MASK___2 = 536805376,
	EPDC_UPD_CORD_YCORD_OFFSET___2 = 16,
	EPDC_UPD_CORD_XCORD_MASK___2 = 8191,
	EPDC_UPD_CORD_XCORD_OFFSET___2 = 0,
	EPDC_UPD_SIZE_HEIGHT_MASK___2 = 536805376,
	EPDC_UPD_SIZE_HEIGHT_OFFSET___2 = 16,
	EPDC_UPD_SIZE_WIDTH_MASK___2 = 8191,
	EPDC_UPD_SIZE_WIDTH_OFFSET___2 = 0,
	EPDC_UPD_CTRL_USE_FIXED___2 = 2147483648,
	EPDC_UPD_CTRL_LUT_SEL_MASK___2 = 4128768,
	EPDC_UPD_CTRL_LUT_SEL_OFFSET___2 = 16,
	EPDC_UPD_CTRL_WAVEFORM_MODE_MASK___2 = 65280,
	EPDC_UPD_CTRL_WAVEFORM_MODE_OFFSET___2 = 8,
	EPDC_UPD_CTRL_NO_LUT_CANCEL = 16,
	EPDC_UPD_CTRL_AUTOWV_PAUSE___2 = 8,
	EPDC_UPD_CTRL_AUTOWV___2 = 4,
	EPDC_UPD_CTRL_DRY_RUN___2 = 2,
	EPDC_UPD_CTRL_UPDATE_MODE_FULL___2 = 1,
	EPDC_UPD_FIXED_FIXNP_EN___2 = 2147483648,
	EPDC_UPD_FIXED_FIXCP_EN___2 = 1073741824,
	EPDC_UPD_FIXED_FIXNP_MASK___2 = 65280,
	EPDC_UPD_FIXED_FIXNP_OFFSET___2 = 8,
	EPDC_UPD_FIXED_FIXCP_MASK___2 = 255,
	EPDC_UPD_FIXED_FIXCP_OFFSET___2 = 0,
	EPDC_AUTOWV_LUT_DATA_MASK___2 = 16711680,
	EPDC_AUTOWV_LUT_DATA_OFFSET___2 = 16,
	EPDC_AUTOWV_LUT_ADDR_MASK___2 = 7,
	EPDC_AUTOWV_LUT_ADDR_OFFSET___2 = 0,
	EPDC_TCE_CTRL_VSCAN_HOLDOFF_MASK___2 = 33488896,
	EPDC_TCE_CTRL_VSCAN_HOLDOFF_OFFSET___2 = 16,
	EPDC_TCE_CTRL_VCOM_VAL_MASK___2 = 3072,
	EPDC_TCE_CTRL_VCOM_VAL_OFFSET___2 = 10,
	EPDC_TCE_CTRL_VCOM_MODE_AUTO___2 = 512,
	EPDC_TCE_CTRL_VCOM_MODE_MANUAL___2 = 0,
	EPDC_TCE_CTRL_DDR_MODE_ENABLE___2 = 256,
	EPDC_TCE_CTRL_LVDS_MODE_CE_ENABLE___2 = 128,
	EPDC_TCE_CTRL_LVDS_MODE_ENABLE___2 = 64,
	EPDC_TCE_CTRL_SCAN_DIR_1_UP___2 = 32,
	EPDC_TCE_CTRL_SCAN_DIR_0_UP___2 = 16,
	EPDC_TCE_CTRL_DUAL_SCAN_ENABLE___2 = 8,
	EPDC_TCE_CTRL_SDDO_WIDTH_16BIT___2 = 4,
	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_2___2 = 1,
	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_4___2 = 2,
	EPDC_TCE_CTRL_PIXELS_PER_SDCLK_8___2 = 3,
	EPDC_TCE_SDCFG_SDCLK_HOLD___2 = 2097152,
	EPDC_TCE_SDCFG_SDSHR___2 = 1048576,
	EPDC_TCE_SDCFG_NUM_CE_MASK___2 = 983040,
	EPDC_TCE_SDCFG_NUM_CE_OFFSET___2 = 16,
	EPDC_TCE_SDCFG_SDDO_REFORMAT_STANDARD___2 = 0,
	EPDC_TCE_SDCFG_SDDO_REFORMAT_FLIP_PIXELS___2 = 16384,
	EPDC_TCE_SDCFG_SDDO_INVERT_ENABLE___2 = 8192,
	EPDC_TCE_SDCFG_PIXELS_PER_CE_MASK___2 = 8191,
	EPDC_TCE_SDCFG_PIXELS_PER_CE_OFFSET___2 = 0,
	EPDC_TCE_SDCFG_GDRL___2 = 16,
	EPDC_TCE_SDCFG_GDOE_MODE_DELAYED_GDCLK___2 = 2,
	EPDC_TCE_SDCFG_GDSP_MODE_FRAME_SYNC___2 = 1,
	EPDC_TCE_SDCFG_GDSP_MODE_ONE_LINE___2 = 0,
	EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_MASK___2 = 268369920,
	EPDC_TCE_HSCAN1_LINE_SYNC_WIDTH_OFFSET___2 = 16,
	EPDC_TCE_HSCAN1_LINE_SYNC_MASK___2 = 4095,
	EPDC_TCE_HSCAN1_LINE_SYNC_OFFSET___2 = 0,
	EPDC_TCE_HSCAN2_LINE_END_MASK___2 = 268369920,
	EPDC_TCE_HSCAN2_LINE_END_OFFSET___2 = 16,
	EPDC_TCE_HSCAN2_LINE_BEGIN_MASK___2 = 4095,
	EPDC_TCE_HSCAN2_LINE_BEGIN_OFFSET___2 = 0,
	EPDC_TCE_VSCAN_FRAME_END_MASK___2 = 16711680,
	EPDC_TCE_VSCAN_FRAME_END_OFFSET___2 = 16,
	EPDC_TCE_VSCAN_FRAME_BEGIN_MASK___2 = 65280,
	EPDC_TCE_VSCAN_FRAME_BEGIN_OFFSET___2 = 8,
	EPDC_TCE_VSCAN_FRAME_SYNC_MASK___2 = 255,
	EPDC_TCE_VSCAN_FRAME_SYNC_OFFSET___2 = 0,
	EPDC_TCE_OE_SDOED_WIDTH_MASK___2 = 4278190080,
	EPDC_TCE_OE_SDOED_WIDTH_OFFSET___2 = 24,
	EPDC_TCE_OE_SDOED_DLY_MASK___2 = 16711680,
	EPDC_TCE_OE_SDOED_DLY_OFFSET___2 = 16,
	EPDC_TCE_OE_SDOEZ_WIDTH_MASK___2 = 65280,
	EPDC_TCE_OE_SDOEZ_WIDTH_OFFSET___2 = 8,
	EPDC_TCE_OE_SDOEZ_DLY_MASK___2 = 255,
	EPDC_TCE_OE_SDOEZ_DLY_OFFSET___2 = 0,
	EPDC_TCE_POLARITY_GDSP_POL_ACTIVE_HIGH___2 = 16,
	EPDC_TCE_POLARITY_GDOE_POL_ACTIVE_HIGH___2 = 8,
	EPDC_TCE_POLARITY_SDOE_POL_ACTIVE_HIGH___2 = 4,
	EPDC_TCE_POLARITY_SDLE_POL_ACTIVE_HIGH___2 = 2,
	EPDC_TCE_POLARITY_SDCE_POL_ACTIVE_HIGH___2 = 1,
	EPDC_TCE_TIMING1_SDLE_SHIFT_NONE___2 = 0,
	EPDC_TCE_TIMING1_SDLE_SHIFT_1___2 = 16,
	EPDC_TCE_TIMING1_SDLE_SHIFT_2___2 = 32,
	EPDC_TCE_TIMING1_SDLE_SHIFT_3___2 = 48,
	EPDC_TCE_TIMING1_SDCLK_INVERT___2 = 8,
	EPDC_TCE_TIMING1_SDCLK_SHIFT_NONE___2 = 0,
	EPDC_TCE_TIMING1_SDCLK_SHIFT_1CYCLE___2 = 1,
	EPDC_TCE_TIMING1_SDCLK_SHIFT_2CYCLES___2 = 2,
	EPDC_TCE_TIMING1_SDCLK_SHIFT_3CYCLES___2 = 3,
	EPDC_TCE_TIMING2_GDCLK_HP_MASK___2 = 4294901760,
	EPDC_TCE_TIMING2_GDCLK_HP_OFFSET___2 = 16,
	EPDC_TCE_TIMING2_GDSP_OFFSET_MASK___2 = 65535,
	EPDC_TCE_TIMING2_GDSP_OFFSET_OFFSET___2 = 0,
	EPDC_TCE_TIMING3_GDOE_OFFSET_MASK___2 = 4294901760,
	EPDC_TCE_TIMING3_GDOE_OFFSET_OFFSET___2 = 16,
	EPDC_TCE_TIMING3_GDCLK_OFFSET_MASK___2 = 65535,
	EPDC_TCE_TIMING3_GDCLK_OFFSET_OFFSET___2 = 0,
	EPDC_PIGEON_CTRL0_LD_PERIOD_MASK = 268369920,
	EPDC_PIGEON_CTRL0_LD_PERIOD_OFFSET = 16,
	EPDC_PIGEON_CTRL0_FD_PERIOD_MASK = 4095,
	EPDC_PIGEON_CTRL0_FD_PERIOD_OFFSET = 0,
	EPDC_PIGEON_CTRL1_LD_PERIOD_MASK = 268369920,
	EPDC_PIGEON_CTRL1_LD_PERIOD_OFFSET = 16,
	EPDC_PIGEON_CTRL1_FD_PERIOD_MASK = 4095,
	EPDC_PIGEON_CTRL1_FD_PERIOD_OFFSET = 0,
	EPDC_IRQ_WB_CMPLT_IRQ___2 = 65536,
	EPDC_IRQ_LUT_COL_IRQ___2 = 131072,
	EPDC_IRQ_TCE_UNDERRUN_IRQ___2 = 262144,
	EPDC_IRQ_FRAME_END_IRQ___2 = 524288,
	EPDC_IRQ_BUS_ERROR_IRQ___2 = 1048576,
	EPDC_IRQ_TCE_IDLE_IRQ___2 = 2097152,
	EPDC_IRQ_UPD_DONE_IRQ___2 = 4194304,
	EPDC_IRQ_PWR_IRQ___2 = 8388608,
	EPDC_STATUS_NEXTLUT_NEXT_LUT_VALID___2 = 256,
	EPDC_STATUS_NEXTLUT_NEXT_LUT_MASK___2 = 63,
	EPDC_STATUS_NEXTLUT_NEXT_LUT_OFFSET___2 = 0,
	EPDC_STATUS_HISTOGRAM_CP_MASK___2 = 2031616,
	EPDC_STATUS_HISTOGRAM_CP_OFFSET___2 = 16,
	EPDC_STATUS_HISTOGRAM_NP_MASK___2 = 7936,
	EPDC_STATUS_HISTOGRAM_NP_OFFSET___2 = 8,
	EPDC_STATUS_UPD_VOID___2 = 8,
	EPDC_STATUS_LUTS_UNDERRUN___2 = 4,
	EPDC_STATUS_LUTS_BUSY___2 = 2,
	EPDC_STATUS_WB_BUSY___2 = 1,
	EPDC_UPD_COL_CORD_YCORD_MASK___2 = 536805376,
	EPDC_UPD_COL_CORD_YCORD_OFFSET___2 = 16,
	EPDC_UPD_COL_CORD_XCORD_MASK___2 = 8191,
	EPDC_UPD_COL_CORD_XCORD_OFFSET___2 = 0,
	EPDC_UPD_COL_SIZE_HEIGHT_MASK___2 = 536805376,
	EPDC_UPD_COL_SIZE_HEIGHT_OFFSET___2 = 16,
	EPDC_UPD_COL_SIZE_WIDTH_MASK___2 = 8191,
	EPDC_UPD_COL_SIZE_WIDTH_OFFSET___2 = 0,
	EPDC_DEBUG_DEBUG_LUT_SEL_MASK = 66060288,
	EPDC_DEBUG_DEBUG_LUT_SEL_OFFSET = 24,
	EPDC_DEBUG_UBW_BURST_LEN_MASK = 61440,
	EPDC_DEBUG_UBW_BURST_LEN_OFFSET = 12,
	EPDC_DEBUG_UBR_BURST_LEN_MASK = 3840,
	EPDC_DEBUG_UBR_BURST_LEN = 8,
	EPDC_DEBUG_UPD_BURST_LEN_MASK = 240,
	EPDC_DEBUG_UPD_BURST_LEN_OFFSET = 4,
	EPDC_DEBUG_UPDATE_SAME = 4,
	EPDC_DEBUG_UNDERRUN_RECOVER___2 = 2,
	EPDC_DEBUG_COLLISION_OFF___2 = 1,
	EPDC_DEBUG_LUT_LUTADDR_MASK = 67043328,
	EPDC_DEBUG_LUT_LUTADDR_OFFSET = 16,
	EPDC_DEBUG_LUT_FRAME_MASK = 32736,
	EPDC_DEBUG_LUT_FRAME_OFFSET = 5,
	EPDC_DEBUG_LUT_STATEMACHINE_MASK = 31,
	EPDC_DEBUG_LUT_STATEMACHINE_OFFSET = 0,
	EPDC_HIST_PARAM_VALUE0_MASK___2 = 31,
	EPDC_HIST_PARAM_VALUE0_OFFSET___2 = 0,
	EPDC_HIST_PARAM_VALUE1_MASK___2 = 7936,
	EPDC_HIST_PARAM_VALUE1_OFFSET___2 = 8,
	EPDC_HIST_PARAM_VALUE2_MASK___2 = 2031616,
	EPDC_HIST_PARAM_VALUE2_OFFSET___2 = 16,
	EPDC_HIST_PARAM_VALUE3_MASK___2 = 520093696,
	EPDC_HIST_PARAM_VALUE3_OFFSET___2 = 24,
	EPDC_HIST_PARAM_VALUE4_MASK___2 = 31,
	EPDC_HIST_PARAM_VALUE4_OFFSET___2 = 0,
	EPDC_HIST_PARAM_VALUE5_MASK___2 = 7936,
	EPDC_HIST_PARAM_VALUE5_OFFSET___2 = 8,
	EPDC_HIST_PARAM_VALUE6_MASK___2 = 2031616,
	EPDC_HIST_PARAM_VALUE6_OFFSET___2 = 16,
	EPDC_HIST_PARAM_VALUE7_MASK___2 = 520093696,
	EPDC_HIST_PARAM_VALUE7_OFFSET___2 = 24,
	EPDC_HIST_PARAM_VALUE8_MASK___2 = 31,
	EPDC_HIST_PARAM_VALUE8_OFFSET___2 = 0,
	EPDC_HIST_PARAM_VALUE9_MASK___2 = 7936,
	EPDC_HIST_PARAM_VALUE9_OFFSET___2 = 8,
	EPDC_HIST_PARAM_VALUE10_MASK___2 = 2031616,
	EPDC_HIST_PARAM_VALUE10_OFFSET___2 = 16,
	EPDC_HIST_PARAM_VALUE11_MASK___2 = 520093696,
	EPDC_HIST_PARAM_VALUE11_OFFSET___2 = 24,
	EPDC_HIST_PARAM_VALUE12_MASK___2 = 31,
	EPDC_HIST_PARAM_VALUE12_OFFSET___2 = 0,
	EPDC_HIST_PARAM_VALUE13_MASK___2 = 7936,
	EPDC_HIST_PARAM_VALUE13_OFFSET___2 = 8,
	EPDC_HIST_PARAM_VALUE14_MASK___2 = 2031616,
	EPDC_HIST_PARAM_VALUE14_OFFSET___2 = 16,
	EPDC_HIST_PARAM_VALUE15_MASK___2 = 520093696,
	EPDC_HIST_PARAM_VALUE15_OFFSET___2 = 24,
	EPDC_GPIO_PWRSTAT = 256,
	EPDC_GPIO_PWRWAKE = 128,
	EPDC_GPIO_PWRCOM___2 = 64,
	EPDC_GPIO_PWRCTRL_MASK___2 = 60,
	EPDC_GPIO_PWRCTRL_OFFSET___2 = 2,
	EPDC_GPIO_BDR_MASK___2 = 3,
	EPDC_GPIO_BDR_OFFSET___2 = 0,
	EPDC_VERSION_MAJOR_MASK___2 = 4278190080,
	EPDC_VERSION_MAJOR_OFFSET___2 = 24,
	EPDC_VERSION_MINOR_MASK___2 = 16711680,
	EPDC_VERSION_MINOR_OFFSET___2 = 16,
	EPDC_VERSION_STEP_MASK___2 = 65535,
	EPDC_VERSION_STEP_OFFSET___2 = 0,
};

struct mxc_epdc_fb_data___2 {
	struct fb_info info;
	struct fb_var_screeninfo epdc_fb_var;
	u32 pseudo_palette[16];
	char fw_str[32];
	struct list_head list;
	struct imx_epdc_fb_mode *cur_mode;
	struct imx_epdc_fb_platform_data *pdata;
	int blank;
	u32 max_pix_size;
	ssize_t map_size;
	dma_addr_t phys_start;
	void *virt_start;
	u32 fb_offset;
	int default_bpp;
	int native_width;
	int native_height;
	int num_screens;
	int epdc_irq;
	struct device *dev;
	int power_state;
	int wait_for_powerdown;
	struct completion powerdown_compl;
	struct clk *epdc_clk_axi;
	struct clk *epdc_clk_pix;
	struct clk *epdc_clk_ahb;
	struct regulator *display_regulator;
	struct regulator *vcom_regulator;
	struct regulator *v3p3_regulator;
	struct regulator *vpos_regulator;
	struct regulator *vneg_regulator;
	bool fw_default_load;
	int rev;
	int num_luts;
	int max_num_updates;
	bool in_init;
	bool hw_ready;
	bool hw_initializing;
	bool waiting_for_idle;
	u32 auto_mode;
	u32 upd_scheme;
	struct list_head upd_pending_list;
	struct list_head upd_buf_queue;
	struct list_head upd_buf_free_list;
	struct list_head upd_buf_collision_list;
	struct update_data_list *cur_update;
	struct mutex queue_mutex;
	int trt_entries;
	int temp_index;
	u8 *temp_range_bounds;
	struct mxcfb_waveform_modes wv_modes;
	bool wv_modes_update;
	bool waveform_is_advanced;
	u32 *waveform_buffer_virt;
	dma_addr_t waveform_buffer_phys;
	u32 waveform_buffer_size;
	u32 *working_buffer_virt;
	dma_addr_t working_buffer_phys;
	u32 working_buffer_size;
	u32 *tmp_working_buffer_virt;
	dma_addr_t tmp_working_buffer_phys;
	dma_addr_t *phys_addr_updbuf;
	void **virt_addr_updbuf;
	u32 upd_buffer_num;
	u32 max_num_buffers;
	dma_addr_t phys_addr_copybuf;
	void *virt_addr_copybuf;
	dma_addr_t phys_addr_y4;
	void *virt_addr_y4;
	dma_addr_t phys_addr_y4c;
	void *virt_addr_y4c;
	dma_addr_t phys_addr_black;
	void *virt_addr_black;
	u32 order_cnt;
	struct list_head full_marker_list;
	u32 *lut_update_order;
	u64 epdc_colliding_luts;
	u64 luts_complete_wb;
	u64 luts_complete;
	struct completion updates_done;
	struct delayed_work epdc_done_work;
	struct workqueue_struct *epdc_submit_workqueue;
	struct work_struct epdc_submit_work;
	struct workqueue_struct *epdc_intr_workqueue;
	struct work_struct epdc_intr_work;
	bool waiting_for_wb;
	bool waiting_for_lut;
	bool waiting_for_lut15;
	struct completion update_res_free;
	struct completion lut15_free;
	struct completion eof_event;
	int eof_sync_period;
	struct mutex power_mutex;
	bool powering_down;
	bool updates_active;
	int pwrdown_delay;
	long unsigned int tce_prevent;
	bool restrict_width;
	struct completion pxp_tx_cmpl;
	struct pxp_channel *pxp_chan;
	int: 32;
	struct pxp_config_data pxp_conf;
	struct dma_async_tx_descriptor *txd;
	dma_cookie_t cookie;
	struct scatterlist sg[14];
	struct mutex pxp_mutex;
	int epdc_wb_mode;
	struct pxp_collision_info col_info;
	u32 hist_status;
	struct regmap *gpr;
	u8 req_gpr;
	u8 req_bit;
	struct regmap *qos_regmap;
	int: 32;
};

enum ipu_channel {
	IDMAC_IC_0 = 0,
	IDMAC_IC_1 = 1,
	IDMAC_ADC_0 = 1,
	IDMAC_IC_2 = 2,
	IDMAC_ADC_1 = 2,
	IDMAC_IC_3 = 3,
	IDMAC_IC_4 = 4,
	IDMAC_IC_5 = 5,
	IDMAC_IC_6 = 6,
	IDMAC_IC_7 = 7,
	IDMAC_IC_8 = 8,
	IDMAC_IC_9 = 9,
	IDMAC_IC_10 = 10,
	IDMAC_IC_11 = 11,
	IDMAC_IC_12 = 12,
	IDMAC_IC_13 = 13,
	IDMAC_SDC_0 = 14,
	IDMAC_SDC_1 = 15,
	IDMAC_SDC_2 = 16,
	IDMAC_SDC_3 = 17,
	IDMAC_ADC_2 = 18,
	IDMAC_ADC_3 = 19,
	IDMAC_ADC_4 = 20,
	IDMAC_ADC_5 = 21,
	IDMAC_ADC_6 = 22,
	IDMAC_ADC_7 = 23,
	IDMAC_PF_0 = 24,
	IDMAC_PF_1 = 25,
	IDMAC_PF_2 = 26,
	IDMAC_PF_3 = 27,
	IDMAC_PF_4 = 28,
	IDMAC_PF_5 = 29,
	IDMAC_PF_6 = 30,
	IDMAC_PF_7 = 31,
};

enum ipu_channel_status {
	IPU_CHANNEL_FREE = 0,
	IPU_CHANNEL_INITIALIZED = 1,
	IPU_CHANNEL_READY = 2,
	IPU_CHANNEL_ENABLED = 3,
};

enum pixel_fmt {
	IPU_PIX_FMT_GENERIC = 0,
	IPU_PIX_FMT_RGB332 = 1,
	IPU_PIX_FMT_YUV420P = 2,
	IPU_PIX_FMT_YUV422P = 3,
	IPU_PIX_FMT_YUV420P2 = 4,
	IPU_PIX_FMT_YVU422P = 5,
	IPU_PIX_FMT_RGB565 = 6,
	IPU_PIX_FMT_RGB666 = 7,
	IPU_PIX_FMT_BGR666 = 8,
	IPU_PIX_FMT_YUYV = 9,
	IPU_PIX_FMT_UYVY = 10,
	IPU_PIX_FMT_RGB24 = 11,
	IPU_PIX_FMT_BGR24 = 12,
	IPU_PIX_FMT_GENERIC_32 = 13,
	IPU_PIX_FMT_RGB32 = 14,
	IPU_PIX_FMT_BGR32 = 15,
	IPU_PIX_FMT_ABGR32 = 16,
	IPU_PIX_FMT_BGRA32 = 17,
	IPU_PIX_FMT_RGBA32 = 18,
};

enum display_port {
	DISP0___2 = 0,
	DISP1___2 = 1,
	DISP2___2 = 2,
	DISP3___2 = 3,
};

struct idmac_video_param {
	short unsigned int in_width;
	short unsigned int in_height;
	uint32_t in_pixel_fmt;
	short unsigned int out_width;
	short unsigned int out_height;
	uint32_t out_pixel_fmt;
	short unsigned int out_stride;
	bool graphics_combine_en;
	bool global_alpha_en;
	bool key_color_en;
	enum display_port disp;
	short unsigned int out_left;
	short unsigned int out_top;
};

union ipu_channel_param {
	struct idmac_video_param video;
};

struct idmac_tx_desc {
	struct dma_async_tx_descriptor txd;
	struct scatterlist *sg;
	unsigned int sg_len;
	struct list_head list;
};

struct idmac_channel {
	struct dma_chan dma_chan;
	dma_cookie_t completed;
	union ipu_channel_param params;
	enum ipu_channel link;
	enum ipu_channel_status status;
	void *client;
	unsigned int n_tx_desc;
	struct idmac_tx_desc *desc;
	struct scatterlist *sg[2];
	struct list_head free_list;
	struct list_head queue;
	spinlock_t lock;
	struct mutex chan_mutex;
	bool sec_chan_en;
	int active_buffer;
	unsigned int eof_irq;
	char eof_name[16];
};

enum disp_data_mapping {
	IPU_DISP_DATA_MAPPING_RGB666 = 0,
	IPU_DISP_DATA_MAPPING_RGB565 = 1,
	IPU_DISP_DATA_MAPPING_RGB888 = 2,
};

struct mx3fb_platform_data {
	struct device *dma_dev;
	const char *name;
	const struct fb_videomode *mode;
	int num_modes;
	enum disp_data_mapping disp_data_fmt;
};

enum ipu_panel {
	IPU_PANEL_SHARP_TFT = 0,
	IPU_PANEL_TFT = 1,
};

struct ipu_di_signal_cfg {
	unsigned int datamask_en: 1;
	unsigned int clksel_en: 1;
	unsigned int clkidle_en: 1;
	unsigned int data_pol: 1;
	unsigned int clk_pol: 1;
	unsigned int enable_pol: 1;
	unsigned int Hsync_pol: 1;
	unsigned int Vsync_pol: 1;
};

struct mx3fb_data {
	struct fb_info *fbi;
	int backlight_level;
	void *reg_base;
	spinlock_t lock;
	struct device *dev;
	struct backlight_device *bl;
	uint32_t h_start_width;
	uint32_t v_start_width;
	enum disp_data_mapping disp_data_fmt;
};

struct dma_chan_request {
	struct mx3fb_data *mx3fb;
	enum ipu_channel id;
};

struct mx3fb_info {
	int blank;
	enum ipu_channel ipu_ch;
	uint32_t cur_ipu_buf;
	u32 pseudo_palette[16];
	struct completion flip_cmpl;
	struct mutex mutex;
	struct mx3fb_data *mx3fb;
	struct idmac_channel *idmac_channel;
	struct dma_async_tx_descriptor *txd;
	dma_cookie_t cookie;
	struct scatterlist sg[2];
	struct fb_var_screeninfo cur_var;
};

struct di_mapping {
	uint32_t b0;
	uint32_t b1;
	uint32_t b2;
};

struct timing_entry {
	u32 min;
	u32 typ;
	u32 max;
};

struct display_timing {
	struct timing_entry pixelclock;
	struct timing_entry hactive;
	struct timing_entry hfront_porch;
	struct timing_entry hback_porch;
	struct timing_entry hsync_len;
	struct timing_entry vactive;
	struct timing_entry vfront_porch;
	struct timing_entry vback_porch;
	struct timing_entry vsync_len;
	enum display_flags flags;
};

struct display_timings {
	unsigned int num_timings;
	unsigned int native_mode;
	struct display_timing **timings;
};

enum mxsfb_devtype {
	MXSFB_V3 = 0,
	MXSFB_V4 = 1,
	MXSFB_V5 = 2,
};

struct mxsfb_devdata {
	unsigned int transfer_count;
	unsigned int cur_buf;
	unsigned int next_buf;
	unsigned int debug0;
	unsigned int hs_wdth_mask;
	unsigned int hs_wdth_shift;
	unsigned int ipversion;
	u32 flags;
};

struct mxsfb_layer;

struct mxsfb_layer_ops {
	void (*enable)(struct mxsfb_layer *);
	void (*disable)(struct mxsfb_layer *);
	void (*setup)(struct mxsfb_layer *);
};

struct mxsfb_info;

struct mxsfb_layer {
	struct fb_info *ol_fb;
	int id;
	int registered;
	atomic_t usage;
	int blank_state;
	uint32_t global_alpha;
	struct mxsfb_layer_ops *ops;
	struct device *dev;
	void *video_mem;
	long unsigned int video_mem_phys;
	size_t video_mem_size;
	struct mxsfb_info *fbi;
};

struct mxsfb_info {
	struct fb_info *fb_info;
	struct platform_device *pdev;
	struct clk *clk_pix;
	struct clk *clk_axi;
	struct clk *clk_disp_axi;
	bool clk_pix_enabled;
	bool clk_axi_enabled;
	bool clk_disp_axi_enabled;
	void *base;
	u32 sync;
	unsigned int allocated_size;
	int enabled;
	unsigned int ld_intf_width;
	unsigned int dotclk_delay;
	const struct mxsfb_devdata *devdata;
	struct regulator *reg_lcd;
	bool wait4vsync;
	struct completion vsync_complete;
	struct completion flip_complete;
	int cur_blank;
	int restore_blank;
	char disp_dev[32];
	struct mxc_dispdrv_handle *dispdrv;
	int id;
	struct fb_var_screeninfo var;
	struct pm_qos_request pm_qos_req;
	char disp_videomode[32];
	struct mxsfb_layer overlay;
};

struct clk_bulk_data {
	const char *id;
	struct clk *clk;
};

struct devm_clk_state {
	struct clk *clk;
	void (*exit)(struct clk *);
};

struct clk_bulk_devres {
	struct clk_bulk_data *clks;
	int num_clks;
};

struct clk_hw;

struct clk_lookup {
	struct list_head node;
	const char *dev_id;
	const char *con_id;
	struct clk *clk;
	struct clk_hw *clk_hw;
};

struct clk_core;

struct clk_init_data;

struct clk_hw {
	struct clk_core *core;
	struct clk *clk;
	const struct clk_init_data *init;
};

struct clk_rate_request {
	long unsigned int rate;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int best_parent_rate;
	struct clk_hw *best_parent_hw;
};

struct clk_duty {
	unsigned int num;
	unsigned int den;
};

struct clk_ops {
	int (*prepare)(struct clk_hw *);
	void (*unprepare)(struct clk_hw *);
	int (*is_prepared)(struct clk_hw *);
	void (*unprepare_unused)(struct clk_hw *);
	int (*enable)(struct clk_hw *);
	void (*disable)(struct clk_hw *);
	int (*is_enabled)(struct clk_hw *);
	void (*disable_unused)(struct clk_hw *);
	int (*save_context)(struct clk_hw *);
	void (*restore_context)(struct clk_hw *);
	long unsigned int (*recalc_rate)(struct clk_hw *, long unsigned int);
	long int (*round_rate)(struct clk_hw *, long unsigned int, long unsigned int *);
	int (*determine_rate)(struct clk_hw *, struct clk_rate_request *);
	int (*set_parent)(struct clk_hw *, u8);
	u8 (*get_parent)(struct clk_hw *);
	int (*set_rate)(struct clk_hw *, long unsigned int, long unsigned int);
	int (*set_rate_and_parent)(struct clk_hw *, long unsigned int, long unsigned int, u8);
	long unsigned int (*recalc_accuracy)(struct clk_hw *, long unsigned int);
	int (*get_phase)(struct clk_hw *);
	int (*set_phase)(struct clk_hw *, int);
	int (*get_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*set_duty_cycle)(struct clk_hw *, struct clk_duty *);
	int (*init)(struct clk_hw *);
	void (*terminate)(struct clk_hw *);
	void (*debug_init)(struct clk_hw *, struct dentry *);
};

struct clk_parent_data {
	const struct clk_hw *hw;
	const char *fw_name;
	const char *name;
	int index;
};

struct clk_init_data {
	const char *name;
	const struct clk_ops *ops;
	const char * const *parent_names;
	const struct clk_parent_data *parent_data;
	const struct clk_hw **parent_hws;
	u8 num_parents;
	long unsigned int flags;
};

struct clk_lookup_alloc {
	struct clk_lookup cl;
	char dev_id[20];
	char con_id[16];
};

struct clk_notifier {
	struct clk *clk;
	struct srcu_notifier_head notifier_head;
	struct list_head node;
};

struct clk {
	struct clk_core *core;
	struct device *dev;
	const char *dev_id;
	const char *con_id;
	long unsigned int min_rate;
	long unsigned int max_rate;
	unsigned int exclusive_count;
	struct hlist_node clks_node;
};

struct clk_parent_map;

struct clk_core {
	const char *name;
	const struct clk_ops *ops;
	struct clk_hw *hw;
	struct module *owner;
	struct device *dev;
	struct device_node *of_node;
	struct clk_core *parent;
	struct clk_parent_map *parents;
	u8 num_parents;
	u8 new_parent_index;
	long unsigned int rate;
	long unsigned int req_rate;
	long unsigned int new_rate;
	struct clk_core *new_parent;
	struct clk_core *new_child;
	long unsigned int flags;
	bool orphan;
	bool rpm_enabled;
	unsigned int enable_count;
	unsigned int prepare_count;
	unsigned int protect_count;
	long unsigned int min_rate;
	long unsigned int max_rate;
	long unsigned int accuracy;
	int phase;
	struct clk_duty duty;
	struct hlist_head children;
	struct hlist_node child_node;
	struct hlist_head clks;
	unsigned int notifier_count;
	struct dentry *dentry;
	struct hlist_node debug_node;
	struct kref ref;
};

struct clk_onecell_data {
	struct clk **clks;
	unsigned int clk_num;
};

struct clk_hw_onecell_data {
	unsigned int num;
	struct clk_hw *hws[0];
};

struct clk_parent_map {
	const struct clk_hw *hw;
	struct clk_core *core;
	const char *fw_name;
	const char *name;
	int index;
};

struct trace_event_raw_clk {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_clk_rate {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int rate;
	char __data[0];
};

struct trace_event_raw_clk_rate_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	long unsigned int min;
	long unsigned int max;
	char __data[0];
};

struct trace_event_raw_clk_parent {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_pname;
	char __data[0];
};

struct trace_event_raw_clk_phase {
	struct trace_entry ent;
	u32 __data_loc_name;
	int phase;
	char __data[0];
};

struct trace_event_raw_clk_duty_cycle {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int num;
	unsigned int den;
	char __data[0];
};

struct trace_event_data_offsets_clk {
	u32 name;
};

struct trace_event_data_offsets_clk_rate {
	u32 name;
};

struct trace_event_data_offsets_clk_rate_range {
	u32 name;
};

struct trace_event_data_offsets_clk_parent {
	u32 name;
	u32 pname;
};

struct trace_event_data_offsets_clk_phase {
	u32 name;
};

struct trace_event_data_offsets_clk_duty_cycle {
	u32 name;
};

typedef void (*btf_trace_clk_enable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_enable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable)(void *, struct clk_core *);

typedef void (*btf_trace_clk_disable_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_prepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare)(void *, struct clk_core *);

typedef void (*btf_trace_clk_unprepare_complete)(void *, struct clk_core *);

typedef void (*btf_trace_clk_set_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_complete)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_min_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_max_rate)(void *, struct clk_core *, long unsigned int);

typedef void (*btf_trace_clk_set_rate_range)(void *, struct clk_core *, long unsigned int, long unsigned int);

typedef void (*btf_trace_clk_set_parent)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_parent_complete)(void *, struct clk_core *, struct clk_core *);

typedef void (*btf_trace_clk_set_phase)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_phase_complete)(void *, struct clk_core *, int);

typedef void (*btf_trace_clk_set_duty_cycle)(void *, struct clk_core *, struct clk_duty *);

typedef void (*btf_trace_clk_set_duty_cycle_complete)(void *, struct clk_core *, struct clk_duty *);

struct clk_notifier_devres {
	struct clk *clk;
	struct notifier_block *nb;
};

struct of_clk_provider {
	struct list_head link;
	struct device_node *node;
	struct clk * (*get)(struct of_phandle_args *, void *);
	struct clk_hw * (*get_hw)(struct of_phandle_args *, void *);
	void *data;
};

struct clock_provider {
	void (*clk_init_cb)(struct device_node *);
	struct device_node *np;
	struct list_head node;
};

struct clk_div_table {
	unsigned int val;
	unsigned int div;
};

struct clk_divider {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	const struct clk_div_table *table;
	spinlock_t *lock;
};

typedef void (*of_init_fn_1)(struct device_node *);

struct clk_fixed_factor {
	struct clk_hw hw;
	unsigned int mult;
	unsigned int div;
};

struct clk_fixed_rate {
	struct clk_hw hw;
	long unsigned int fixed_rate;
	long unsigned int fixed_accuracy;
	long unsigned int flags;
};

struct clk_gate {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 flags;
	spinlock_t *lock;
};

struct clk_multiplier {
	struct clk_hw hw;
	void *reg;
	u8 shift;
	u8 width;
	u8 flags;
	spinlock_t *lock;
};

struct clk_mux {
	struct clk_hw hw;
	void *reg;
	const u32 *table;
	u32 mask;
	u8 shift;
	u8 flags;
	spinlock_t *lock;
};

struct clk_composite {
	struct clk_hw hw;
	struct clk_ops ops;
	struct clk_hw *mux_hw;
	struct clk_hw *rate_hw;
	struct clk_hw *gate_hw;
	const struct clk_ops *mux_ops;
	const struct clk_ops *rate_ops;
	const struct clk_ops *gate_ops;
};

struct clk_fractional_divider {
	struct clk_hw hw;
	void *reg;
	u8 mshift;
	u8 mwidth;
	u32 mmask;
	u8 nshift;
	u8 nwidth;
	u32 nmask;
	u8 flags;
	void (*approximation)(struct clk_hw *, long unsigned int, long unsigned int *, long unsigned int *, long unsigned int *);
	spinlock_t *lock;
};

struct clk_gpio {
	struct clk_hw hw;
	struct gpio_desc *gpiod;
};

struct clk_pwm {
	struct clk_hw hw;
	struct pwm_device *pwm;
	u32 fixed_rate;
};

struct clk_busy_divider {
	struct clk_divider div;
	const struct clk_ops *div_ops;
	void *reg;
	u8 shift;
};

struct clk_busy_mux {
	struct clk_mux mux;
	const struct clk_ops *mux_ops;
	void *reg;
	u8 shift;
};

struct imx_fracn_gppll_rate_table {
	unsigned int rate;
	unsigned int mfi;
	unsigned int mfn;
	unsigned int mfd;
	unsigned int rdiv;
	unsigned int odiv;
};

struct imx_fracn_gppll_clk {
	const struct imx_fracn_gppll_rate_table *rate_table;
	int rate_count;
	int flags;
};

struct clk_fracn_gppll {
	struct clk_hw hw;
	void *base;
	const struct imx_fracn_gppll_rate_table *rate_table;
	int rate_count;
};

struct clk_cpu {
	struct clk_hw hw;
	struct clk *div;
	struct clk *mux;
	struct clk *pll;
	struct clk *step;
};

struct clk_divider_gate {
	struct clk_divider divider;
	u32 cached_val;
};

struct clk_fixup_div {
	struct clk_divider divider;
	const struct clk_ops *ops;
	void (*fixup)(u32 *);
};

struct clk_fixup_mux {
	struct clk_mux mux;
	const struct clk_ops *ops;
	void (*fixup)(u32 *);
};

struct clk_frac_pll {
	struct clk_hw hw;
	void *base;
};

struct imx_sema4_mutex {
	u32 valid;
	u32 gate_num;
	unsigned char gate_val;
	wait_queue_head_t wait_q;
};

struct imx_shared_clk {
	struct clk *self;
	struct clk *parent;
	void *m4_clk;
	void *m4_clk_parent;
	u8 ca9_enabled;
	u8 cm4_enabled;
};

struct imx_shared_mem {
	u32 ca9_valid;
	u32 cm4_valid;
	struct imx_shared_clk imx_clk[100];
};

struct clk_gate2 {
	struct clk_hw hw;
	void *reg;
	u8 bit_idx;
	u8 cgr_val;
	u8 cgr_mask;
	u8 flags;
	spinlock_t *lock;
	unsigned int *share_count;
};

struct imx93_clk_gate {
	struct clk_hw hw;
	void *reg;
	u32 bit_idx;
	u32 val;
	u32 mask;
	spinlock_t *lock;
	unsigned int *share_count;
};

struct clk_gate_exclusive {
	struct clk_gate gate;
	u32 exclusive_mask;
};

struct clk_pfd {
	struct clk_hw hw;
	void *reg;
	u8 idx;
};

enum imx_pfdv2_type {
	IMX_PFDV2_IMX7ULP = 0,
	IMX_PFDV2_IMX8ULP = 1,
};

struct clk_pfdv2 {
	struct clk_hw hw;
	void *reg;
	u8 gate_bit;
	u8 vld_bit;
	u8 frac_off;
};

enum imx_pllv1_type {
	IMX_PLLV1_IMX1 = 0,
	IMX_PLLV1_IMX21 = 1,
	IMX_PLLV1_IMX25 = 2,
	IMX_PLLV1_IMX27 = 3,
	IMX_PLLV1_IMX31 = 4,
	IMX_PLLV1_IMX35 = 5,
};

struct clk_pllv1 {
	struct clk_hw hw;
	void *base;
	enum imx_pllv1_type type;
};

struct clk_pllv2 {
	struct clk_hw hw;
	void *base;
};

enum imx_pllv3_type {
	IMX_PLLV3_GENERIC = 0,
	IMX_PLLV3_SYS = 1,
	IMX_PLLV3_USB = 2,
	IMX_PLLV3_USB_VF610 = 3,
	IMX_PLLV3_AV = 4,
	IMX_PLLV3_ENET = 5,
	IMX_PLLV3_ENET_IMX7 = 6,
	IMX_PLLV3_SYS_VF610 = 7,
	IMX_PLLV3_DDR_IMX7 = 8,
	IMX_PLLV3_AV_IMX7 = 9,
};

struct clk_pllv3 {
	struct clk_hw hw;
	void *base;
	u32 power_bit;
	bool powerup_set;
	u32 div_mask;
	u32 div_shift;
	long unsigned int ref_clock;
	u32 num_offset;
	u32 denom_offset;
};

struct clk_pllv3_vf610_mf {
	u32 mfi;
	u32 mfn;
	u32 mfd;
};

enum imx_pllv4_type {
	IMX_PLLV4_IMX7ULP = 0,
	IMX_PLLV4_IMX8ULP = 1,
};

struct clk_pllv4 {
	struct clk_hw hw;
	void *base;
	u32 cfg_offset;
	u32 num_offset;
	u32 denom_offset;
};

enum imx_pll14xx_type {
	PLL_1416X = 0,
	PLL_1443X = 1,
};

struct imx_pll14xx_rate_table {
	unsigned int rate;
	unsigned int pdiv;
	unsigned int mdiv;
	unsigned int sdiv;
	unsigned int kdiv;
};

struct imx_pll14xx_clk {
	enum imx_pll14xx_type type;
	const struct imx_pll14xx_rate_table *rate_table;
	int rate_count;
	int flags;
};

struct clk_pll14xx {
	struct clk_hw hw;
	void *base;
	enum imx_pll14xx_type type;
	const struct imx_pll14xx_rate_table *rate_table;
	int rate_count;
};

struct clk_sscg_pll_setup {
	int divr1;
	int divf1;
	int divr2;
	int divf2;
	int divq;
	int bypass;
	uint64_t vco1;
	uint64_t vco2;
	uint64_t fout;
	uint64_t ref;
	uint64_t ref_div1;
	uint64_t ref_div2;
	uint64_t fout_request;
	int fout_error;
	int: 32;
};

struct clk_sscg_pll {
	struct clk_hw hw;
	const struct clk_ops ops;
	void *base;
	int: 32;
	struct clk_sscg_pll_setup setup;
	u8 parent;
	u8 bypass1;
	u8 bypass2;
	int: 8;
	int: 32;
};

struct dma_chan_tbl_ent {
	struct dma_chan *chan;
};

struct dmaengine_unmap_pool {
	struct kmem_cache *cache;
	const char *name;
	mempool_t *pool;
	size_t size;
};

struct dmaengine_desc_callback {
	dma_async_tx_callback callback;
	dma_async_tx_callback_result callback_result;
	void *callback_param;
};

struct virt_dma_desc {
	struct dma_async_tx_descriptor tx;
	struct dmaengine_result tx_result;
	struct list_head node;
};

struct virt_dma_chan {
	struct dma_chan chan;
	struct tasklet_struct task;
	void (*desc_free)(struct virt_dma_desc *);
	spinlock_t lock;
	struct list_head desc_allocated;
	struct list_head desc_submitted;
	struct list_head desc_issued;
	struct list_head desc_completed;
	struct list_head desc_terminated;
	struct virt_dma_desc *cyclic;
};

struct of_dma {
	struct list_head of_dma_controllers;
	struct device_node *of_node;
	struct dma_chan * (*of_dma_xlate)(struct of_phandle_args *, struct of_dma *);
	void * (*of_dma_route_allocate)(struct of_phandle_args *, struct of_dma *);
	struct dma_router *dma_router;
	void *of_dma_data;
};

struct of_dma_filter_info {
	dma_cap_mask_t dma_cap;
	dma_filter_fn filter_fn;
};

enum fsl_edma_pm_state {
	RUNNING = 0,
	SUSPENDED = 1,
};

struct fsl_edma_hw_tcd {
	__le32 saddr;
	__le16 soff;
	__le16 attr;
	__le32 nbytes;
	__le32 slast;
	__le32 daddr;
	__le16 doff;
	__le16 citer;
	__le32 dlast_sga;
	__le16 csr;
	__le16 biter;
};

struct edma_regs {
	void *cr;
	void *es;
	void *erqh;
	void *erql;
	void *eeih;
	void *eeil;
	void *seei;
	void *ceei;
	void *serq;
	void *cerq;
	void *cint;
	void *cerr;
	void *ssrt;
	void *cdne;
	void *inth;
	void *intl;
	void *errh;
	void *errl;
	struct fsl_edma_hw_tcd *tcd;
};

struct fsl_edma_sw_tcd {
	dma_addr_t ptcd;
	struct fsl_edma_hw_tcd *vtcd;
};

struct dma_pool;

struct fsl_edma_engine;

struct fsl_edma_desc;

struct fsl_edma_chan {
	struct virt_dma_chan vchan;
	enum dma_status status;
	enum fsl_edma_pm_state pm_state;
	bool idle;
	u32 slave_id;
	struct fsl_edma_engine *edma;
	struct fsl_edma_desc *edesc;
	struct dma_slave_config cfg;
	u32 attr;
	bool is_sw;
	struct dma_pool *tcd_pool;
	dma_addr_t dma_dev_addr;
	u32 dma_dev_size;
	enum dma_data_direction dma_dir;
	char chan_name[16];
	u32 chn_real_count;
};

struct fsl_edma_drvdata;

struct fsl_edma_engine {
	struct dma_device dma_dev;
	void *membase;
	void *muxbase[2];
	struct clk *muxclk[2];
	struct clk *dmaclk;
	struct mutex fsl_edma_mutex;
	const struct fsl_edma_drvdata *drvdata;
	u32 n_chans;
	int *txirqs;
	int errirq;
	bool big_endian;
	struct edma_regs regs;
	struct fsl_edma_chan chans[0];
};

struct fsl_edma_desc {
	struct virt_dma_desc vdesc;
	struct fsl_edma_chan *echan;
	bool iscyclic;
	enum dma_transfer_direction dirn;
	unsigned int n_tcds;
	struct fsl_edma_sw_tcd tcd[0];
};

enum edma_version {
	v1 = 0,
	v2 = 1,
	v3 = 2,
};

struct fsl_edma_drvdata {
	enum edma_version version;
	u32 dmamuxs;
	bool has_dmaclk;
	bool mux_swap;
	int (*setup_irq)(struct platform_device *, struct fsl_edma_engine *);
	u8 txirq_count;
};

struct mxs_dma_ccw {
	u32 next;
	u16 bits;
	u16 xfer_bytes;
	u32 bufaddr;
	u32 pio_words[16];
};

struct mxs_dma_engine;

struct mxs_dma_chan {
	struct mxs_dma_engine *mxs_dma;
	struct dma_chan chan;
	struct dma_async_tx_descriptor desc;
	struct tasklet_struct tasklet;
	unsigned int chan_irq;
	struct mxs_dma_ccw *ccw;
	dma_addr_t ccw_phys;
	int desc_count;
	enum dma_status status;
	unsigned int flags;
	bool reset;
	struct dma_pool *ccw_pool;
};

enum mxs_dma_id {
	IMX23_DMA = 0,
	IMX28_DMA = 1,
};

enum mxs_dma_devtype {
	MXS_DMA_APBH = 0,
	MXS_DMA_APBX = 1,
};

struct mxs_dma_engine {
	enum mxs_dma_id dev_id;
	enum mxs_dma_devtype type;
	void *base;
	struct clk *clk;
	struct dma_device dma_device;
	struct mxs_dma_chan mxs_chans[16];
	struct platform_device *pdev;
	unsigned int nr_channels;
};

struct mxs_dma_type {
	enum mxs_dma_id id;
	enum mxs_dma_devtype type;
};

struct mxs_dma_filter_param {
	unsigned int chan_id;
};

struct idmac {
	struct dma_device dma;
};

struct ipu {
	void *reg_ipu;
	void *reg_ic;
	unsigned int irq_fn;
	unsigned int irq_err;
	unsigned int irq_base;
	long unsigned int channel_init_mask;
	spinlock_t lock;
	struct clk *ipu_clk;
	struct device *dev;
	struct idmac idmac;
	struct idmac_channel channel[32];
	struct tasklet_struct tasklet;
};

struct ipu_irq_bank {
	unsigned int control;
	unsigned int status;
	struct ipu *ipu;
};

struct ipu_irq_map {
	unsigned int irq;
	int source;
	struct ipu_irq_bank *bank;
	struct ipu *ipu;
};

enum ipu_color_space {
	IPU_COLORSPACE_RGB = 0,
	IPU_COLORSPACE_YCBCR = 1,
	IPU_COLORSPACE_YUV = 2,
};

enum ipu_rotate_mode {
	IPU_ROTATE_NONE = 0,
	IPU_ROTATE_VERT_FLIP = 1,
	IPU_ROTATE_HORIZ_FLIP = 2,
	IPU_ROTATE_180 = 3,
	IPU_ROTATE_90_RIGHT = 4,
	IPU_ROTATE_90_RIGHT_VFLIP = 5,
	IPU_ROTATE_90_RIGHT_HFLIP = 6,
	IPU_ROTATE_90_LEFT = 7,
};

struct chan_param_mem_planar {
	u32 xv: 10;
	u32 yv: 10;
	u32 xb: 12;
	u32 yb: 12;
	u32 res1: 2;
	u32 nsb: 1;
	u32 lnpb: 6;
	u32 ubo_l: 11;
	u32 ubo_h: 15;
	u32 vbo_l: 17;
	u32 vbo_h: 9;
	u32 res2: 3;
	u32 fw: 12;
	u32 fh_l: 8;
	u32 fh_h: 4;
	u32 res3: 28;
	u32 eba0;
	u32 eba1;
	u32 bpp: 3;
	u32 sl: 14;
	u32 pfs: 3;
	u32 bam: 3;
	u32 res4: 2;
	u32 npb: 6;
	u32 res5: 1;
	u32 sat: 2;
	u32 res6: 30;
};

struct chan_param_mem_interleaved {
	u32 xv: 10;
	u32 yv: 10;
	u32 xb: 12;
	u32 yb: 12;
	u32 sce: 1;
	u32 res1: 1;
	u32 nsb: 1;
	u32 lnpb: 6;
	u32 sx: 10;
	u32 sy_l: 1;
	u32 sy_h: 9;
	u32 ns: 10;
	u32 sm: 10;
	u32 sdx_l: 3;
	u32 sdx_h: 2;
	u32 sdy: 5;
	u32 sdrx: 1;
	u32 sdry: 1;
	u32 sdr1: 1;
	u32 res2: 2;
	u32 fw: 12;
	u32 fh_l: 8;
	u32 fh_h: 4;
	u32 res3: 28;
	u32 eba0;
	u32 eba1;
	u32 bpp: 3;
	u32 sl: 14;
	u32 pfs: 3;
	u32 bam: 3;
	u32 res4: 2;
	u32 npb: 6;
	u32 res5: 1;
	u32 sat: 2;
	u32 scc: 1;
	u32 ofs0: 5;
	u32 ofs1: 5;
	u32 ofs2: 5;
	u32 ofs3: 5;
	u32 wid0: 3;
	u32 wid1: 3;
	u32 wid2: 3;
	u32 wid3: 3;
	u32 dec_sel: 1;
	u32 res6: 28;
};

union chan_param_mem {
	struct chan_param_mem_planar pp;
	struct chan_param_mem_interleaved ip;
};

struct pxp_dma {
	struct dma_device dma;
};

struct pxps {
	struct platform_device *pdev;
	struct clk *clk;
	struct clk *clk_disp_axi;
	void *base;
	int irq;
	spinlock_t lock;
	struct mutex clk_mutex;
	int clk_stat;
	int pxp_ongoing;
	int lut_state;
	struct device *dev;
	struct pxp_dma pxp_dma;
	struct pxp_channel channel[16];
	struct work_struct work;
	struct pxp_config_data pxp_conf_state;
	struct timer_list clk_timer;
	struct task_struct *dispatch;
	wait_queue_head_t thread_waitq;
	struct completion complete;
	int: 32;
};

struct mux_config {
	uint32_t mux0_sel: 2;
	uint32_t mux1_sel: 2;
	uint32_t mux2_sel: 2;
	uint32_t mux3_sel: 2;
	uint32_t mux4_sel: 2;
	uint32_t mux5_sel: 2;
	uint32_t mux6_sel: 2;
	uint32_t mux7_sel: 2;
	uint32_t mux8_sel: 2;
	uint32_t mux9_sel: 2;
	uint32_t mux10_sel: 2;
	uint32_t mux11_sel: 2;
	uint32_t mux12_sel: 2;
	uint32_t mux13_sel: 2;
	uint32_t mux14_sel: 2;
	uint32_t mux15_sel: 2;
};

struct ps_ctrl {
	uint32_t format: 6;
	uint32_t wb_swap: 1;
	uint32_t rsvd0: 1;
	uint32_t decy: 2;
	uint32_t decx: 2;
	uint32_t rsvd1: 20;
};

struct ps_scale {
	uint32_t xscale: 15;
	uint32_t rsvd1: 1;
	uint32_t yscale: 15;
	uint32_t rsvd2: 1;
};

struct as_ctrl {
	uint32_t rsvd0: 1;
	uint32_t alpha_ctrl: 2;
	uint32_t enable_colorkey: 1;
	uint32_t format: 4;
	uint32_t alpha: 8;
	uint32_t rop: 4;
	uint32_t alpha0_invert: 1;
	uint32_t alpha1_invert: 1;
	uint32_t rsvd1: 10;
};

struct out_ctrl {
	uint32_t format: 5;
	uint32_t rsvd0: 3;
	uint32_t interlaced_output: 2;
	uint32_t rsvd1: 13;
	uint32_t alpha_output: 1;
	uint32_t alpha: 8;
};

struct coordinate {
	uint32_t y: 14;
	uint32_t rsvd0: 2;
	uint32_t x: 14;
	uint32_t rsvd1: 2;
};

struct pxp_alpha_ctrl {
	uint32_t poter_duff_enable: 1;
	uint32_t s0_s1_factor_mode: 2;
	uint32_t s0_global_alpha_mode: 2;
	uint32_t s0_alpha_mode: 1;
	uint32_t s0_color_mode: 1;
	uint32_t rsvd1: 1;
	uint32_t s1_s0_factor_mode: 2;
	uint32_t s1_global_alpha_mode: 2;
	uint32_t s1_alpha_mode: 1;
	uint32_t s1_color_mode: 1;
	uint32_t rsvd0: 2;
	uint32_t s0_global_alpha: 8;
	uint32_t s1_global_alpha: 8;
};

struct store_ctrl {
	uint32_t ch_en: 1;
	uint32_t block_en: 1;
	uint32_t block_16: 1;
	uint32_t handshake_en: 1;
	uint32_t array_en: 1;
	uint32_t array_line_num: 2;
	uint32_t rsvd3: 1;
	uint32_t store_bypass_en: 1;
	uint32_t store_memory_en: 1;
	uint32_t pack_in_sel: 1;
	uint32_t fill_data_en: 1;
	uint32_t rsvd2: 4;
	uint32_t wr_num_bytes: 2;
	uint32_t rsvd1: 6;
	uint32_t combine_2channel: 1;
	uint32_t rsvd0: 6;
	uint32_t arbit_en: 1;
};

struct store_size {
	uint32_t out_width: 16;
	uint32_t out_height: 16;
};

struct store_pitch {
	uint32_t ch0_out_pitch: 16;
	uint32_t ch1_out_pitch: 16;
};

struct store_shift_ctrl {
	uint32_t rsvd2: 2;
	uint32_t output_active_bpp: 2;
	uint32_t out_yuv422_1p_en: 1;
	uint32_t out_yuv422_2p_en: 1;
	uint32_t rsvd1: 1;
	uint32_t shift_bypass: 1;
	uint32_t rsvd0: 24;
};

struct store_d_shift {
	uint64_t d_shift_width0: 6;
	uint64_t rsvd3: 1;
	uint64_t d_shift_flag0: 1;
	uint64_t d_shift_width1: 6;
	uint64_t rsvd2: 1;
	uint64_t d_shift_flag1: 1;
	uint64_t d_shift_width2: 6;
	uint64_t rsvd1: 1;
	uint64_t d_shift_flag2: 1;
	uint64_t d_shift_width3: 6;
	uint64_t rsvd0: 1;
	uint64_t d_shift_flag3: 1;
	uint64_t d_shift_width4: 6;
	uint64_t rsvd7: 1;
	uint64_t d_shift_flag4: 1;
	uint64_t d_shift_width5: 6;
	uint64_t rsvd6: 1;
	uint64_t d_shift_flag5: 1;
	uint64_t d_shift_width6: 6;
	uint64_t rsvd5: 1;
	uint64_t d_shift_flag6: 1;
	uint64_t d_shift_width7: 6;
	uint64_t rsvd4: 1;
	uint64_t d_shift_flag7: 1;
};

struct store_d_mask {
	uint64_t d_mask_l: 32;
	uint64_t d_mask_h: 32;
};

struct fetch_ctrl {
	uint32_t ch_en: 1;
	uint32_t block_en: 1;
	uint32_t block_16: 1;
	uint32_t handshake_en: 1;
	uint32_t bypass_pixel_en: 1;
	uint32_t high_byte: 1;
	uint32_t rsvd4: 3;
	uint32_t hflip: 1;
	uint32_t vflip: 1;
	uint32_t rsvd3: 1;
	uint32_t rotation_angle: 2;
	uint32_t rsvd2: 2;
	uint32_t rd_num_bytes: 2;
	uint32_t rsvd1: 6;
	uint32_t handshake_scan_line_num: 2;
	uint32_t rsvd0: 5;
	uint32_t arbit_en: 1;
};

struct fetch_active_size_ulc {
	uint32_t active_size_ulc_x: 16;
	uint32_t active_size_ulc_y: 16;
};

struct fetch_active_size_lrc {
	uint32_t active_size_lrc_x: 16;
	uint32_t active_size_lrc_y: 16;
};

struct fetch_size {
	uint32_t input_total_width: 16;
	uint32_t input_total_height: 16;
};

struct fetch_pitch {
	uint32_t ch0_input_pitch: 16;
	uint32_t ch1_input_pitch: 16;
};

struct fetch_shift_ctrl {
	uint32_t input_active_bpp: 2;
	uint32_t rsvd1: 6;
	uint32_t expand_format: 3;
	uint32_t expand_en: 1;
	uint32_t shift_bypass: 1;
	uint32_t rsvd0: 19;
};

struct fetch_shift_offset {
	uint32_t offset0: 5;
	uint32_t rsvd3: 3;
	uint32_t offset1: 5;
	uint32_t rsvd2: 3;
	uint32_t offset2: 5;
	uint32_t rsvd1: 3;
	uint32_t offset3: 5;
	uint32_t rsvd0: 3;
};

struct fetch_shift_width {
	uint32_t width0: 4;
	uint32_t width1: 4;
	uint32_t width2: 4;
	uint32_t width3: 4;
	uint32_t rsvd0: 16;
};

enum pxp_alpha_blending_version {
	PXP_ALPHA_BLENDING_NONE = 0,
	PXP_ALPHA_BLENDING_V1 = 1,
	PXP_ALPHA_BLENDING_V2 = 2,
};

struct pxp_alpha_global {
	unsigned int color_key_enable;
	bool combine_enable;
	bool global_alpha_enable;
	bool global_override;
	bool alpha_invert;
	bool local_alpha_enable;
	unsigned char global_alpha;
	int comp_mask;
};

struct rectangle {
	uint16_t x;
	uint16_t y;
	uint16_t width;
	uint16_t height;
};

struct pxp_alpha_info {
	uint8_t alpha_mode;
	uint8_t rop_type;
	struct pxp_alpha s0_alpha;
	struct pxp_alpha s1_alpha;
};

struct pxp_op_info {
	uint16_t op_type;
	uint16_t rotation;
	uint8_t flip;
	uint8_t fill_en;
	uint32_t fill_data;
	uint8_t alpha_blending;
	struct pxp_alpha_info alpha_info;
	uint32_t dither_mode;
	uint32_t quant_bit;
	bool partial_update;
	bool alpha_en;
	bool lut_update;
	bool reagl_en;
	bool reagl_d_en;
	bool detection_only;
	int lut;
	uint32_t lut_status_1;
	uint32_t lut_status_2;
};

struct pxp_pixmap {
	uint8_t channel_id;
	uint8_t bpp;
	int32_t pitch;
	uint16_t width;
	uint16_t height;
	struct rectangle crop;
	uint32_t rotate;
	uint8_t flip;
	uint32_t format;
	uint32_t flags;
	bool valid;
	dma_addr_t paddr;
	dma_addr_t paddr_u;
	dma_addr_t paddr_v;
	struct pxp_alpha_global g_alpha;
};

struct pxp_task_info {
	uint8_t input_num;
	uint8_t output_num;
	struct pxp_pixmap input[2];
	struct pxp_pixmap output[2];
	struct pxp_op_info op_info;
	uint32_t pxp_2d_flags;
};

struct pxp_devdata;

struct pxps___2 {
	struct platform_device *pdev;
	struct clk *ipg_clk;
	struct clk *axi_clk;
	void *base;
	int irq;
	spinlock_t lock;
	struct mutex clk_mutex;
	int clk_stat;
	int pxp_ongoing;
	int lut_state;
	struct device *dev;
	struct pxp_dma pxp_dma;
	struct pxp_channel channel[16];
	struct work_struct work;
	const struct pxp_devdata *devdata;
	struct pxp_task_info task;
	int: 32;
	struct pxp_config_data pxp_conf_state;
	struct timer_list clk_timer;
	struct task_struct *dispatch;
	wait_queue_head_t thread_waitq;
	struct completion complete;
	struct regmap *gpr;
};

struct pxp_devdata {
	void (*pxp_wfe_a_configure)(struct pxps___2 *);
	void (*pxp_wfe_a_process)(struct pxps___2 *);
	void (*pxp_lut_status_set)(struct pxps___2 *, unsigned int);
	void (*pxp_lut_status_clr)(unsigned int);
	void (*pxp_dithering_configure)(struct pxps___2 *);
	void (*pxp_lut_cleanup_multiple)(struct pxps___2 *, u64, bool);
	void (*pxp_data_path_config)(struct pxps___2 *);
	void (*pxp_restart)(struct pxps___2 *);
	unsigned int version;
	bool input_fetch_arbit_en;
};

struct color_component {
	uint8_t id;
	uint8_t offset;
	uint8_t length;
	uint8_t mask;
};

struct color {
	uint32_t format;
	struct color_component comp[4];
};

struct mux {
	uint32_t id;
	uint8_t mux_inputs[4];
	uint8_t mux_outputs[2];
};

struct edge_node {
	uint32_t adjvex;
	uint32_t prev_vnode;
	struct edge_node *next;
	long unsigned int mux_used;
	struct mux_config muxes;
};

struct vetex_node {
	uint8_t type;
	struct edge_node *first;
};

struct path_node {
	struct list_head node;
	uint32_t id;
	uint32_t distance;
	uint32_t prev_node;
};

enum {
	DITHER0_LUT = 0,
	DITHER0_ERR0 = 1,
	DITHER0_ERR1 = 2,
	DITHER1_LUT = 3,
	DITHER2_LUT = 4,
	ALU_A = 5,
	ALU_B = 6,
	WFE_A = 7,
	WFE_B = 8,
	RESERVED = 21,
};

enum pxp_devtype {
	PXP_V3 = 0,
	PXP_V3P = 1,
	PXP_V3_8ULP = 2,
	PXP_V3_IMX93 = 3,
};

struct pxp_register {
	u32 offset;
	const char * const name;
	bool opt;
};

struct pxp_chan_handle {
	unsigned int handle;
	int hist_status;
};

struct pxp_mem_desc {
	unsigned int handle;
	unsigned int size;
	dma_addr_t phys_addr;
	void *virt_uaddr;
	unsigned int mtype;
	__u32 flags;
	__s32 fd;
};

struct pxp_mem_flush {
	unsigned int handle;
	unsigned int type;
};

struct pxp_irq_info {
	wait_queue_head_t waitq;
	atomic_t irq_pending;
	int hist_status;
};

struct pxp_buffer_hash {
	struct hlist_head *hash_table;
	u32 order;
	spinlock_t hash_lock;
};

struct dma_buf_attachment;

struct pxp_buf_obj {
	uint32_t handle;
	uint32_t size;
	uint32_t mem_type;
	long unsigned int offset;
	void *virtual;
	long unsigned int attrs;
	struct hlist_node item;
	struct sg_table *sgt_base;
	struct dma_buf_attachment *db_attach;
};

struct dma_buf;

struct dma_buf_attach_ops;

struct dma_buf_attachment {
	struct dma_buf *dmabuf;
	struct device *dev;
	struct list_head node;
	struct sg_table *sgt;
	enum dma_data_direction dir;
	bool peer2peer;
	const struct dma_buf_attach_ops *importer_ops;
	void *importer_priv;
	void *priv;
};

struct pxp_chan_obj {
	uint32_t handle;
	struct dma_chan *chan;
};

struct pxp_file {
	struct file *filp;
	struct idr buffer_idr;
	spinlock_t buffer_lock;
	struct idr channel_idr;
	spinlock_t channel_lock;
};

struct pxp_attachment {
	struct sg_table sgt;
	enum dma_data_direction dma_dir;
};

struct iosys_map {
	union {
		void *vaddr_iomem;
		void *vaddr;
	};
	bool is_iomem;
};

struct dma_fence_ops;

struct dma_fence {
	spinlock_t *lock;
	const struct dma_fence_ops *ops;
	union {
		struct list_head cb_list;
		ktime_t timestamp;
		struct callback_head rcu;
	};
	u64 context;
	u64 seqno;
	long unsigned int flags;
	struct kref refcount;
	int error;
	int: 32;
};

struct dma_fence_ops {
	bool use_64bit_seqno;
	const char * (*get_driver_name)(struct dma_fence *);
	const char * (*get_timeline_name)(struct dma_fence *);
	bool (*enable_signaling)(struct dma_fence *);
	bool (*signaled)(struct dma_fence *);
	long int (*wait)(struct dma_fence *, bool, long int);
	void (*release)(struct dma_fence *);
	void (*fence_value_str)(struct dma_fence *, char *, int);
	void (*timeline_value_str)(struct dma_fence *, char *, int);
};

struct dma_fence_cb;

typedef void (*dma_fence_func_t)(struct dma_fence *, struct dma_fence_cb *);

struct dma_fence_cb {
	struct list_head node;
	dma_fence_func_t func;
};

struct dma_buf_ops {
	bool cache_sgt_mapping;
	int (*attach)(struct dma_buf *, struct dma_buf_attachment *);
	void (*detach)(struct dma_buf *, struct dma_buf_attachment *);
	int (*pin)(struct dma_buf_attachment *);
	void (*unpin)(struct dma_buf_attachment *);
	struct sg_table * (*map_dma_buf)(struct dma_buf_attachment *, enum dma_data_direction);
	void (*unmap_dma_buf)(struct dma_buf_attachment *, struct sg_table *, enum dma_data_direction);
	void (*release)(struct dma_buf *);
	int (*begin_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*end_cpu_access)(struct dma_buf *, enum dma_data_direction);
	int (*mmap)(struct dma_buf *, struct vm_area_struct *);
	int (*vmap)(struct dma_buf *, struct iosys_map *);
	void (*vunmap)(struct dma_buf *, struct iosys_map *);
};

struct dma_buf_poll_cb_t {
	struct dma_fence_cb cb;
	wait_queue_head_t *poll;
	__poll_t active;
};

struct dma_resv;

struct dma_buf {
	size_t size;
	struct file *file;
	struct list_head attachments;
	const struct dma_buf_ops *ops;
	struct mutex lock;
	unsigned int vmapping_counter;
	struct iosys_map vmap_ptr;
	const char *exp_name;
	const char *name;
	spinlock_t name_lock;
	struct module *owner;
	struct list_head list_node;
	void *priv;
	struct dma_resv *resv;
	wait_queue_head_t poll;
	struct dma_buf_poll_cb_t cb_in;
	struct dma_buf_poll_cb_t cb_out;
};

struct dma_buf_attach_ops {
	bool allow_peer2peer;
	void (*move_notify)(struct dma_buf_attachment *);
};

struct dma_buf_export_info {
	const char *exp_name;
	struct module *owner;
	const struct dma_buf_ops *ops;
	size_t size;
	int flags;
	struct dma_resv *resv;
	void *priv;
};

struct soc_device_attribute {
	const char *machine;
	const char *family;
	const char *revision;
	const char *serial_number;
	const char *soc_id;
	const void *data;
	const struct attribute_group *custom_attr_group;
};

struct soc_device;

enum gpd_status {
	GENPD_STATE_ON = 0,
	GENPD_STATE_OFF = 1,
};

struct dev_power_governor {
	bool (*power_down_ok)(struct dev_pm_domain *);
	bool (*suspend_ok)(struct device *);
};

struct gpd_dev_ops {
	int (*start)(struct device *);
	int (*stop)(struct device *);
};

struct genpd_governor_data {
	s64 max_off_time_ns;
	bool max_off_time_changed;
	int: 24;
	int: 32;
	ktime_t next_wakeup;
	bool cached_power_down_ok;
	bool cached_power_down_state_idx;
	int: 16;
	int: 32;
};

struct genpd_power_state {
	s64 power_off_latency_ns;
	s64 power_on_latency_ns;
	s64 residency_ns;
	u64 usage;
	u64 rejected;
	struct fwnode_handle *fwnode;
	int: 32;
	u64 idle_time;
	void *data;
	int: 32;
};

struct opp_table;

struct dev_pm_opp;

struct genpd_lock_ops;

struct generic_pm_domain {
	struct device dev;
	struct dev_pm_domain domain;
	struct list_head gpd_list_node;
	struct list_head parent_links;
	struct list_head child_links;
	struct list_head dev_list;
	struct dev_power_governor *gov;
	struct genpd_governor_data *gd;
	struct work_struct power_off_work;
	struct fwnode_handle *provider;
	bool has_provider;
	const char *name;
	atomic_t sd_count;
	enum gpd_status status;
	unsigned int device_count;
	unsigned int suspended_count;
	unsigned int prepared_count;
	unsigned int performance_state;
	cpumask_var_t cpus;
	int (*power_off)(struct generic_pm_domain *);
	int (*power_on)(struct generic_pm_domain *);
	struct raw_notifier_head power_notifiers;
	struct opp_table *opp_table;
	unsigned int (*opp_to_performance_state)(struct generic_pm_domain *, struct dev_pm_opp *);
	int (*set_performance_state)(struct generic_pm_domain *, unsigned int);
	struct gpd_dev_ops dev_ops;
	int (*attach_dev)(struct generic_pm_domain *, struct device *);
	void (*detach_dev)(struct generic_pm_domain *, struct device *);
	unsigned int flags;
	struct genpd_power_state *states;
	void (*free_states)(struct genpd_power_state *, unsigned int);
	unsigned int state_count;
	unsigned int state_idx;
	int: 32;
	u64 on_time;
	u64 accounting_time;
	const struct genpd_lock_ops *lock_ops;
	union {
		struct mutex mlock;
		struct {
			spinlock_t slock;
			long unsigned int lock_flags;
		};
	};
	unsigned int state_idx_saved;
	struct clk_bulk_data *clks;
	int num_clks;
	int: 32;
};

struct genpd_lock_ops {
	void (*lock)(struct generic_pm_domain *);
	void (*lock_nested)(struct generic_pm_domain *, int);
	int (*lock_interruptible)(struct generic_pm_domain *);
	void (*unlock)(struct generic_pm_domain *);
};

typedef struct generic_pm_domain * (*genpd_xlate_t)(struct of_phandle_args *, void *);

struct genpd_onecell_data {
	struct generic_pm_domain **domains;
	unsigned int num_domains;
	genpd_xlate_t xlate;
};

struct imx_pm_domain {
	struct generic_pm_domain base;
	struct regmap *regmap;
	struct regulator *supply;
	struct clk *clk[7];
	int num_clks;
	unsigned int reg_offs;
	signed char cntr_pdn_bit;
	unsigned int ipg_rate_mhz;
	int: 32;
};

struct imx_gpc_dt_data {
	int num_domains;
	bool err009619_present;
	bool err006287_present;
};

struct imx_pgc_regs {
	u16 map;
	u16 pup;
	u16 pdn;
	u16 hsk;
};

struct imx_pgc_noc_data {
	u32 off;
	u32 priority;
	u32 mode;
	u32 extctrl;
};

struct imx_pgc_domain {
	struct generic_pm_domain genpd;
	struct regmap *regmap;
	struct regmap *noc_regmap;
	const struct imx_pgc_regs *regs;
	struct regulator *regulator;
	struct reset_control *reset;
	struct clk_bulk_data *clks;
	int num_clks;
	long unsigned int pgc;
	const struct {
		u32 pxx;
		u32 map;
		u32 hskreq;
		u32 hskack;
	} bits;
	const int voltage;
	const bool keep_clocks;
	struct device *dev;
	unsigned int pgc_sw_pup_reg;
	unsigned int pgc_sw_pdn_reg;
	const struct imx_pgc_noc_data *noc_data[6];
	int: 32;
};

struct imx_pgc_domain_data {
	const struct imx_pgc_domain *domains;
	size_t domains_num;
	const struct regmap_access_table *reg_access_table;
	const struct imx_pgc_regs *pgc_regs;
};

struct imx8m_pm_domain {
	struct device *dev;
	int: 32;
	struct generic_pm_domain pd;
	u32 domain_index;
	struct clk *clk[6];
	unsigned int num_clks;
	struct regulator *reg;
	int: 32;
};

enum imx8m_pm_domain_state {
	PD_STATE_OFF = 0,
	PD_STATE_ON = 1,
};

struct virtio_driver {
	struct device_driver driver;
	const struct virtio_device_id *id_table;
	const unsigned int *feature_table;
	unsigned int feature_table_size;
	const unsigned int *feature_table_legacy;
	unsigned int feature_table_size_legacy;
	int (*validate)(struct virtio_device *);
	int (*probe)(struct virtio_device *);
	void (*scan)(struct virtio_device *);
	void (*remove)(struct virtio_device *);
	void (*config_changed)(struct virtio_device *);
	int (*freeze)(struct virtio_device *);
	int (*restore)(struct virtio_device *);
};

typedef __u16 __virtio16;

typedef __u32 __virtio32;

typedef __u64 __virtio64;

struct vring_desc {
	__virtio64 addr;
	__virtio32 len;
	__virtio16 flags;
	__virtio16 next;
};

struct vring_avail {
	__virtio16 flags;
	__virtio16 idx;
	__virtio16 ring[0];
};

struct vring_used_elem {
	__virtio32 id;
	__virtio32 len;
};

typedef struct vring_used_elem vring_used_elem_t;

struct vring_used {
	__virtio16 flags;
	__virtio16 idx;
	vring_used_elem_t ring[0];
};

typedef struct vring_desc vring_desc_t;

typedef struct vring_avail vring_avail_t;

typedef struct vring_used vring_used_t;

struct vring {
	unsigned int num;
	vring_desc_t *desc;
	vring_avail_t *avail;
	vring_used_t *used;
};

struct vring_packed_desc_event {
	__le16 off_wrap;
	__le16 flags;
};

struct vring_packed_desc {
	__le64 addr;
	__le32 len;
	__le16 id;
	__le16 flags;
};

struct vring_desc_state_split {
	void *data;
	struct vring_desc *indir_desc;
};

struct vring_desc_state_packed {
	void *data;
	struct vring_packed_desc *indir_desc;
	u16 num;
	u16 last;
};

struct vring_desc_extra {
	dma_addr_t addr;
	u32 len;
	u16 flags;
	u16 next;
};

struct vring_virtqueue_split {
	struct vring vring;
	u16 avail_flags_shadow;
	u16 avail_idx_shadow;
	struct vring_desc_state_split *desc_state;
	struct vring_desc_extra *desc_extra;
	dma_addr_t queue_dma_addr;
	size_t queue_size_in_bytes;
	u32 vring_align;
	bool may_reduce_num;
};

struct vring_virtqueue_packed {
	struct {
		unsigned int num;
		struct vring_packed_desc *desc;
		struct vring_packed_desc_event *driver;
		struct vring_packed_desc_event *device;
	} vring;
	bool avail_wrap_counter;
	u16 avail_used_flags;
	u16 next_avail_idx;
	u16 event_flags_shadow;
	struct vring_desc_state_packed *desc_state;
	struct vring_desc_extra *desc_extra;
	dma_addr_t ring_dma_addr;
	dma_addr_t driver_event_dma_addr;
	dma_addr_t device_event_dma_addr;
	size_t ring_size_in_bytes;
	size_t event_size_in_bytes;
};

struct vring_virtqueue {
	struct virtqueue vq;
	bool packed_ring;
	bool use_dma_api;
	bool weak_barriers;
	bool broken;
	bool indirect;
	bool event;
	unsigned int free_head;
	unsigned int num_added;
	u16 last_used_idx;
	bool event_triggered;
	union {
		struct vring_virtqueue_split split;
		struct vring_virtqueue_packed packed;
	};
	bool (*notify)(struct virtqueue *);
	bool we_own_ring;
};

struct pre_voltage_change_data {
	long unsigned int old_uV;
	long unsigned int min_uV;
	long unsigned int max_uV;
};

struct regulator_bulk_data {
	const char *supply;
	int init_load_uA;
	struct regulator *consumer;
	int ret;
};

struct regulator_voltage {
	int min_uV;
	int max_uV;
};

struct regulator {
	struct device *dev;
	struct list_head list;
	unsigned int always_on: 1;
	unsigned int bypass: 1;
	unsigned int device_link: 1;
	int uA_load;
	unsigned int enable_count;
	unsigned int deferred_disables;
	struct regulator_voltage voltage[5];
	const char *supply_name;
	struct device_attribute dev_attr;
	struct regulator_dev *rdev;
	struct dentry *debugfs;
};

struct regulator_coupler {
	struct list_head list;
	int (*attach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*detach_regulator)(struct regulator_coupler *, struct regulator_dev *);
	int (*balance_voltage)(struct regulator_coupler *, struct regulator_dev *, suspend_state_t);
};

struct ww_class {
	atomic_long_t stamp;
	struct lock_class_key acquire_key;
	struct lock_class_key mutex_key;
	const char *acquire_name;
	const char *mutex_name;
	unsigned int is_wait_die;
};

enum regulator_status {
	REGULATOR_STATUS_OFF = 0,
	REGULATOR_STATUS_ON = 1,
	REGULATOR_STATUS_ERROR = 2,
	REGULATOR_STATUS_FAST = 3,
	REGULATOR_STATUS_NORMAL = 4,
	REGULATOR_STATUS_IDLE = 5,
	REGULATOR_STATUS_STANDBY = 6,
	REGULATOR_STATUS_BYPASS = 7,
	REGULATOR_STATUS_UNDEFINED = 8,
};

enum regulator_detection_severity {
	REGULATOR_SEVERITY_PROT = 0,
	REGULATOR_SEVERITY_ERR = 1,
	REGULATOR_SEVERITY_WARN = 2,
};

struct regulator_enable_gpio {
	struct list_head list;
	struct gpio_desc *gpiod;
	u32 enable_count;
	u32 request_count;
};

enum regulator_active_discharge {
	REGULATOR_ACTIVE_DISCHARGE_DEFAULT = 0,
	REGULATOR_ACTIVE_DISCHARGE_DISABLE = 1,
	REGULATOR_ACTIVE_DISCHARGE_ENABLE = 2,
};

struct trace_event_raw_regulator_basic {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regulator_range {
	struct trace_entry ent;
	u32 __data_loc_name;
	int min;
	int max;
	char __data[0];
};

struct trace_event_raw_regulator_value {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int val;
	char __data[0];
};

struct trace_event_data_offsets_regulator_basic {
	u32 name;
};

struct trace_event_data_offsets_regulator_range {
	u32 name;
};

struct trace_event_data_offsets_regulator_value {
	u32 name;
};

typedef void (*btf_trace_regulator_enable)(void *, const char *);

typedef void (*btf_trace_regulator_enable_delay)(void *, const char *);

typedef void (*btf_trace_regulator_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_disable)(void *, const char *);

typedef void (*btf_trace_regulator_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_enable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable)(void *, const char *);

typedef void (*btf_trace_regulator_bypass_disable_complete)(void *, const char *);

typedef void (*btf_trace_regulator_set_voltage)(void *, const char *, int, int);

typedef void (*btf_trace_regulator_set_voltage_complete)(void *, const char *, unsigned int);

enum regulator_get_type {
	NORMAL_GET = 0,
	EXCLUSIVE_GET = 1,
	OPTIONAL_GET = 2,
	MAX_GET_TYPE = 3,
};

struct regulator_map {
	struct list_head list;
	const char *dev_name;
	const char *supply;
	struct regulator_dev *regulator;
};

struct regulator_supply_alias {
	struct list_head list;
	struct device *src_dev;
	const char *src_supply;
	struct device *alias_dev;
	const char *alias_supply;
};

struct summary_data {
	struct seq_file *s;
	struct regulator_dev *parent;
	int level;
};

struct summary_lock_data {
	struct ww_acquire_ctx *ww_ctx;
	struct regulator_dev **new_contended_rdev;
	struct regulator_dev **old_contended_rdev;
};

struct fixed_voltage_config {
	const char *supply_name;
	const char *input_supply;
	int microvolts;
	unsigned int startup_delay;
	unsigned int off_on_delay;
	unsigned int enabled_at_boot: 1;
	struct regulator_init_data *init_data;
};

struct fixed_regulator_data {
	struct fixed_voltage_config cfg;
	struct regulator_init_data init_data;
	struct platform_device pdev;
};

struct regulator_err_state {
	struct regulator_dev *rdev;
	long unsigned int notifs;
	long unsigned int errors;
	int possible_errs;
};

struct regulator_irq_data {
	struct regulator_err_state *states;
	int num_states;
	void *data;
	long int opaque;
};

struct regulator_irq_desc {
	const char *name;
	int fatal_cnt;
	int reread_ms;
	int irq_off_ms;
	bool skip_off;
	bool high_prio;
	void *data;
	int (*die)(struct regulator_irq_data *);
	int (*map_event)(int, struct regulator_irq_data *, long unsigned int *);
	int (*renable)(struct regulator_irq_data *);
};

struct regulator_bulk_devres {
	struct regulator_bulk_data *consumers;
	int num_consumers;
};

struct regulator_supply_alias_match {
	struct device *dev;
	const char *id;
};

struct regulator_notifier_match {
	struct regulator *regulator;
	struct notifier_block *nb;
};

enum {
	REGULATOR_ERROR_CLEARED = 0,
	REGULATOR_FAILED_RETRY = 1,
	REGULATOR_ERROR_ON = 2,
};

struct regulator_irq {
	struct regulator_irq_data rdata;
	struct regulator_irq_desc desc;
	int irq;
	int retry_cnt;
	struct delayed_work isr_work;
};

struct of_regulator_match {
	const char *name;
	void *driver_data;
	struct regulator_init_data *init_data;
	struct device_node *of_node;
	const struct regulator_desc *desc;
};

struct devm_of_regulator_matches {
	struct of_regulator_match *matches;
	unsigned int num_matches;
};

struct fixed_voltage_data {
	struct regulator_desc desc;
	struct regulator_dev *dev;
	struct clk *enable_clock;
	unsigned int enable_counter;
	int performance_state;
};

struct fixed_dev_type {
	bool has_enable_clock;
	bool has_performance_state;
};

struct anatop_regulator {
	u32 delay_reg;
	int delay_bit_shift;
	int delay_bit_width;
	struct regulator_desc rdesc;
	bool bypass;
	int sel;
};

struct mfd_cell_acpi_match;

struct mfd_cell {
	const char *name;
	int id;
	int level;
	int (*enable)(struct platform_device *);
	int (*disable)(struct platform_device *);
	int (*suspend)(struct platform_device *);
	int (*resume)(struct platform_device *);
	void *platform_data;
	size_t pdata_size;
	const struct software_node *swnode;
	const char *of_compatible;
	int: 32;
	const u64 of_reg;
	bool use_of_reg;
	const struct mfd_cell_acpi_match *acpi_match;
	int num_resources;
	const struct resource *resources;
	bool ignore_resource_conflicts;
	bool pm_runtime_no_callbacks;
	const char * const *parent_supplies;
	int num_parent_supplies;
	int: 32;
};

struct mfd_cell_acpi_match {
	const char *pnpid;
	int: 32;
	const long long unsigned int adr;
};

enum da9052_chip_id {
	DA9052 = 0,
	DA9053_AA = 1,
	DA9053_BA = 2,
	DA9053_BB = 3,
	DA9053_BC = 4,
};

struct regmap_irq_chip_data;

struct da9052 {
	struct device *dev;
	struct regmap *regmap;
	struct mutex auxadc_lock;
	struct completion done;
	int irq_base;
	struct regmap_irq_chip_data *irq_data;
	u8 chip_id;
	int chip_irq;
	int (*fix_io)(struct da9052 *, unsigned char);
};

struct led_platform_data;

struct da9052_pdata {
	struct led_platform_data *pled;
	int (*init)(struct da9052 *);
	int irq_base;
	int gpio_base;
	int use_for_apm;
	struct regulator_init_data *regulators[14];
};

struct da9052_regulator_info {
	struct regulator_desc reg_desc;
	int step_uV;
	int min_uV;
	int max_uV;
	unsigned char activate_bit;
};

struct da9052_regulator {
	struct da9052 *da9052;
	struct da9052_regulator_info *info;
	struct regulator_dev *rdev;
};

struct reg_field {
	unsigned int reg;
	unsigned int lsb;
	unsigned int msb;
	unsigned int id_size;
	unsigned int id_offset;
};

enum da9062_compatible_types {
	COMPAT_TYPE_DA9061 = 1,
	COMPAT_TYPE_DA9062 = 2,
};

struct da9062 {
	struct device *dev;
	struct regmap *regmap;
	struct regmap_irq_chip_data *regmap_irq;
	enum da9062_compatible_types chip_type;
};

enum {
	DA9061_ID_BUCK1 = 0,
	DA9061_ID_BUCK2 = 1,
	DA9061_ID_BUCK3 = 2,
	DA9061_ID_LDO1 = 3,
	DA9061_ID_LDO2 = 4,
	DA9061_ID_LDO3 = 5,
	DA9061_ID_LDO4 = 6,
	DA9061_MAX_REGULATORS = 7,
};

enum {
	DA9062_ID_BUCK1 = 0,
	DA9062_ID_BUCK2 = 1,
	DA9062_ID_BUCK3 = 2,
	DA9062_ID_BUCK4 = 3,
	DA9062_ID_LDO1 = 4,
	DA9062_ID_LDO2 = 5,
	DA9062_ID_LDO3 = 6,
	DA9062_ID_LDO4 = 7,
	DA9062_MAX_REGULATORS = 8,
};

struct da9062_regulator_info {
	struct regulator_desc desc;
	struct reg_field mode;
	struct reg_field suspend;
	struct reg_field sleep;
	struct reg_field suspend_sleep;
	unsigned int suspend_vsel_reg;
	struct reg_field oc_event;
};

struct regmap_field;

struct da9062_regulator {
	struct regulator_desc desc;
	struct regulator_dev *rdev;
	struct da9062 *hw;
	const struct da9062_regulator_info *info;
	struct regmap_field *mode;
	struct regmap_field *suspend;
	struct regmap_field *sleep;
	struct regmap_field *suspend_sleep;
};

struct da9062_regulators {
	int irq_ldo_lim;
	unsigned int n_regulators;
	struct da9062_regulator regulator[0];
};

enum da9063_type {
	PMIC_TYPE_DA9063 = 0,
	PMIC_TYPE_DA9063L = 1,
};

struct da9063 {
	struct device *dev;
	enum da9063_type type;
	unsigned char variant_code;
	unsigned int flags;
	struct regmap *regmap;
	int chip_irq;
	unsigned int irq_base;
	struct regmap_irq_chip_data *regmap_irq;
};

enum {
	DA9063_ID_BCORE1 = 0,
	DA9063_ID_BCORE2 = 1,
	DA9063_ID_BPRO = 2,
	DA9063_ID_BMEM = 3,
	DA9063_ID_BIO = 4,
	DA9063_ID_BPERI = 5,
	DA9063_ID_BCORES_MERGED = 6,
	DA9063_ID_BMEM_BIO_MERGED = 7,
	DA9063_ID_LDO3 = 8,
	DA9063_ID_LDO7 = 9,
	DA9063_ID_LDO8 = 10,
	DA9063_ID_LDO9 = 11,
	DA9063_ID_LDO11 = 12,
	DA9063_ID_LDO1 = 13,
	DA9063_ID_LDO2 = 14,
	DA9063_ID_LDO4 = 15,
	DA9063_ID_LDO5 = 16,
	DA9063_ID_LDO6 = 17,
	DA9063_ID_LDO10 = 18,
};

struct da9063_regulator_data {
	int id;
	struct regulator_init_data *initdata;
};

struct da9063_regulators_pdata {
	unsigned int n_regulators;
	struct da9063_regulator_data *regulator_data;
};

struct da9063_regulator_info {
	struct regulator_desc desc;
	struct reg_field mode;
	struct reg_field suspend;
	struct reg_field sleep;
	struct reg_field suspend_sleep;
	unsigned int suspend_vsel_reg;
	struct reg_field oc_event;
};

struct da9063_dev_model {
	const struct da9063_regulator_info *regulator_info;
	unsigned int n_regulators;
	enum da9063_type type;
};

struct da9063_regulator {
	struct regulator_desc desc;
	struct regulator_dev *rdev;
	struct da9063 *hw;
	const struct da9063_regulator_info *info;
	struct regmap_field *mode;
	struct regmap_field *suspend;
	struct regmap_field *sleep;
	struct regmap_field *suspend_sleep;
};

struct da9063_regulators {
	unsigned int n_regulators;
	struct da9063_regulator regulator[0];
};

enum {
	BUCK_MODE_MANUAL = 0,
	BUCK_MODE_SLEEP = 1,
	BUCK_MODE_SYNC = 2,
	BUCK_MODE_AUTO = 3,
};

struct gpio_regulator_state {
	int value;
	int gpios;
};

struct gpio_regulator_config {
	const char *supply_name;
	const char *input_supply;
	unsigned int enabled_at_boot: 1;
	unsigned int startup_delay;
	enum gpiod_flags *gflags;
	int ngpios;
	struct gpio_regulator_state *states;
	int nr_states;
	enum regulator_type type;
	struct regulator_init_data *init_data;
};

struct gpio_regulator_data {
	struct regulator_desc desc;
	struct gpio_desc **gpiods;
	int nr_gpios;
	struct gpio_regulator_state *states;
	int nr_states;
	int state;
};

enum ltc3676_reg {
	LTC3676_SW1 = 0,
	LTC3676_SW2 = 1,
	LTC3676_SW3 = 2,
	LTC3676_SW4 = 3,
	LTC3676_LDO1 = 4,
	LTC3676_LDO2 = 5,
	LTC3676_LDO3 = 6,
	LTC3676_LDO4 = 7,
	LTC3676_NUM_REGULATORS = 8,
};

struct ltc3676 {
	struct regmap *regmap;
	struct device *dev;
	struct regulator_desc regulator_descs[8];
	struct regulator_dev *regulators[8];
};

enum {
	REG_MAX17135_EXT_TEMP = 0,
	REG_MAX17135_CONFIG = 1,
	REG_MAX17135_INT_TEMP = 4,
	REG_MAX17135_STATUS = 5,
	REG_MAX17135_PRODUCT_REV = 6,
	REG_MAX17135_PRODUCT_ID = 7,
	REG_MAX17135_DVR = 8,
	REG_MAX17135_ENABLE = 9,
	REG_MAX17135_FAULT = 10,
	REG_MAX17135_HVINP = 11,
	REG_MAX17135_PRGM_CTRL = 12,
	REG_MAX17135_TIMING1 = 16,
	REG_MAX17135_TIMING2 = 17,
	REG_MAX17135_TIMING3 = 18,
	REG_MAX17135_TIMING4 = 19,
	REG_MAX17135_TIMING5 = 20,
	REG_MAX17135_TIMING6 = 21,
	REG_MAX17135_TIMING7 = 22,
	REG_MAX17135_TIMING8 = 23,
};

struct max17135_platform_data;

struct max17135 {
	int rev;
	struct device *dev;
	struct max17135_platform_data *pdata;
	struct i2c_client *i2c_client;
	unsigned int gvee_pwrup;
	unsigned int vneg_pwrup;
	unsigned int vpos_pwrup;
	unsigned int gvdd_pwrup;
	unsigned int gvdd_pwrdn;
	unsigned int vpos_pwrdn;
	unsigned int vneg_pwrdn;
	unsigned int gvee_pwrdn;
	int gpio_pmic_pwrgood;
	int gpio_pmic_vcom_ctrl;
	int gpio_pmic_wakeup;
	int gpio_pmic_v3p3;
	int gpio_pmic_intr;
	int pass_num;
	int vcom_uV;
	bool vcom_setup;
	int max_wait;
};

struct max17135_regulator_data;

struct max17135_platform_data {
	unsigned int gvee_pwrup;
	unsigned int vneg_pwrup;
	unsigned int vpos_pwrup;
	unsigned int gvdd_pwrup;
	unsigned int gvdd_pwrdn;
	unsigned int vpos_pwrdn;
	unsigned int vneg_pwrdn;
	unsigned int gvee_pwrdn;
	int gpio_pmic_pwrgood;
	int gpio_pmic_vcom_ctrl;
	int gpio_pmic_wakeup;
	int gpio_pmic_v3p3;
	int gpio_pmic_intr;
	int pass_num;
	int vcom_uV;
	struct max17135_regulator_data *regulators;
	int num_regulators;
};

enum {
	MAX17135_DISPLAY = 0,
	MAX17135_GVDD = 1,
	MAX17135_GVEE = 2,
	MAX17135_HVINN = 3,
	MAX17135_HVINP = 4,
	MAX17135_VCOM = 5,
	MAX17135_VNEG = 6,
	MAX17135_VPOS = 7,
	MAX17135_V3P3 = 8,
	MAX17135_NUM_REGULATORS = 9,
};

struct max17135_regulator_data {
	int id;
	struct regulator_init_data *initdata;
	struct device_node *reg_node;
};

struct max17135_vcom_programming_data {
	int vcom_min_uV;
	int vcom_max_uV;
	int vcom_step_uV;
};

struct max17135_data {
	int num_regulators;
	struct max17135 *max17135;
	struct regulator_dev **rdev;
};

struct mc13xxx_regulator_init_data {
	int id;
	struct regulator_init_data *init_data;
	struct device_node *node;
};

struct mc13xxx_regulator_platform_data {
	int num_regulators;
	struct mc13xxx_regulator_init_data *regulators;
};

struct mc13xxx_regulator {
	struct regulator_desc desc;
	int reg;
	int enable_bit;
	int vsel_reg;
	int vsel_shift;
	int vsel_mask;
};

struct mc13xxx;

struct mc13xxx_regulator_priv {
	struct mc13xxx *mc13xxx;
	u32 powermisc_pwgt_state;
	struct mc13xxx_regulator *mc13xxx_regulators;
	int num_regulators;
	struct regulator_dev *regulators[0];
};

enum pf1550_regs {
	PF1550_SW1 = 0,
	PF1550_SW2 = 1,
	PF1550_SW3 = 2,
	PF1550_VREFDDR = 3,
	PF1550_LDO1 = 4,
	PF1550_LDO2 = 5,
	PF1550_LDO3 = 6,
};

enum pf1550_rpmsg_cmd {
	PF1550_ENABLE = 0,
	PF1550_DISABLE = 1,
	PF1550_IS_ENABLED = 2,
	PF1550_SET_VOL = 3,
	PF1550_GET_VOL = 4,
	PF1550_GET_REG = 5,
	PF1550_SET_REG = 6,
};

enum pf1550_resp {
	PF1550_SUCCESS = 0,
	PF1550_FAILED = 1,
	PF1550_UNSURPPORT = 2,
};

enum pf1550_status {
	PF1550_DISABLED = 0,
	PF1550_ENABLED = 1,
};

struct pf1550_regulator_rpmsg;

struct pf1550_regulator_info {
	struct rpmsg_device *rpdev;
	bool is_ready;
	struct device *dev;
	struct pf1550_regulator_rpmsg *msg;
	struct completion cmd_complete;
	struct pm_qos_request pm_qos_req;
	struct mutex lock;
	struct regulator_desc *regulators;
};

struct pf1550_regulator_rpmsg {
	struct imx_rpmsg_head header;
	union {
		u8 regulator;
		u8 reg;
	};
	u8 response;
	u8 status;
	union {
		u32 voltage;
		u32 val;
	};
} __attribute__((packed));

enum chips {
	PFUZE100 = 0,
	PFUZE200 = 1,
	PFUZE3000 = 3,
	PFUZE3001 = 49,
};

struct pfuze_regulator {
	struct regulator_desc desc;
	unsigned char stby_reg;
	unsigned char stby_mask;
	bool sw_reg;
};

struct pfuze_chip {
	int chip_id;
	int flags;
	struct regmap *regmap;
	struct device *dev;
	bool need_restore;
	unsigned int reg_save_array[46];
	struct pfuze_regulator regulator_descs[16];
	struct regulator_dev *regulators[16];
	struct pfuze_regulator *pfuze_regulators;
};

enum {
	RN5T618_DCDC1 = 0,
	RN5T618_DCDC2 = 1,
	RN5T618_DCDC3 = 2,
	RN5T618_DCDC4 = 3,
	RN5T618_DCDC5 = 4,
	RN5T618_LDO1 = 5,
	RN5T618_LDO2 = 6,
	RN5T618_LDO3 = 7,
	RN5T618_LDO4 = 8,
	RN5T618_LDO5 = 9,
	RN5T618_LDO6 = 10,
	RN5T618_LDO7 = 11,
	RN5T618_LDO8 = 12,
	RN5T618_LDO9 = 13,
	RN5T618_LDO10 = 14,
	RN5T618_LDORTC1 = 15,
	RN5T618_LDORTC2 = 16,
	RN5T618_REG_NUM = 17,
};

enum {
	RN5T567 = 0,
	RN5T618 = 1,
	RC5T619 = 2,
};

struct rn5t618 {
	struct regmap *regmap;
	struct device *dev;
	long int variant;
	int irq;
	struct regmap_irq_chip_data *irq_data;
};

struct reset_control;

struct reset_control_bulk_data {
	const char *id;
	struct reset_control *rstc;
};

struct reset_control {
	struct reset_controller_dev *rcdev;
	struct list_head list;
	unsigned int id;
	struct kref refcnt;
	bool acquired;
	bool shared;
	bool array;
	atomic_t deassert_count;
	atomic_t triggered_count;
};

struct reset_control_lookup {
	struct list_head list;
	const char *provider;
	unsigned int index;
	const char *dev_id;
	const char *con_id;
};

struct reset_control_array {
	struct reset_control base;
	unsigned int num_rstcs;
	struct reset_control *rstc[0];
};

struct reset_control_bulk_devres {
	int num_rstcs;
	struct reset_control_bulk_data *rstcs;
};

struct dispmix_reset_controller {
	struct reset_controller_dev rcdev;
	struct device *dev;
	struct regmap *rstcon;
	struct clk *ipg_clk;
	bool active_low;
};

struct dispmix_reset_entry {
	uint32_t reg_off;
	uint32_t bit_off;
};

struct dispmix_reset_pdata {
	const struct dispmix_reset_entry *resets;
	uint32_t nr_resets;
	const struct regmap_config *config;
};

struct imx7_src_signal {
	unsigned int offset;
	unsigned int bit;
};

struct imx7_src_variant {
	const struct imx7_src_signal *signals;
	unsigned int signals_num;
	struct reset_control_ops ops;
};

struct imx7_src {
	struct reset_controller_dev rcdev;
	struct regmap *regmap;
	const struct imx7_src_signal *signals;
};

enum imx7_src_registers {
	SRC_A7RCR0 = 4,
	SRC_M4RCR = 12,
	SRC_ERCR = 20,
	SRC_HSICPHY_RCR = 28,
	SRC_USBOPHY1_RCR = 32,
	SRC_USBOPHY2_RCR = 36,
	SRC_MIPIPHY_RCR = 40,
	SRC_PCIEPHY_RCR = 44,
	SRC_DDRC_RCR = 4096,
};

enum imx8mq_src_registers {
	SRC_A53RCR0 = 4,
	SRC_HDMI_RCR = 48,
	SRC_DISP_RCR = 52,
	SRC_GPU_RCR = 64,
	SRC_VPU_RCR = 68,
	SRC_PCIE2_RCR = 72,
	SRC_MIPIPHY1_RCR = 76,
	SRC_MIPIPHY2_RCR = 80,
	SRC_DDRC2_RCR = 4100,
};

enum imx8mp_src_registers {
	SRC_SUPERMIX_RCR = 24,
	SRC_AUDIOMIX_RCR = 28,
	SRC_MLMIX_RCR = 40,
	SRC_GPU2D_RCR = 56,
	SRC_GPU3D_RCR = 60,
	SRC_VPU_G1_RCR = 72,
	SRC_VPU_G2_RCR = 76,
	SRC_VPUVC8KE_RCR = 80,
	SRC_NOC_RCR = 84,
};

struct gpio_reset_data {
	struct reset_controller_dev rcdev;
	unsigned int gpio;
	bool active_low;
	s32 delay_us;
	s32 post_delay_ms;
};

struct serial_icounter_struct {
	int cts;
	int dsr;
	int rng;
	int dcd;
	int rx;
	int tx;
	int frame;
	int overrun;
	int parity;
	int brk;
	int buf_overrun;
	int reserved[9];
};

struct serial_struct {
	int type;
	int line;
	unsigned int port;
	int irq;
	int flags;
	int xmit_fifo_size;
	int custom_divisor;
	int baud_base;
	short unsigned int close_delay;
	char io_type;
	char reserved_char[1];
	int hub6;
	short unsigned int closing_wait;
	short unsigned int closing_wait2;
	unsigned char *iomem_base;
	short unsigned int iomem_reg_shift;
	unsigned int port_high;
	long unsigned int iomap_base;
};

struct tty_file_private {
	struct tty_struct *tty;
	struct file *file;
	struct list_head list;
};

struct n_tty_data {
	size_t read_head;
	size_t commit_head;
	size_t canon_head;
	size_t echo_head;
	size_t echo_commit;
	size_t echo_mark;
	long unsigned int char_map[8];
	long unsigned int overrun_time;
	int num_overrun;
	bool no_room;
	unsigned char lnext: 1;
	unsigned char erasing: 1;
	unsigned char raw: 1;
	unsigned char real_raw: 1;
	unsigned char icanon: 1;
	unsigned char push: 1;
	char read_buf[4096];
	long unsigned int read_flags[128];
	unsigned char echo_buf[4096];
	size_t read_tail;
	size_t line_start;
	size_t lookahead_count;
	unsigned int column;
	unsigned int canon_column;
	size_t echo_tail;
	struct mutex atomic_read_lock;
	struct mutex output_lock;
};

enum {
	ERASE = 0,
	WERASE = 1,
	KILL = 2,
};

struct termios {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
};

struct termios2 {
	tcflag_t c_iflag;
	tcflag_t c_oflag;
	tcflag_t c_cflag;
	tcflag_t c_lflag;
	cc_t c_line;
	cc_t c_cc[19];
	speed_t c_ispeed;
	speed_t c_ospeed;
};

struct termio {
	short unsigned int c_iflag;
	short unsigned int c_oflag;
	short unsigned int c_cflag;
	short unsigned int c_lflag;
	unsigned char c_line;
	unsigned char c_cc[8];
};

struct ldsem_waiter {
	struct list_head list;
	struct task_struct *task;
};

struct pts_fs_info;

struct input_id {
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
};

struct input_absinfo {
	__s32 value;
	__s32 minimum;
	__s32 maximum;
	__s32 fuzz;
	__s32 flat;
	__s32 resolution;
};

struct input_keymap_entry {
	__u8 flags;
	__u8 len;
	__u16 index;
	__u32 keycode;
	__u8 scancode[32];
};

struct ff_replay {
	__u16 length;
	__u16 delay;
};

struct ff_trigger {
	__u16 button;
	__u16 interval;
};

struct ff_envelope {
	__u16 attack_length;
	__u16 attack_level;
	__u16 fade_length;
	__u16 fade_level;
};

struct ff_constant_effect {
	__s16 level;
	struct ff_envelope envelope;
};

struct ff_ramp_effect {
	__s16 start_level;
	__s16 end_level;
	struct ff_envelope envelope;
};

struct ff_condition_effect {
	__u16 right_saturation;
	__u16 left_saturation;
	__s16 right_coeff;
	__s16 left_coeff;
	__u16 deadband;
	__s16 center;
};

struct ff_periodic_effect {
	__u16 waveform;
	__u16 period;
	__s16 magnitude;
	__s16 offset;
	__u16 phase;
	struct ff_envelope envelope;
	__u32 custom_len;
	__s16 *custom_data;
};

struct ff_rumble_effect {
	__u16 strong_magnitude;
	__u16 weak_magnitude;
};

struct ff_effect {
	__u16 type;
	__s16 id;
	__u16 direction;
	struct ff_trigger trigger;
	struct ff_replay replay;
	union {
		struct ff_constant_effect constant;
		struct ff_ramp_effect ramp;
		struct ff_periodic_effect periodic;
		struct ff_condition_effect condition[2];
		struct ff_rumble_effect rumble;
	} u;
};

struct input_device_id {
	kernel_ulong_t flags;
	__u16 bustype;
	__u16 vendor;
	__u16 product;
	__u16 version;
	kernel_ulong_t evbit[1];
	kernel_ulong_t keybit[24];
	kernel_ulong_t relbit[1];
	kernel_ulong_t absbit[2];
	kernel_ulong_t mscbit[1];
	kernel_ulong_t ledbit[1];
	kernel_ulong_t sndbit[1];
	kernel_ulong_t ffbit[4];
	kernel_ulong_t swbit[1];
	kernel_ulong_t propbit[1];
	kernel_ulong_t driver_info;
};

struct input_value {
	__u16 type;
	__u16 code;
	__s32 value;
};

struct ff_device;

struct input_dev_poller;

struct input_mt;

struct input_handle;

struct input_dev {
	const char *name;
	const char *phys;
	const char *uniq;
	struct input_id id;
	long unsigned int propbit[1];
	long unsigned int evbit[1];
	long unsigned int keybit[24];
	long unsigned int relbit[1];
	long unsigned int absbit[2];
	long unsigned int mscbit[1];
	long unsigned int ledbit[1];
	long unsigned int sndbit[1];
	long unsigned int ffbit[4];
	long unsigned int swbit[1];
	unsigned int hint_events_per_packet;
	unsigned int keycodemax;
	unsigned int keycodesize;
	void *keycode;
	int (*setkeycode)(struct input_dev *, const struct input_keymap_entry *, unsigned int *);
	int (*getkeycode)(struct input_dev *, struct input_keymap_entry *);
	struct ff_device *ff;
	struct input_dev_poller *poller;
	unsigned int repeat_key;
	struct timer_list timer;
	int rep[2];
	struct input_mt *mt;
	struct input_absinfo *absinfo;
	long unsigned int key[24];
	long unsigned int led[1];
	long unsigned int snd[1];
	long unsigned int sw[1];
	int (*open)(struct input_dev *);
	void (*close)(struct input_dev *);
	int (*flush)(struct input_dev *, struct file *);
	int (*event)(struct input_dev *, unsigned int, unsigned int, int);
	struct input_handle *grab;
	spinlock_t event_lock;
	struct mutex mutex;
	unsigned int users;
	bool going_away;
	struct device dev;
	struct list_head h_list;
	struct list_head node;
	unsigned int num_vals;
	unsigned int max_vals;
	struct input_value *vals;
	bool devres_managed;
	ktime_t timestamp[3];
	bool inhibited;
	int: 24;
	int: 32;
};

struct ff_device {
	int (*upload)(struct input_dev *, struct ff_effect *, struct ff_effect *);
	int (*erase)(struct input_dev *, int);
	int (*playback)(struct input_dev *, int, int);
	void (*set_gain)(struct input_dev *, u16);
	void (*set_autocenter)(struct input_dev *, u16);
	void (*destroy)(struct ff_device *);
	void *private;
	long unsigned int ffbit[4];
	struct mutex mutex;
	int max_effects;
	struct ff_effect *effects;
	struct file *effect_owners[0];
};

struct input_handler;

struct input_handle {
	void *private;
	int open;
	const char *name;
	struct input_dev *dev;
	struct input_handler *handler;
	struct list_head d_node;
	struct list_head h_node;
};

struct input_handler {
	void *private;
	void (*event)(struct input_handle *, unsigned int, unsigned int, int);
	void (*events)(struct input_handle *, const struct input_value *, unsigned int);
	bool (*filter)(struct input_handle *, unsigned int, unsigned int, int);
	bool (*match)(struct input_handler *, struct input_dev *);
	int (*connect)(struct input_handler *, struct input_dev *, const struct input_device_id *);
	void (*disconnect)(struct input_handle *);
	void (*start)(struct input_handle *);
	bool legacy_minors;
	int minor;
	const char *name;
	const struct input_device_id *id_table;
	struct list_head h_list;
	struct list_head node;
};

struct sysrq_state {
	struct input_handle handle;
	struct work_struct reinject_work;
	long unsigned int key_down[24];
	unsigned int alt;
	unsigned int alt_use;
	unsigned int shift;
	unsigned int shift_use;
	bool active;
	bool need_reinject;
	bool reinjecting;
	bool reset_canceled;
	bool reset_requested;
	long unsigned int reset_keybit[24];
	int reset_seq_len;
	int reset_seq_cnt;
	int reset_seq_version;
	struct timer_list keyreset_timer;
};

struct unipair {
	short unsigned int unicode;
	short unsigned int fontpos;
};

struct unimapdesc {
	short unsigned int entry_ct;
	struct unipair *entries;
};

struct kbd_repeat {
	int delay;
	int period;
};

struct console_font_op {
	unsigned int op;
	unsigned int flags;
	unsigned int width;
	unsigned int height;
	unsigned int charcount;
	unsigned char *data;
};

struct vt_stat {
	short unsigned int v_active;
	short unsigned int v_signal;
	short unsigned int v_state;
};

struct vt_sizes {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_scrollsize;
};

struct vt_consize {
	short unsigned int v_rows;
	short unsigned int v_cols;
	short unsigned int v_vlin;
	short unsigned int v_clin;
	short unsigned int v_vcol;
	short unsigned int v_ccol;
};

struct vt_event {
	unsigned int event;
	unsigned int oldev;
	unsigned int newev;
	unsigned int pad[4];
};

struct vt_setactivate {
	unsigned int console;
	struct vt_mode mode;
};

struct vt_spawn_console {
	spinlock_t lock;
	struct pid *pid;
	int sig;
};

struct vt_event_wait {
	struct list_head list;
	struct vt_event event;
	int done;
};

struct vt_notifier_param {
	struct vc_data *vc;
	unsigned int c;
};

struct vcs_poll_data {
	struct notifier_block notifier;
	unsigned int cons_num;
	int event;
	wait_queue_head_t waitq;
	struct fasync_struct *fasync;
};

struct tiocl_selection {
	short unsigned int xs;
	short unsigned int ys;
	short unsigned int xe;
	short unsigned int ye;
	short unsigned int sel_mode;
};

struct vc_selection {
	struct mutex lock;
	struct vc_data *cons;
	char *buffer;
	unsigned int buf_len;
	volatile int start;
	int end;
};

struct kbentry {
	unsigned char kb_table;
	unsigned char kb_index;
	short unsigned int kb_value;
};

struct kbsentry {
	unsigned char kb_func;
	unsigned char kb_string[512];
};

struct kbdiacr {
	unsigned char diacr;
	unsigned char base;
	unsigned char result;
};

struct kbdiacrs {
	unsigned int kb_cnt;
	struct kbdiacr kbdiacr[256];
};

struct kbdiacruc {
	unsigned int diacr;
	unsigned int base;
	unsigned int result;
};

struct kbdiacrsuc {
	unsigned int kb_cnt;
	struct kbdiacruc kbdiacruc[256];
};

struct kbkeycode {
	unsigned int scancode;
	unsigned int keycode;
};

struct keyboard_notifier_param {
	struct vc_data *vc;
	int down;
	int shift;
	int ledstate;
	unsigned int value;
};

struct kbd_struct {
	unsigned char lockstate;
	unsigned char slockstate;
	unsigned char ledmode: 1;
	unsigned char ledflagstate: 4;
	char: 3;
	unsigned char default_ledflagstate: 4;
	unsigned char kbdmode: 3;
	char: 1;
	unsigned char modeflags: 5;
};

enum led_brightness {
	LED_OFF = 0,
	LED_ON = 1,
	LED_HALF = 127,
	LED_FULL = 255,
};

struct led_hw_trigger_type {
	int dummy;
};

struct led_pattern;

struct led_trigger;

struct led_classdev {
	const char *name;
	unsigned int brightness;
	unsigned int max_brightness;
	int flags;
	long unsigned int work_flags;
	void (*brightness_set)(struct led_classdev *, enum led_brightness);
	int (*brightness_set_blocking)(struct led_classdev *, enum led_brightness);
	enum led_brightness (*brightness_get)(struct led_classdev *);
	int (*blink_set)(struct led_classdev *, long unsigned int *, long unsigned int *);
	int (*pattern_set)(struct led_classdev *, struct led_pattern *, u32, int);
	int (*pattern_clear)(struct led_classdev *);
	struct device *dev;
	const struct attribute_group **groups;
	struct list_head node;
	const char *default_trigger;
	long unsigned int blink_delay_on;
	long unsigned int blink_delay_off;
	struct timer_list blink_timer;
	int blink_brightness;
	int new_blink_brightness;
	void (*flash_resume)(struct led_classdev *);
	struct work_struct set_brightness_work;
	int delayed_set_value;
	struct rw_semaphore trigger_lock;
	struct led_trigger *trigger;
	struct list_head trig_list;
	void *trigger_data;
	bool activated;
	struct led_hw_trigger_type *trigger_type;
	struct mutex led_access;
};

struct led_pattern {
	u32 delta_t;
	int brightness;
};

struct led_trigger {
	const char *name;
	int (*activate)(struct led_classdev *);
	void (*deactivate)(struct led_classdev *);
	struct led_hw_trigger_type *trigger_type;
	spinlock_t leddev_list_lock;
	struct list_head led_cdevs;
	struct list_head next_trig;
	const struct attribute_group **groups;
};

typedef void k_handler_fn(struct vc_data *, unsigned char, char);

typedef void fn_handler_fn(struct vc_data *);

struct getset_keycode_data {
	struct input_keymap_entry ke;
	int error;
};

struct kbd_led_trigger {
	struct led_trigger trigger;
	unsigned int mask;
};

enum translation_map {
	LAT1_MAP = 0,
	GRAF_MAP = 1,
	IBMPC_MAP = 2,
	USER_MAP = 3,
	FIRST_MAP = 0,
	LAST_MAP = 3,
};

struct uni_pagedict {
	u16 **uni_pgdir[32];
	long unsigned int refcount;
	long unsigned int sum;
	unsigned char *inverse_translations[4];
	u16 *inverse_trans_unicode;
};

typedef uint32_t char32_t;

struct uni_screen {
	char32_t *lines[0];
};

struct con_driver {
	const struct consw *con;
	const char *desc;
	struct device *dev;
	int node;
	int first;
	int last;
	int flag;
};

enum {
	blank_off = 0,
	blank_normal_wait = 1,
	blank_vesa_wait = 2,
};

enum {
	EPecma = 0,
	EPdec = 1,
	EPeq = 2,
	EPgt = 3,
	EPlt = 4,
};

struct rgb {
	u8 r;
	u8 g;
	u8 b;
};

enum {
	ESnormal = 0,
	ESesc = 1,
	ESsquare = 2,
	ESgetpars = 3,
	ESfunckey = 4,
	EShash = 5,
	ESsetG0 = 6,
	ESsetG1 = 7,
	ESpercent = 8,
	EScsiignore = 9,
	ESnonstd = 10,
	ESpalette = 11,
	ESosc = 12,
	ESapc = 13,
	ESpm = 14,
	ESdcs = 15,
};

struct interval {
	uint32_t first;
	uint32_t last;
};

struct vc_draw_region {
	long unsigned int from;
	long unsigned int to;
	int x;
};

struct serial_rs485 {
	__u32 flags;
	__u32 delay_rts_before_send;
	__u32 delay_rts_after_send;
	union {
		__u32 padding[5];
		struct {
			__u8 addr_recv;
			__u8 addr_dest;
			__u8 padding0[2];
			__u32 padding1[4];
		};
	};
};

struct serial_iso7816 {
	__u32 flags;
	__u32 tg;
	__u32 sc_fi;
	__u32 sc_di;
	__u32 clk;
	__u32 reserved[5];
};

struct circ_buf {
	char *buf;
	int head;
	int tail;
};

struct uart_port;

struct uart_ops {
	unsigned int (*tx_empty)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*stop_tx)(struct uart_port *);
	void (*start_tx)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	void (*send_xchar)(struct uart_port *, char);
	void (*stop_rx)(struct uart_port *);
	void (*start_rx)(struct uart_port *);
	void (*enable_ms)(struct uart_port *);
	void (*break_ctl)(struct uart_port *, int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*flush_buffer)(struct uart_port *);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	const char * (*type)(struct uart_port *);
	void (*release_port)(struct uart_port *);
	int (*request_port)(struct uart_port *);
	void (*config_port)(struct uart_port *, int);
	int (*verify_port)(struct uart_port *, struct serial_struct *);
	int (*ioctl)(struct uart_port *, unsigned int, long unsigned int);
};

struct uart_icount {
	__u32 cts;
	__u32 dsr;
	__u32 rng;
	__u32 dcd;
	__u32 rx;
	__u32 tx;
	__u32 frame;
	__u32 overrun;
	__u32 parity;
	__u32 brk;
	__u32 buf_overrun;
};

typedef u64 upf_t;

typedef unsigned int upstat_t;

struct uart_state;

struct uart_port {
	spinlock_t lock;
	long unsigned int iobase;
	unsigned char *membase;
	unsigned int (*serial_in)(struct uart_port *, int);
	void (*serial_out)(struct uart_port *, int, int);
	void (*set_termios)(struct uart_port *, struct ktermios *, const struct ktermios *);
	void (*set_ldisc)(struct uart_port *, struct ktermios *);
	unsigned int (*get_mctrl)(struct uart_port *);
	void (*set_mctrl)(struct uart_port *, unsigned int);
	unsigned int (*get_divisor)(struct uart_port *, unsigned int, unsigned int *);
	void (*set_divisor)(struct uart_port *, unsigned int, unsigned int, unsigned int);
	int (*startup)(struct uart_port *);
	void (*shutdown)(struct uart_port *);
	void (*throttle)(struct uart_port *);
	void (*unthrottle)(struct uart_port *);
	int (*handle_irq)(struct uart_port *);
	void (*pm)(struct uart_port *, unsigned int, unsigned int);
	void (*handle_break)(struct uart_port *);
	int (*rs485_config)(struct uart_port *, struct ktermios *, struct serial_rs485 *);
	int (*iso7816_config)(struct uart_port *, struct serial_iso7816 *);
	unsigned int irq;
	long unsigned int irqflags;
	unsigned int uartclk;
	unsigned int fifosize;
	unsigned char x_char;
	unsigned char regshift;
	unsigned char iotype;
	unsigned char quirks;
	unsigned int read_status_mask;
	unsigned int ignore_status_mask;
	struct uart_state *state;
	struct uart_icount icount;
	struct console *cons;
	upf_t flags;
	upstat_t status;
	int hw_stopped;
	unsigned int mctrl;
	unsigned int frame_time;
	unsigned int type;
	const struct uart_ops *ops;
	unsigned int custom_divisor;
	unsigned int line;
	unsigned int minor;
	resource_size_t mapbase;
	resource_size_t mapsize;
	struct device *dev;
	long unsigned int sysrq;
	unsigned int sysrq_ch;
	unsigned char has_sysrq;
	unsigned char sysrq_seq;
	unsigned char hub6;
	unsigned char suspended;
	unsigned char console_reinit;
	const char *name;
	struct attribute_group *attr_group;
	const struct attribute_group **tty_groups;
	struct serial_rs485 rs485;
	struct serial_rs485 rs485_supported;
	struct gpio_desc *rs485_term_gpio;
	struct serial_iso7816 iso7816;
	void *private_data;
	int: 32;
};

enum uart_pm_state {
	UART_PM_STATE_ON = 0,
	UART_PM_STATE_OFF = 3,
	UART_PM_STATE_UNDEFINED = 4,
};

struct uart_state {
	struct tty_port port;
	enum uart_pm_state pm_state;
	struct circ_buf xmit;
	atomic_t refcount;
	wait_queue_head_t remove_wait;
	struct uart_port *uart_port;
};

struct uart_driver {
	struct module *owner;
	const char *driver_name;
	const char *dev_name;
	int major;
	int minor;
	int nr;
	struct console *cons;
	struct uart_state *state;
	struct tty_driver *tty_driver;
};

struct uart_match {
	struct uart_port *port;
	struct uart_driver *driver;
};

struct earlycon_device {
	struct console *con;
	int: 32;
	struct uart_port port;
	char options[16];
	unsigned int baud;
	int: 32;
};

struct earlycon_id {
	char name[15];
	char name_term;
	char compatible[128];
	int (*setup)(struct earlycon_device *, const char *);
};

enum imx_uart_type {
	IMX1_UART = 0,
	IMX21_UART = 1,
	IMX53_UART = 2,
	IMX6Q_UART = 3,
};

struct imx_uart_data {
	unsigned int uts_reg;
	enum imx_uart_type devtype;
};

enum imx_tx_state {
	OFF = 0,
	WAIT_AFTER_RTS = 1,
	SEND = 2,
	WAIT_AFTER_SEND = 3,
};

struct mctrl_gpios;

struct imx_port {
	struct uart_port port;
	struct timer_list timer;
	unsigned int old_status;
	unsigned int have_rtscts: 1;
	unsigned int have_rtsgpio: 1;
	unsigned int dte_mode: 1;
	unsigned int inverted_tx: 1;
	unsigned int inverted_rx: 1;
	struct clk *clk_ipg;
	struct clk *clk_per;
	const struct imx_uart_data *devdata;
	struct mctrl_gpios *gpios;
	unsigned int ucr1;
	unsigned int ucr2;
	unsigned int ucr3;
	unsigned int ucr4;
	unsigned int ufcr;
	unsigned int dma_is_enabled: 1;
	unsigned int dma_is_rxing: 1;
	unsigned int dma_is_txing: 1;
	struct dma_chan *dma_chan_rx;
	struct dma_chan *dma_chan_tx;
	struct scatterlist rx_sgl;
	struct scatterlist tx_sgl[2];
	void *rx_buf;
	struct circ_buf rx_ring;
	unsigned int rx_buf_size;
	unsigned int rx_period_length;
	unsigned int rx_periods;
	dma_cookie_t rx_cookie;
	unsigned int tx_bytes;
	unsigned int dma_tx_nents;
	unsigned int saved_reg[10];
	bool context_saved;
	enum imx_tx_state tx_state;
	int: 32;
	struct hrtimer trigger_start_tx;
	struct hrtimer trigger_stop_tx;
	struct pm_qos_request pm_qos_req;
};

struct imx_port_ucrs {
	unsigned int ucr1;
	unsigned int ucr2;
	unsigned int ucr3;
};

enum lpuart_type {
	VF610_LPUART = 0,
	LS1021A_LPUART = 1,
	LS1028A_LPUART = 2,
	IMX7ULP_LPUART = 3,
	IMX8ULP_LPUART = 4,
	IMX8QXP_LPUART = 5,
	IMXRT1050_LPUART = 6,
};

struct lpuart_port {
	struct uart_port port;
	enum lpuart_type devtype;
	struct clk *ipg_clk;
	struct clk *baud_clk;
	unsigned int txfifo_size;
	unsigned int rxfifo_size;
	u8 rx_watermark;
	bool dma_eeop;
	bool lpuart_dma_tx_use;
	bool lpuart_dma_rx_use;
	struct dma_chan *dma_tx_chan;
	struct dma_chan *dma_rx_chan;
	struct dma_async_tx_descriptor *dma_tx_desc;
	struct dma_async_tx_descriptor *dma_rx_desc;
	dma_cookie_t dma_tx_cookie;
	dma_cookie_t dma_rx_cookie;
	unsigned int dma_tx_bytes;
	unsigned int dma_rx_bytes;
	bool dma_tx_in_progress;
	unsigned int dma_rx_timeout;
	struct timer_list lpuart_timer;
	struct scatterlist rx_sgl;
	struct scatterlist tx_sgl[2];
	struct circ_buf rx_ring;
	int rx_dma_rng_buf_len;
	int rx_dma_periods;
	unsigned int dma_tx_nents;
	wait_queue_head_t dma_wait;
	bool is_cs7;
	int: 24;
	int: 32;
};

struct lpuart_soc_data {
	enum lpuart_type devtype;
	char iotype;
	u8 reg_off;
	u8 rx_watermark;
};

enum mctrl_gpio_idx {
	UART_GPIO_CTS = 0,
	UART_GPIO_DSR = 1,
	UART_GPIO_DCD = 2,
	UART_GPIO_RNG = 3,
	UART_GPIO_RI = 3,
	UART_GPIO_RTS = 4,
	UART_GPIO_DTR = 5,
	UART_GPIO_MAX = 6,
};

struct mctrl_gpios {
	struct uart_port *port;
	struct gpio_desc *gpio[6];
	int irq[6];
	unsigned int mctrl_prev;
	bool mctrl_on;
};

struct serdev_device;

struct serdev_device_ops {
	int (*receive_buf)(struct serdev_device *, const unsigned char *, size_t);
	void (*write_wakeup)(struct serdev_device *);
};

struct serdev_controller;

struct serdev_device {
	struct device dev;
	int nr;
	struct serdev_controller *ctrl;
	const struct serdev_device_ops *ops;
	struct completion write_comp;
	struct mutex write_lock;
};

struct serdev_controller_ops;

struct serdev_controller {
	struct device dev;
	unsigned int nr;
	struct serdev_device *serdev;
	const struct serdev_controller_ops *ops;
	int: 32;
};

struct serdev_device_driver {
	struct device_driver driver;
	int (*probe)(struct serdev_device *);
	void (*remove)(struct serdev_device *);
};

enum serdev_parity {
	SERDEV_PARITY_NONE = 0,
	SERDEV_PARITY_EVEN = 1,
	SERDEV_PARITY_ODD = 2,
};

struct serdev_controller_ops {
	int (*write_buf)(struct serdev_controller *, const unsigned char *, size_t);
	void (*write_flush)(struct serdev_controller *);
	int (*write_room)(struct serdev_controller *);
	int (*open)(struct serdev_controller *);
	void (*close)(struct serdev_controller *);
	void (*set_flow_control)(struct serdev_controller *, bool);
	int (*set_parity)(struct serdev_controller *, enum serdev_parity);
	unsigned int (*set_baudrate)(struct serdev_controller *, unsigned int);
	void (*wait_until_sent)(struct serdev_controller *, long int);
	int (*get_tiocm)(struct serdev_controller *);
	int (*set_tiocm)(struct serdev_controller *, unsigned int, unsigned int);
};

struct serport {
	struct tty_port *port;
	struct tty_struct *tty;
	struct tty_driver *tty_drv;
	int tty_idx;
	long unsigned int flags;
};

struct memdev {
	const char *name;
	umode_t mode;
	const struct file_operations *fops;
	fmode_t fmode;
};

struct timer_rand_state {
	long unsigned int last_time;
	long int last_delta;
	long int last_delta2;
};

enum chacha_constants {
	CHACHA_CONSTANT_EXPA = 1634760805,
	CHACHA_CONSTANT_ND_3 = 857760878,
	CHACHA_CONSTANT_2_BY = 2036477234,
	CHACHA_CONSTANT_TE_K = 1797285236,
};

enum {
	CRNG_EMPTY = 0,
	CRNG_EARLY = 1,
	CRNG_READY = 2,
};

enum {
	CRNG_RESEED_START_INTERVAL = 100,
	CRNG_RESEED_INTERVAL = 6000,
};

struct crng {
	u8 key[32];
	long unsigned int generation;
	local_lock_t lock;
};

struct batch_u8 {
	u8 entropy[96];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u16 {
	u16 entropy[48];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u32 {
	u32 entropy[24];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

struct batch_u64 {
	u64 entropy[12];
	local_lock_t lock;
	long unsigned int generation;
	unsigned int position;
};

enum {
	POOL_BITS = 256,
	POOL_READY_BITS = 256,
	POOL_EARLY_BITS = 128,
};

struct fast_pool {
	long unsigned int pool[4];
	long unsigned int last;
	unsigned int count;
	struct timer_list mix;
};

struct entropy_timer_state {
	long unsigned int entropy;
	struct timer_list timer;
	unsigned int samples;
	unsigned int samples_per_bit;
};

enum {
	NUM_TRIAL_SAMPLES = 8192,
	MAX_SAMPLES_PER_BIT = 6,
};

enum {
	MIX_INFLIGHT = 2147483648,
};

struct hwrng {
	const char *name;
	int (*init)(struct hwrng *);
	void (*cleanup)(struct hwrng *);
	int (*data_present)(struct hwrng *, int);
	int (*data_read)(struct hwrng *, u32 *);
	int (*read)(struct hwrng *, void *, size_t, bool);
	long unsigned int priv;
	short unsigned int quality;
	struct list_head list;
	struct kref ref;
	struct completion cleanup_done;
	struct completion dying;
};

struct imx_rngc {
	struct device *dev;
	struct clk *clk;
	void *base;
	struct hwrng rng;
	struct completion rng_op_done;
	u32 err_reg;
};

struct tee_client_device_id {
	uuid_t uuid;
};

struct tee_ioctl_version_data {
	__u32 impl_id;
	__u32 impl_caps;
	__u32 gen_caps;
};

struct tee_ioctl_param {
	__u64 attr;
	__u64 a;
	__u64 b;
	__u64 c;
};

struct tee_ioctl_open_session_arg {
	__u8 uuid[16];
	__u8 clnt_uuid[16];
	__u32 clnt_login;
	__u32 cancel_id;
	__u32 session;
	__u32 ret;
	__u32 ret_origin;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_ioctl_invoke_arg {
	__u32 func;
	__u32 session;
	__u32 cancel_id;
	__u32 ret;
	__u32 ret_origin;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_device;

struct tee_context {
	struct tee_device *teedev;
	void *data;
	struct kref refcount;
	bool releasing;
	bool supp_nowait;
	bool cap_memref_null;
};

struct tee_shm;

struct tee_param_memref {
	size_t shm_offs;
	size_t size;
	struct tee_shm *shm;
};

struct tee_shm {
	struct tee_context *ctx;
	phys_addr_t paddr;
	void *kaddr;
	size_t size;
	unsigned int offset;
	struct page **pages;
	size_t num_pages;
	refcount_t refcount;
	u32 flags;
	int id;
	u64 sec_world_id;
};

struct tee_param_value {
	u64 a;
	u64 b;
	u64 c;
};

struct tee_param {
	u64 attr;
	union {
		struct tee_param_memref memref;
		struct tee_param_value value;
	} u;
};

struct tee_client_device {
	struct tee_client_device_id id;
	struct device dev;
};

struct tee_client_driver {
	const struct tee_client_device_id *id_table;
	struct device_driver driver;
};

struct optee_rng_private {
	struct device *dev;
	struct tee_context *ctx;
	u32 session_id;
	u32 data_rate;
	struct tee_shm *entropy_shm_pool;
	struct hwrng optee_rng;
};

enum {
	SEMA4_CP0INE = 64,
	SEMA4_CP1INE = 72,
	SEMA4_CP0NTF = 128,
	SEMA4_CP1NTF = 136,
};

struct imx_sema4_mutex_device {
	struct device *dev;
	u16 cpntf_val;
	u16 cpine_val;
	void *ioaddr;
	spinlock_t lock;
	int irq;
	u16 alloced;
	struct imx_sema4_mutex *mutex_ptr[16];
};

struct cb_id {
	__u32 idx;
	__u32 val;
};

struct cn_msg {
	struct cb_id id;
	__u32 seq;
	__u32 ack;
	__u16 len;
	__u16 flags;
	__u8 data[0];
};

struct cn_queue_dev {
	atomic_t refcnt;
	unsigned char name[32];
	struct list_head queue_list;
	spinlock_t queue_lock;
	struct sock *nls;
};

struct cn_callback_id {
	unsigned char name[32];
	struct cb_id id;
};

struct cn_callback_entry {
	struct list_head callback_entry;
	refcount_t refcnt;
	struct cn_queue_dev *pdev;
	struct cn_callback_id id;
	void (*callback)(struct cn_msg *, struct netlink_skb_parms *);
	u32 seq;
	u32 group;
};

struct cn_dev {
	struct cb_id id;
	u32 seq;
	u32 groups;
	struct sock *nls;
	struct cn_queue_dev *cbdev;
};

enum proc_cn_mcast_op {
	PROC_CN_MCAST_LISTEN = 1,
	PROC_CN_MCAST_IGNORE = 2,
};

struct fork_proc_event {
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
	__kernel_pid_t child_pid;
	__kernel_pid_t child_tgid;
};

struct exec_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct id_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	union {
		__u32 ruid;
		__u32 rgid;
	} r;
	union {
		__u32 euid;
		__u32 egid;
	} e;
};

struct sid_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
};

struct ptrace_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t tracer_pid;
	__kernel_pid_t tracer_tgid;
};

struct comm_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	char comm[16];
};

struct coredump_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct exit_proc_event {
	__kernel_pid_t process_pid;
	__kernel_pid_t process_tgid;
	__u32 exit_code;
	__u32 exit_signal;
	__kernel_pid_t parent_pid;
	__kernel_pid_t parent_tgid;
};

struct proc_event {
	enum what what;
	__u32 cpu;
	__u64 timestamp_ns;
	union {
		struct {
			__u32 err;
		} ack;
		struct fork_proc_event fork;
		struct exec_proc_event exec;
		struct id_proc_event id;
		struct sid_proc_event sid;
		struct ptrace_proc_event ptrace;
		struct comm_proc_event comm;
		struct coredump_proc_event coredump;
		struct exit_proc_event exit;
	} event_data;
};

struct local_event {
	local_lock_t lock;
	__u32 count;
};

struct component_ops {
	int (*bind)(struct device *, struct device *, void *);
	void (*unbind)(struct device *, struct device *, void *);
};

struct component_master_ops {
	int (*bind)(struct device *);
	void (*unbind)(struct device *);
};

struct component;

struct component_match_array {
	void *data;
	int (*compare)(struct device *, void *);
	int (*compare_typed)(struct device *, int, void *);
	void (*release)(struct device *, void *);
	struct component *component;
	bool duplicate;
};

struct aggregate_device;

struct component {
	struct list_head node;
	struct aggregate_device *adev;
	bool bound;
	const struct component_ops *ops;
	int subcomponent;
	struct device *dev;
};

struct component_match {
	size_t alloc;
	size_t num;
	struct component_match_array *compare;
};

struct aggregate_device {
	struct list_head node;
	bool bound;
	const struct component_master_ops *ops;
	struct device *parent;
	struct component_match *match;
};

struct fwnode_link {
	struct fwnode_handle *supplier;
	struct list_head s_hook;
	struct fwnode_handle *consumer;
	struct list_head c_hook;
};

struct wake_irq {
	struct device *dev;
	unsigned int status;
	int irq;
	const char *name;
};

enum dpm_order {
	DPM_ORDER_NONE = 0,
	DPM_ORDER_DEV_AFTER_PARENT = 1,
	DPM_ORDER_PARENT_BEFORE_DEV = 2,
	DPM_ORDER_DEV_LAST = 3,
};

struct subsys_private {
	struct kset subsys;
	struct kset *devices_kset;
	struct list_head interfaces;
	struct mutex mutex;
	struct kset *drivers_kset;
	struct klist klist_devices;
	struct klist klist_drivers;
	struct blocking_notifier_head bus_notifier;
	unsigned int drivers_autoprobe: 1;
	struct bus_type *bus;
	struct kset glue_dirs;
	struct class *class;
};

struct driver_private {
	struct kobject kobj;
	struct klist klist_devices;
	struct klist_node knode_bus;
	struct module_kobject *mkobj;
	struct device_driver *driver;
};

struct dev_ext_attribute {
	struct device_attribute attr;
	void *var;
};

struct device_private {
	struct klist klist_children;
	struct klist_node knode_parent;
	struct klist_node knode_driver;
	struct klist_node knode_bus;
	struct klist_node knode_class;
	struct list_head deferred_probe;
	struct device_driver *async_driver;
	char *deferred_probe_reason;
	struct device *device;
	u8 dead: 1;
};

union device_attr_group_devres {
	const struct attribute_group *group;
	const struct attribute_group **groups;
};

struct class_dir {
	struct kobject kobj;
	struct class *class;
};

struct root_device {
	struct device dev;
	struct module *owner;
	int: 32;
};

struct subsys_dev_iter {
	struct klist_iter ki;
	const struct device_type *type;
};

struct subsys_interface {
	const char *name;
	struct bus_type *subsys;
	struct list_head node;
	int (*add_dev)(struct device *, struct subsys_interface *);
	void (*remove_dev)(struct device *, struct subsys_interface *);
};

struct device_attach_data {
	struct device *dev;
	bool check_async;
	bool want_async;
	bool have_async;
};

struct class_attribute_string {
	struct class_attribute attr;
	char *str;
};

struct class_compat {
	struct kobject *kobj;
};

typedef void *acpi_handle;

struct irq_affinity_devres {
	unsigned int count;
	unsigned int irq[0];
};

struct platform_object {
	struct platform_device pdev;
	char name[0];
};

struct cpu_attr {
	struct device_attribute attr;
	const struct cpumask * const map;
};

typedef struct kobject *kobj_probe_t(dev_t, int *, void *);

struct probe {
	struct probe *next;
	dev_t dev;
	long unsigned int range;
	struct module *owner;
	kobj_probe_t *get;
	int (*lock)(dev_t, void *);
	void *data;
};

struct kobj_map {
	struct probe *probes[255];
	struct mutex *lock;
};

typedef void (*dr_release_t)(struct device *, void *);

typedef int (*dr_match_t)(struct device *, void *, void *);

struct devres_node {
	struct list_head entry;
	dr_release_t release;
	const char *name;
	size_t size;
};

struct devres {
	struct devres_node node;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u8 data[0];
};

struct devres_group {
	struct devres_node node[2];
	void *id;
	int color;
};

struct action_devres {
	void *data;
	void (*action)(void *);
};

struct pages_devres {
	long unsigned int addr;
	unsigned int order;
};

struct attribute_container {
	struct list_head node;
	struct klist containers;
	struct class *class;
	const struct attribute_group *grp;
	struct device_attribute **attrs;
	int (*match)(struct attribute_container *, struct device *);
	long unsigned int flags;
};

struct internal_container {
	struct klist_node node;
	struct attribute_container *cont;
	int: 32;
	struct device classdev;
};

struct transport_container;

struct transport_class {
	struct class class;
	int (*setup)(struct transport_container *, struct device *, struct device *);
	int (*configure)(struct transport_container *, struct device *, struct device *);
	int (*remove)(struct transport_container *, struct device *, struct device *);
};

struct transport_container {
	struct attribute_container ac;
	const struct attribute_group *statistics;
};

struct anon_transport_class {
	struct transport_class tclass;
	struct attribute_container container;
};

struct container_dev {
	struct device dev;
	int (*offline)(struct container_dev *);
	int: 32;
};

typedef void * (*devcon_match_fn_t)(struct fwnode_handle *, const char *, void *);

enum cache_type {
	CACHE_TYPE_NOCACHE = 0,
	CACHE_TYPE_INST = 1,
	CACHE_TYPE_DATA = 2,
	CACHE_TYPE_SEPARATE = 3,
	CACHE_TYPE_UNIFIED = 4,
};

struct cacheinfo {
	unsigned int id;
	enum cache_type type;
	unsigned int level;
	unsigned int coherency_line_size;
	unsigned int number_of_sets;
	unsigned int ways_of_associativity;
	unsigned int physical_line_partition;
	unsigned int size;
	cpumask_t shared_cpu_map;
	unsigned int attributes;
	void *fw_token;
	bool disable_sysfs;
	void *priv;
};

struct cpu_cacheinfo {
	struct cacheinfo *info_list;
	unsigned int num_levels;
	unsigned int num_leaves;
	bool cpu_map_populated;
};

struct cache_type_info {
	const char *size_prop;
	const char *line_size_props[2];
	const char *nr_sets_prop;
};

struct software_node_ref_args {
	const struct software_node *node;
	unsigned int nargs;
	u64 args[8];
};

struct swnode {
	struct kobject kobj;
	struct fwnode_handle fwnode;
	const struct software_node *node;
	int id;
	struct ida child_ids;
	struct list_head entry;
	struct list_head children;
	struct swnode *parent;
	unsigned int allocated: 1;
	unsigned int managed: 1;
};

struct req {
	struct req *next;
	struct completion done;
	int err;
	const char *name;
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
	struct device *dev;
};

enum pm_qos_flags_status {
	PM_QOS_FLAGS_UNDEFINED = 4294967295,
	PM_QOS_FLAGS_NONE = 0,
	PM_QOS_FLAGS_SOME = 1,
	PM_QOS_FLAGS_ALL = 2,
};

typedef int (*pm_callback_t)(struct device *);

struct of_phandle_iterator {
	const char *cells_name;
	int cell_count;
	const struct device_node *parent;
	const __be32 *list_end;
	const __be32 *phandle_end;
	const __be32 *cur;
	uint32_t cur_count;
	phandle phandle;
	struct device_node *node;
};

enum genpd_notication {
	GENPD_NOTIFY_PRE_OFF = 0,
	GENPD_NOTIFY_OFF = 1,
	GENPD_NOTIFY_PRE_ON = 2,
	GENPD_NOTIFY_ON = 3,
};

struct gpd_link {
	struct generic_pm_domain *parent;
	struct list_head parent_node;
	struct generic_pm_domain *child;
	struct list_head child_node;
	unsigned int performance_state;
	unsigned int prev_performance_state;
};

struct gpd_timing_data {
	s64 suspend_latency_ns;
	s64 resume_latency_ns;
	s64 effective_constraint_ns;
	ktime_t next_wakeup;
	bool constraint_changed;
	bool cached_suspend_ok;
	int: 16;
	int: 32;
};

struct generic_pm_domain_data {
	struct pm_domain_data base;
	struct gpd_timing_data *td;
	struct notifier_block nb;
	struct notifier_block *power_nb;
	int cpu;
	unsigned int performance_state;
	unsigned int default_pstate;
	unsigned int rpm_pstate;
	void *data;
};

struct of_genpd_provider {
	struct list_head link;
	struct device_node *node;
	genpd_xlate_t xlate;
	void *data;
};

struct pm_clk_notifier_block {
	struct notifier_block nb;
	struct dev_pm_domain *pm_domain;
	char *con_ids[0];
};

enum pce_status {
	PCE_STATUS_NONE = 0,
	PCE_STATUS_ACQUIRED = 1,
	PCE_STATUS_PREPARED = 2,
	PCE_STATUS_ENABLED = 3,
	PCE_STATUS_ERROR = 4,
};

struct pm_clock_entry {
	struct list_head node;
	char *con_id;
	struct clk *clk;
	enum pce_status status;
	bool enabled_when_prepared;
};

struct firmware_fallback_config {
	unsigned int force_sysfs_fallback;
	unsigned int ignore_sysfs_fallback;
	int old_timeout;
	int loading_timeout;
};

enum fw_opt {
	FW_OPT_UEVENT = 1,
	FW_OPT_NOWAIT = 2,
	FW_OPT_USERHELPER = 4,
	FW_OPT_NO_WARN = 8,
	FW_OPT_NOCACHE = 16,
	FW_OPT_NOFALLBACK_SYSFS = 32,
	FW_OPT_FALLBACK_PLATFORM = 64,
	FW_OPT_PARTIAL = 128,
};

enum fw_status {
	FW_STATUS_UNKNOWN = 0,
	FW_STATUS_LOADING = 1,
	FW_STATUS_DONE = 2,
	FW_STATUS_ABORTED = 3,
};

struct fw_state {
	struct completion completion;
	enum fw_status status;
};

struct firmware_cache;

struct fw_priv {
	struct kref ref;
	struct list_head list;
	struct firmware_cache *fwc;
	struct fw_state fw_st;
	void *data;
	size_t size;
	size_t allocated_size;
	size_t offset;
	u32 opt_flags;
	bool is_paged_buf;
	struct page **pages;
	int nr_pages;
	int page_array_size;
	bool need_uevent;
	struct list_head pending_list;
	const char *fw_name;
};

struct firmware_cache {
	spinlock_t lock;
	struct list_head head;
	int state;
	spinlock_t name_lock;
	struct list_head fw_names;
	struct delayed_work work;
	struct notifier_block pm_notify;
};

struct fw_cache_entry {
	struct list_head list;
	const char *name;
};

struct fw_name_devm {
	long unsigned int magic;
	const char *name;
};

struct firmware_work {
	struct work_struct work;
	struct module *module;
	const char *name;
	struct device *device;
	void *context;
	void (*cont)(const struct firmware *, void *);
	u32 opt_flags;
};

struct fw_sysfs {
	bool nowait;
	int: 24;
	int: 32;
	struct device dev;
	struct fw_priv *fw_priv;
	struct firmware *fw;
	void *fw_upload_priv;
	int: 32;
};

struct builtin_fw {
	char *name;
	void *data;
	long unsigned int size;
};

struct reg_sequence {
	unsigned int reg;
	unsigned int def;
	unsigned int delay_us;
};

typedef int (*regmap_hw_write)(void *, const void *, size_t);

typedef int (*regmap_hw_gather_write)(void *, const void *, size_t, const void *, size_t);

struct regmap_async;

typedef int (*regmap_hw_async_write)(void *, const void *, size_t, const void *, size_t, struct regmap_async *);

struct regmap;

struct regmap_async {
	struct list_head list;
	struct regmap *map;
	void *work_buf;
};

typedef int (*regmap_hw_read)(void *, const void *, size_t, void *, size_t);

typedef int (*regmap_hw_reg_read)(void *, unsigned int, unsigned int *);

typedef int (*regmap_hw_reg_noinc_read)(void *, unsigned int, void *, size_t);

typedef int (*regmap_hw_reg_write)(void *, unsigned int, unsigned int);

typedef int (*regmap_hw_reg_noinc_write)(void *, unsigned int, const void *, size_t);

typedef int (*regmap_hw_reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);

typedef struct regmap_async * (*regmap_hw_async_alloc)();

typedef void (*regmap_hw_free_context)(void *);

struct regmap_bus {
	bool fast_io;
	regmap_hw_write write;
	regmap_hw_gather_write gather_write;
	regmap_hw_async_write async_write;
	regmap_hw_reg_write reg_write;
	regmap_hw_reg_noinc_write reg_noinc_write;
	regmap_hw_reg_update_bits reg_update_bits;
	regmap_hw_read read;
	regmap_hw_reg_read reg_read;
	regmap_hw_reg_noinc_read reg_noinc_read;
	regmap_hw_free_context free_context;
	regmap_hw_async_alloc async_alloc;
	u8 read_flag_mask;
	enum regmap_endian reg_format_endian_default;
	enum regmap_endian val_format_endian_default;
	size_t max_raw_read;
	size_t max_raw_write;
	bool free_on_exit;
};

struct regmap_format {
	size_t buf_size;
	size_t reg_bytes;
	size_t pad_bytes;
	size_t reg_downshift;
	size_t val_bytes;
	void (*format_write)(struct regmap *, unsigned int, unsigned int);
	void (*format_reg)(void *, unsigned int, unsigned int);
	void (*format_val)(void *, unsigned int, unsigned int);
	unsigned int (*parse_val)(const void *);
	void (*parse_inplace)(void *);
};

struct hwspinlock;

struct regcache_ops;

struct regmap {
	union {
		struct mutex mutex;
		struct {
			spinlock_t spinlock;
			long unsigned int spinlock_flags;
		};
		struct {
			raw_spinlock_t raw_spinlock;
			long unsigned int raw_spinlock_flags;
		};
	};
	regmap_lock lock;
	regmap_unlock unlock;
	void *lock_arg;
	gfp_t alloc_flags;
	unsigned int reg_base;
	struct device *dev;
	void *work_buf;
	struct regmap_format format;
	const struct regmap_bus *bus;
	void *bus_context;
	const char *name;
	bool async;
	spinlock_t async_lock;
	wait_queue_head_t async_waitq;
	struct list_head async_list;
	struct list_head async_free;
	int async_ret;
	bool debugfs_disable;
	struct dentry *debugfs;
	const char *debugfs_name;
	unsigned int debugfs_reg_len;
	unsigned int debugfs_val_len;
	unsigned int debugfs_tot_len;
	struct list_head debugfs_off_cache;
	struct mutex cache_lock;
	unsigned int max_register;
	bool (*writeable_reg)(struct device *, unsigned int);
	bool (*readable_reg)(struct device *, unsigned int);
	bool (*volatile_reg)(struct device *, unsigned int);
	bool (*precious_reg)(struct device *, unsigned int);
	bool (*writeable_noinc_reg)(struct device *, unsigned int);
	bool (*readable_noinc_reg)(struct device *, unsigned int);
	const struct regmap_access_table *wr_table;
	const struct regmap_access_table *rd_table;
	const struct regmap_access_table *volatile_table;
	const struct regmap_access_table *precious_table;
	const struct regmap_access_table *wr_noinc_table;
	const struct regmap_access_table *rd_noinc_table;
	int (*reg_read)(void *, unsigned int, unsigned int *);
	int (*reg_write)(void *, unsigned int, unsigned int);
	int (*reg_update_bits)(void *, unsigned int, unsigned int, unsigned int);
	int (*read)(void *, const void *, size_t, void *, size_t);
	int (*write)(void *, const void *, size_t);
	bool defer_caching;
	long unsigned int read_flag_mask;
	long unsigned int write_flag_mask;
	int reg_shift;
	int reg_stride;
	int reg_stride_order;
	const struct regcache_ops *cache_ops;
	enum regcache_type cache_type;
	unsigned int cache_size_raw;
	unsigned int cache_word_size;
	unsigned int num_reg_defaults;
	unsigned int num_reg_defaults_raw;
	bool cache_only;
	bool cache_bypass;
	bool cache_free;
	struct reg_default *reg_defaults;
	const void *reg_defaults_raw;
	void *cache;
	bool cache_dirty;
	bool no_sync_defaults;
	struct reg_sequence *patch;
	int patch_regs;
	bool use_single_read;
	bool use_single_write;
	bool can_multi_write;
	size_t max_raw_read;
	size_t max_raw_write;
	struct rb_root range_tree;
	void *selector_work_buf;
	struct hwspinlock *hwlock;
	bool can_sleep;
};

struct regcache_ops {
	const char *name;
	enum regcache_type type;
	int (*init)(struct regmap *);
	int (*exit)(struct regmap *);
	void (*debugfs_init)(struct regmap *);
	int (*read)(struct regmap *, unsigned int, unsigned int *);
	int (*write)(struct regmap *, unsigned int, unsigned int);
	int (*sync)(struct regmap *, unsigned int, unsigned int);
	int (*drop)(struct regmap *, unsigned int, unsigned int);
};

struct regmap_range_node {
	struct rb_node node;
	const char *name;
	struct regmap *map;
	unsigned int range_min;
	unsigned int range_max;
	unsigned int selector_reg;
	unsigned int selector_mask;
	int selector_shift;
	unsigned int window_start;
	unsigned int window_len;
};

struct regmap_field {
	struct regmap *regmap;
	unsigned int mask;
	unsigned int shift;
	unsigned int reg;
	unsigned int id_size;
	unsigned int id_offset;
};

struct trace_event_raw_regmap_reg {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	unsigned int val;
	char __data[0];
};

struct trace_event_raw_regmap_bulk {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	u32 __data_loc_buf;
	int val_len;
	char __data[0];
};

struct trace_event_raw_regmap_block {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int reg;
	int count;
	char __data[0];
};

struct trace_event_raw_regcache_sync {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_status;
	u32 __data_loc_type;
	char __data[0];
};

struct trace_event_raw_regmap_bool {
	struct trace_entry ent;
	u32 __data_loc_name;
	int flag;
	char __data[0];
};

struct trace_event_raw_regmap_async {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_regcache_drop_region {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int from;
	unsigned int to;
	char __data[0];
};

struct trace_event_data_offsets_regmap_reg {
	u32 name;
};

struct trace_event_data_offsets_regmap_bulk {
	u32 name;
	u32 buf;
};

struct trace_event_data_offsets_regmap_block {
	u32 name;
};

struct trace_event_data_offsets_regcache_sync {
	u32 name;
	u32 status;
	u32 type;
};

struct trace_event_data_offsets_regmap_bool {
	u32 name;
};

struct trace_event_data_offsets_regmap_async {
	u32 name;
};

struct trace_event_data_offsets_regcache_drop_region {
	u32 name;
};

typedef void (*btf_trace_regmap_reg_write)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_reg_read_cache)(void *, struct regmap *, unsigned int, unsigned int);

typedef void (*btf_trace_regmap_bulk_write)(void *, struct regmap *, unsigned int, const void *, int);

typedef void (*btf_trace_regmap_bulk_read)(void *, struct regmap *, unsigned int, const void *, int);

typedef void (*btf_trace_regmap_hw_read_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_read_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_hw_write_done)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regcache_sync)(void *, struct regmap *, const char *, const char *);

typedef void (*btf_trace_regmap_cache_only)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_cache_bypass)(void *, struct regmap *, bool);

typedef void (*btf_trace_regmap_async_write_start)(void *, struct regmap *, unsigned int, int);

typedef void (*btf_trace_regmap_async_io_complete)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_start)(void *, struct regmap *);

typedef void (*btf_trace_regmap_async_complete_done)(void *, struct regmap *);

typedef void (*btf_trace_regcache_drop_region)(void *, struct regmap *, unsigned int, unsigned int);

struct regcache_rbtree_node {
	void *block;
	long int *cache_present;
	unsigned int base_reg;
	unsigned int blklen;
	struct rb_node node;
};

struct regcache_rbtree_ctx {
	struct rb_root root;
	struct regcache_rbtree_node *cached_rbnode;
};

struct regmap_debugfs_off_cache {
	struct list_head list;
	off_t min;
	off_t max;
	unsigned int base_reg;
	unsigned int max_reg;
};

struct regmap_debugfs_node {
	struct regmap *map;
	struct list_head link;
};

struct regmap_async_spi {
	struct regmap_async core;
	struct spi_message m;
	struct spi_transfer t[2];
};

struct regmap_mmio_context {
	void *regs;
	unsigned int val_bytes;
	bool big_endian;
	bool attached_clk;
	struct clk *clk;
	void (*reg_write)(struct regmap_mmio_context *, unsigned int, unsigned int);
	unsigned int (*reg_read)(struct regmap_mmio_context *, unsigned int);
};

struct regmap_irq_type {
	unsigned int type_reg_offset;
	unsigned int type_reg_mask;
	unsigned int type_rising_val;
	unsigned int type_falling_val;
	unsigned int type_level_low_val;
	unsigned int type_level_high_val;
	unsigned int types_supported;
};

struct regmap_irq {
	unsigned int reg_offset;
	unsigned int mask;
	struct regmap_irq_type type;
};

struct regmap_irq_sub_irq_map {
	unsigned int num_regs;
	unsigned int *offset;
};

struct regmap_irq_chip {
	const char *name;
	unsigned int main_status;
	unsigned int num_main_status_bits;
	struct regmap_irq_sub_irq_map *sub_reg_offsets;
	int num_main_regs;
	unsigned int status_base;
	unsigned int mask_base;
	unsigned int unmask_base;
	unsigned int ack_base;
	unsigned int wake_base;
	unsigned int type_base;
	unsigned int *virt_reg_base;
	const unsigned int *config_base;
	unsigned int irq_reg_stride;
	unsigned int init_ack_masked: 1;
	unsigned int mask_invert: 1;
	unsigned int mask_unmask_non_inverted: 1;
	unsigned int use_ack: 1;
	unsigned int ack_invert: 1;
	unsigned int clear_ack: 1;
	unsigned int wake_invert: 1;
	unsigned int runtime_pm: 1;
	unsigned int type_invert: 1;
	unsigned int type_in_mask: 1;
	unsigned int clear_on_unmask: 1;
	unsigned int not_fixed_stride: 1;
	unsigned int status_invert: 1;
	int num_regs;
	const struct regmap_irq *irqs;
	int num_irqs;
	int num_type_reg;
	int num_virt_regs;
	int num_config_bases;
	int num_config_regs;
	int (*handle_pre_irq)(void *);
	int (*handle_post_irq)(void *);
	int (*set_type_virt)(unsigned int **, unsigned int, long unsigned int, int);
	int (*set_type_config)(unsigned int **, unsigned int, const struct regmap_irq *, int);
	unsigned int (*get_irq_reg)(struct regmap_irq_chip_data *, unsigned int, int);
	void *irq_drv_data;
};

struct regmap_irq_chip_data {
	struct mutex lock;
	struct irq_chip irq_chip;
	struct regmap *map;
	const struct regmap_irq_chip *chip;
	int irq_base;
	struct irq_domain *domain;
	int irq;
	int wake_count;
	unsigned int mask_base;
	unsigned int unmask_base;
	void *status_reg_buf;
	unsigned int *main_status_buf;
	unsigned int *status_buf;
	unsigned int *mask_buf;
	unsigned int *mask_buf_def;
	unsigned int *wake_buf;
	unsigned int *type_buf;
	unsigned int *type_buf_def;
	unsigned int **virt_buf;
	unsigned int **config_buf;
	unsigned int irq_reg_stride;
	unsigned int (*get_irq_reg)(struct regmap_irq_chip_data *, unsigned int, int);
	unsigned int clear_status: 1;
};

struct soc_device {
	struct device dev;
	struct soc_device_attribute *attr;
	int soc_dev_num;
};

struct devcd_entry {
	struct device devcd_dev;
	void *data;
	size_t datalen;
	struct mutex mutex;
	bool delete_work;
	struct module *owner;
	ssize_t (*read)(char *, loff_t, size_t, void *, size_t);
	void (*free)(void *);
	struct delayed_work del_wk;
	struct device *failing_dev;
	int: 32;
};

typedef void (*irq_write_msi_msg_t)(struct msi_desc *, struct msi_msg *);

struct platform_msi_priv_data {
	struct device *dev;
	void *host_data;
	msi_alloc_info_t arg;
	irq_write_msi_msg_t write_msg;
	int devid;
};

enum scale_freq_source {
	SCALE_FREQ_SOURCE_CPUFREQ = 0,
	SCALE_FREQ_SOURCE_ARCH = 1,
	SCALE_FREQ_SOURCE_CPPC = 2,
};

struct scale_freq_data {
	enum scale_freq_source source;
	void (*set_freq_scale)();
};

struct trace_event_raw_thermal_pressure_update {
	struct trace_entry ent;
	long unsigned int thermal_pressure;
	int cpu;
	char __data[0];
};

struct trace_event_data_offsets_thermal_pressure_update {};

typedef void (*btf_trace_thermal_pressure_update)(void *, int, long unsigned int);

struct trace_event_raw_devres {
	struct trace_entry ent;
	u32 __data_loc_devname;
	struct device *dev;
	const char *op;
	void *node;
	const char *name;
	size_t size;
	char __data[0];
};

struct trace_event_data_offsets_devres {
	u32 devname;
};

typedef void (*btf_trace_devres_log)(void *, struct device *, const char *, void *, const char *, size_t);

struct brd_device {
	int brd_number;
	struct gendisk *brd_disk;
	struct list_head brd_list;
	spinlock_t brd_lock;
	struct xarray brd_pages;
	u64 brd_nr_pages;
};

typedef short unsigned int __kernel_old_dev_t;

enum {
	LO_FLAGS_READ_ONLY = 1,
	LO_FLAGS_AUTOCLEAR = 4,
	LO_FLAGS_PARTSCAN = 8,
	LO_FLAGS_DIRECT_IO = 16,
};

struct loop_info {
	int lo_number;
	__kernel_old_dev_t lo_device;
	long unsigned int lo_inode;
	__kernel_old_dev_t lo_rdevice;
	int lo_offset;
	int lo_encrypt_type;
	int lo_encrypt_key_size;
	int lo_flags;
	char lo_name[64];
	unsigned char lo_encrypt_key[32];
	long unsigned int lo_init[2];
	char reserved[4];
};

struct loop_info64 {
	__u64 lo_device;
	__u64 lo_inode;
	__u64 lo_rdevice;
	__u64 lo_offset;
	__u64 lo_sizelimit;
	__u32 lo_number;
	__u32 lo_encrypt_type;
	__u32 lo_encrypt_key_size;
	__u32 lo_flags;
	__u8 lo_file_name[64];
	__u8 lo_crypt_name[64];
	__u8 lo_encrypt_key[32];
	__u64 lo_init[2];
};

struct loop_config {
	__u32 fd;
	__u32 block_size;
	struct loop_info64 info;
	__u64 __reserved[8];
};

enum {
	Lo_unbound = 0,
	Lo_bound = 1,
	Lo_rundown = 2,
	Lo_deleting = 3,
};

struct loop_device {
	int lo_number;
	int: 32;
	loff_t lo_offset;
	loff_t lo_sizelimit;
	int lo_flags;
	char lo_file_name[64];
	struct file *lo_backing_file;
	struct block_device *lo_device;
	gfp_t old_gfp_mask;
	spinlock_t lo_lock;
	int lo_state;
	spinlock_t lo_work_lock;
	struct workqueue_struct *workqueue;
	struct work_struct rootcg_work;
	struct list_head rootcg_cmd_list;
	struct list_head idle_worker_list;
	struct rb_root worker_tree;
	struct timer_list timer;
	bool use_dio;
	bool sysfs_inited;
	struct request_queue *lo_queue;
	struct blk_mq_tag_set tag_set;
	struct gendisk *lo_disk;
	struct mutex lo_mutex;
	bool idr_visible;
	int: 24;
	int: 32;
};

struct loop_cmd {
	struct list_head list_entry;
	bool use_aio;
	atomic_t ref;
	long int ret;
	int: 32;
	struct kiocb iocb;
	struct bio_vec *bvec;
	struct cgroup_subsys_state *blkcg_css;
	struct cgroup_subsys_state *memcg_css;
	int: 32;
};

struct loop_worker {
	struct rb_node rb_node;
	struct work_struct work;
	struct list_head cmd_list;
	struct list_head idle_list;
	struct loop_device *lo;
	struct cgroup_subsys_state *blkcg_css;
	long unsigned int last_ran_at;
};

enum i2c_driver_flags {
	I2C_DRV_ACPI_WAIVE_D0_PROBE = 1,
};

typedef int (*nvmem_reg_read_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_reg_write_t)(void *, unsigned int, void *, size_t);

typedef int (*nvmem_cell_post_process_t)(void *, const char *, unsigned int, void *, size_t);

enum nvmem_type {
	NVMEM_TYPE_UNKNOWN = 0,
	NVMEM_TYPE_EEPROM = 1,
	NVMEM_TYPE_OTP = 2,
	NVMEM_TYPE_BATTERY_BACKED = 3,
	NVMEM_TYPE_FRAM = 4,
};

struct nvmem_keepout {
	unsigned int start;
	unsigned int end;
	unsigned char value;
};

struct nvmem_cell_info;

struct nvmem_config {
	struct device *dev;
	const char *name;
	int id;
	struct module *owner;
	struct gpio_desc *wp_gpio;
	const struct nvmem_cell_info *cells;
	int ncells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	enum nvmem_type type;
	bool read_only;
	bool root_only;
	bool ignore_wp;
	struct device_node *of_node;
	bool no_of_node;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	nvmem_cell_post_process_t cell_post_process;
	int size;
	int word_size;
	int stride;
	void *priv;
	bool compat;
	struct device *base_dev;
};

struct nvmem_cell_info {
	const char *name;
	unsigned int offset;
	unsigned int bytes;
	unsigned int bit_offset;
	unsigned int nbits;
	struct device_node *np;
};

struct at24_data {
	struct mutex lock;
	unsigned int write_max;
	unsigned int num_addresses;
	unsigned int offset_adj;
	u32 byte_len;
	u16 page_size;
	u8 flags;
	struct nvmem_device *nvmem;
	struct regulator *vcc_reg;
	void (*read_post)(unsigned int, char *, size_t);
	u8 bank_addr_shift;
	struct regmap *client_regmaps[0];
};

struct at24_chip_data {
	u32 byte_len;
	u8 flags;
	u8 bank_addr_shift;
	void (*read_post)(unsigned int, char *, size_t);
};

struct spi_eeprom {
	u32 byte_len;
	char name[10];
	u32 page_size;
	u16 flags;
	void *context;
};

struct at25_data {
	struct spi_eeprom chip;
	struct spi_device *spi;
	struct mutex lock;
	unsigned int addrlen;
	struct nvmem_config nvmem_config;
	struct nvmem_device *nvmem;
	u8 sernum[8];
	u8 command[4];
};

struct sram_config {
	int (*init)();
	bool map_only_reserved;
};

struct sram_partition {
	void *base;
	struct gen_pool *pool;
	struct bin_attribute battr;
	struct mutex lock;
	struct list_head list;
};

struct sram_dev {
	const struct sram_config *config;
	struct device *dev;
	void *virt_base;
	bool no_memory_wc;
	struct gen_pool *pool;
	struct clk *clk;
	struct sram_partition *partition;
	u32 partitions;
};

struct sram_reserve {
	struct list_head list;
	u32 start;
	u32 size;
	struct resource res;
	bool export;
	bool pool;
	bool protect_exec;
	const char *label;
};

struct pci_endpoint_test_xfer_param {
	long unsigned int size;
	unsigned char flags;
};

enum pci_barno___2 {
	BAR_0___2 = 0,
	BAR_1___2 = 1,
	BAR_2___2 = 2,
	BAR_3___2 = 3,
	BAR_4___2 = 4,
	BAR_5___2 = 5,
};

struct pci_endpoint_test {
	struct pci_dev *pdev;
	void *base;
	void *bar[6];
	struct completion irq_raised;
	int last_irq;
	int num_irqs;
	int irq_type;
	struct mutex mutex;
	struct miscdevice miscdev;
	enum pci_barno___2 test_reg_bar;
	size_t alignment;
	const char *name;
};

struct pci_endpoint_test_data {
	enum pci_barno___2 test_reg_bar;
	size_t alignment;
	int irq_type;
};

struct stmpe_client_info {
	void *data;
	int irq;
	void *client;
	struct device *dev;
	int (*read_byte)(struct stmpe *, u8);
	int (*write_byte)(struct stmpe *, u8, u8);
	int (*read_block)(struct stmpe *, u8, u8, u8 *);
	int (*write_block)(struct stmpe *, u8, u8, const u8 *);
	void (*init)(struct stmpe *);
};

struct stmpe_variant_block;

struct stmpe_variant_info {
	const char *name;
	u16 id_val;
	u16 id_mask;
	int num_gpios;
	int af_bits;
	const u8 *regs;
	struct stmpe_variant_block *blocks;
	int num_blocks;
	int num_irqs;
	int (*enable)(struct stmpe *, unsigned int, bool);
	int (*get_altfunc)(struct stmpe *, enum stmpe_block);
	int (*enable_autosleep)(struct stmpe *, int);
};

struct stmpe_platform_data {
	int id;
	unsigned int blocks;
	unsigned int irq_trigger;
	bool autosleep;
	int autosleep_timeout;
};

struct stmpe_variant_block {
	const struct mfd_cell *cell;
	int irq;
	enum stmpe_block block;
};

struct wm8994_ldo_pdata {
	const struct regulator_init_data *init_data;
};

struct wm8994_drc_cfg {
	const char *name;
	u16 regs[5];
};

struct wm8994_retune_mobile_cfg {
	const char *name;
	unsigned int rate;
	u16 regs[20];
};

struct wm8958_mbc_cfg {
	const char *name;
	u16 cutoff_regs[20];
	u16 coeff_regs[48];
	u16 combined_regs[56];
};

struct wm8958_vss_hpf_cfg {
	const char *name;
	u16 regs[2];
};

struct wm8958_vss_cfg {
	const char *name;
	u16 regs[148];
};

struct wm8958_enh_eq_cfg {
	const char *name;
	u16 regs[32];
};

struct wm8958_micd_rate {
	int sysclk;
	bool idle;
	int start;
	int rate;
};

struct wm8994_pdata {
	int gpio_base;
	int gpio_defaults[11];
	struct wm8994_ldo_pdata ldo[2];
	int irq_base;
	long unsigned int irq_flags;
	int num_drc_cfgs;
	struct wm8994_drc_cfg *drc_cfgs;
	int num_retune_mobile_cfgs;
	struct wm8994_retune_mobile_cfg *retune_mobile_cfgs;
	int num_mbc_cfgs;
	struct wm8958_mbc_cfg *mbc_cfgs;
	int num_vss_cfgs;
	struct wm8958_vss_cfg *vss_cfgs;
	int num_vss_hpf_cfgs;
	struct wm8958_vss_hpf_cfg *vss_hpf_cfgs;
	int num_enh_eq_cfgs;
	struct wm8958_enh_eq_cfg *enh_eq_cfgs;
	int num_micd_rates;
	struct wm8958_micd_rate *micd_rates;
	int micb1_delay;
	int micb2_delay;
	unsigned int lineout1_diff: 1;
	unsigned int lineout2_diff: 1;
	unsigned int lineout1fb: 1;
	unsigned int lineout2fb: 1;
	int micdet_delay;
	int mic_id_delay;
	int micdet_irq;
	unsigned int micbias1_lvl: 1;
	unsigned int micbias2_lvl: 1;
	unsigned int jd_scthr: 2;
	unsigned int jd_thr: 2;
	unsigned int jd_ext_cap: 1;
	int micbias[2];
	u16 micd_lvl_sel;
	bool ldo_ena_always_driven;
	bool spkmode_pu;
	bool csnaddr_pd;
	int max_channels_clocked[3];
	int irq_gpio;
};

enum wm8994_type {
	WM8994 = 0,
	WM8958 = 1,
	WM1811 = 2,
};

struct regulator_dev;

struct wm8994 {
	struct wm8994_pdata pdata;
	enum wm8994_type type;
	int revision;
	int cust_id;
	struct device *dev;
	struct regmap *regmap;
	bool ldo_ena_always_driven;
	int gpio_base;
	int irq_base;
	int irq;
	struct regmap_irq_chip_data *irq_data;
	struct irq_domain *edge_irq;
	bool suspended;
	struct regulator_dev *dbvdd;
	int num_supplies;
	struct regulator_bulk_data *supplies;
};

struct mxc_hdmi_data {
	struct platform_device *pdev;
	long unsigned int *reg_base;
	long unsigned int reg_phys_base;
	struct device *dev;
};

struct mc13xxx_led_platform_data {
	int id;
	const char *name;
	const char *default_trigger;
};

struct mc13xxx_leds_platform_data {
	struct mc13xxx_led_platform_data *led;
	int num_leds;
	u32 led_control[6];
};

struct mc13xxx_buttons_platform_data {
	int b1on_flags;
	short unsigned int b1on_key;
	int b2on_flags;
	short unsigned int b2on_key;
	int b3on_flags;
	short unsigned int b3on_key;
};

struct mc13xxx_ts_platform_data {
	u8 ato;
	bool atox;
};

enum mc13783_ssi_port {
	MC13783_SSI1_PORT = 0,
	MC13783_SSI2_PORT = 1,
};

struct mc13xxx_codec_platform_data {
	enum mc13783_ssi_port adc_ssi_port;
	enum mc13783_ssi_port dac_ssi_port;
};

struct mc13xxx_platform_data {
	unsigned int flags;
	struct mc13xxx_regulator_platform_data regulators;
	struct mc13xxx_leds_platform_data *leds;
	struct mc13xxx_buttons_platform_data *buttons;
	struct mc13xxx_ts_platform_data touch;
	struct mc13xxx_codec_platform_data *codec;
};

struct mc13xxx;

struct mc13xxx_variant {
	const char *name;
	void (*print_revision)(struct mc13xxx *, u32);
};

struct mc13xxx {
	struct regmap *regmap;
	struct device *dev;
	const struct mc13xxx_variant *variant;
	struct regmap_irq irqs[48];
	struct regmap_irq_chip irq_chip;
	struct regmap_irq_chip_data *irq_data;
	struct mutex lock;
	int irq;
	int flags;
	int adcflags;
};

struct mc13xxx_adcdone_data {
	struct mc13xxx *mc13xxx;
	struct completion done;
};

struct mfd_of_node_entry {
	struct list_head list;
	struct device *dev;
	struct device_node *np;
};

enum da9061_irqs {
	DA9061_IRQ_ONKEY = 0,
	DA9061_IRQ_WDG_WARN = 1,
	DA9061_IRQ_SEQ_RDY = 2,
	DA9061_IRQ_TEMP = 3,
	DA9061_IRQ_LDO_LIM = 4,
	DA9061_IRQ_DVC_RDY = 5,
	DA9061_IRQ_VDD_WARN = 6,
	DA9061_IRQ_GPI0 = 7,
	DA9061_IRQ_GPI1 = 8,
	DA9061_IRQ_GPI2 = 9,
	DA9061_IRQ_GPI3 = 10,
	DA9061_IRQ_GPI4 = 11,
	DA9061_NUM_IRQ = 12,
};

enum da9062_irqs {
	DA9062_IRQ_ONKEY = 0,
	DA9062_IRQ_ALARM = 1,
	DA9062_IRQ_TICK = 2,
	DA9062_IRQ_WDG_WARN = 3,
	DA9062_IRQ_SEQ_RDY = 4,
	DA9062_IRQ_TEMP = 5,
	DA9062_IRQ_LDO_LIM = 6,
	DA9062_IRQ_DVC_RDY = 7,
	DA9062_IRQ_VDD_WARN = 8,
	DA9062_IRQ_GPI0 = 9,
	DA9062_IRQ_GPI1 = 10,
	DA9062_IRQ_GPI2 = 11,
	DA9062_IRQ_GPI3 = 12,
	DA9062_IRQ_GPI4 = 13,
	DA9062_NUM_IRQ = 14,
};

enum da9063_irqs {
	DA9063_IRQ_ONKEY = 0,
	DA9063_IRQ_ALARM = 1,
	DA9063_IRQ_TICK = 2,
	DA9063_IRQ_ADC_RDY = 3,
	DA9063_IRQ_SEQ_RDY = 4,
	DA9063_IRQ_WAKE = 5,
	DA9063_IRQ_TEMP = 6,
	DA9063_IRQ_COMP_1V2 = 7,
	DA9063_IRQ_LDO_LIM = 8,
	DA9063_IRQ_REG_UVOV = 9,
	DA9063_IRQ_DVC_RDY = 10,
	DA9063_IRQ_VDD_MON = 11,
	DA9063_IRQ_WARN = 12,
	DA9063_IRQ_GPI0 = 13,
	DA9063_IRQ_GPI1 = 14,
	DA9063_IRQ_GPI2 = 15,
	DA9063_IRQ_GPI3 = 16,
	DA9063_IRQ_GPI4 = 17,
	DA9063_IRQ_GPI5 = 18,
	DA9063_IRQ_GPI6 = 19,
	DA9063_IRQ_GPI7 = 20,
	DA9063_IRQ_GPI8 = 21,
	DA9063_IRQ_GPI9 = 22,
	DA9063_IRQ_GPI10 = 23,
	DA9063_IRQ_GPI11 = 24,
	DA9063_IRQ_GPI12 = 25,
	DA9063_IRQ_GPI13 = 26,
	DA9063_IRQ_GPI14 = 27,
	DA9063_IRQ_GPI15 = 28,
};

enum da9063_variant_codes {
	PMIC_DA9063_AD = 3,
	PMIC_DA9063_BB = 5,
	PMIC_DA9063_CA = 6,
	PMIC_DA9063_DA = 7,
	PMIC_DA9063_EA = 8,
};

enum da9063_page_sel_buf_fmt {
	DA9063_PAGE_SEL_BUF_PAGE_REG = 0,
	DA9063_PAGE_SEL_BUF_PAGE_VAL = 1,
	DA9063_PAGE_SEL_BUF_SIZE = 2,
};

enum da9063_paged_read_msgs {
	DA9063_PAGED_READ_MSG_PAGE_SEL = 0,
	DA9063_PAGED_READ_MSG_REG_SEL = 1,
	DA9063_PAGED_READ_MSG_DATA = 2,
	DA9063_PAGED_READ_MSG_CNT = 3,
};

enum {
	DA9063_DEV_ID_REG = 0,
	DA9063_VAR_ID_REG = 1,
	DA9063_CHIP_ID_REGS = 2,
};

enum {
	PMIC_SUCCESS = 0,
	PMIC_ERROR = 4294967295,
	PMIC_PARAMETER_ERROR = 4294967294,
	PMIC_NOT_SUPPORTED = 4294967293,
	PMIC_SYSTEM_ERROR_EINTR = 4294967292,
	PMIC_MALLOC_ERROR = 4294967291,
	PMIC_UNSUBSCRIBE_ERROR = 4294967290,
	PMIC_EVENT_NOT_SUBSCRIBED = 4294967289,
	PMIC_EVENT_CALL_BACK = 4294967288,
	PMIC_CLIENT_NBOVERFLOW = 4294967287,
};

struct v4l2_rds_data {
	__u8 lsb;
	__u8 msb;
	__u8 block;
};

struct kfifo {
	union {
		struct __kfifo kfifo;
		unsigned char *type;
		const unsigned char *const_type;
		char (*rectype)[0];
		void *ptr;
		const void *ptr_const;
	};
	unsigned char buf[0];
};

enum si476x_iqclk_config {
	SI476X_IQCLK_NOOP = 0,
	SI476X_IQCLK_TRISTATE = 1,
	SI476X_IQCLK_IQ = 21,
};

enum si476x_iqfs_config {
	SI476X_IQFS_NOOP = 0,
	SI476X_IQFS_TRISTATE = 1,
	SI476X_IQFS_IQ = 21,
};

enum si476x_iout_config {
	SI476X_IOUT_NOOP = 0,
	SI476X_IOUT_TRISTATE = 1,
	SI476X_IOUT_OUTPUT = 22,
};

enum si476x_qout_config {
	SI476X_QOUT_NOOP = 0,
	SI476X_QOUT_TRISTATE = 1,
	SI476X_QOUT_OUTPUT = 22,
};

enum si476x_dclk_config {
	SI476X_DCLK_NOOP = 0,
	SI476X_DCLK_TRISTATE = 1,
	SI476X_DCLK_DAUDIO = 10,
};

enum si476x_dfs_config {
	SI476X_DFS_NOOP = 0,
	SI476X_DFS_TRISTATE = 1,
	SI476X_DFS_DAUDIO = 10,
};

enum si476x_dout_config {
	SI476X_DOUT_NOOP = 0,
	SI476X_DOUT_TRISTATE = 1,
	SI476X_DOUT_I2S_OUTPUT = 12,
	SI476X_DOUT_I2S_INPUT = 13,
};

enum si476x_xout_config {
	SI476X_XOUT_NOOP = 0,
	SI476X_XOUT_TRISTATE = 1,
	SI476X_XOUT_I2S_INPUT = 13,
	SI476X_XOUT_MODE_SELECT = 23,
};

enum si476x_icin_config {
	SI476X_ICIN_NOOP = 0,
	SI476X_ICIN_TRISTATE = 1,
	SI476X_ICIN_GPO1_HIGH = 2,
	SI476X_ICIN_GPO1_LOW = 3,
	SI476X_ICIN_IC_LINK = 30,
};

enum si476x_icip_config {
	SI476X_ICIP_NOOP = 0,
	SI476X_ICIP_TRISTATE = 1,
	SI476X_ICIP_GPO2_HIGH = 2,
	SI476X_ICIP_GPO2_LOW = 3,
	SI476X_ICIP_IC_LINK = 30,
};

enum si476x_icon_config {
	SI476X_ICON_NOOP = 0,
	SI476X_ICON_TRISTATE = 1,
	SI476X_ICON_I2S = 10,
	SI476X_ICON_IC_LINK = 30,
};

enum si476x_icop_config {
	SI476X_ICOP_NOOP = 0,
	SI476X_ICOP_TRISTATE = 1,
	SI476X_ICOP_I2S = 10,
	SI476X_ICOP_IC_LINK = 30,
};

enum si476x_lrout_config {
	SI476X_LROUT_NOOP = 0,
	SI476X_LROUT_TRISTATE = 1,
	SI476X_LROUT_AUDIO = 2,
	SI476X_LROUT_MPX = 3,
};

enum si476x_intb_config {
	SI476X_INTB_NOOP = 0,
	SI476X_INTB_TRISTATE = 1,
	SI476X_INTB_DAUDIO = 10,
	SI476X_INTB_IRQ = 40,
};

enum si476x_a1_config {
	SI476X_A1_NOOP = 0,
	SI476X_A1_TRISTATE = 1,
	SI476X_A1_IRQ = 40,
};

struct si476x_pinmux {
	enum si476x_dclk_config dclk;
	enum si476x_dfs_config dfs;
	enum si476x_dout_config dout;
	enum si476x_xout_config xout;
	enum si476x_iqclk_config iqclk;
	enum si476x_iqfs_config iqfs;
	enum si476x_iout_config iout;
	enum si476x_qout_config qout;
	enum si476x_icin_config icin;
	enum si476x_icip_config icip;
	enum si476x_icon_config icon;
	enum si476x_icop_config icop;
	enum si476x_lrout_config lrout;
	enum si476x_intb_config intb;
	enum si476x_a1_config a1;
};

enum si476x_ibias6x {
	SI476X_IBIAS6X_OTHER = 0,
	SI476X_IBIAS6X_RCVR1_NON_4MHZ_CLK = 1,
};

enum si476x_xstart {
	SI476X_XSTART_MULTIPLE_TUNER = 17,
	SI476X_XSTART_NORMAL = 119,
};

enum si476x_freq {
	SI476X_FREQ_4_MHZ = 0,
	SI476X_FREQ_37P209375_MHZ = 1,
	SI476X_FREQ_36P4_MHZ = 2,
	SI476X_FREQ_37P8_MHZ = 3,
};

enum si476x_xmode {
	SI476X_XMODE_CRYSTAL_RCVR1 = 1,
	SI476X_XMODE_EXT_CLOCK = 2,
	SI476X_XMODE_CRYSTAL_RCVR2_3 = 3,
};

enum si476x_xbiashc {
	SI476X_XBIASHC_SINGLE_RECEIVER = 0,
	SI476X_XBIASHC_MULTIPLE_RECEIVER = 1,
};

enum si476x_xbias {
	SI476X_XBIAS_RCVR2_3 = 0,
	SI476X_XBIAS_4MHZ_RCVR1 = 3,
	SI476X_XBIAS_RCVR1 = 7,
};

enum si476x_func {
	SI476X_FUNC_BOOTLOADER = 0,
	SI476X_FUNC_FM_RECEIVER = 1,
	SI476X_FUNC_AM_RECEIVER = 2,
	SI476X_FUNC_WB_RECEIVER = 3,
};

struct si476x_power_up_args {
	enum si476x_ibias6x ibias6x;
	enum si476x_xstart xstart;
	u8 xcload;
	bool fastboot;
	enum si476x_xbiashc xbiashc;
	enum si476x_xbias xbias;
	enum si476x_func func;
	enum si476x_freq freq;
	enum si476x_xmode xmode;
};

enum si476x_phase_diversity_mode {
	SI476X_PHDIV_DISABLED = 0,
	SI476X_PHDIV_PRIMARY_COMBINING = 1,
	SI476X_PHDIV_PRIMARY_ANTENNA = 2,
	SI476X_PHDIV_SECONDARY_ANTENNA = 3,
	SI476X_PHDIV_SECONDARY_COMBINING = 5,
};

struct si476x_rsq_status_report {
	__u8 multhint;
	__u8 multlint;
	__u8 snrhint;
	__u8 snrlint;
	__u8 rssihint;
	__u8 rssilint;
	__u8 bltf;
	__u8 snr_ready;
	__u8 rssiready;
	__u8 injside;
	__u8 afcrl;
	__u8 valid;
	__u16 readfreq;
	__s8 freqoff;
	__s8 rssi;
	__s8 snr;
	__s8 issi;
	__s8 lassi;
	__s8 hassi;
	__s8 mult;
	__u8 dev;
	__u16 readantcap;
	__s8 assi;
	__s8 usn;
	__u8 pilotdev;
	__u8 rdsdev;
	__u8 assidev;
	__u8 strongdev;
	__u16 rdspi;
};

struct si476x_acf_status_report {
	__u8 blend_int;
	__u8 hblend_int;
	__u8 hicut_int;
	__u8 chbw_int;
	__u8 softmute_int;
	__u8 smute;
	__u8 smattn;
	__u8 chbw;
	__u8 hicut;
	__u8 hiblend;
	__u8 pilot;
	__u8 stblend;
};

struct si476x_agc_status_report {
	__u8 mxhi;
	__u8 mxlo;
	__u8 lnahi;
	__u8 lnalo;
	__u8 fmagc1;
	__u8 fmagc2;
	__u8 pgagain;
	__u8 fmwblang;
};

struct si476x_rds_blockcount_report {
	__u16 expected;
	__u16 received;
	__u16 uncorrectable;
};

enum si476x_part_revisions {
	SI476X_REVISION_A10 = 0,
	SI476X_REVISION_A20 = 1,
	SI476X_REVISION_A30 = 2,
};

enum si476x_mfd_cells {
	SI476X_RADIO_CELL = 0,
	SI476X_CODEC_CELL = 1,
	SI476X_MFD_CELLS = 2,
};

enum si476x_power_state {
	SI476X_POWER_DOWN = 0,
	SI476X_POWER_UP_FULL = 1,
	SI476X_POWER_INCONSISTENT = 2,
};

struct si476x_core {
	struct i2c_client *client;
	struct regmap *regmap;
	int chip_id;
	int: 32;
	struct mfd_cell cells[2];
	struct mutex cmd_lock;
	atomic_t users;
	wait_queue_head_t rds_read_queue;
	struct kfifo rds_fifo;
	struct work_struct rds_fifo_drainer;
	bool rds_drainer_is_working;
	struct mutex rds_drainer_status_lock;
	wait_queue_head_t command;
	atomic_t cts;
	wait_queue_head_t tuning;
	atomic_t stc;
	struct si476x_power_up_args power_up_parameters;
	enum si476x_power_state power_state;
	struct regulator_bulk_data supplies[4];
	int gpio_reset;
	struct si476x_pinmux pinmux;
	enum si476x_phase_diversity_mode diversity_mode;
	atomic_t is_alive;
	struct delayed_work status_monitor;
	int revision;
	int rds_fifo_depth;
};

struct si476x_func_info {
	struct {
		u8 major;
		u8 minor[2];
	} firmware;
	u16 patch_id;
	enum si476x_func func;
};

struct si476x_power_down_args {
	bool xosc;
};

enum si476x_tunemode {
	SI476X_TM_VALIDATED_NORMAL_TUNE = 0,
	SI476X_TM_INVALIDATED_FAST_TUNE = 1,
	SI476X_TM_VALIDATED_AF_TUNE = 2,
	SI476X_TM_VALIDATED_AF_CHECK = 3,
};

enum si476x_smoothmetrics {
	SI476X_SM_INITIALIZE_AUDIO = 0,
	SI476X_SM_TRANSITION_AUDIO = 1,
};

struct si476x_rds_status_report {
	bool rdstpptyint;
	bool rdspiint;
	bool rdssyncint;
	bool rdsfifoint;
	bool tpptyvalid;
	bool pivalid;
	bool rdssync;
	bool rdsfifolost;
	bool tp;
	u8 pty;
	u16 pi;
	u8 rdsfifoused;
	u8 ble[4];
	struct v4l2_rds_data rds[4];
};

struct si476x_rsq_status_args {
	bool primary;
	bool rsqack;
	bool attune;
	bool cancel;
	bool stcack;
};

enum si476x_injside {
	SI476X_INJSIDE_AUTO = 0,
	SI476X_INJSIDE_LOW = 1,
	SI476X_INJSIDE_HIGH = 2,
};

struct si476x_tune_freq_args {
	bool zifsr;
	bool hd;
	enum si476x_injside injside;
	int freq;
	enum si476x_tunemode tunemode;
	enum si476x_smoothmetrics smoothmetrics;
	int antcap;
};

enum si476x_i2c_type {
	SI476X_I2C_SEND = 0,
	SI476X_I2C_RECV = 1,
};

enum si476x_status_response_bits {
	SI476X_CTS = 128,
	SI476X_ERR = 64,
	SI476X_WB_ASQ_INT = 16,
	SI476X_RSQ_INT = 8,
	SI476X_FM_RDS_INT = 4,
	SI476X_ACF_INT = 2,
	SI476X_STC_INT = 1,
};

enum si476x_acf_status_report_bits {
	SI476X_ACF_BLEND_INT = 16,
	SI476X_ACF_HIBLEND_INT = 8,
	SI476X_ACF_HICUT_INT = 4,
	SI476X_ACF_CHBW_INT = 2,
	SI476X_ACF_SOFTMUTE_INT = 1,
	SI476X_ACF_SMUTE = 1,
	SI476X_ACF_SMATTN = 31,
	SI476X_ACF_PILOT = 128,
	SI476X_ACF_STBLEND = 4294967167,
};

enum si476x_agc_status_report_bits {
	SI476X_AGC_MXHI = 32,
	SI476X_AGC_MXLO = 16,
	SI476X_AGC_LNAHI = 8,
	SI476X_AGC_LNALO = 4,
};

enum si476x_errors {
	SI476X_ERR_BAD_COMMAND = 16,
	SI476X_ERR_BAD_ARG1 = 17,
	SI476X_ERR_BAD_ARG2 = 18,
	SI476X_ERR_BAD_ARG3 = 19,
	SI476X_ERR_BAD_ARG4 = 20,
	SI476X_ERR_BUSY = 24,
	SI476X_ERR_BAD_INTERNAL_MEMORY = 32,
	SI476X_ERR_BAD_PATCH = 48,
	SI476X_ERR_BAD_BOOT_MODE = 49,
	SI476X_ERR_BAD_PROPERTY = 64,
};

typedef int (*tune_freq_func_t)(struct si476x_core *, struct si476x_tune_freq_args *);

struct si476x_property_range {
	u16 low;
	u16 high;
};

typedef bool (*valid_property_pred_t)(struct si476x_core *, u16);

struct si476x_platform_data {
	int gpio_reset;
	struct si476x_power_up_args power_up_parameters;
	enum si476x_phase_diversity_mode diversity_mode;
	struct si476x_pinmux pinmux;
};

enum si476x_freq_supported_chips {
	SI476X_CHIP_SI4761 = 1,
	SI476X_CHIP_SI4764 = 2,
	SI476X_CHIP_SI4768 = 3,
};

enum si476x_interrupt_flags {
	SI476X_STCIEN = 1,
	SI476X_ACFIEN = 2,
	SI476X_RDSIEN = 4,
	SI476X_RSQIEN = 8,
	SI476X_ERRIEN = 64,
	SI476X_CTSIEN = 128,
	SI476X_STCREP = 256,
	SI476X_ACFREP = 512,
	SI476X_RDSREP = 1024,
	SI476X_RSQREP = 2048,
};

enum si476x_common_receiver_properties {
	SI476X_PROP_INT_CTL_ENABLE = 0,
	SI476X_PROP_DIGITAL_IO_INPUT_SAMPLE_RATE = 512,
	SI476X_PROP_DIGITAL_IO_INPUT_FORMAT = 513,
	SI476X_PROP_DIGITAL_IO_OUTPUT_SAMPLE_RATE = 514,
	SI476X_PROP_DIGITAL_IO_OUTPUT_FORMAT = 515,
	SI476X_PROP_AUDIO_MUTE = 769,
	SI476X_PROP_SEEK_BAND_BOTTOM = 4352,
	SI476X_PROP_SEEK_BAND_TOP = 4353,
	SI476X_PROP_SEEK_FREQUENCY_SPACING = 4354,
	SI476X_PROP_VALID_MAX_TUNE_ERROR = 8192,
	SI476X_PROP_VALID_SNR_THRESHOLD = 8195,
	SI476X_PROP_VALID_RSSI_THRESHOLD = 8196,
};

enum {
	RN5T618_IRQ_SYS = 0,
	RN5T618_IRQ_DCDC = 1,
	RN5T618_IRQ_RTC = 2,
	RN5T618_IRQ_ADC = 3,
	RN5T618_IRQ_GPIO = 4,
	RN5T618_IRQ_CHG = 5,
	RN5T618_NR_IRQS = 6,
};

struct syscon_platform_data {
	const char *label;
};

struct syscon {
	struct device_node *np;
	struct regmap *regmap;
	struct list_head list;
};

struct dma_resv_list;

struct dma_resv {
	struct ww_mutex lock;
	struct dma_resv_list *fences;
};

struct dma_fence_unwrap {
	struct dma_fence *chain;
	struct dma_fence *array;
	unsigned int index;
};

struct sync_file {
	struct file *file;
	char user_name[32];
	struct list_head sync_file_list;
	wait_queue_head_t wq;
	long unsigned int flags;
	struct dma_fence *fence;
	struct dma_fence_cb cb;
};

enum dma_resv_usage {
	DMA_RESV_USAGE_KERNEL = 0,
	DMA_RESV_USAGE_WRITE = 1,
	DMA_RESV_USAGE_READ = 2,
	DMA_RESV_USAGE_BOOKKEEP = 3,
};

struct dma_resv_iter {
	struct dma_resv *obj;
	enum dma_resv_usage usage;
	struct dma_fence *fence;
	enum dma_resv_usage fence_usage;
	unsigned int index;
	struct dma_resv_list *fences;
	unsigned int num_fences;
	bool is_restarted;
};

struct dma_buf_sync {
	__u64 flags;
};

struct dma_buf_export_sync_file {
	__u32 flags;
	__s32 fd;
};

struct dma_buf_import_sync_file {
	__u32 flags;
	__s32 fd;
};

struct dma_buf_list {
	struct list_head head;
	struct mutex lock;
};

enum dma_fence_flag_bits {
	DMA_FENCE_FLAG_SIGNALED_BIT = 0,
	DMA_FENCE_FLAG_TIMESTAMP_BIT = 1,
	DMA_FENCE_FLAG_ENABLE_SIGNAL_BIT = 2,
	DMA_FENCE_FLAG_USER_BITS = 3,
};

struct trace_event_raw_dma_fence {
	struct trace_entry ent;
	u32 __data_loc_driver;
	u32 __data_loc_timeline;
	unsigned int context;
	unsigned int seqno;
	char __data[0];
};

struct trace_event_data_offsets_dma_fence {
	u32 driver;
	u32 timeline;
};

typedef void (*btf_trace_dma_fence_emit)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_init)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_destroy)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_enable_signal)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_signaled)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_start)(void *, struct dma_fence *);

typedef void (*btf_trace_dma_fence_wait_end)(void *, struct dma_fence *);

struct default_wait_cb {
	struct dma_fence_cb base;
	struct task_struct *task;
};

struct dma_fence_array;

struct dma_fence_array_cb {
	struct dma_fence_cb cb;
	struct dma_fence_array *array;
};

struct dma_fence_array {
	struct dma_fence base;
	spinlock_t lock;
	unsigned int num_fences;
	atomic_t num_pending;
	struct dma_fence **fences;
	struct irq_work work;
};

struct dma_fence_chain {
	struct dma_fence base;
	struct dma_fence *prev;
	int: 32;
	u64 prev_seqno;
	struct dma_fence *fence;
	union {
		struct dma_fence_cb cb;
		struct irq_work work;
	};
	spinlock_t lock;
};

struct dma_resv_list {
	struct callback_head rcu;
	u32 num_fences;
	u32 max_fences;
	struct dma_fence *table[0];
};

struct sync_merge_data {
	char name[32];
	__s32 fd2;
	__s32 fence;
	__u32 flags;
	__u32 pad;
};

struct sync_fence_info {
	char obj_name[32];
	char driver_name[32];
	__s32 status;
	__u32 flags;
	__u64 timestamp_ns;
};

struct sync_file_info {
	char name[32];
	__s32 status;
	__u32 flags;
	__u32 num_fences;
	__u32 pad;
	__u64 sync_fence_info;
};

enum sam_status {
	SAM_STAT_GOOD = 0,
	SAM_STAT_CHECK_CONDITION = 2,
	SAM_STAT_CONDITION_MET = 4,
	SAM_STAT_BUSY = 8,
	SAM_STAT_INTERMEDIATE = 16,
	SAM_STAT_INTERMEDIATE_CONDITION_MET = 20,
	SAM_STAT_RESERVATION_CONFLICT = 24,
	SAM_STAT_COMMAND_TERMINATED = 34,
	SAM_STAT_TASK_SET_FULL = 40,
	SAM_STAT_ACA_ACTIVE = 48,
	SAM_STAT_TASK_ABORTED = 64,
};

struct scsi_sense_hdr {
	u8 response_code;
	u8 sense_key;
	u8 asc;
	u8 ascq;
	u8 byte4;
	u8 byte5;
	u8 byte6;
	u8 additional_length;
};

enum scsi_host_status {
	DID_OK = 0,
	DID_NO_CONNECT = 1,
	DID_BUS_BUSY = 2,
	DID_TIME_OUT = 3,
	DID_BAD_TARGET = 4,
	DID_ABORT = 5,
	DID_PARITY = 6,
	DID_ERROR = 7,
	DID_RESET = 8,
	DID_BAD_INTR = 9,
	DID_PASSTHROUGH = 10,
	DID_SOFT_ERROR = 11,
	DID_IMM_RETRY = 12,
	DID_REQUEUE = 13,
	DID_TRANSPORT_DISRUPTED = 14,
	DID_TRANSPORT_FAILFAST = 15,
	DID_TRANSPORT_MARGINAL = 20,
};

enum scsi_disposition {
	NEEDS_RETRY = 8193,
	SUCCESS = 8194,
	FAILED = 8195,
	QUEUED = 8196,
	SOFT_ERROR = 8197,
	ADD_TO_MLQUEUE = 8198,
	TIMEOUT_ERROR = 8199,
	SCSI_RETURN_NOT_HANDLED = 8200,
	FAST_IO_FAIL = 8201,
};

typedef __u64 blist_flags_t;

enum scsi_device_state {
	SDEV_CREATED = 1,
	SDEV_RUNNING = 2,
	SDEV_CANCEL = 3,
	SDEV_DEL = 4,
	SDEV_QUIESCE = 5,
	SDEV_OFFLINE = 6,
	SDEV_TRANSPORT_OFFLINE = 7,
	SDEV_BLOCK = 8,
	SDEV_CREATED_BLOCK = 9,
};

enum scsi_device_event {
	SDEV_EVT_MEDIA_CHANGE = 1,
	SDEV_EVT_INQUIRY_CHANGE_REPORTED = 2,
	SDEV_EVT_CAPACITY_CHANGE_REPORTED = 3,
	SDEV_EVT_SOFT_THRESHOLD_REACHED_REPORTED = 4,
	SDEV_EVT_MODE_PARAMETER_CHANGE_REPORTED = 5,
	SDEV_EVT_LUN_CHANGE_REPORTED = 6,
	SDEV_EVT_ALUA_STATE_CHANGE_REPORTED = 7,
	SDEV_EVT_POWER_ON_RESET_OCCURRED = 8,
	SDEV_EVT_FIRST = 1,
	SDEV_EVT_LAST = 8,
	SDEV_EVT_MAXBITS = 9,
};

struct scsi_vpd {
	struct callback_head rcu;
	int len;
	unsigned char data[0];
};

enum scsi_vpd_parameters {
	SCSI_VPD_HEADER_SIZE = 4,
};

struct bsg_device;

struct Scsi_Host;

struct scsi_target;

struct scsi_device_handler;

struct scsi_device {
	struct Scsi_Host *host;
	struct request_queue *request_queue;
	struct list_head siblings;
	struct list_head same_target_siblings;
	struct sbitmap budget_map;
	atomic_t device_blocked;
	atomic_t restarts;
	spinlock_t list_lock;
	struct list_head starved_entry;
	short unsigned int queue_depth;
	short unsigned int max_queue_depth;
	short unsigned int last_queue_full_depth;
	short unsigned int last_queue_full_count;
	long unsigned int last_queue_full_time;
	long unsigned int queue_ramp_up_period;
	long unsigned int last_queue_ramp_up;
	unsigned int id;
	unsigned int channel;
	u64 lun;
	unsigned int manufacturer;
	unsigned int sector_size;
	void *hostdata;
	unsigned char type;
	char scsi_level;
	char inq_periph_qual;
	struct mutex inquiry_mutex;
	unsigned char inquiry_len;
	unsigned char *inquiry;
	const char *vendor;
	const char *model;
	const char *rev;
	struct scsi_vpd *vpd_pg0;
	struct scsi_vpd *vpd_pg83;
	struct scsi_vpd *vpd_pg80;
	struct scsi_vpd *vpd_pg89;
	struct scsi_vpd *vpd_pgb0;
	struct scsi_vpd *vpd_pgb1;
	struct scsi_vpd *vpd_pgb2;
	struct scsi_target *sdev_target;
	blist_flags_t sdev_bflags;
	unsigned int eh_timeout;
	unsigned int removable: 1;
	unsigned int changed: 1;
	unsigned int busy: 1;
	unsigned int lockable: 1;
	unsigned int locked: 1;
	unsigned int borken: 1;
	unsigned int disconnect: 1;
	unsigned int soft_reset: 1;
	unsigned int sdtr: 1;
	unsigned int wdtr: 1;
	unsigned int ppr: 1;
	unsigned int tagged_supported: 1;
	unsigned int simple_tags: 1;
	unsigned int was_reset: 1;
	unsigned int expecting_cc_ua: 1;
	unsigned int use_10_for_rw: 1;
	unsigned int use_10_for_ms: 1;
	unsigned int set_dbd_for_ms: 1;
	unsigned int no_report_opcodes: 1;
	unsigned int no_write_same: 1;
	unsigned int use_16_for_rw: 1;
	unsigned int skip_ms_page_8: 1;
	unsigned int skip_ms_page_3f: 1;
	unsigned int skip_vpd_pages: 1;
	unsigned int try_vpd_pages: 1;
	unsigned int use_192_bytes_for_3f: 1;
	unsigned int no_start_on_add: 1;
	unsigned int allow_restart: 1;
	unsigned int manage_start_stop: 1;
	unsigned int start_stop_pwr_cond: 1;
	unsigned int no_uld_attach: 1;
	unsigned int select_no_atn: 1;
	unsigned int fix_capacity: 1;
	unsigned int guess_capacity: 1;
	unsigned int retry_hwerror: 1;
	unsigned int last_sector_bug: 1;
	unsigned int no_read_disc_info: 1;
	unsigned int no_read_capacity_16: 1;
	unsigned int try_rc_10_first: 1;
	unsigned int security_supported: 1;
	unsigned int is_visible: 1;
	unsigned int wce_default_on: 1;
	unsigned int no_dif: 1;
	unsigned int broken_fua: 1;
	unsigned int lun_in_cdb: 1;
	unsigned int unmap_limit_for_ws: 1;
	unsigned int rpm_autosuspend: 1;
	unsigned int ignore_media_change: 1;
	unsigned int silence_suspend: 1;
	unsigned int queue_stopped;
	bool offline_already;
	atomic_t disk_events_disable_depth;
	long unsigned int supported_events[1];
	long unsigned int pending_events[1];
	struct list_head event_list;
	struct work_struct event_work;
	unsigned int max_device_blocked;
	atomic_t iorequest_cnt;
	atomic_t iodone_cnt;
	atomic_t ioerr_cnt;
	atomic_t iotmo_cnt;
	int: 32;
	struct device sdev_gendev;
	struct device sdev_dev;
	struct execute_work ew;
	struct work_struct requeue_work;
	struct scsi_device_handler *handler;
	void *handler_data;
	size_t dma_drain_len;
	void *dma_drain_buf;
	unsigned int sg_timeout;
	unsigned int sg_reserved_size;
	struct bsg_device *bsg_dev;
	unsigned char access_state;
	struct mutex state_mutex;
	enum scsi_device_state sdev_state;
	struct task_struct *quiesced_by;
	long unsigned int sdev_data[0];
	int: 32;
};

enum scsi_host_state {
	SHOST_CREATED = 1,
	SHOST_RUNNING = 2,
	SHOST_CANCEL = 3,
	SHOST_DEL = 4,
	SHOST_RECOVERY = 5,
	SHOST_CANCEL_RECOVERY = 6,
	SHOST_DEL_RECOVERY = 7,
};

struct scsi_host_template;

struct scsi_transport_template;

struct Scsi_Host {
	struct list_head __devices;
	struct list_head __targets;
	struct list_head starved_list;
	spinlock_t default_lock;
	spinlock_t *host_lock;
	struct mutex scan_mutex;
	struct list_head eh_abort_list;
	struct list_head eh_cmd_q;
	struct task_struct *ehandler;
	struct completion *eh_action;
	wait_queue_head_t host_wait;
	struct scsi_host_template *hostt;
	struct scsi_transport_template *transportt;
	struct kref tagset_refcnt;
	struct completion tagset_freed;
	struct blk_mq_tag_set tag_set;
	atomic_t host_blocked;
	unsigned int host_failed;
	unsigned int host_eh_scheduled;
	unsigned int host_no;
	int eh_deadline;
	long unsigned int last_reset;
	unsigned int max_channel;
	unsigned int max_id;
	int: 32;
	u64 max_lun;
	unsigned int unique_id;
	short unsigned int max_cmd_len;
	int this_id;
	int can_queue;
	short int cmd_per_lun;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int opt_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	unsigned int nr_hw_queues;
	unsigned int nr_maps;
	unsigned int active_mode: 2;
	unsigned int host_self_blocked: 1;
	unsigned int reverse_ordering: 1;
	unsigned int tmf_in_progress: 1;
	unsigned int async_scan: 1;
	unsigned int eh_noresume: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int short_inquiry: 1;
	unsigned int no_scsi2_lun_in_cdb: 1;
	char work_q_name[20];
	struct workqueue_struct *work_q;
	struct workqueue_struct *tmf_work_q;
	unsigned int max_host_blocked;
	unsigned int prot_capabilities;
	unsigned char prot_guard_type;
	long unsigned int base;
	long unsigned int io_port;
	unsigned char n_io_port;
	unsigned char dma_channel;
	unsigned int irq;
	enum scsi_host_state shost_state;
	int: 32;
	struct device shost_gendev;
	struct device shost_dev;
	void *shost_data;
	struct device *dma_dev;
	long unsigned int hostdata[0];
};

enum scsi_target_state {
	STARGET_CREATED = 1,
	STARGET_RUNNING = 2,
	STARGET_REMOVE = 3,
	STARGET_CREATED_REMOVE = 4,
	STARGET_DEL = 5,
};

struct scsi_target {
	struct scsi_device *starget_sdev_user;
	struct list_head siblings;
	struct list_head devices;
	int: 32;
	struct device dev;
	struct kref reap_ref;
	unsigned int channel;
	unsigned int id;
	unsigned int create: 1;
	unsigned int single_lun: 1;
	unsigned int pdt_1f_for_no_lun: 1;
	unsigned int no_report_luns: 1;
	unsigned int expecting_lun_change: 1;
	atomic_t target_busy;
	atomic_t target_blocked;
	unsigned int can_queue;
	unsigned int max_target_blocked;
	char scsi_level;
	enum scsi_target_state state;
	void *hostdata;
	long unsigned int starget_data[0];
	int: 32;
};

struct scsi_data_buffer {
	struct sg_table table;
	unsigned int length;
};

enum scsi_cmnd_submitter {
	SUBMITTED_BY_BLOCK_LAYER = 0,
	SUBMITTED_BY_SCSI_ERROR_HANDLER = 1,
	SUBMITTED_BY_SCSI_RESET_IOCTL = 2,
};

struct scsi_cmnd {
	struct scsi_device *device;
	struct list_head eh_entry;
	struct delayed_work abort_work;
	struct callback_head rcu;
	int eh_eflags;
	int budget_token;
	long unsigned int jiffies_at_alloc;
	int retries;
	int allowed;
	unsigned char prot_op;
	unsigned char prot_type;
	unsigned char prot_flags;
	enum scsi_cmnd_submitter submitter;
	short unsigned int cmd_len;
	enum dma_data_direction sc_data_direction;
	unsigned char cmnd[32];
	struct scsi_data_buffer sdb;
	struct scsi_data_buffer *prot_sdb;
	unsigned int underflow;
	unsigned int transfersize;
	unsigned int resid_len;
	unsigned int sense_len;
	unsigned char *sense_buffer;
	int flags;
	long unsigned int state;
	unsigned int extra_len;
	unsigned char *host_scribble;
	int result;
};

enum scsi_prot_operations {
	SCSI_PROT_NORMAL = 0,
	SCSI_PROT_READ_INSERT = 1,
	SCSI_PROT_WRITE_STRIP = 2,
	SCSI_PROT_READ_STRIP = 3,
	SCSI_PROT_WRITE_INSERT = 4,
	SCSI_PROT_READ_PASS = 5,
	SCSI_PROT_WRITE_PASS = 6,
};

struct scsi_driver {
	struct device_driver gendrv;
	void (*rescan)(struct device *);
	blk_status_t (*init_command)(struct scsi_cmnd *);
	void (*uninit_command)(struct scsi_cmnd *);
	int (*done)(struct scsi_cmnd *);
	int (*eh_action)(struct scsi_cmnd *, int);
	void (*eh_reset)(struct scsi_cmnd *);
};

struct scsi_host_template {
	unsigned int cmd_size;
	int (*queuecommand)(struct Scsi_Host *, struct scsi_cmnd *);
	void (*commit_rqs)(struct Scsi_Host *, u16);
	struct module *module;
	const char *name;
	const char * (*info)(struct Scsi_Host *);
	int (*ioctl)(struct scsi_device *, unsigned int, void *);
	int (*init_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*exit_cmd_priv)(struct Scsi_Host *, struct scsi_cmnd *);
	int (*eh_abort_handler)(struct scsi_cmnd *);
	int (*eh_device_reset_handler)(struct scsi_cmnd *);
	int (*eh_target_reset_handler)(struct scsi_cmnd *);
	int (*eh_bus_reset_handler)(struct scsi_cmnd *);
	int (*eh_host_reset_handler)(struct scsi_cmnd *);
	int (*slave_alloc)(struct scsi_device *);
	int (*slave_configure)(struct scsi_device *);
	void (*slave_destroy)(struct scsi_device *);
	int (*target_alloc)(struct scsi_target *);
	void (*target_destroy)(struct scsi_target *);
	int (*scan_finished)(struct Scsi_Host *, long unsigned int);
	void (*scan_start)(struct Scsi_Host *);
	int (*change_queue_depth)(struct scsi_device *, int);
	void (*map_queues)(struct Scsi_Host *);
	int (*mq_poll)(struct Scsi_Host *, unsigned int);
	bool (*dma_need_drain)(struct request *);
	int (*bios_param)(struct scsi_device *, struct block_device *, sector_t, int *);
	void (*unlock_native_capacity)(struct scsi_device *);
	int (*show_info)(struct seq_file *, struct Scsi_Host *);
	int (*write_info)(struct Scsi_Host *, char *, int);
	enum blk_eh_timer_return (*eh_timed_out)(struct scsi_cmnd *);
	bool (*eh_should_retry_cmd)(struct scsi_cmnd *);
	int (*host_reset)(struct Scsi_Host *, int);
	const char *proc_name;
	struct proc_dir_entry *proc_dir;
	int can_queue;
	int this_id;
	short unsigned int sg_tablesize;
	short unsigned int sg_prot_tablesize;
	unsigned int max_sectors;
	unsigned int max_segment_size;
	long unsigned int dma_boundary;
	long unsigned int virt_boundary_mask;
	short int cmd_per_lun;
	unsigned char present;
	int tag_alloc_policy;
	unsigned int track_queue_depth: 1;
	unsigned int supported_mode: 2;
	unsigned int emulated: 1;
	unsigned int skip_settle_delay: 1;
	unsigned int no_write_same: 1;
	unsigned int host_tagset: 1;
	unsigned int max_host_blocked;
	const struct attribute_group **shost_groups;
	const struct attribute_group **sdev_groups;
	int: 32;
	u64 vendor_id;
	int rpm_autosuspend_delay;
	int: 32;
};

struct trace_event_raw_scsi_dispatch_cmd_start {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_dispatch_cmd_error {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int rtn;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_cmd_done_timeout_template {
	struct trace_entry ent;
	unsigned int host_no;
	unsigned int channel;
	unsigned int id;
	unsigned int lun;
	int result;
	unsigned int opcode;
	unsigned int cmd_len;
	int driver_tag;
	int scheduler_tag;
	unsigned int data_sglen;
	unsigned int prot_sglen;
	unsigned char prot_op;
	u32 __data_loc_cmnd;
	char __data[0];
};

struct trace_event_raw_scsi_eh_wakeup {
	struct trace_entry ent;
	unsigned int host_no;
	char __data[0];
};

struct trace_event_data_offsets_scsi_dispatch_cmd_start {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_dispatch_cmd_error {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_cmd_done_timeout_template {
	u32 cmnd;
};

struct trace_event_data_offsets_scsi_eh_wakeup {};

typedef void (*btf_trace_scsi_dispatch_cmd_start)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_error)(void *, struct scsi_cmnd *, int);

typedef void (*btf_trace_scsi_dispatch_cmd_done)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_dispatch_cmd_timeout)(void *, struct scsi_cmnd *);

typedef void (*btf_trace_scsi_eh_wakeup)(void *, struct Scsi_Host *);

struct scsi_transport_template {
	struct transport_container host_attrs;
	struct transport_container target_attrs;
	struct transport_container device_attrs;
	int (*user_scan)(struct Scsi_Host *, uint, uint, u64);
	int device_size;
	int device_private_offset;
	int target_size;
	int target_private_offset;
	int host_size;
	unsigned int create_work_queue: 1;
	void (*eh_strategy_handler)(struct Scsi_Host *);
};

struct scsi_host_busy_iter_data {
	bool (*fn)(struct scsi_cmnd *, void *);
	void *priv;
};

struct request_sense;

struct cdrom_generic_command {
	unsigned char cmd[12];
	unsigned char *buffer;
	unsigned int buflen;
	int stat;
	struct request_sense *sense;
	unsigned char data_direction;
	int quiet;
	int timeout;
	union {
		void *reserved[1];
		void *unused;
	};
};

struct request_sense {
	__u8 error_code: 7;
	__u8 valid: 1;
	__u8 segment_number;
	__u8 sense_key: 4;
	__u8 reserved2: 1;
	__u8 ili: 1;
	__u8 reserved1: 2;
	__u8 information[4];
	__u8 add_sense_len;
	__u8 command_info[4];
	__u8 asc;
	__u8 ascq;
	__u8 fruc;
	__u8 sks[3];
	__u8 asb[46];
};

enum scsi_msg_byte {
	COMMAND_COMPLETE = 0,
	EXTENDED_MESSAGE = 1,
	SAVE_POINTERS = 2,
	RESTORE_POINTERS = 3,
	DISCONNECT = 4,
	INITIATOR_ERROR = 5,
	ABORT_TASK_SET = 6,
	MESSAGE_REJECT = 7,
	NOP = 8,
	MSG_PARITY_ERROR = 9,
	LINKED_CMD_COMPLETE = 10,
	LINKED_FLG_CMD_COMPLETE = 11,
	TARGET_RESET = 12,
	ABORT_TASK = 13,
	CLEAR_TASK_SET = 14,
	INITIATE_RECOVERY = 15,
	RELEASE_RECOVERY = 16,
	TERMINATE_IO_PROC = 17,
	CLEAR_ACA = 22,
	LOGICAL_UNIT_RESET = 23,
	SIMPLE_QUEUE_TAG = 32,
	HEAD_OF_QUEUE_TAG = 33,
	ORDERED_QUEUE_TAG = 34,
	IGNORE_WIDE_RESIDUE = 35,
	ACA = 36,
	QAS_REQUEST = 85,
	BUS_DEVICE_RESET = 12,
	ABORT = 6,
};

struct scsi_ioctl_command {
	unsigned int inlen;
	unsigned int outlen;
	unsigned char data[0];
};

struct scsi_idlun {
	__u32 dev_id;
	__u32 host_unique_id;
};

struct sg_io_hdr {
	int interface_id;
	int dxfer_direction;
	unsigned char cmd_len;
	unsigned char mx_sb_len;
	short unsigned int iovec_count;
	unsigned int dxfer_len;
	void *dxferp;
	unsigned char *cmdp;
	void *sbp;
	unsigned int timeout;
	unsigned int flags;
	int pack_id;
	void *usr_ptr;
	unsigned char status;
	unsigned char masked_status;
	unsigned char msg_status;
	unsigned char sb_len_wr;
	short unsigned int host_status;
	short unsigned int driver_status;
	int resid;
	unsigned int duration;
	unsigned int info;
};

typedef void (*activate_complete)(void *, int);

struct scsi_device_handler {
	struct list_head list;
	struct module *module;
	const char *name;
	enum scsi_disposition (*check_sense)(struct scsi_device *, struct scsi_sense_hdr *);
	int (*attach)(struct scsi_device *);
	void (*detach)(struct scsi_device *);
	int (*activate)(struct scsi_device *, activate_complete, void *);
	blk_status_t (*prep_fn)(struct scsi_device *, struct request *);
	int (*set_params)(struct scsi_device *, const char *);
	void (*rescan)(struct scsi_device *);
};

struct scsi_eh_save {
	int result;
	unsigned int resid_len;
	int eh_eflags;
	enum dma_data_direction data_direction;
	unsigned int underflow;
	unsigned char cmd_len;
	unsigned char prot_op;
	unsigned char cmnd[32];
	struct scsi_data_buffer sdb;
	struct scatterlist sense_sgl;
};

enum scsi_ml_status {
	SCSIML_STAT_OK = 0,
	SCSIML_STAT_RESV_CONFLICT = 1,
	SCSIML_STAT_NOSPC = 2,
	SCSIML_STAT_MED_ERROR = 3,
	SCSIML_STAT_TGT_FAILURE = 4,
};

struct scsi_mode_data {
	__u32 length;
	__u16 block_descriptor_length;
	__u8 medium_type;
	__u8 device_specific;
	__u8 header_length;
	__u8 longlba: 1;
};

struct scsi_event {
	enum scsi_device_event evt_type;
	struct list_head node;
};

enum scsi_host_prot_capabilities {
	SHOST_DIF_TYPE1_PROTECTION = 1,
	SHOST_DIF_TYPE2_PROTECTION = 2,
	SHOST_DIF_TYPE3_PROTECTION = 4,
	SHOST_DIX_TYPE0_PROTECTION = 8,
	SHOST_DIX_TYPE1_PROTECTION = 16,
	SHOST_DIX_TYPE2_PROTECTION = 32,
	SHOST_DIX_TYPE3_PROTECTION = 64,
};

enum {
	ACTION_FAIL = 0,
	ACTION_REPREP = 1,
	ACTION_DELAYED_REPREP = 2,
	ACTION_RETRY = 3,
	ACTION_DELAYED_RETRY = 4,
};

struct value_name_pair;

struct sa_name_list {
	int opcode;
	const struct value_name_pair *arr;
	int arr_sz;
};

struct value_name_pair {
	int value;
	const char *name;
};

struct error_info {
	short unsigned int code12;
	short unsigned int size;
};

struct error_info2 {
	unsigned char code1;
	unsigned char code2_min;
	unsigned char code2_max;
	const char *str;
	const char *fmt;
};

struct scsi_lun {
	__u8 scsi_lun[8];
};

enum scsi_timeouts {
	SCSI_DEFAULT_EH_TIMEOUT = 1000,
};

enum scsi_scan_mode {
	SCSI_SCAN_INITIAL = 0,
	SCSI_SCAN_RESCAN = 1,
	SCSI_SCAN_MANUAL = 2,
};

struct async_scan_data {
	struct list_head list;
	struct Scsi_Host *shost;
	struct completion prev_finished;
};

enum scsi_devinfo_key {
	SCSI_DEVINFO_GLOBAL = 0,
	SCSI_DEVINFO_SPI = 1,
};

struct scsi_dev_info_list {
	struct list_head dev_info_list;
	char vendor[8];
	char model[16];
	blist_flags_t flags;
	unsigned int compatible;
	int: 32;
};

struct scsi_dev_info_list_table {
	struct list_head node;
	struct list_head scsi_dev_info_list;
	const char *name;
	int key;
};

struct scsi_varlen_cdb_hdr {
	__u8 opcode;
	__u8 control;
	__u8 misc[5];
	__u8 additional_cdb_length;
	__be16 service_action;
};

enum bip_flags {
	BIP_BLOCK_INTEGRITY = 1,
	BIP_MAPPED_INTEGRITY = 2,
	BIP_CTRL_NOCHECK = 4,
	BIP_DISK_NOCHECK = 8,
	BIP_IP_CHECKSUM = 16,
};

enum t10_dif_type {
	T10_PI_TYPE0_PROTECTION = 0,
	T10_PI_TYPE1_PROTECTION = 1,
	T10_PI_TYPE2_PROTECTION = 2,
	T10_PI_TYPE3_PROTECTION = 3,
};

enum scsi_prot_flags {
	SCSI_PROT_TRANSFER_PI = 1,
	SCSI_PROT_GUARD_CHECK = 2,
	SCSI_PROT_REF_CHECK = 4,
	SCSI_PROT_REF_INCREMENT = 8,
	SCSI_PROT_IP_CHECKSUM = 16,
};

enum {
	SD_EXT_CDB_SIZE = 32,
	SD_MEMPOOL_SIZE = 2,
};

enum {
	SD_DEF_XFER_BLOCKS = 65535,
	SD_MAX_XFER_BLOCKS = 4294967295,
	SD_MAX_WS10_BLOCKS = 65535,
	SD_MAX_WS16_BLOCKS = 8388607,
};

enum {
	SD_LBP_FULL = 0,
	SD_LBP_UNMAP = 1,
	SD_LBP_WS16 = 2,
	SD_LBP_WS10 = 3,
	SD_LBP_ZERO = 4,
	SD_LBP_DISABLE = 5,
};

enum {
	SD_ZERO_WRITE = 0,
	SD_ZERO_WS = 1,
	SD_ZERO_WS16_UNMAP = 2,
	SD_ZERO_WS10_UNMAP = 3,
};

struct opal_dev;

struct scsi_disk {
	struct scsi_device *device;
	int: 32;
	struct device disk_dev;
	struct gendisk *disk;
	struct opal_dev *opal_dev;
	atomic_t openers;
	int: 32;
	sector_t capacity;
	int max_retries;
	u32 min_xfer_blocks;
	u32 max_xfer_blocks;
	u32 opt_xfer_blocks;
	u32 max_ws_blocks;
	u32 max_unmap_blocks;
	u32 unmap_granularity;
	u32 unmap_alignment;
	u32 index;
	unsigned int physical_block_size;
	unsigned int max_medium_access_timeouts;
	unsigned int medium_access_timed_out;
	u8 media_present;
	u8 write_prot;
	u8 protection_type;
	u8 provisioning_mode;
	u8 zeroing_mode;
	u8 nr_actuators;
	unsigned int ATO: 1;
	unsigned int cache_override: 1;
	unsigned int WCE: 1;
	unsigned int RCD: 1;
	unsigned int DPOFUA: 1;
	unsigned int first_scan: 1;
	unsigned int lbpme: 1;
	unsigned int lbprz: 1;
	unsigned int lbpu: 1;
	unsigned int lbpws: 1;
	unsigned int lbpws10: 1;
	unsigned int lbpvpd: 1;
	unsigned int ws10: 1;
	unsigned int ws16: 1;
	unsigned int rc_basis: 2;
	unsigned int zoned: 2;
	unsigned int urswrz: 1;
	unsigned int security: 1;
	unsigned int ignore_medium_access_errors: 1;
	int: 27;
	int: 32;
};

enum nvme_subsys_type {
	NVME_NQN_DISC = 1,
	NVME_NQN_NVME = 2,
	NVME_NQN_CURR = 3,
};

enum nvme_ctrl_type {
	NVME_CTRL_IO = 1,
	NVME_CTRL_DISC = 2,
	NVME_CTRL_ADMIN = 3,
};

enum nvme_dctype {
	NVME_DCTYPE_NOT_REPORTED = 0,
	NVME_DCTYPE_DDC = 1,
	NVME_DCTYPE_CDC = 2,
};

enum {
	NVME_CAP_CSS_NVM = 1,
	NVME_CAP_CSS_CSI = 64,
};

enum {
	NVME_CAP_CRMS_CRWMS = 0,
	NVME_CAP_CRMS_CRIMS = 0,
};

struct nvme_id_power_state {
	__le16 max_power;
	__u8 rsvd2;
	__u8 flags;
	__le32 entry_lat;
	__le32 exit_lat;
	__u8 read_tput;
	__u8 read_lat;
	__u8 write_tput;
	__u8 write_lat;
	__le16 idle_power;
	__u8 idle_scale;
	__u8 rsvd19;
	__le16 active_power;
	__u8 active_work_scale;
	__u8 rsvd23[9];
};

enum {
	NVME_PS_FLAGS_MAX_POWER_SCALE = 1,
	NVME_PS_FLAGS_NON_OP_STATE = 2,
};

enum nvme_ctrl_attr {
	NVME_CTRL_ATTR_HID_128_BIT = 1,
	NVME_CTRL_ATTR_TBKAS = 64,
	NVME_CTRL_ATTR_ELBAS = 32768,
};

struct nvme_id_ctrl {
	__le16 vid;
	__le16 ssvid;
	char sn[20];
	char mn[40];
	char fr[8];
	__u8 rab;
	__u8 ieee[3];
	__u8 cmic;
	__u8 mdts;
	__le16 cntlid;
	__le32 ver;
	__le32 rtd3r;
	__le32 rtd3e;
	__le32 oaes;
	__le32 ctratt;
	__u8 rsvd100[11];
	__u8 cntrltype;
	__u8 fguid[16];
	__le16 crdt1;
	__le16 crdt2;
	__le16 crdt3;
	__u8 rsvd134[122];
	__le16 oacs;
	__u8 acl;
	__u8 aerl;
	__u8 frmw;
	__u8 lpa;
	__u8 elpe;
	__u8 npss;
	__u8 avscc;
	__u8 apsta;
	__le16 wctemp;
	__le16 cctemp;
	__le16 mtfa;
	__le32 hmpre;
	__le32 hmmin;
	__u8 tnvmcap[16];
	__u8 unvmcap[16];
	__le32 rpmbs;
	__le16 edstt;
	__u8 dsto;
	__u8 fwug;
	__le16 kas;
	__le16 hctma;
	__le16 mntmt;
	__le16 mxtmt;
	__le32 sanicap;
	__le32 hmminds;
	__le16 hmmaxd;
	__u8 rsvd338[4];
	__u8 anatt;
	__u8 anacap;
	__le32 anagrpmax;
	__le32 nanagrpid;
	__u8 rsvd352[160];
	__u8 sqes;
	__u8 cqes;
	__le16 maxcmd;
	__le32 nn;
	__le16 oncs;
	__le16 fuses;
	__u8 fna;
	__u8 vwc;
	__le16 awun;
	__le16 awupf;
	__u8 nvscc;
	__u8 nwpc;
	__le16 acwu;
	__u8 rsvd534[2];
	__le32 sgls;
	__le32 mnan;
	__u8 rsvd544[224];
	char subnqn[256];
	__u8 rsvd1024[768];
	__le32 ioccsz;
	__le32 iorcsz;
	__le16 icdoff;
	__u8 ctrattr;
	__u8 msdbd;
	__u8 rsvd1804[2];
	__u8 dctype;
	__u8 rsvd1807[241];
	struct nvme_id_power_state psd[32];
	__u8 vs[1024];
};

enum {
	NVME_CTRL_CMIC_MULTI_PORT = 1,
	NVME_CTRL_CMIC_MULTI_CTRL = 2,
	NVME_CTRL_CMIC_ANA = 8,
	NVME_CTRL_ONCS_COMPARE = 1,
	NVME_CTRL_ONCS_WRITE_UNCORRECTABLE = 2,
	NVME_CTRL_ONCS_DSM = 4,
	NVME_CTRL_ONCS_WRITE_ZEROES = 8,
	NVME_CTRL_ONCS_RESERVATIONS = 32,
	NVME_CTRL_ONCS_TIMESTAMP = 64,
	NVME_CTRL_VWC_PRESENT = 1,
	NVME_CTRL_OACS_SEC_SUPP = 1,
	NVME_CTRL_OACS_NS_MNGT_SUPP = 8,
	NVME_CTRL_OACS_DIRECTIVES = 32,
	NVME_CTRL_OACS_DBBUF_SUPP = 256,
	NVME_CTRL_LPA_CMD_EFFECTS_LOG = 2,
	NVME_CTRL_CTRATT_128_ID = 1,
	NVME_CTRL_CTRATT_NON_OP_PSP = 2,
	NVME_CTRL_CTRATT_NVM_SETS = 4,
	NVME_CTRL_CTRATT_READ_RECV_LVLS = 8,
	NVME_CTRL_CTRATT_ENDURANCE_GROUPS = 16,
	NVME_CTRL_CTRATT_PREDICTABLE_LAT = 32,
	NVME_CTRL_CTRATT_NAMESPACE_GRANULARITY = 128,
	NVME_CTRL_CTRATT_UUID_LIST = 512,
};

struct nvme_lbaf {
	__le16 ms;
	__u8 ds;
	__u8 rp;
};

struct nvme_id_ns {
	__le64 nsze;
	__le64 ncap;
	__le64 nuse;
	__u8 nsfeat;
	__u8 nlbaf;
	__u8 flbas;
	__u8 mc;
	__u8 dpc;
	__u8 dps;
	__u8 nmic;
	__u8 rescap;
	__u8 fpi;
	__u8 dlfeat;
	__le16 nawun;
	__le16 nawupf;
	__le16 nacwu;
	__le16 nabsn;
	__le16 nabo;
	__le16 nabspf;
	__le16 noiob;
	__u8 nvmcap[16];
	__le16 npwg;
	__le16 npwa;
	__le16 npdg;
	__le16 npda;
	__le16 nows;
	__u8 rsvd74[18];
	__le32 anagrpid;
	__u8 rsvd96[3];
	__u8 nsattr;
	__le16 nvmsetid;
	__le16 endgid;
	__u8 nguid[16];
	__u8 eui64[8];
	struct nvme_lbaf lbaf[64];
	__u8 vs[3712];
};

struct nvme_id_ns_cs_indep {
	__u8 nsfeat;
	__u8 nmic;
	__u8 rescap;
	__u8 fpi;
	__le32 anagrpid;
	__u8 nsattr;
	__u8 rsvd9;
	__le16 nvmsetid;
	__le16 endgid;
	__u8 nstat;
	__u8 rsvd15[4081];
};

struct nvme_id_ns_nvm {
	__le64 lbstm;
	__u8 pic;
	__u8 rsvd9[3];
	__le32 elbaf[64];
	__u8 rsvd268[3828];
};

enum {
	NVME_ID_NS_NVM_STS_MASK = 63,
	NVME_ID_NS_NVM_GUARD_SHIFT = 7,
	NVME_ID_NS_NVM_GUARD_MASK = 3,
};

struct nvme_id_ctrl_nvm {
	__u8 vsl;
	__u8 wzsl;
	__u8 wusl;
	__u8 dmrl;
	__le32 dmrsl;
	__le64 dmsl;
	__u8 rsvd16[4080];
};

enum {
	NVME_ID_CNS_NS = 0,
	NVME_ID_CNS_CTRL = 1,
	NVME_ID_CNS_NS_ACTIVE_LIST = 2,
	NVME_ID_CNS_NS_DESC_LIST = 3,
	NVME_ID_CNS_CS_NS = 5,
	NVME_ID_CNS_CS_CTRL = 6,
	NVME_ID_CNS_NS_CS_INDEP = 8,
	NVME_ID_CNS_NS_PRESENT_LIST = 16,
	NVME_ID_CNS_NS_PRESENT = 17,
	NVME_ID_CNS_CTRL_NS_LIST = 18,
	NVME_ID_CNS_CTRL_LIST = 19,
	NVME_ID_CNS_SCNDRY_CTRL_LIST = 21,
	NVME_ID_CNS_NS_GRANULARITY = 22,
	NVME_ID_CNS_UUID_LIST = 23,
};

enum {
	NVME_CSI_NVM = 0,
	NVME_CSI_ZNS = 2,
};

enum {
	NVME_NS_FEAT_THIN = 1,
	NVME_NS_FEAT_ATOMICS = 2,
	NVME_NS_FEAT_IO_OPT = 16,
	NVME_NS_ATTR_RO = 1,
	NVME_NS_FLBAS_LBA_MASK = 15,
	NVME_NS_FLBAS_LBA_UMASK = 96,
	NVME_NS_FLBAS_LBA_SHIFT = 1,
	NVME_NS_FLBAS_META_EXT = 16,
	NVME_NS_NMIC_SHARED = 1,
	NVME_LBAF_RP_BEST = 0,
	NVME_LBAF_RP_BETTER = 1,
	NVME_LBAF_RP_GOOD = 2,
	NVME_LBAF_RP_DEGRADED = 3,
	NVME_NS_DPC_PI_LAST = 16,
	NVME_NS_DPC_PI_FIRST = 8,
	NVME_NS_DPC_PI_TYPE3 = 4,
	NVME_NS_DPC_PI_TYPE2 = 2,
	NVME_NS_DPC_PI_TYPE1 = 1,
	NVME_NS_DPS_PI_FIRST = 8,
	NVME_NS_DPS_PI_MASK = 7,
	NVME_NS_DPS_PI_TYPE1 = 1,
	NVME_NS_DPS_PI_TYPE2 = 2,
	NVME_NS_DPS_PI_TYPE3 = 3,
};

enum {
	NVME_NSTAT_NRDY = 1,
};

enum {
	NVME_NVM_NS_16B_GUARD = 0,
	NVME_NVM_NS_32B_GUARD = 1,
	NVME_NVM_NS_64B_GUARD = 2,
};

struct nvme_ns_id_desc {
	__u8 nidt;
	__u8 nidl;
	__le16 reserved;
};

enum {
	NVME_NIDT_EUI64 = 1,
	NVME_NIDT_NGUID = 2,
	NVME_NIDT_UUID = 3,
	NVME_NIDT_CSI = 4,
};

struct nvme_fw_slot_info_log {
	__u8 afi;
	__u8 rsvd1[7];
	__le64 frs[7];
	__u8 rsvd64[448];
};

enum {
	NVME_CMD_EFFECTS_CSUPP = 1,
	NVME_CMD_EFFECTS_LBCC = 2,
	NVME_CMD_EFFECTS_NCC = 4,
	NVME_CMD_EFFECTS_NIC = 8,
	NVME_CMD_EFFECTS_CCC = 16,
	NVME_CMD_EFFECTS_CSE_MASK = 196608,
	NVME_CMD_EFFECTS_UUID_SEL = 524288,
};

struct nvme_effects_log {
	__le32 acs[256];
	__le32 iocs[256];
	__u8 resv[2048];
};

enum {
	NVME_AER_ERROR = 0,
	NVME_AER_SMART = 1,
	NVME_AER_NOTICE = 2,
	NVME_AER_CSS = 6,
	NVME_AER_VS = 7,
};

enum {
	NVME_AER_ERROR_PERSIST_INT_ERR = 3,
};

enum {
	NVME_AER_NOTICE_NS_CHANGED = 0,
	NVME_AER_NOTICE_FW_ACT_STARTING = 1,
	NVME_AER_NOTICE_ANA = 3,
	NVME_AER_NOTICE_DISC_CHANGED = 240,
};

enum {
	NVME_AEN_BIT_NS_ATTR = 8,
	NVME_AEN_BIT_FW_ACT = 9,
	NVME_AEN_BIT_ANA_CHANGE = 11,
	NVME_AEN_BIT_DISC_CHANGE = 31,
};

enum {
	NVME_AEN_CFG_NS_ATTR = 256,
	NVME_AEN_CFG_FW_ACT = 512,
	NVME_AEN_CFG_ANA_CHANGE = 2048,
	NVME_AEN_CFG_DISC_CHANGE = 2147483648,
};

enum nvme_opcode {
	nvme_cmd_flush = 0,
	nvme_cmd_write = 1,
	nvme_cmd_read = 2,
	nvme_cmd_write_uncor = 4,
	nvme_cmd_compare = 5,
	nvme_cmd_write_zeroes = 8,
	nvme_cmd_dsm = 9,
	nvme_cmd_verify = 12,
	nvme_cmd_resv_register = 13,
	nvme_cmd_resv_report = 14,
	nvme_cmd_resv_acquire = 17,
	nvme_cmd_resv_release = 21,
	nvme_cmd_zone_mgmt_send = 121,
	nvme_cmd_zone_mgmt_recv = 122,
	nvme_cmd_zone_append = 125,
};

struct nvme_sgl_desc {
	__le64 addr;
	__le32 length;
	__u8 rsvd[3];
	__u8 type;
};

struct nvme_keyed_sgl_desc {
	__le64 addr;
	__u8 length[3];
	__u8 key[4];
	__u8 type;
};

union nvme_data_ptr {
	struct {
		__le64 prp1;
		__le64 prp2;
	};
	struct nvme_sgl_desc sgl;
	struct nvme_keyed_sgl_desc ksgl;
};

enum {
	NVME_CMD_FUSE_FIRST = 1,
	NVME_CMD_FUSE_SECOND = 2,
	NVME_CMD_SGL_METABUF = 64,
	NVME_CMD_SGL_METASEG = 128,
	NVME_CMD_SGL_ALL = 192,
};

struct nvme_common_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le32 cdw2[2];
	__le64 metadata;
	union nvme_data_ptr dptr;
	union {
		struct {
			__le32 cdw10;
			__le32 cdw11;
			__le32 cdw12;
			__le32 cdw13;
			__le32 cdw14;
			__le32 cdw15;
		};
		struct {
			__le32 cdw10;
			__le32 cdw11;
			__le32 cdw12;
			__le32 cdw13;
			__le32 cdw14;
			__le32 cdw15;
		} cdws;
	};
};

struct nvme_rw_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le32 cdw2;
	__le32 cdw3;
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le32 reftag;
	__le16 apptag;
	__le16 appmask;
};

enum {
	NVME_RW_LR = 32768,
	NVME_RW_FUA = 16384,
	NVME_RW_APPEND_PIREMAP = 512,
	NVME_RW_DSM_FREQ_UNSPEC = 0,
	NVME_RW_DSM_FREQ_TYPICAL = 1,
	NVME_RW_DSM_FREQ_RARE = 2,
	NVME_RW_DSM_FREQ_READS = 3,
	NVME_RW_DSM_FREQ_WRITES = 4,
	NVME_RW_DSM_FREQ_RW = 5,
	NVME_RW_DSM_FREQ_ONCE = 6,
	NVME_RW_DSM_FREQ_PREFETCH = 7,
	NVME_RW_DSM_FREQ_TEMP = 8,
	NVME_RW_DSM_LATENCY_NONE = 0,
	NVME_RW_DSM_LATENCY_IDLE = 16,
	NVME_RW_DSM_LATENCY_NORM = 32,
	NVME_RW_DSM_LATENCY_LOW = 48,
	NVME_RW_DSM_SEQ_REQ = 64,
	NVME_RW_DSM_COMPRESSED = 128,
	NVME_RW_PRINFO_PRCHK_REF = 1024,
	NVME_RW_PRINFO_PRCHK_APP = 2048,
	NVME_RW_PRINFO_PRCHK_GUARD = 4096,
	NVME_RW_PRINFO_PRACT = 8192,
	NVME_RW_DTYPE_STREAMS = 16,
};

struct nvme_dsm_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 nr;
	__le32 attributes;
	__u32 rsvd12[4];
};

enum {
	NVME_DSMGMT_IDR = 1,
	NVME_DSMGMT_IDW = 2,
	NVME_DSMGMT_AD = 4,
};

struct nvme_dsm_range {
	__le32 cattr;
	__le32 nlb;
	__le64 slba;
};

struct nvme_write_zeroes_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2;
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le16 length;
	__le16 control;
	__le32 dsmgmt;
	__le32 reftag;
	__le16 apptag;
	__le16 appmask;
};

enum nvme_zone_mgmt_action {
	NVME_ZONE_CLOSE = 1,
	NVME_ZONE_FINISH = 2,
	NVME_ZONE_OPEN = 3,
	NVME_ZONE_RESET = 4,
	NVME_ZONE_OFFLINE = 5,
	NVME_ZONE_SET_DESC_EXT = 16,
};

struct nvme_zone_mgmt_send_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le32 cdw2[2];
	__le64 metadata;
	union nvme_data_ptr dptr;
	__le64 slba;
	__le32 cdw12;
	__u8 zsa;
	__u8 select_all;
	__u8 rsvd13[2];
	__le32 cdw14[2];
};

struct nvme_zone_mgmt_recv_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__le64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le64 slba;
	__le32 numd;
	__u8 zra;
	__u8 zrasf;
	__u8 pr;
	__u8 rsvd13;
	__le32 cdw14[2];
};

struct nvme_feat_auto_pst {
	__le64 entries[32];
};

struct nvme_feat_host_behavior {
	__u8 acre;
	__u8 etdas;
	__u8 lbafee;
	__u8 resv1[509];
};

enum {
	NVME_ENABLE_ACRE = 1,
	NVME_ENABLE_LBAFEE = 1,
};

enum nvme_admin_opcode {
	nvme_admin_delete_sq = 0,
	nvme_admin_create_sq = 1,
	nvme_admin_get_log_page = 2,
	nvme_admin_delete_cq = 4,
	nvme_admin_create_cq = 5,
	nvme_admin_identify = 6,
	nvme_admin_abort_cmd = 8,
	nvme_admin_set_features = 9,
	nvme_admin_get_features = 10,
	nvme_admin_async_event = 12,
	nvme_admin_ns_mgmt = 13,
	nvme_admin_activate_fw = 16,
	nvme_admin_download_fw = 17,
	nvme_admin_dev_self_test = 20,
	nvme_admin_ns_attach = 21,
	nvme_admin_keep_alive = 24,
	nvme_admin_directive_send = 25,
	nvme_admin_directive_recv = 26,
	nvme_admin_virtual_mgmt = 28,
	nvme_admin_nvme_mi_send = 29,
	nvme_admin_nvme_mi_recv = 30,
	nvme_admin_dbbuf = 124,
	nvme_admin_format_nvm = 128,
	nvme_admin_security_send = 129,
	nvme_admin_security_recv = 130,
	nvme_admin_sanitize_nvm = 132,
	nvme_admin_get_lba_status = 134,
	nvme_admin_vendor_start = 192,
};

enum {
	NVME_QUEUE_PHYS_CONTIG = 1,
	NVME_CQ_IRQ_ENABLED = 2,
	NVME_SQ_PRIO_URGENT = 0,
	NVME_SQ_PRIO_HIGH = 2,
	NVME_SQ_PRIO_MEDIUM = 4,
	NVME_SQ_PRIO_LOW = 6,
	NVME_FEAT_ARBITRATION = 1,
	NVME_FEAT_POWER_MGMT = 2,
	NVME_FEAT_LBA_RANGE = 3,
	NVME_FEAT_TEMP_THRESH = 4,
	NVME_FEAT_ERR_RECOVERY = 5,
	NVME_FEAT_VOLATILE_WC = 6,
	NVME_FEAT_NUM_QUEUES = 7,
	NVME_FEAT_IRQ_COALESCE = 8,
	NVME_FEAT_IRQ_CONFIG = 9,
	NVME_FEAT_WRITE_ATOMIC = 10,
	NVME_FEAT_ASYNC_EVENT = 11,
	NVME_FEAT_AUTO_PST = 12,
	NVME_FEAT_HOST_MEM_BUF = 13,
	NVME_FEAT_TIMESTAMP = 14,
	NVME_FEAT_KATO = 15,
	NVME_FEAT_HCTM = 16,
	NVME_FEAT_NOPSC = 17,
	NVME_FEAT_RRL = 18,
	NVME_FEAT_PLM_CONFIG = 19,
	NVME_FEAT_PLM_WINDOW = 20,
	NVME_FEAT_HOST_BEHAVIOR = 22,
	NVME_FEAT_SANITIZE = 23,
	NVME_FEAT_SW_PROGRESS = 128,
	NVME_FEAT_HOST_ID = 129,
	NVME_FEAT_RESV_MASK = 130,
	NVME_FEAT_RESV_PERSIST = 131,
	NVME_FEAT_WRITE_PROTECT = 132,
	NVME_FEAT_VENDOR_START = 192,
	NVME_FEAT_VENDOR_END = 255,
	NVME_LOG_ERROR = 1,
	NVME_LOG_SMART = 2,
	NVME_LOG_FW_SLOT = 3,
	NVME_LOG_CHANGED_NS = 4,
	NVME_LOG_CMD_EFFECTS = 5,
	NVME_LOG_DEVICE_SELF_TEST = 6,
	NVME_LOG_TELEMETRY_HOST = 7,
	NVME_LOG_TELEMETRY_CTRL = 8,
	NVME_LOG_ENDURANCE_GROUP = 9,
	NVME_LOG_ANA = 12,
	NVME_LOG_DISC = 112,
	NVME_LOG_RESERVATION = 128,
	NVME_FWACT_REPL = 0,
	NVME_FWACT_REPL_ACTV = 8,
	NVME_FWACT_ACTV = 16,
};

struct nvme_identify {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__u8 cns;
	__u8 rsvd3;
	__le16 ctrlid;
	__u8 rsvd11[3];
	__u8 csi;
	__u32 rsvd12[4];
};

struct nvme_features {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 fid;
	__le32 dword11;
	__le32 dword12;
	__le32 dword13;
	__le32 dword14;
	__le32 dword15;
};

struct nvme_create_cq {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__u64 rsvd8;
	__le16 cqid;
	__le16 qsize;
	__le16 cq_flags;
	__le16 irq_vector;
	__u32 rsvd12[4];
};

struct nvme_create_sq {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__u64 rsvd8;
	__le16 sqid;
	__le16 qsize;
	__le16 sq_flags;
	__le16 cqid;
	__u32 rsvd12[4];
};

struct nvme_delete_queue {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[9];
	__le16 qid;
	__u16 rsvd10;
	__u32 rsvd11[5];
};

struct nvme_abort_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[9];
	__le16 sqid;
	__u16 cid;
	__u32 rsvd11[5];
};

struct nvme_download_firmware {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	union nvme_data_ptr dptr;
	__le32 numd;
	__le32 offset;
	__u32 rsvd12[4];
};

struct nvme_format_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[4];
	__le32 cdw10;
	__u32 rsvd11[5];
};

struct nvme_get_log_page_command {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__u8 lid;
	__u8 lsp;
	__le16 numdl;
	__le16 numdu;
	__u16 rsvd11;
	union {
		struct {
			__le32 lpol;
			__le32 lpou;
		};
		__le64 lpo;
	};
	__u8 rsvd14[3];
	__u8 csi;
	__u32 rsvd15;
};

struct nvme_directive_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__le32 nsid;
	__u64 rsvd2[2];
	union nvme_data_ptr dptr;
	__le32 numd;
	__u8 doper;
	__u8 dtype;
	__le16 dspec;
	__u8 endir;
	__u8 tdtype;
	__u16 rsvd15;
	__u32 rsvd16[3];
};

enum nvmf_fabrics_opcode {
	nvme_fabrics_command = 127,
};

enum nvmf_capsule_command {
	nvme_fabrics_type_property_set = 0,
	nvme_fabrics_type_connect = 1,
	nvme_fabrics_type_property_get = 4,
	nvme_fabrics_type_auth_send = 5,
	nvme_fabrics_type_auth_receive = 6,
};

struct nvmf_common_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 ts[24];
};

struct nvmf_connect_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__le16 recfmt;
	__le16 qid;
	__le16 sqsize;
	__u8 cattr;
	__u8 resv3;
	__le32 kato;
	__u8 resv4[12];
};

struct nvmf_property_set_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 attrib;
	__u8 resv3[3];
	__le32 offset;
	__le64 value;
	__u8 resv4[8];
};

struct nvmf_property_get_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[35];
	__u8 attrib;
	__u8 resv3[3];
	__le32 offset;
	__u8 resv4[16];
};

struct nvmf_auth_common_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__u8 resv3;
	__u8 spsp0;
	__u8 spsp1;
	__u8 secp;
	__le32 al_tl;
	__u8 resv4[16];
};

struct nvmf_auth_send_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__u8 resv3;
	__u8 spsp0;
	__u8 spsp1;
	__u8 secp;
	__le32 tl;
	__u8 resv4[16];
};

struct nvmf_auth_receive_command {
	__u8 opcode;
	__u8 resv1;
	__u16 command_id;
	__u8 fctype;
	__u8 resv2[19];
	union nvme_data_ptr dptr;
	__u8 resv3;
	__u8 spsp0;
	__u8 spsp1;
	__u8 secp;
	__le32 al;
	__u8 resv4[16];
};

struct nvme_dbbuf {
	__u8 opcode;
	__u8 flags;
	__u16 command_id;
	__u32 rsvd1[5];
	__le64 prp1;
	__le64 prp2;
	__u32 rsvd12[6];
};

struct nvme_command {
	union {
		struct nvme_common_command common;
		struct nvme_rw_command rw;
		struct nvme_identify identify;
		struct nvme_features features;
		struct nvme_create_cq create_cq;
		struct nvme_create_sq create_sq;
		struct nvme_delete_queue delete_queue;
		struct nvme_download_firmware dlfw;
		struct nvme_format_cmd format;
		struct nvme_dsm_cmd dsm;
		struct nvme_write_zeroes_cmd write_zeroes;
		struct nvme_zone_mgmt_send_cmd zms;
		struct nvme_zone_mgmt_recv_cmd zmr;
		struct nvme_abort_cmd abort;
		struct nvme_get_log_page_command get_log_page;
		struct nvmf_common_command fabrics;
		struct nvmf_connect_command connect;
		struct nvmf_property_set_command prop_set;
		struct nvmf_property_get_command prop_get;
		struct nvmf_auth_common_command auth_common;
		struct nvmf_auth_send_command auth_send;
		struct nvmf_auth_receive_command auth_receive;
		struct nvme_dbbuf dbbuf;
		struct nvme_directive_cmd directive;
	};
};

enum {
	NVME_SC_SUCCESS = 0,
	NVME_SC_INVALID_OPCODE = 1,
	NVME_SC_INVALID_FIELD = 2,
	NVME_SC_CMDID_CONFLICT = 3,
	NVME_SC_DATA_XFER_ERROR = 4,
	NVME_SC_POWER_LOSS = 5,
	NVME_SC_INTERNAL = 6,
	NVME_SC_ABORT_REQ = 7,
	NVME_SC_ABORT_QUEUE = 8,
	NVME_SC_FUSED_FAIL = 9,
	NVME_SC_FUSED_MISSING = 10,
	NVME_SC_INVALID_NS = 11,
	NVME_SC_CMD_SEQ_ERROR = 12,
	NVME_SC_SGL_INVALID_LAST = 13,
	NVME_SC_SGL_INVALID_COUNT = 14,
	NVME_SC_SGL_INVALID_DATA = 15,
	NVME_SC_SGL_INVALID_METADATA = 16,
	NVME_SC_SGL_INVALID_TYPE = 17,
	NVME_SC_CMB_INVALID_USE = 18,
	NVME_SC_PRP_INVALID_OFFSET = 19,
	NVME_SC_ATOMIC_WU_EXCEEDED = 20,
	NVME_SC_OP_DENIED = 21,
	NVME_SC_SGL_INVALID_OFFSET = 22,
	NVME_SC_RESERVED = 23,
	NVME_SC_HOST_ID_INCONSIST = 24,
	NVME_SC_KA_TIMEOUT_EXPIRED = 25,
	NVME_SC_KA_TIMEOUT_INVALID = 26,
	NVME_SC_ABORTED_PREEMPT_ABORT = 27,
	NVME_SC_SANITIZE_FAILED = 28,
	NVME_SC_SANITIZE_IN_PROGRESS = 29,
	NVME_SC_SGL_INVALID_GRANULARITY = 30,
	NVME_SC_CMD_NOT_SUP_CMB_QUEUE = 31,
	NVME_SC_NS_WRITE_PROTECTED = 32,
	NVME_SC_CMD_INTERRUPTED = 33,
	NVME_SC_TRANSIENT_TR_ERR = 34,
	NVME_SC_ADMIN_COMMAND_MEDIA_NOT_READY = 36,
	NVME_SC_INVALID_IO_CMD_SET = 44,
	NVME_SC_LBA_RANGE = 128,
	NVME_SC_CAP_EXCEEDED = 129,
	NVME_SC_NS_NOT_READY = 130,
	NVME_SC_RESERVATION_CONFLICT = 131,
	NVME_SC_FORMAT_IN_PROGRESS = 132,
	NVME_SC_CQ_INVALID = 256,
	NVME_SC_QID_INVALID = 257,
	NVME_SC_QUEUE_SIZE = 258,
	NVME_SC_ABORT_LIMIT = 259,
	NVME_SC_ABORT_MISSING = 260,
	NVME_SC_ASYNC_LIMIT = 261,
	NVME_SC_FIRMWARE_SLOT = 262,
	NVME_SC_FIRMWARE_IMAGE = 263,
	NVME_SC_INVALID_VECTOR = 264,
	NVME_SC_INVALID_LOG_PAGE = 265,
	NVME_SC_INVALID_FORMAT = 266,
	NVME_SC_FW_NEEDS_CONV_RESET = 267,
	NVME_SC_INVALID_QUEUE = 268,
	NVME_SC_FEATURE_NOT_SAVEABLE = 269,
	NVME_SC_FEATURE_NOT_CHANGEABLE = 270,
	NVME_SC_FEATURE_NOT_PER_NS = 271,
	NVME_SC_FW_NEEDS_SUBSYS_RESET = 272,
	NVME_SC_FW_NEEDS_RESET = 273,
	NVME_SC_FW_NEEDS_MAX_TIME = 274,
	NVME_SC_FW_ACTIVATE_PROHIBITED = 275,
	NVME_SC_OVERLAPPING_RANGE = 276,
	NVME_SC_NS_INSUFFICIENT_CAP = 277,
	NVME_SC_NS_ID_UNAVAILABLE = 278,
	NVME_SC_NS_ALREADY_ATTACHED = 280,
	NVME_SC_NS_IS_PRIVATE = 281,
	NVME_SC_NS_NOT_ATTACHED = 282,
	NVME_SC_THIN_PROV_NOT_SUPP = 283,
	NVME_SC_CTRL_LIST_INVALID = 284,
	NVME_SC_SELT_TEST_IN_PROGRESS = 285,
	NVME_SC_BP_WRITE_PROHIBITED = 286,
	NVME_SC_CTRL_ID_INVALID = 287,
	NVME_SC_SEC_CTRL_STATE_INVALID = 288,
	NVME_SC_CTRL_RES_NUM_INVALID = 289,
	NVME_SC_RES_ID_INVALID = 290,
	NVME_SC_PMR_SAN_PROHIBITED = 291,
	NVME_SC_ANA_GROUP_ID_INVALID = 292,
	NVME_SC_ANA_ATTACH_FAILED = 293,
	NVME_SC_BAD_ATTRIBUTES = 384,
	NVME_SC_INVALID_PI = 385,
	NVME_SC_READ_ONLY = 386,
	NVME_SC_ONCS_NOT_SUPPORTED = 387,
	NVME_SC_CONNECT_FORMAT = 384,
	NVME_SC_CONNECT_CTRL_BUSY = 385,
	NVME_SC_CONNECT_INVALID_PARAM = 386,
	NVME_SC_CONNECT_RESTART_DISC = 387,
	NVME_SC_CONNECT_INVALID_HOST = 388,
	NVME_SC_DISCOVERY_RESTART = 400,
	NVME_SC_AUTH_REQUIRED = 401,
	NVME_SC_ZONE_BOUNDARY_ERROR = 440,
	NVME_SC_ZONE_FULL = 441,
	NVME_SC_ZONE_READ_ONLY = 442,
	NVME_SC_ZONE_OFFLINE = 443,
	NVME_SC_ZONE_INVALID_WRITE = 444,
	NVME_SC_ZONE_TOO_MANY_ACTIVE = 445,
	NVME_SC_ZONE_TOO_MANY_OPEN = 446,
	NVME_SC_ZONE_INVALID_TRANSITION = 447,
	NVME_SC_WRITE_FAULT = 640,
	NVME_SC_READ_ERROR = 641,
	NVME_SC_GUARD_CHECK = 642,
	NVME_SC_APPTAG_CHECK = 643,
	NVME_SC_REFTAG_CHECK = 644,
	NVME_SC_COMPARE_FAILED = 645,
	NVME_SC_ACCESS_DENIED = 646,
	NVME_SC_UNWRITTEN_BLOCK = 647,
	NVME_SC_INTERNAL_PATH_ERROR = 768,
	NVME_SC_ANA_PERSISTENT_LOSS = 769,
	NVME_SC_ANA_INACCESSIBLE = 770,
	NVME_SC_ANA_TRANSITION = 771,
	NVME_SC_CTRL_PATH_ERROR = 864,
	NVME_SC_HOST_PATH_ERROR = 880,
	NVME_SC_HOST_ABORTED_CMD = 881,
	NVME_SC_CRD = 6144,
	NVME_SC_MORE = 8192,
	NVME_SC_DNR = 16384,
};

union nvme_result {
	__le16 u16;
	__le32 u32;
	__le64 u64;
};

enum nvme_quirks {
	NVME_QUIRK_STRIPE_SIZE = 1,
	NVME_QUIRK_IDENTIFY_CNS = 2,
	NVME_QUIRK_DEALLOCATE_ZEROES = 4,
	NVME_QUIRK_DELAY_BEFORE_CHK_RDY = 8,
	NVME_QUIRK_NO_APST = 16,
	NVME_QUIRK_NO_DEEPEST_PS = 32,
	NVME_QUIRK_MEDIUM_PRIO_SQ = 128,
	NVME_QUIRK_IGNORE_DEV_SUBNQN = 256,
	NVME_QUIRK_DISABLE_WRITE_ZEROES = 512,
	NVME_QUIRK_SIMPLE_SUSPEND = 1024,
	NVME_QUIRK_SINGLE_VECTOR = 2048,
	NVME_QUIRK_128_BYTES_SQES = 4096,
	NVME_QUIRK_SHARED_TAGS = 8192,
	NVME_QUIRK_NO_TEMP_THRESH_CHANGE = 16384,
	NVME_QUIRK_NO_NS_DESC_LIST = 32768,
	NVME_QUIRK_DMA_ADDRESS_BITS_48 = 65536,
	NVME_QUIRK_SKIP_CID_GEN = 131072,
	NVME_QUIRK_BOGUS_NID = 262144,
};

struct nvme_ctrl;

struct nvme_request {
	struct nvme_command *cmd;
	int: 32;
	union nvme_result result;
	u8 genctr;
	u8 retries;
	u8 flags;
	u16 status;
	struct nvme_ctrl *ctrl;
	int: 32;
};

enum nvme_ctrl_state {
	NVME_CTRL_NEW = 0,
	NVME_CTRL_LIVE = 1,
	NVME_CTRL_RESETTING = 2,
	NVME_CTRL_CONNECTING = 3,
	NVME_CTRL_DELETING = 4,
	NVME_CTRL_DELETING_NOIO = 5,
	NVME_CTRL_DEAD = 6,
};

struct nvme_fault_inject {};

struct nvme_ctrl_ops;

struct nvme_subsystem;

struct nvmf_ctrl_options;

struct nvme_ctrl {
	bool comp_seen;
	enum nvme_ctrl_state state;
	bool identified;
	spinlock_t lock;
	struct mutex scan_lock;
	const struct nvme_ctrl_ops *ops;
	struct request_queue *admin_q;
	struct request_queue *connect_q;
	struct request_queue *fabrics_q;
	struct device *dev;
	int instance;
	int numa_node;
	struct blk_mq_tag_set *tagset;
	struct blk_mq_tag_set *admin_tagset;
	struct list_head namespaces;
	struct rw_semaphore namespaces_rwsem;
	struct device ctrl_device;
	struct device *device;
	struct cdev cdev;
	struct work_struct reset_work;
	struct work_struct delete_work;
	wait_queue_head_t state_wq;
	struct nvme_subsystem *subsys;
	struct list_head subsys_entry;
	struct opal_dev *opal_dev;
	char name[12];
	u16 cntlid;
	u32 ctrl_config;
	u16 mtfa;
	u32 queue_count;
	u64 cap;
	u32 max_hw_sectors;
	u32 max_segments;
	u32 max_integrity_segments;
	u32 max_discard_sectors;
	u32 max_discard_segments;
	u32 max_zeroes_sectors;
	u16 crdt[3];
	u16 oncs;
	u32 dmrsl;
	u16 oacs;
	u16 sqsize;
	u32 max_namespaces;
	atomic_t abort_limit;
	u8 vwc;
	u32 vs;
	u32 sgls;
	u16 kas;
	u8 npss;
	u8 apsta;
	u16 wctemp;
	u16 cctemp;
	u32 oaes;
	u32 aen_result;
	u32 ctratt;
	unsigned int shutdown_timeout;
	unsigned int kato;
	bool subsystem;
	long unsigned int quirks;
	struct nvme_id_power_state psd[32];
	struct nvme_effects_log *effects;
	struct xarray cels;
	struct work_struct scan_work;
	struct work_struct async_event_work;
	struct delayed_work ka_work;
	struct delayed_work failfast_work;
	struct nvme_command ka_cmd;
	struct work_struct fw_act_work;
	long unsigned int events;
	int: 32;
	u64 ps_max_latency_us;
	bool apst_enabled;
	u32 hmpre;
	u32 hmmin;
	u32 hmminds;
	u16 hmmaxd;
	u32 ioccsz;
	u32 iorcsz;
	u16 icdoff;
	u16 maxcmd;
	int nr_reconnects;
	long unsigned int flags;
	struct nvmf_ctrl_options *opts;
	struct page *discard_page;
	long unsigned int discard_page_busy;
	struct nvme_fault_inject fault_inject;
	enum nvme_ctrl_type cntrltype;
	enum nvme_dctype dctype;
	int: 32;
};

enum {
	NVME_REQ_CANCELLED = 1,
	NVME_REQ_USERCMD = 2,
};

enum nvme_ctrl_flags {
	NVME_CTRL_FAILFAST_EXPIRED = 0,
	NVME_CTRL_ADMIN_Q_STOPPED = 1,
	NVME_CTRL_STARTED_ONCE = 2,
};

struct nvme_ctrl_ops {
	const char *name;
	struct module *module;
	unsigned int flags;
	int (*reg_read32)(struct nvme_ctrl *, u32, u32 *);
	int (*reg_write32)(struct nvme_ctrl *, u32, u32);
	int (*reg_read64)(struct nvme_ctrl *, u32, u64 *);
	void (*free_ctrl)(struct nvme_ctrl *);
	void (*submit_async_event)(struct nvme_ctrl *);
	void (*delete_ctrl)(struct nvme_ctrl *);
	void (*stop_ctrl)(struct nvme_ctrl *);
	int (*get_address)(struct nvme_ctrl *, char *, int);
	void (*print_device_info)(struct nvme_ctrl *);
	bool (*supports_pci_p2pdma)(struct nvme_ctrl *);
};

struct nvme_subsystem {
	int instance;
	int: 32;
	struct device dev;
	struct kref ref;
	struct list_head entry;
	struct mutex lock;
	struct list_head ctrls;
	struct list_head nsheads;
	char subnqn[223];
	char serial[20];
	char model[40];
	char firmware_rev[8];
	u8 cmic;
	enum nvme_subsys_type subtype;
	u16 vendor_id;
	u16 awupf;
	struct ida ns_ida;
};

struct nvmf_host;

struct nvmf_ctrl_options {
	unsigned int mask;
	char *transport;
	char *subsysnqn;
	char *traddr;
	char *trsvcid;
	char *host_traddr;
	char *host_iface;
	size_t queue_size;
	unsigned int nr_io_queues;
	unsigned int reconnect_delay;
	bool discovery_nqn;
	bool duplicate_connect;
	unsigned int kato;
	struct nvmf_host *host;
	int max_reconnects;
	char *dhchap_secret;
	char *dhchap_ctrl_secret;
	bool disable_sqflow;
	bool hdr_digest;
	bool data_digest;
	unsigned int nr_write_queues;
	unsigned int nr_poll_queues;
	int tos;
	int fast_io_fail_tmo;
};

struct nvme_ns_ids {
	u8 eui64[8];
	u8 nguid[16];
	uuid_t uuid;
	u8 csi;
};

struct nvme_ns_head {
	struct list_head list;
	struct srcu_struct srcu;
	struct nvme_subsystem *subsys;
	unsigned int ns_id;
	struct nvme_ns_ids ids;
	struct list_head entry;
	struct kref ref;
	bool shared;
	int instance;
	struct nvme_effects_log *effects;
	struct cdev cdev;
	struct device cdev_device;
	struct gendisk *disk;
	int: 32;
};

enum nvme_ns_features {
	NVME_NS_EXT_LBAS = 1,
	NVME_NS_METADATA_SUPPORTED = 2,
};

struct nvme_ns {
	struct list_head list;
	struct nvme_ctrl *ctrl;
	struct request_queue *queue;
	struct gendisk *disk;
	struct list_head siblings;
	struct kref kref;
	struct nvme_ns_head *head;
	int lba_shift;
	u16 ms;
	u16 pi_size;
	u16 sgs;
	u32 sws;
	u8 pi_type;
	u8 guard_type;
	long unsigned int features;
	long unsigned int flags;
	struct cdev cdev;
	int: 32;
	struct device cdev_device;
	struct nvme_fault_inject fault_inject;
};

struct nvmf_host {
	struct kref ref;
	struct list_head list;
	char nqn[223];
	uuid_t id;
};

struct trace_event_raw_nvme_setup_cmd {
	struct trace_entry ent;
	char disk[32];
	int ctrl_id;
	int qid;
	u8 opcode;
	u8 flags;
	u8 fctype;
	u16 cid;
	u32 nsid;
	bool metadata;
	u8 cdw10[24];
	char __data[0];
};

struct trace_event_raw_nvme_complete_rq {
	struct trace_entry ent;
	char disk[32];
	int ctrl_id;
	int qid;
	int cid;
	int: 32;
	u64 result;
	u8 retries;
	u8 flags;
	u16 status;
	char __data[0];
	int: 32;
};

struct trace_event_raw_nvme_async_event {
	struct trace_entry ent;
	int ctrl_id;
	u32 result;
	char __data[0];
};

struct trace_event_raw_nvme_sq {
	struct trace_entry ent;
	int ctrl_id;
	char disk[32];
	int qid;
	u16 sq_head;
	u16 sq_tail;
	char __data[0];
};

struct trace_event_data_offsets_nvme_setup_cmd {};

struct trace_event_data_offsets_nvme_complete_rq {};

struct trace_event_data_offsets_nvme_async_event {};

struct trace_event_data_offsets_nvme_sq {};

typedef void (*btf_trace_nvme_setup_cmd)(void *, struct request *, struct nvme_command *);

typedef void (*btf_trace_nvme_complete_rq)(void *, struct request *);

typedef void (*btf_trace_nvme_async_event)(void *, struct nvme_ctrl *, u32);

typedef void (*btf_trace_nvme_sq)(void *, struct request *, __le16, int);

struct nvme_ns_info {
	struct nvme_ns_ids ids;
	u32 nsid;
	__le32 anagrpid;
	bool is_shared;
	bool is_readonly;
	bool is_ready;
};

enum nvme_disposition {
	COMPLETE = 0,
	RETRY = 1,
	FAILOVER = 2,
	AUTHENTICATE = 3,
};

struct nvme_core_quirk_entry {
	u16 vid;
	const char *mn;
	const char *fr;
	long unsigned int quirks;
};

struct nvme_user_io {
	__u8 opcode;
	__u8 flags;
	__u16 control;
	__u16 nblocks;
	__u16 rsvd;
	__u64 metadata;
	__u64 addr;
	__u64 slba;
	__u32 dsmgmt;
	__u32 reftag;
	__u16 apptag;
	__u16 appmask;
	int: 32;
};

struct nvme_passthru_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	__u32 data_len;
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 result;
};

struct nvme_passthru_cmd64 {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	union {
		__u32 data_len;
		__u32 vec_cnt;
	};
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 rsvd2;
	__u64 result;
};

struct nvme_uring_cmd {
	__u8 opcode;
	__u8 flags;
	__u16 rsvd1;
	__u32 nsid;
	__u32 cdw2;
	__u32 cdw3;
	__u64 metadata;
	__u64 addr;
	__u32 metadata_len;
	__u32 data_len;
	__u32 cdw10;
	__u32 cdw11;
	__u32 cdw12;
	__u32 cdw13;
	__u32 cdw14;
	__u32 cdw15;
	__u32 timeout_ms;
	__u32 rsvd2;
};

struct bio_integrity_payload {
	struct bio *bip_bio;
	struct bvec_iter bip_iter;
	short unsigned int bip_vcnt;
	short unsigned int bip_max_vcnt;
	short unsigned int bip_flags;
	struct bvec_iter bio_iter;
	short: 16;
	struct work_struct bip_work;
	struct bio_vec *bip_vec;
	struct bio_vec bip_inline_vecs[0];
} __attribute__((packed));

struct nvme_uring_data {
	__u64 metadata;
	__u64 addr;
	__u32 data_len;
	__u32 metadata_len;
	__u32 timeout_ms;
	int: 32;
};

struct nvme_uring_cmd_pdu {
	union {
		struct bio *bio;
		struct request *req;
	};
	u32 meta_len;
	u32 nvme_status;
	int: 32;
	union {
		struct {
			void *meta;
			void *meta_buffer;
		};
		u64 result;
	} u;
};

enum pci_ers_result {
	PCI_ERS_RESULT_NONE = 1,
	PCI_ERS_RESULT_CAN_RECOVER = 2,
	PCI_ERS_RESULT_NEED_RESET = 3,
	PCI_ERS_RESULT_DISCONNECT = 4,
	PCI_ERS_RESULT_RECOVERED = 5,
	PCI_ERS_RESULT_NO_AER_DRIVER = 6,
};

enum {
	NVME_CMBSZ_SQS = 1,
	NVME_CMBSZ_CQS = 2,
	NVME_CMBSZ_LISTS = 4,
	NVME_CMBSZ_RDS = 8,
	NVME_CMBSZ_WDS = 16,
	NVME_CMBSZ_SZ_SHIFT = 12,
	NVME_CMBSZ_SZ_MASK = 1048575,
	NVME_CMBSZ_SZU_SHIFT = 8,
	NVME_CMBSZ_SZU_MASK = 15,
};

enum {
	NVME_CMBMSC_CRE = 1,
	NVME_CMBMSC_CMSE = 2,
};

enum {
	NVME_SGL_FMT_DATA_DESC = 0,
	NVME_SGL_FMT_SEG_DESC = 2,
	NVME_SGL_FMT_LAST_SEG_DESC = 3,
	NVME_KEY_SGL_FMT_DATA_DESC = 4,
	NVME_TRANSPORT_SGL_DATA_DESC = 5,
};

enum {
	NVME_HOST_MEM_ENABLE = 1,
	NVME_HOST_MEM_RETURN = 2,
};

struct nvme_host_mem_buf_desc {
	__le64 addr;
	__le32 size;
	__u32 rsvd;
};

struct nvme_completion {
	union nvme_result result;
	__le16 sq_head;
	__le16 sq_id;
	__u16 command_id;
	__le16 status;
};

struct nvme_queue;

struct nvme_dev {
	struct nvme_queue *queues;
	struct blk_mq_tag_set tagset;
	struct blk_mq_tag_set admin_tagset;
	u32 *dbs;
	struct device *dev;
	struct dma_pool *prp_page_pool;
	struct dma_pool *prp_small_pool;
	unsigned int online_queues;
	unsigned int max_qid;
	unsigned int io_queues[3];
	unsigned int num_vecs;
	u32 q_depth;
	int io_sqes;
	u32 db_stride;
	void *bar;
	long unsigned int bar_mapped_size;
	struct work_struct remove_work;
	struct mutex shutdown_lock;
	bool subsystem;
	u64 cmb_size;
	bool cmb_use_sqes;
	u32 cmbsz;
	u32 cmbloc;
	int: 32;
	struct nvme_ctrl ctrl;
	u32 last_ps;
	bool hmb;
	mempool_t *iod_mempool;
	u32 *dbbuf_dbs;
	dma_addr_t dbbuf_dbs_dma_addr;
	u32 *dbbuf_eis;
	dma_addr_t dbbuf_eis_dma_addr;
	int: 32;
	u64 host_mem_size;
	u32 nr_host_mem_descs;
	dma_addr_t host_mem_descs_dma;
	struct nvme_host_mem_buf_desc *host_mem_descs;
	void **host_mem_desc_bufs;
	unsigned int nr_allocated_queues;
	unsigned int nr_write_queues;
	unsigned int nr_poll_queues;
	bool attrs_added;
};

struct nvme_queue {
	struct nvme_dev *dev;
	spinlock_t sq_lock;
	void *sq_cmds;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t cq_poll_lock;
	struct nvme_completion *cqes;
	dma_addr_t sq_dma_addr;
	dma_addr_t cq_dma_addr;
	u32 *q_db;
	u32 q_depth;
	u16 cq_vector;
	u16 sq_tail;
	u16 last_sq_tail;
	u16 cq_head;
	u16 qid;
	u8 cq_phase;
	u8 sqes;
	long unsigned int flags;
	u32 *dbbuf_sq_db;
	u32 *dbbuf_cq_db;
	u32 *dbbuf_sq_ei;
	u32 *dbbuf_cq_ei;
	struct completion delete_done;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct nvme_iod {
	struct nvme_request req;
	struct nvme_command cmd;
	bool use_sgl;
	bool aborted;
	s8 nr_allocations;
	unsigned int dma_len;
	dma_addr_t first_dma;
	dma_addr_t meta_dma;
	struct sg_table sgt;
	int: 32;
};

enum {
	ATA_MAX_DEVICES = 2,
	ATA_MAX_PRD = 256,
	ATA_SECT_SIZE = 512,
	ATA_MAX_SECTORS_128 = 128,
	ATA_MAX_SECTORS = 256,
	ATA_MAX_SECTORS_1024 = 1024,
	ATA_MAX_SECTORS_LBA48 = 65535,
	ATA_MAX_SECTORS_TAPE = 65535,
	ATA_MAX_TRIM_RNUM = 64,
	ATA_ID_WORDS = 256,
	ATA_ID_CONFIG = 0,
	ATA_ID_CYLS = 1,
	ATA_ID_HEADS = 3,
	ATA_ID_SECTORS = 6,
	ATA_ID_SERNO = 10,
	ATA_ID_BUF_SIZE = 21,
	ATA_ID_FW_REV = 23,
	ATA_ID_PROD = 27,
	ATA_ID_MAX_MULTSECT = 47,
	ATA_ID_DWORD_IO = 48,
	ATA_ID_TRUSTED = 48,
	ATA_ID_CAPABILITY = 49,
	ATA_ID_OLD_PIO_MODES = 51,
	ATA_ID_OLD_DMA_MODES = 52,
	ATA_ID_FIELD_VALID = 53,
	ATA_ID_CUR_CYLS = 54,
	ATA_ID_CUR_HEADS = 55,
	ATA_ID_CUR_SECTORS = 56,
	ATA_ID_MULTSECT = 59,
	ATA_ID_LBA_CAPACITY = 60,
	ATA_ID_SWDMA_MODES = 62,
	ATA_ID_MWDMA_MODES = 63,
	ATA_ID_PIO_MODES = 64,
	ATA_ID_EIDE_DMA_MIN = 65,
	ATA_ID_EIDE_DMA_TIME = 66,
	ATA_ID_EIDE_PIO = 67,
	ATA_ID_EIDE_PIO_IORDY = 68,
	ATA_ID_ADDITIONAL_SUPP = 69,
	ATA_ID_QUEUE_DEPTH = 75,
	ATA_ID_SATA_CAPABILITY = 76,
	ATA_ID_SATA_CAPABILITY_2 = 77,
	ATA_ID_FEATURE_SUPP = 78,
	ATA_ID_MAJOR_VER = 80,
	ATA_ID_COMMAND_SET_1 = 82,
	ATA_ID_COMMAND_SET_2 = 83,
	ATA_ID_CFSSE = 84,
	ATA_ID_CFS_ENABLE_1 = 85,
	ATA_ID_CFS_ENABLE_2 = 86,
	ATA_ID_CSF_DEFAULT = 87,
	ATA_ID_UDMA_MODES = 88,
	ATA_ID_HW_CONFIG = 93,
	ATA_ID_SPG = 98,
	ATA_ID_LBA_CAPACITY_2 = 100,
	ATA_ID_SECTOR_SIZE = 106,
	ATA_ID_WWN = 108,
	ATA_ID_LOGICAL_SECTOR_SIZE = 117,
	ATA_ID_COMMAND_SET_3 = 119,
	ATA_ID_COMMAND_SET_4 = 120,
	ATA_ID_LAST_LUN = 126,
	ATA_ID_DLF = 128,
	ATA_ID_CSFO = 129,
	ATA_ID_CFA_POWER = 160,
	ATA_ID_CFA_KEY_MGMT = 162,
	ATA_ID_CFA_MODES = 163,
	ATA_ID_DATA_SET_MGMT = 169,
	ATA_ID_SCT_CMD_XPORT = 206,
	ATA_ID_ROT_SPEED = 217,
	ATA_ID_PIO4 = 2,
	ATA_ID_SERNO_LEN = 20,
	ATA_ID_FW_REV_LEN = 8,
	ATA_ID_PROD_LEN = 40,
	ATA_ID_WWN_LEN = 8,
	ATA_PCI_CTL_OFS = 2,
	ATA_PIO0 = 1,
	ATA_PIO1 = 3,
	ATA_PIO2 = 7,
	ATA_PIO3 = 15,
	ATA_PIO4 = 31,
	ATA_PIO5 = 63,
	ATA_PIO6 = 127,
	ATA_PIO4_ONLY = 16,
	ATA_SWDMA0 = 1,
	ATA_SWDMA1 = 3,
	ATA_SWDMA2 = 7,
	ATA_SWDMA2_ONLY = 4,
	ATA_MWDMA0 = 1,
	ATA_MWDMA1 = 3,
	ATA_MWDMA2 = 7,
	ATA_MWDMA3 = 15,
	ATA_MWDMA4 = 31,
	ATA_MWDMA12_ONLY = 6,
	ATA_MWDMA2_ONLY = 4,
	ATA_UDMA0 = 1,
	ATA_UDMA1 = 3,
	ATA_UDMA2 = 7,
	ATA_UDMA3 = 15,
	ATA_UDMA4 = 31,
	ATA_UDMA5 = 63,
	ATA_UDMA6 = 127,
	ATA_UDMA7 = 255,
	ATA_UDMA24_ONLY = 20,
	ATA_UDMA_MASK_40C = 7,
	ATA_PRD_SZ = 8,
	ATA_PRD_TBL_SZ = 2048,
	ATA_PRD_EOT = 2147483648,
	ATA_DMA_TABLE_OFS = 4,
	ATA_DMA_STATUS = 2,
	ATA_DMA_CMD = 0,
	ATA_DMA_WR = 8,
	ATA_DMA_START = 1,
	ATA_DMA_INTR = 4,
	ATA_DMA_ERR = 2,
	ATA_DMA_ACTIVE = 1,
	ATA_HOB = 128,
	ATA_NIEN = 2,
	ATA_LBA = 64,
	ATA_DEV1 = 16,
	ATA_DEVICE_OBS = 160,
	ATA_DEVCTL_OBS = 8,
	ATA_BUSY = 128,
	ATA_DRDY = 64,
	ATA_DF = 32,
	ATA_DSC = 16,
	ATA_DRQ = 8,
	ATA_CORR = 4,
	ATA_SENSE = 2,
	ATA_ERR = 1,
	ATA_SRST = 4,
	ATA_ICRC = 128,
	ATA_BBK = 128,
	ATA_UNC = 64,
	ATA_MC = 32,
	ATA_IDNF = 16,
	ATA_MCR = 8,
	ATA_ABORTED = 4,
	ATA_TRK0NF = 2,
	ATA_AMNF = 1,
	ATAPI_LFS = 240,
	ATAPI_EOM = 2,
	ATAPI_ILI = 1,
	ATAPI_IO = 2,
	ATAPI_COD = 1,
	ATA_REG_DATA = 0,
	ATA_REG_ERR = 1,
	ATA_REG_NSECT = 2,
	ATA_REG_LBAL = 3,
	ATA_REG_LBAM = 4,
	ATA_REG_LBAH = 5,
	ATA_REG_DEVICE = 6,
	ATA_REG_STATUS = 7,
	ATA_REG_FEATURE = 1,
	ATA_REG_CMD = 7,
	ATA_REG_BYTEL = 4,
	ATA_REG_BYTEH = 5,
	ATA_REG_DEVSEL = 6,
	ATA_REG_IRQ = 2,
	ATA_CMD_DEV_RESET = 8,
	ATA_CMD_CHK_POWER = 229,
	ATA_CMD_STANDBY = 226,
	ATA_CMD_IDLE = 227,
	ATA_CMD_EDD = 144,
	ATA_CMD_DOWNLOAD_MICRO = 146,
	ATA_CMD_DOWNLOAD_MICRO_DMA = 147,
	ATA_CMD_NOP = 0,
	ATA_CMD_FLUSH = 231,
	ATA_CMD_FLUSH_EXT = 234,
	ATA_CMD_ID_ATA = 236,
	ATA_CMD_ID_ATAPI = 161,
	ATA_CMD_SERVICE = 162,
	ATA_CMD_READ = 200,
	ATA_CMD_READ_EXT = 37,
	ATA_CMD_READ_QUEUED = 38,
	ATA_CMD_READ_STREAM_EXT = 43,
	ATA_CMD_READ_STREAM_DMA_EXT = 42,
	ATA_CMD_WRITE = 202,
	ATA_CMD_WRITE_EXT = 53,
	ATA_CMD_WRITE_QUEUED = 54,
	ATA_CMD_WRITE_STREAM_EXT = 59,
	ATA_CMD_WRITE_STREAM_DMA_EXT = 58,
	ATA_CMD_WRITE_FUA_EXT = 61,
	ATA_CMD_WRITE_QUEUED_FUA_EXT = 62,
	ATA_CMD_FPDMA_READ = 96,
	ATA_CMD_FPDMA_WRITE = 97,
	ATA_CMD_NCQ_NON_DATA = 99,
	ATA_CMD_FPDMA_SEND = 100,
	ATA_CMD_FPDMA_RECV = 101,
	ATA_CMD_PIO_READ = 32,
	ATA_CMD_PIO_READ_EXT = 36,
	ATA_CMD_PIO_WRITE = 48,
	ATA_CMD_PIO_WRITE_EXT = 52,
	ATA_CMD_READ_MULTI = 196,
	ATA_CMD_READ_MULTI_EXT = 41,
	ATA_CMD_WRITE_MULTI = 197,
	ATA_CMD_WRITE_MULTI_EXT = 57,
	ATA_CMD_WRITE_MULTI_FUA_EXT = 206,
	ATA_CMD_SET_FEATURES = 239,
	ATA_CMD_SET_MULTI = 198,
	ATA_CMD_PACKET = 160,
	ATA_CMD_VERIFY = 64,
	ATA_CMD_VERIFY_EXT = 66,
	ATA_CMD_WRITE_UNCORR_EXT = 69,
	ATA_CMD_STANDBYNOW1 = 224,
	ATA_CMD_IDLEIMMEDIATE = 225,
	ATA_CMD_SLEEP = 230,
	ATA_CMD_INIT_DEV_PARAMS = 145,
	ATA_CMD_READ_NATIVE_MAX = 248,
	ATA_CMD_READ_NATIVE_MAX_EXT = 39,
	ATA_CMD_SET_MAX = 249,
	ATA_CMD_SET_MAX_EXT = 55,
	ATA_CMD_READ_LOG_EXT = 47,
	ATA_CMD_WRITE_LOG_EXT = 63,
	ATA_CMD_READ_LOG_DMA_EXT = 71,
	ATA_CMD_WRITE_LOG_DMA_EXT = 87,
	ATA_CMD_TRUSTED_NONDATA = 91,
	ATA_CMD_TRUSTED_RCV = 92,
	ATA_CMD_TRUSTED_RCV_DMA = 93,
	ATA_CMD_TRUSTED_SND = 94,
	ATA_CMD_TRUSTED_SND_DMA = 95,
	ATA_CMD_PMP_READ = 228,
	ATA_CMD_PMP_READ_DMA = 233,
	ATA_CMD_PMP_WRITE = 232,
	ATA_CMD_PMP_WRITE_DMA = 235,
	ATA_CMD_CONF_OVERLAY = 177,
	ATA_CMD_SEC_SET_PASS = 241,
	ATA_CMD_SEC_UNLOCK = 242,
	ATA_CMD_SEC_ERASE_PREP = 243,
	ATA_CMD_SEC_ERASE_UNIT = 244,
	ATA_CMD_SEC_FREEZE_LOCK = 245,
	ATA_CMD_SEC_DISABLE_PASS = 246,
	ATA_CMD_CONFIG_STREAM = 81,
	ATA_CMD_SMART = 176,
	ATA_CMD_MEDIA_LOCK = 222,
	ATA_CMD_MEDIA_UNLOCK = 223,
	ATA_CMD_DSM = 6,
	ATA_CMD_CHK_MED_CRD_TYP = 209,
	ATA_CMD_CFA_REQ_EXT_ERR = 3,
	ATA_CMD_CFA_WRITE_NE = 56,
	ATA_CMD_CFA_TRANS_SECT = 135,
	ATA_CMD_CFA_ERASE = 192,
	ATA_CMD_CFA_WRITE_MULT_NE = 205,
	ATA_CMD_REQ_SENSE_DATA = 11,
	ATA_CMD_SANITIZE_DEVICE = 180,
	ATA_CMD_ZAC_MGMT_IN = 74,
	ATA_CMD_ZAC_MGMT_OUT = 159,
	ATA_CMD_RESTORE = 16,
	ATA_SUBCMD_FPDMA_RECV_RD_LOG_DMA_EXT = 1,
	ATA_SUBCMD_FPDMA_RECV_ZAC_MGMT_IN = 2,
	ATA_SUBCMD_FPDMA_SEND_DSM = 0,
	ATA_SUBCMD_FPDMA_SEND_WR_LOG_DMA_EXT = 2,
	ATA_SUBCMD_NCQ_NON_DATA_ABORT_QUEUE = 0,
	ATA_SUBCMD_NCQ_NON_DATA_SET_FEATURES = 5,
	ATA_SUBCMD_NCQ_NON_DATA_ZERO_EXT = 6,
	ATA_SUBCMD_NCQ_NON_DATA_ZAC_MGMT_OUT = 7,
	ATA_SUBCMD_ZAC_MGMT_IN_REPORT_ZONES = 0,
	ATA_SUBCMD_ZAC_MGMT_OUT_CLOSE_ZONE = 1,
	ATA_SUBCMD_ZAC_MGMT_OUT_FINISH_ZONE = 2,
	ATA_SUBCMD_ZAC_MGMT_OUT_OPEN_ZONE = 3,
	ATA_SUBCMD_ZAC_MGMT_OUT_RESET_WRITE_POINTER = 4,
	ATA_LOG_DIRECTORY = 0,
	ATA_LOG_SATA_NCQ = 16,
	ATA_LOG_NCQ_NON_DATA = 18,
	ATA_LOG_NCQ_SEND_RECV = 19,
	ATA_LOG_IDENTIFY_DEVICE = 48,
	ATA_LOG_CONCURRENT_POSITIONING_RANGES = 71,
	ATA_LOG_SECURITY = 6,
	ATA_LOG_SATA_SETTINGS = 8,
	ATA_LOG_ZONED_INFORMATION = 9,
	ATA_LOG_DEVSLP_OFFSET = 48,
	ATA_LOG_DEVSLP_SIZE = 8,
	ATA_LOG_DEVSLP_MDAT = 0,
	ATA_LOG_DEVSLP_MDAT_MASK = 31,
	ATA_LOG_DEVSLP_DETO = 1,
	ATA_LOG_DEVSLP_VALID = 7,
	ATA_LOG_DEVSLP_VALID_MASK = 128,
	ATA_LOG_NCQ_PRIO_OFFSET = 9,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_SEND_RECV_SUBCMDS_DSM = 1,
	ATA_LOG_NCQ_SEND_RECV_DSM_OFFSET = 4,
	ATA_LOG_NCQ_SEND_RECV_DSM_TRIM = 1,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_OFFSET = 8,
	ATA_LOG_NCQ_SEND_RECV_RD_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_OFFSET = 12,
	ATA_LOG_NCQ_SEND_RECV_WR_LOG_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OFFSET = 16,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_OUT_SUPPORTED = 1,
	ATA_LOG_NCQ_SEND_RECV_ZAC_MGMT_IN_SUPPORTED = 2,
	ATA_LOG_NCQ_SEND_RECV_SIZE = 20,
	ATA_LOG_NCQ_NON_DATA_SUBCMDS_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_OFFSET = 0,
	ATA_LOG_NCQ_NON_DATA_ABORT_NCQ = 1,
	ATA_LOG_NCQ_NON_DATA_ABORT_ALL = 2,
	ATA_LOG_NCQ_NON_DATA_ABORT_STREAMING = 4,
	ATA_LOG_NCQ_NON_DATA_ABORT_NON_STREAMING = 8,
	ATA_LOG_NCQ_NON_DATA_ABORT_SELECTED = 16,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OFFSET = 28,
	ATA_LOG_NCQ_NON_DATA_ZAC_MGMT_OUT = 1,
	ATA_LOG_NCQ_NON_DATA_SIZE = 64,
	ATA_CMD_READ_LONG = 34,
	ATA_CMD_READ_LONG_ONCE = 35,
	ATA_CMD_WRITE_LONG = 50,
	ATA_CMD_WRITE_LONG_ONCE = 51,
	SETFEATURES_XFER = 3,
	XFER_UDMA_7 = 71,
	XFER_UDMA_6 = 70,
	XFER_UDMA_5 = 69,
	XFER_UDMA_4 = 68,
	XFER_UDMA_3 = 67,
	XFER_UDMA_2 = 66,
	XFER_UDMA_1 = 65,
	XFER_UDMA_0 = 64,
	XFER_MW_DMA_4 = 36,
	XFER_MW_DMA_3 = 35,
	XFER_MW_DMA_2 = 34,
	XFER_MW_DMA_1 = 33,
	XFER_MW_DMA_0 = 32,
	XFER_SW_DMA_2 = 18,
	XFER_SW_DMA_1 = 17,
	XFER_SW_DMA_0 = 16,
	XFER_PIO_6 = 14,
	XFER_PIO_5 = 13,
	XFER_PIO_4 = 12,
	XFER_PIO_3 = 11,
	XFER_PIO_2 = 10,
	XFER_PIO_1 = 9,
	XFER_PIO_0 = 8,
	XFER_PIO_SLOW = 0,
	SETFEATURES_WC_ON = 2,
	SETFEATURES_WC_OFF = 130,
	SETFEATURES_RA_ON = 170,
	SETFEATURES_RA_OFF = 85,
	SETFEATURES_AAM_ON = 66,
	SETFEATURES_AAM_OFF = 194,
	SETFEATURES_SPINUP = 7,
	SETFEATURES_SPINUP_TIMEOUT = 30000,
	SETFEATURES_SATA_ENABLE = 16,
	SETFEATURES_SATA_DISABLE = 144,
	SATA_FPDMA_OFFSET = 1,
	SATA_FPDMA_AA = 2,
	SATA_DIPM = 3,
	SATA_FPDMA_IN_ORDER = 4,
	SATA_AN = 5,
	SATA_SSP = 6,
	SATA_DEVSLP = 9,
	SETFEATURE_SENSE_DATA = 195,
	ATA_SET_MAX_ADDR = 0,
	ATA_SET_MAX_PASSWD = 1,
	ATA_SET_MAX_LOCK = 2,
	ATA_SET_MAX_UNLOCK = 3,
	ATA_SET_MAX_FREEZE_LOCK = 4,
	ATA_SET_MAX_PASSWD_DMA = 5,
	ATA_SET_MAX_UNLOCK_DMA = 6,
	ATA_DCO_RESTORE = 192,
	ATA_DCO_FREEZE_LOCK = 193,
	ATA_DCO_IDENTIFY = 194,
	ATA_DCO_SET = 195,
	ATA_SMART_ENABLE = 216,
	ATA_SMART_READ_VALUES = 208,
	ATA_SMART_READ_THRESHOLDS = 209,
	ATA_DSM_TRIM = 1,
	ATA_SMART_LBAM_PASS = 79,
	ATA_SMART_LBAH_PASS = 194,
	ATAPI_PKT_DMA = 1,
	ATAPI_DMADIR = 4,
	ATAPI_CDB_LEN = 16,
	SATA_PMP_MAX_PORTS = 15,
	SATA_PMP_CTRL_PORT = 15,
	SATA_PMP_GSCR_DWORDS = 128,
	SATA_PMP_GSCR_PROD_ID = 0,
	SATA_PMP_GSCR_REV = 1,
	SATA_PMP_GSCR_PORT_INFO = 2,
	SATA_PMP_GSCR_ERROR = 32,
	SATA_PMP_GSCR_ERROR_EN = 33,
	SATA_PMP_GSCR_FEAT = 64,
	SATA_PMP_GSCR_FEAT_EN = 96,
	SATA_PMP_PSCR_STATUS = 0,
	SATA_PMP_PSCR_ERROR = 1,
	SATA_PMP_PSCR_CONTROL = 2,
	SATA_PMP_FEAT_BIST = 1,
	SATA_PMP_FEAT_PMREQ = 2,
	SATA_PMP_FEAT_DYNSSC = 4,
	SATA_PMP_FEAT_NOTIFY = 8,
	ATA_CBL_NONE = 0,
	ATA_CBL_PATA40 = 1,
	ATA_CBL_PATA80 = 2,
	ATA_CBL_PATA40_SHORT = 3,
	ATA_CBL_PATA_UNK = 4,
	ATA_CBL_PATA_IGN = 5,
	ATA_CBL_SATA = 6,
	SCR_STATUS = 0,
	SCR_ERROR = 1,
	SCR_CONTROL = 2,
	SCR_ACTIVE = 3,
	SCR_NOTIFICATION = 4,
	SERR_DATA_RECOVERED = 1,
	SERR_COMM_RECOVERED = 2,
	SERR_DATA = 256,
	SERR_PERSISTENT = 512,
	SERR_PROTOCOL = 1024,
	SERR_INTERNAL = 2048,
	SERR_PHYRDY_CHG = 65536,
	SERR_PHY_INT_ERR = 131072,
	SERR_COMM_WAKE = 262144,
	SERR_10B_8B_ERR = 524288,
	SERR_DISPARITY = 1048576,
	SERR_CRC = 2097152,
	SERR_HANDSHAKE = 4194304,
	SERR_LINK_SEQ_ERR = 8388608,
	SERR_TRANS_ST_ERROR = 16777216,
	SERR_UNRECOG_FIS = 33554432,
	SERR_DEV_XCHG = 67108864,
};

enum ata_prot_flags {
	ATA_PROT_FLAG_PIO = 1,
	ATA_PROT_FLAG_DMA = 2,
	ATA_PROT_FLAG_NCQ = 4,
	ATA_PROT_FLAG_ATAPI = 8,
	ATA_PROT_UNKNOWN = 255,
	ATA_PROT_NODATA = 0,
	ATA_PROT_PIO = 1,
	ATA_PROT_DMA = 2,
	ATA_PROT_NCQ_NODATA = 4,
	ATA_PROT_NCQ = 6,
	ATAPI_PROT_NODATA = 8,
	ATAPI_PROT_PIO = 9,
	ATAPI_PROT_DMA = 10,
};

struct ata_bmdma_prd {
	__le32 addr;
	__le32 flags_len;
};

enum {
	LIBATA_MAX_PRD = 128,
	LIBATA_DUMB_MAX_PRD = 64,
	ATA_DEF_QUEUE = 1,
	ATA_MAX_QUEUE = 32,
	ATA_TAG_INTERNAL = 32,
	ATA_SHORT_PAUSE = 16,
	ATAPI_MAX_DRAIN = 16384,
	ATA_ALL_DEVICES = 3,
	ATA_SHT_EMULATED = 1,
	ATA_SHT_THIS_ID = 4294967295,
	ATA_TFLAG_LBA48 = 1,
	ATA_TFLAG_ISADDR = 2,
	ATA_TFLAG_DEVICE = 4,
	ATA_TFLAG_WRITE = 8,
	ATA_TFLAG_LBA = 16,
	ATA_TFLAG_FUA = 32,
	ATA_TFLAG_POLLING = 64,
	ATA_DFLAG_LBA = 1,
	ATA_DFLAG_LBA48 = 2,
	ATA_DFLAG_CDB_INTR = 4,
	ATA_DFLAG_NCQ = 8,
	ATA_DFLAG_FLUSH_EXT = 16,
	ATA_DFLAG_ACPI_PENDING = 32,
	ATA_DFLAG_ACPI_FAILED = 64,
	ATA_DFLAG_AN = 128,
	ATA_DFLAG_TRUSTED = 256,
	ATA_DFLAG_DMADIR = 1024,
	ATA_DFLAG_CFG_MASK = 4095,
	ATA_DFLAG_PIO = 4096,
	ATA_DFLAG_NCQ_OFF = 8192,
	ATA_DFLAG_SLEEPING = 32768,
	ATA_DFLAG_DUBIOUS_XFER = 65536,
	ATA_DFLAG_NO_UNLOAD = 131072,
	ATA_DFLAG_UNLOCK_HPA = 262144,
	ATA_DFLAG_NCQ_SEND_RECV = 524288,
	ATA_DFLAG_NCQ_PRIO = 1048576,
	ATA_DFLAG_NCQ_PRIO_ENABLED = 2097152,
	ATA_DFLAG_INIT_MASK = 16777215,
	ATA_DFLAG_DETACH = 16777216,
	ATA_DFLAG_DETACHED = 33554432,
	ATA_DFLAG_DA = 67108864,
	ATA_DFLAG_DEVSLP = 134217728,
	ATA_DFLAG_ACPI_DISABLED = 268435456,
	ATA_DFLAG_D_SENSE = 536870912,
	ATA_DFLAG_ZAC = 1073741824,
	ATA_DFLAG_FEATURES_MASK = 202899712,
	ATA_DEV_UNKNOWN = 0,
	ATA_DEV_ATA = 1,
	ATA_DEV_ATA_UNSUP = 2,
	ATA_DEV_ATAPI = 3,
	ATA_DEV_ATAPI_UNSUP = 4,
	ATA_DEV_PMP = 5,
	ATA_DEV_PMP_UNSUP = 6,
	ATA_DEV_SEMB = 7,
	ATA_DEV_SEMB_UNSUP = 8,
	ATA_DEV_ZAC = 9,
	ATA_DEV_ZAC_UNSUP = 10,
	ATA_DEV_NONE = 11,
	ATA_LFLAG_NO_HRST = 2,
	ATA_LFLAG_NO_SRST = 4,
	ATA_LFLAG_ASSUME_ATA = 8,
	ATA_LFLAG_ASSUME_SEMB = 16,
	ATA_LFLAG_ASSUME_CLASS = 24,
	ATA_LFLAG_NO_RETRY = 32,
	ATA_LFLAG_DISABLED = 64,
	ATA_LFLAG_SW_ACTIVITY = 128,
	ATA_LFLAG_NO_LPM = 256,
	ATA_LFLAG_RST_ONCE = 512,
	ATA_LFLAG_CHANGED = 1024,
	ATA_LFLAG_NO_DEBOUNCE_DELAY = 2048,
	ATA_FLAG_SLAVE_POSS = 1,
	ATA_FLAG_SATA = 2,
	ATA_FLAG_NO_LPM = 4,
	ATA_FLAG_NO_LOG_PAGE = 32,
	ATA_FLAG_NO_ATAPI = 64,
	ATA_FLAG_PIO_DMA = 128,
	ATA_FLAG_PIO_LBA48 = 256,
	ATA_FLAG_PIO_POLLING = 512,
	ATA_FLAG_NCQ = 1024,
	ATA_FLAG_NO_POWEROFF_SPINDOWN = 2048,
	ATA_FLAG_NO_HIBERNATE_SPINDOWN = 4096,
	ATA_FLAG_DEBUGMSG = 8192,
	ATA_FLAG_FPDMA_AA = 16384,
	ATA_FLAG_IGN_SIMPLEX = 32768,
	ATA_FLAG_NO_IORDY = 65536,
	ATA_FLAG_ACPI_SATA = 131072,
	ATA_FLAG_AN = 262144,
	ATA_FLAG_PMP = 524288,
	ATA_FLAG_FPDMA_AUX = 1048576,
	ATA_FLAG_EM = 2097152,
	ATA_FLAG_SW_ACTIVITY = 4194304,
	ATA_FLAG_NO_DIPM = 8388608,
	ATA_FLAG_SAS_HOST = 16777216,
	ATA_PFLAG_EH_PENDING = 1,
	ATA_PFLAG_EH_IN_PROGRESS = 2,
	ATA_PFLAG_FROZEN = 4,
	ATA_PFLAG_RECOVERED = 8,
	ATA_PFLAG_LOADING = 16,
	ATA_PFLAG_SCSI_HOTPLUG = 64,
	ATA_PFLAG_INITIALIZING = 128,
	ATA_PFLAG_RESETTING = 256,
	ATA_PFLAG_UNLOADING = 512,
	ATA_PFLAG_UNLOADED = 1024,
	ATA_PFLAG_SUSPENDED = 131072,
	ATA_PFLAG_PM_PENDING = 262144,
	ATA_PFLAG_INIT_GTM_VALID = 524288,
	ATA_PFLAG_PIO32 = 1048576,
	ATA_PFLAG_PIO32CHANGE = 2097152,
	ATA_PFLAG_EXTERNAL = 4194304,
	ATA_QCFLAG_ACTIVE = 1,
	ATA_QCFLAG_DMAMAP = 2,
	ATA_QCFLAG_IO = 8,
	ATA_QCFLAG_RESULT_TF = 16,
	ATA_QCFLAG_CLEAR_EXCL = 32,
	ATA_QCFLAG_QUIET = 64,
	ATA_QCFLAG_RETRY = 128,
	ATA_QCFLAG_FAILED = 65536,
	ATA_QCFLAG_SENSE_VALID = 131072,
	ATA_QCFLAG_EH_SCHEDULED = 262144,
	ATA_HOST_SIMPLEX = 1,
	ATA_HOST_STARTED = 2,
	ATA_HOST_PARALLEL_SCAN = 4,
	ATA_HOST_IGNORE_ATA = 8,
	ATA_TMOUT_BOOT = 30000,
	ATA_TMOUT_BOOT_QUICK = 7000,
	ATA_TMOUT_INTERNAL_QUICK = 5000,
	ATA_TMOUT_MAX_PARK = 30000,
	ATA_TMOUT_FF_WAIT_LONG = 2000,
	ATA_TMOUT_FF_WAIT = 800,
	ATA_WAIT_AFTER_RESET = 150,
	ATA_TMOUT_PMP_SRST_WAIT = 5000,
	ATA_TMOUT_SPURIOUS_PHY = 10000,
	BUS_UNKNOWN = 0,
	BUS_DMA = 1,
	BUS_IDLE = 2,
	BUS_NOINTR = 3,
	BUS_NODATA = 4,
	BUS_TIMER = 5,
	BUS_PIO = 6,
	BUS_EDD = 7,
	BUS_IDENTIFY = 8,
	BUS_PACKET = 9,
	PORT_UNKNOWN = 0,
	PORT_ENABLED = 1,
	PORT_DISABLED = 2,
	ATA_NR_PIO_MODES = 7,
	ATA_NR_MWDMA_MODES = 5,
	ATA_NR_UDMA_MODES = 8,
	ATA_SHIFT_PIO = 0,
	ATA_SHIFT_MWDMA = 7,
	ATA_SHIFT_UDMA = 12,
	ATA_SHIFT_PRIO = 6,
	ATA_PRIO_HIGH = 2,
	ATA_DMA_PAD_SZ = 4,
	ATA_ERING_SIZE = 32,
	ATA_DEFER_LINK = 1,
	ATA_DEFER_PORT = 2,
	ATA_EH_DESC_LEN = 80,
	ATA_EH_REVALIDATE = 1,
	ATA_EH_SOFTRESET = 2,
	ATA_EH_HARDRESET = 4,
	ATA_EH_RESET = 6,
	ATA_EH_ENABLE_LINK = 8,
	ATA_EH_PARK = 32,
	ATA_EH_PERDEV_MASK = 33,
	ATA_EH_ALL_ACTIONS = 15,
	ATA_EHI_HOTPLUGGED = 1,
	ATA_EHI_NO_AUTOPSY = 4,
	ATA_EHI_QUIET = 8,
	ATA_EHI_NO_RECOVERY = 16,
	ATA_EHI_DID_SOFTRESET = 65536,
	ATA_EHI_DID_HARDRESET = 131072,
	ATA_EHI_PRINTINFO = 262144,
	ATA_EHI_SETMODE = 524288,
	ATA_EHI_POST_SETMODE = 1048576,
	ATA_EHI_DID_RESET = 196608,
	ATA_EHI_TO_SLAVE_MASK = 12,
	ATA_EH_MAX_TRIES = 5,
	ATA_LINK_RESUME_TRIES = 5,
	ATA_PROBE_MAX_TRIES = 3,
	ATA_EH_DEV_TRIES = 3,
	ATA_EH_PMP_TRIES = 5,
	ATA_EH_PMP_LINK_TRIES = 3,
	SATA_PMP_RW_TIMEOUT = 3000,
	ATA_EH_CMD_TIMEOUT_TABLE_SIZE = 7,
	ATA_HORKAGE_DIAGNOSTIC = 1,
	ATA_HORKAGE_NODMA = 2,
	ATA_HORKAGE_NONCQ = 4,
	ATA_HORKAGE_MAX_SEC_128 = 8,
	ATA_HORKAGE_BROKEN_HPA = 16,
	ATA_HORKAGE_DISABLE = 32,
	ATA_HORKAGE_HPA_SIZE = 64,
	ATA_HORKAGE_IVB = 256,
	ATA_HORKAGE_STUCK_ERR = 512,
	ATA_HORKAGE_BRIDGE_OK = 1024,
	ATA_HORKAGE_ATAPI_MOD16_DMA = 2048,
	ATA_HORKAGE_FIRMWARE_WARN = 4096,
	ATA_HORKAGE_1_5_GBPS = 8192,
	ATA_HORKAGE_NOSETXFER = 16384,
	ATA_HORKAGE_BROKEN_FPDMA_AA = 32768,
	ATA_HORKAGE_DUMP_ID = 65536,
	ATA_HORKAGE_MAX_SEC_LBA48 = 131072,
	ATA_HORKAGE_ATAPI_DMADIR = 262144,
	ATA_HORKAGE_NO_NCQ_TRIM = 524288,
	ATA_HORKAGE_NOLPM = 1048576,
	ATA_HORKAGE_WD_BROKEN_LPM = 2097152,
	ATA_HORKAGE_ZERO_AFTER_TRIM = 4194304,
	ATA_HORKAGE_NO_DMA_LOG = 8388608,
	ATA_HORKAGE_NOTRIM = 16777216,
	ATA_HORKAGE_MAX_SEC_1024 = 33554432,
	ATA_HORKAGE_MAX_TRIM_128M = 67108864,
	ATA_HORKAGE_NO_NCQ_ON_ATI = 134217728,
	ATA_HORKAGE_NO_ID_DEV_LOG = 268435456,
	ATA_HORKAGE_NO_LOG_DIR = 536870912,
	ATA_DMA_MASK_ATA = 1,
	ATA_DMA_MASK_ATAPI = 2,
	ATA_DMA_MASK_CFA = 4,
	ATAPI_READ = 0,
	ATAPI_WRITE = 1,
	ATAPI_READ_CD = 2,
	ATAPI_PASS_THRU = 3,
	ATAPI_MISC = 4,
	ATA_TIMING_SETUP = 1,
	ATA_TIMING_ACT8B = 2,
	ATA_TIMING_REC8B = 4,
	ATA_TIMING_CYC8B = 8,
	ATA_TIMING_8BIT = 14,
	ATA_TIMING_ACTIVE = 16,
	ATA_TIMING_RECOVER = 32,
	ATA_TIMING_DMACK_HOLD = 64,
	ATA_TIMING_CYCLE = 128,
	ATA_TIMING_UDMA = 256,
	ATA_TIMING_ALL = 511,
	ATA_ACPI_FILTER_SETXFER = 1,
	ATA_ACPI_FILTER_LOCK = 2,
	ATA_ACPI_FILTER_DIPM = 4,
	ATA_ACPI_FILTER_FPDMA_OFFSET = 8,
	ATA_ACPI_FILTER_FPDMA_AA = 16,
	ATA_ACPI_FILTER_DEFAULT = 7,
};

enum ata_xfer_mask {
	ATA_MASK_PIO = 127,
	ATA_MASK_MWDMA = 3968,
	ATA_MASK_UDMA = 1044480,
};

enum hsm_task_states {
	HSM_ST_IDLE = 0,
	HSM_ST_FIRST = 1,
	HSM_ST = 2,
	HSM_ST_LAST = 3,
	HSM_ST_ERR = 4,
};

enum ata_completion_errors {
	AC_ERR_OK = 0,
	AC_ERR_DEV = 1,
	AC_ERR_HSM = 2,
	AC_ERR_TIMEOUT = 4,
	AC_ERR_MEDIA = 8,
	AC_ERR_ATA_BUS = 16,
	AC_ERR_HOST_BUS = 32,
	AC_ERR_SYSTEM = 64,
	AC_ERR_INVALID = 128,
	AC_ERR_OTHER = 256,
	AC_ERR_NODEV_HINT = 512,
	AC_ERR_NCQ = 1024,
};

enum ata_lpm_policy {
	ATA_LPM_UNKNOWN = 0,
	ATA_LPM_MAX_POWER = 1,
	ATA_LPM_MED_POWER = 2,
	ATA_LPM_MED_POWER_WITH_DIPM = 3,
	ATA_LPM_MIN_POWER_WITH_PARTIAL = 4,
	ATA_LPM_MIN_POWER = 5,
};

struct ata_queued_cmd;

typedef void (*ata_qc_cb_t)(struct ata_queued_cmd *);

struct ata_taskfile {
	long unsigned int flags;
	u8 protocol;
	u8 ctl;
	u8 hob_feature;
	u8 hob_nsect;
	u8 hob_lbal;
	u8 hob_lbam;
	u8 hob_lbah;
	union {
		u8 error;
		u8 feature;
	};
	u8 nsect;
	u8 lbal;
	u8 lbam;
	u8 lbah;
	u8 device;
	union {
		u8 status;
		u8 command;
	};
	u32 auxiliary;
};

struct ata_port;

struct ata_device;

struct ata_queued_cmd {
	struct ata_port *ap;
	struct ata_device *dev;
	struct scsi_cmnd *scsicmd;
	void (*scsidone)(struct scsi_cmnd *);
	struct ata_taskfile tf;
	u8 cdb[16];
	long unsigned int flags;
	unsigned int tag;
	unsigned int hw_tag;
	unsigned int n_elem;
	unsigned int orig_n_elem;
	int dma_dir;
	unsigned int sect_size;
	unsigned int nbytes;
	unsigned int extrabytes;
	unsigned int curbytes;
	struct scatterlist sgent;
	struct scatterlist *sg;
	struct scatterlist *cursg;
	unsigned int cursg_ofs;
	unsigned int err_mask;
	struct ata_taskfile result_tf;
	ata_qc_cb_t complete_fn;
	void *private_data;
	void *lldd_task;
};

struct ata_link;

typedef int (*ata_prereset_fn_t)(struct ata_link *, long unsigned int);

struct ata_eh_info {
	struct ata_device *dev;
	u32 serror;
	unsigned int err_mask;
	unsigned int action;
	unsigned int dev_action[2];
	unsigned int flags;
	unsigned int probe_mask;
	char desc[80];
	int desc_len;
};

struct ata_eh_context {
	struct ata_eh_info i;
	int tries[2];
	int cmd_timeout_idx[14];
	unsigned int classes[2];
	unsigned int did_probe_mask;
	unsigned int unloaded_mask;
	unsigned int saved_ncq_enabled;
	u8 saved_xfer_mode[2];
	long unsigned int last_reset;
};

struct ata_ering_entry {
	unsigned int eflags;
	unsigned int err_mask;
	u64 timestamp;
};

struct ata_ering {
	int cursor;
	int: 32;
	struct ata_ering_entry ring[32];
};

struct ata_cpr_log;

struct ata_device {
	struct ata_link *link;
	unsigned int devno;
	unsigned int horkage;
	long unsigned int flags;
	struct scsi_device *sdev;
	void *private_data;
	struct device tdev;
	u64 n_sectors;
	u64 n_native_sectors;
	unsigned int class;
	long unsigned int unpark_deadline;
	u8 pio_mode;
	u8 dma_mode;
	u8 xfer_mode;
	unsigned int xfer_shift;
	unsigned int multi_count;
	unsigned int max_sectors;
	unsigned int cdb_len;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	u16 cylinders;
	u16 heads;
	u16 sectors;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	union {
		u16 id[256];
		u32 gscr[128];
	};
	u8 devslp_timing[8];
	u8 ncq_send_recv_cmds[20];
	u8 ncq_non_data_cmds[64];
	u32 zac_zoned_cap;
	u32 zac_zones_optimal_open;
	u32 zac_zones_optimal_nonseq;
	u32 zac_zones_max_open;
	struct ata_cpr_log *cpr_log;
	int spdn_cnt;
	int: 32;
	struct ata_ering ering;
};

struct ata_link {
	struct ata_port *ap;
	int pmp;
	struct device tdev;
	unsigned int active_tag;
	u32 sactive;
	unsigned int flags;
	u32 saved_scontrol;
	unsigned int hw_sata_spd_limit;
	unsigned int sata_spd_limit;
	unsigned int sata_spd;
	enum ata_lpm_policy lpm_policy;
	struct ata_eh_info eh_info;
	struct ata_eh_context eh_context;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct ata_device device[2];
	long unsigned int last_lpm_change;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef int (*ata_reset_fn_t)(struct ata_link *, unsigned int *, long unsigned int);

typedef void (*ata_postreset_fn_t)(struct ata_link *, unsigned int *);

enum sw_activity {
	OFF___2 = 0,
	BLINK_ON = 1,
	BLINK_OFF = 2,
};

struct ata_ioports {
	void *cmd_addr;
	void *data_addr;
	void *error_addr;
	void *feature_addr;
	void *nsect_addr;
	void *lbal_addr;
	void *lbam_addr;
	void *lbah_addr;
	void *device_addr;
	void *status_addr;
	void *command_addr;
	void *altstatus_addr;
	void *ctl_addr;
	void *bmdma_addr;
	void *scr_addr;
};

struct ata_port_operations;

struct ata_host {
	spinlock_t lock;
	struct device *dev;
	void * const *iomap;
	unsigned int n_ports;
	unsigned int n_tags;
	void *private_data;
	struct ata_port_operations *ops;
	long unsigned int flags;
	struct kref kref;
	struct mutex eh_mutex;
	struct task_struct *eh_owner;
	struct ata_port *simplex_claimed;
	struct ata_port *ports[0];
};

struct ata_port_operations {
	int (*qc_defer)(struct ata_queued_cmd *);
	int (*check_atapi_dma)(struct ata_queued_cmd *);
	enum ata_completion_errors (*qc_prep)(struct ata_queued_cmd *);
	unsigned int (*qc_issue)(struct ata_queued_cmd *);
	bool (*qc_fill_rtf)(struct ata_queued_cmd *);
	int (*cable_detect)(struct ata_port *);
	unsigned int (*mode_filter)(struct ata_device *, unsigned int);
	void (*set_piomode)(struct ata_port *, struct ata_device *);
	void (*set_dmamode)(struct ata_port *, struct ata_device *);
	int (*set_mode)(struct ata_link *, struct ata_device **);
	unsigned int (*read_id)(struct ata_device *, struct ata_taskfile *, __le16 *);
	void (*dev_config)(struct ata_device *);
	void (*freeze)(struct ata_port *);
	void (*thaw)(struct ata_port *);
	ata_prereset_fn_t prereset;
	ata_reset_fn_t softreset;
	ata_reset_fn_t hardreset;
	ata_postreset_fn_t postreset;
	ata_prereset_fn_t pmp_prereset;
	ata_reset_fn_t pmp_softreset;
	ata_reset_fn_t pmp_hardreset;
	ata_postreset_fn_t pmp_postreset;
	void (*error_handler)(struct ata_port *);
	void (*lost_interrupt)(struct ata_port *);
	void (*post_internal_cmd)(struct ata_queued_cmd *);
	void (*sched_eh)(struct ata_port *);
	void (*end_eh)(struct ata_port *);
	int (*scr_read)(struct ata_link *, unsigned int, u32 *);
	int (*scr_write)(struct ata_link *, unsigned int, u32);
	void (*pmp_attach)(struct ata_port *);
	void (*pmp_detach)(struct ata_port *);
	int (*set_lpm)(struct ata_link *, enum ata_lpm_policy, unsigned int);
	int (*port_suspend)(struct ata_port *, pm_message_t);
	int (*port_resume)(struct ata_port *);
	int (*port_start)(struct ata_port *);
	void (*port_stop)(struct ata_port *);
	void (*host_stop)(struct ata_host *);
	void (*sff_dev_select)(struct ata_port *, unsigned int);
	void (*sff_set_devctl)(struct ata_port *, u8);
	u8 (*sff_check_status)(struct ata_port *);
	u8 (*sff_check_altstatus)(struct ata_port *);
	void (*sff_tf_load)(struct ata_port *, const struct ata_taskfile *);
	void (*sff_tf_read)(struct ata_port *, struct ata_taskfile *);
	void (*sff_exec_command)(struct ata_port *, const struct ata_taskfile *);
	unsigned int (*sff_data_xfer)(struct ata_queued_cmd *, unsigned char *, unsigned int, int);
	void (*sff_irq_on)(struct ata_port *);
	bool (*sff_irq_check)(struct ata_port *);
	void (*sff_irq_clear)(struct ata_port *);
	void (*sff_drain_fifo)(struct ata_queued_cmd *);
	void (*bmdma_setup)(struct ata_queued_cmd *);
	void (*bmdma_start)(struct ata_queued_cmd *);
	void (*bmdma_stop)(struct ata_queued_cmd *);
	u8 (*bmdma_status)(struct ata_port *);
	ssize_t (*em_show)(struct ata_port *, char *);
	ssize_t (*em_store)(struct ata_port *, const char *, size_t);
	ssize_t (*sw_activity_show)(struct ata_device *, char *);
	ssize_t (*sw_activity_store)(struct ata_device *, enum sw_activity);
	ssize_t (*transmit_led_message)(struct ata_port *, u32, ssize_t);
	void (*phy_reset)(struct ata_port *);
	void (*eng_timeout)(struct ata_port *);
	const struct ata_port_operations *inherits;
};

struct ata_port_stats {
	long unsigned int unhandled_irq;
	long unsigned int idle_irq;
	long unsigned int rw_reqbuf;
};

struct ata_port {
	struct Scsi_Host *scsi_host;
	struct ata_port_operations *ops;
	spinlock_t *lock;
	long unsigned int flags;
	unsigned int pflags;
	unsigned int print_id;
	unsigned int local_port_no;
	unsigned int port_no;
	struct ata_ioports ioaddr;
	u8 ctl;
	u8 last_ctl;
	struct ata_link *sff_pio_task_link;
	struct delayed_work sff_pio_task;
	struct ata_bmdma_prd *bmdma_prd;
	dma_addr_t bmdma_prd_dma;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	unsigned int cbl;
	struct ata_queued_cmd qcmd[33];
	int: 32;
	u64 qc_active;
	int nr_active_links;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct ata_link link;
	struct ata_link *slave_link;
	int nr_pmp_links;
	struct ata_link *pmp_link;
	struct ata_link *excl_link;
	struct ata_port_stats stats;
	struct ata_host *host;
	struct device *dev;
	int: 32;
	struct device tdev;
	struct mutex scsi_scan_mutex;
	struct delayed_work hotplug_task;
	struct work_struct scsi_rescan_task;
	unsigned int hsm_task_state;
	struct list_head eh_done_q;
	wait_queue_head_t eh_wait_q;
	int eh_tries;
	struct completion park_req_pending;
	pm_message_t pm_mesg;
	enum ata_lpm_policy target_lpm_policy;
	struct timer_list fastdrain_timer;
	unsigned int fastdrain_cnt;
	int: 32;
	async_cookie_t cookie;
	int em_message_type;
	void *private_data;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u8 sector_buf[512];
};

struct ata_cpr {
	u8 num;
	u8 num_storage_elements;
	int: 16;
	int: 32;
	u64 start_lba;
	u64 num_lbas;
};

struct ata_cpr_log {
	u8 nr_cpr;
	int: 24;
	int: 32;
	struct ata_cpr cpr[0];
};

struct ata_port_info {
	long unsigned int flags;
	long unsigned int link_flags;
	unsigned int pio_mask;
	unsigned int mwdma_mask;
	unsigned int udma_mask;
	struct ata_port_operations *port_ops;
	void *private_data;
};

struct pci_bits {
	unsigned int reg;
	unsigned int width;
	long unsigned int mask;
	long unsigned int val;
};

enum ata_link_iter_mode {
	ATA_LITER_EDGE = 0,
	ATA_LITER_HOST_FIRST = 1,
	ATA_LITER_PMP_FIRST = 2,
};

enum ata_dev_iter_mode {
	ATA_DITER_ENABLED = 0,
	ATA_DITER_ENABLED_REVERSE = 1,
	ATA_DITER_ALL = 2,
	ATA_DITER_ALL_REVERSE = 3,
};

struct trace_event_raw_ata_qc_issue_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	unsigned char proto;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_qc_complete_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned char status;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char error;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char ctl;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_ata_tf_load {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned char cmd;
	unsigned char dev;
	unsigned char lbal;
	unsigned char lbam;
	unsigned char lbah;
	unsigned char nsect;
	unsigned char feature;
	unsigned char hob_lbal;
	unsigned char hob_lbam;
	unsigned char hob_lbah;
	unsigned char hob_nsect;
	unsigned char hob_feature;
	unsigned char proto;
	char __data[0];
};

struct trace_event_raw_ata_exec_command_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int tag;
	unsigned char cmd;
	unsigned char feature;
	unsigned char hob_nsect;
	unsigned char proto;
	char __data[0];
};

struct trace_event_raw_ata_bmdma_status {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int tag;
	unsigned char host_stat;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_link_autopsy_qc {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int eh_err_mask;
	char __data[0];
};

struct trace_event_raw_ata_eh_action_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int eh_action;
	char __data[0];
};

struct trace_event_raw_ata_link_reset_begin_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int class[2];
	long unsigned int deadline;
	char __data[0];
};

struct trace_event_raw_ata_link_reset_end_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int class[2];
	int rc;
	char __data[0];
};

struct trace_event_raw_ata_port_eh_begin_template {
	struct trace_entry ent;
	unsigned int ata_port;
	char __data[0];
};

struct trace_event_raw_ata_sff_hsm_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int qc_flags;
	unsigned int protocol;
	unsigned int hsm_state;
	unsigned char dev_state;
	char __data[0];
};

struct trace_event_raw_ata_transfer_data_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned int ata_dev;
	unsigned int tag;
	unsigned int flags;
	unsigned int offset;
	unsigned int bytes;
	char __data[0];
};

struct trace_event_raw_ata_sff_template {
	struct trace_entry ent;
	unsigned int ata_port;
	unsigned char hsm_state;
	char __data[0];
};

struct trace_event_data_offsets_ata_qc_issue_template {};

struct trace_event_data_offsets_ata_qc_complete_template {};

struct trace_event_data_offsets_ata_tf_load {};

struct trace_event_data_offsets_ata_exec_command_template {};

struct trace_event_data_offsets_ata_bmdma_status {};

struct trace_event_data_offsets_ata_eh_link_autopsy {};

struct trace_event_data_offsets_ata_eh_link_autopsy_qc {};

struct trace_event_data_offsets_ata_eh_action_template {};

struct trace_event_data_offsets_ata_link_reset_begin_template {};

struct trace_event_data_offsets_ata_link_reset_end_template {};

struct trace_event_data_offsets_ata_port_eh_begin_template {};

struct trace_event_data_offsets_ata_sff_hsm_template {};

struct trace_event_data_offsets_ata_transfer_data_template {};

struct trace_event_data_offsets_ata_sff_template {};

typedef void (*btf_trace_ata_qc_prep)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_issue)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_internal)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_failed)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_qc_complete_done)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_tf_load)(void *, struct ata_port *, const struct ata_taskfile *);

typedef void (*btf_trace_ata_exec_command)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_setup)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_start)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_stop)(void *, struct ata_port *, const struct ata_taskfile *, unsigned int);

typedef void (*btf_trace_ata_bmdma_status)(void *, struct ata_port *, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy)(void *, struct ata_device *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_link_autopsy_qc)(void *, struct ata_queued_cmd *);

typedef void (*btf_trace_ata_eh_about_to_do)(void *, struct ata_link *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_eh_done)(void *, struct ata_link *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_link_hardreset_begin)(void *, struct ata_link *, unsigned int *, long unsigned int);

typedef void (*btf_trace_ata_slave_hardreset_begin)(void *, struct ata_link *, unsigned int *, long unsigned int);

typedef void (*btf_trace_ata_link_softreset_begin)(void *, struct ata_link *, unsigned int *, long unsigned int);

typedef void (*btf_trace_ata_link_hardreset_end)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_slave_hardreset_end)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_link_softreset_end)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_link_postreset)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_slave_postreset)(void *, struct ata_link *, unsigned int *, int);

typedef void (*btf_trace_ata_std_sched_eh)(void *, struct ata_port *);

typedef void (*btf_trace_ata_port_freeze)(void *, struct ata_port *);

typedef void (*btf_trace_ata_port_thaw)(void *, struct ata_port *);

typedef void (*btf_trace_ata_sff_hsm_state)(void *, struct ata_queued_cmd *, unsigned char);

typedef void (*btf_trace_ata_sff_hsm_command_complete)(void *, struct ata_queued_cmd *, unsigned char);

typedef void (*btf_trace_ata_sff_port_intr)(void *, struct ata_queued_cmd *, unsigned char);

typedef void (*btf_trace_ata_sff_pio_transfer_data)(void *, struct ata_queued_cmd *, unsigned int, unsigned int);

typedef void (*btf_trace_atapi_pio_transfer_data)(void *, struct ata_queued_cmd *, unsigned int, unsigned int);

typedef void (*btf_trace_atapi_send_cdb)(void *, struct ata_queued_cmd *, unsigned int, unsigned int);

typedef void (*btf_trace_ata_sff_flush_pio_task)(void *, struct ata_port *);

enum {
	ATA_READID_POSTRESET = 1,
	ATA_DNXFER_PIO = 0,
	ATA_DNXFER_DMA = 1,
	ATA_DNXFER_40C = 2,
	ATA_DNXFER_FORCE_PIO = 3,
	ATA_DNXFER_FORCE_PIO0 = 4,
	ATA_DNXFER_QUIET = 2147483648,
};

struct ata_force_param {
	const char *name;
	u8 cbl;
	u8 spd_limit;
	unsigned int xfer_mask;
	unsigned int horkage_on;
	unsigned int horkage_off;
	u16 lflags_on;
	u16 lflags_off;
};

struct ata_force_ent {
	int port;
	int device;
	struct ata_force_param param;
};

struct ata_xfer_ent {
	int shift;
	int bits;
	u8 base;
};

struct ata_blacklist_entry {
	const char *model_num;
	const char *model_rev;
	long unsigned int horkage;
};

typedef unsigned int (*ata_xlat_func_t)(struct ata_queued_cmd *);

struct ata_scsi_args {
	struct ata_device *dev;
	u16 *id;
	struct scsi_cmnd *cmd;
};

enum ata_lpm_hints {
	ATA_LPM_EMPTY = 1,
	ATA_LPM_HIPM = 2,
	ATA_LPM_WAKE_ONLY = 4,
};

enum {
	ATA_EH_SPDN_NCQ_OFF = 1,
	ATA_EH_SPDN_SPEED_DOWN = 2,
	ATA_EH_SPDN_FALLBACK_TO_PIO = 4,
	ATA_EH_SPDN_KEEP_ERRORS = 8,
	ATA_EFLAG_IS_IO = 1,
	ATA_EFLAG_DUBIOUS_XFER = 2,
	ATA_EFLAG_OLD_ER = 2147483648,
	ATA_ECAT_NONE = 0,
	ATA_ECAT_ATA_BUS = 1,
	ATA_ECAT_TOUT_HSM = 2,
	ATA_ECAT_UNK_DEV = 3,
	ATA_ECAT_DUBIOUS_NONE = 4,
	ATA_ECAT_DUBIOUS_ATA_BUS = 5,
	ATA_ECAT_DUBIOUS_TOUT_HSM = 6,
	ATA_ECAT_DUBIOUS_UNK_DEV = 7,
	ATA_ECAT_NR = 8,
	ATA_EH_CMD_DFL_TIMEOUT = 5000,
	ATA_EH_RESET_COOL_DOWN = 5000,
	ATA_EH_PRERESET_TIMEOUT = 10000,
	ATA_EH_FASTDRAIN_INTERVAL = 3000,
	ATA_EH_UA_TRIES = 5,
	ATA_EH_PROBE_TRIAL_INTERVAL = 60000,
	ATA_EH_PROBE_TRIALS = 2,
};

struct ata_eh_cmd_timeout_ent {
	const u8 *commands;
	const unsigned int *timeouts;
};

struct speed_down_verdict_arg {
	u64 since;
	int xfer_ok;
	int nr_errors[8];
	int: 32;
};

struct ata_internal {
	struct scsi_transport_template t;
	struct device_attribute private_port_attrs[3];
	struct device_attribute private_link_attrs[3];
	struct device_attribute private_dev_attrs[9];
	struct transport_container link_attr_cont;
	struct transport_container dev_attr_cont;
	struct device_attribute *link_attrs[4];
	struct device_attribute *port_attrs[4];
	struct device_attribute *dev_attrs[10];
};

struct ata_show_ering_arg {
	char *buf;
	int written;
};

enum {
	AHCI_MAX_PORTS = 32,
	AHCI_MAX_SG = 168,
	AHCI_DMA_BOUNDARY = 4294967295,
	AHCI_MAX_CMDS = 32,
	AHCI_CMD_SZ = 32,
	AHCI_CMD_SLOT_SZ = 1024,
	AHCI_RX_FIS_SZ = 256,
	AHCI_CMD_TBL_CDB = 64,
	AHCI_CMD_TBL_HDR_SZ = 128,
	AHCI_CMD_TBL_SZ = 2816,
	AHCI_CMD_TBL_AR_SZ = 90112,
	AHCI_PORT_PRIV_DMA_SZ = 91392,
	AHCI_PORT_PRIV_FBS_DMA_SZ = 95232,
	AHCI_IRQ_ON_SG = 2147483648,
	AHCI_CMD_ATAPI = 32,
	AHCI_CMD_WRITE = 64,
	AHCI_CMD_PREFETCH = 128,
	AHCI_CMD_RESET = 256,
	AHCI_CMD_CLR_BUSY = 1024,
	RX_FIS_PIO_SETUP = 32,
	RX_FIS_D2H_REG = 64,
	RX_FIS_SDB = 88,
	RX_FIS_UNK = 96,
	HOST_CAP = 0,
	HOST_CTL = 4,
	HOST_IRQ_STAT = 8,
	HOST_PORTS_IMPL = 12,
	HOST_VERSION = 16,
	HOST_EM_LOC = 28,
	HOST_EM_CTL = 32,
	HOST_CAP2 = 36,
	HOST_RESET = 1,
	HOST_IRQ_EN = 2,
	HOST_MRSM = 4,
	HOST_AHCI_EN = 2147483648,
	HOST_CAP_SXS = 32,
	HOST_CAP_EMS = 64,
	HOST_CAP_CCC = 128,
	HOST_CAP_PART = 8192,
	HOST_CAP_SSC = 16384,
	HOST_CAP_PIO_MULTI = 32768,
	HOST_CAP_FBS = 65536,
	HOST_CAP_PMP = 131072,
	HOST_CAP_ONLY = 262144,
	HOST_CAP_CLO = 16777216,
	HOST_CAP_LED = 33554432,
	HOST_CAP_ALPM = 67108864,
	HOST_CAP_SSS = 134217728,
	HOST_CAP_MPS = 268435456,
	HOST_CAP_SNTF = 536870912,
	HOST_CAP_NCQ = 1073741824,
	HOST_CAP_64 = 2147483648,
	HOST_CAP2_BOH = 1,
	HOST_CAP2_NVMHCI = 2,
	HOST_CAP2_APST = 4,
	HOST_CAP2_SDS = 8,
	HOST_CAP2_SADM = 16,
	HOST_CAP2_DESO = 32,
	PORT_LST_ADDR = 0,
	PORT_LST_ADDR_HI = 4,
	PORT_FIS_ADDR = 8,
	PORT_FIS_ADDR_HI = 12,
	PORT_IRQ_STAT = 16,
	PORT_IRQ_MASK = 20,
	PORT_CMD = 24,
	PORT_TFDATA = 32,
	PORT_SIG = 36,
	PORT_CMD_ISSUE = 56,
	PORT_SCR_STAT = 40,
	PORT_SCR_CTL = 44,
	PORT_SCR_ERR = 48,
	PORT_SCR_ACT = 52,
	PORT_SCR_NTF = 60,
	PORT_FBS = 64,
	PORT_DEVSLP = 68,
	PORT_IRQ_COLD_PRES = 2147483648,
	PORT_IRQ_TF_ERR = 1073741824,
	PORT_IRQ_HBUS_ERR = 536870912,
	PORT_IRQ_HBUS_DATA_ERR = 268435456,
	PORT_IRQ_IF_ERR = 134217728,
	PORT_IRQ_IF_NONFATAL = 67108864,
	PORT_IRQ_OVERFLOW = 16777216,
	PORT_IRQ_BAD_PMP = 8388608,
	PORT_IRQ_PHYRDY = 4194304,
	PORT_IRQ_DMPS = 128,
	PORT_IRQ_CONNECT = 64,
	PORT_IRQ_SG_DONE = 32,
	PORT_IRQ_UNK_FIS = 16,
	PORT_IRQ_SDB_FIS = 8,
	PORT_IRQ_DMAS_FIS = 4,
	PORT_IRQ_PIOS_FIS = 2,
	PORT_IRQ_D2H_REG_FIS = 1,
	PORT_IRQ_FREEZE = 683671632,
	PORT_IRQ_ERROR = 2025848912,
	DEF_PORT_IRQ = 2025848959,
	PORT_CMD_ASP = 134217728,
	PORT_CMD_ALPE = 67108864,
	PORT_CMD_ATAPI = 16777216,
	PORT_CMD_FBSCP = 4194304,
	PORT_CMD_ESP = 2097152,
	PORT_CMD_CPD = 1048576,
	PORT_CMD_MPSP = 524288,
	PORT_CMD_HPCP = 262144,
	PORT_CMD_PMP = 131072,
	PORT_CMD_LIST_ON = 32768,
	PORT_CMD_FIS_ON = 16384,
	PORT_CMD_FIS_RX = 16,
	PORT_CMD_CLO = 8,
	PORT_CMD_POWER_ON = 4,
	PORT_CMD_SPIN_UP = 2,
	PORT_CMD_START = 1,
	PORT_CMD_ICC_MASK = 4026531840,
	PORT_CMD_ICC_ACTIVE = 268435456,
	PORT_CMD_ICC_PARTIAL = 536870912,
	PORT_CMD_ICC_SLUMBER = 1610612736,
	PORT_CMD_CAP = 8126464,
	PORT_FBS_DWE_OFFSET = 16,
	PORT_FBS_ADO_OFFSET = 12,
	PORT_FBS_DEV_OFFSET = 8,
	PORT_FBS_DEV_MASK = 3840,
	PORT_FBS_SDE = 4,
	PORT_FBS_DEC = 2,
	PORT_FBS_EN = 1,
	PORT_DEVSLP_DM_OFFSET = 25,
	PORT_DEVSLP_DM_MASK = 503316480,
	PORT_DEVSLP_DITO_OFFSET = 15,
	PORT_DEVSLP_MDAT_OFFSET = 10,
	PORT_DEVSLP_DETO_OFFSET = 2,
	PORT_DEVSLP_DSP = 2,
	PORT_DEVSLP_ADSE = 1,
	AHCI_HFLAG_NO_NCQ = 1,
	AHCI_HFLAG_IGN_IRQ_IF_ERR = 2,
	AHCI_HFLAG_IGN_SERR_INTERNAL = 4,
	AHCI_HFLAG_32BIT_ONLY = 8,
	AHCI_HFLAG_MV_PATA = 16,
	AHCI_HFLAG_NO_MSI = 32,
	AHCI_HFLAG_NO_PMP = 64,
	AHCI_HFLAG_SECT255 = 256,
	AHCI_HFLAG_YES_NCQ = 512,
	AHCI_HFLAG_NO_SUSPEND = 1024,
	AHCI_HFLAG_SRST_TOUT_IS_OFFLINE = 2048,
	AHCI_HFLAG_NO_SNTF = 4096,
	AHCI_HFLAG_NO_FPDMA_AA = 8192,
	AHCI_HFLAG_YES_FBS = 16384,
	AHCI_HFLAG_DELAY_ENGINE = 32768,
	AHCI_HFLAG_NO_DEVSLP = 131072,
	AHCI_HFLAG_NO_FBS = 262144,
	AHCI_HFLAG_MULTI_MSI = 1048576,
	AHCI_HFLAG_WAKE_BEFORE_STOP = 4194304,
	AHCI_HFLAG_YES_ALPM = 8388608,
	AHCI_HFLAG_NO_WRITE_TO_RO = 16777216,
	AHCI_HFLAG_USE_LPM_POLICY = 33554432,
	AHCI_HFLAG_SUSPEND_PHYS = 67108864,
	AHCI_HFLAG_NO_SXS = 268435456,
	AHCI_FLAG_COMMON = 393346,
	ICH_MAP = 144,
	PCS_6 = 146,
	PCS_7 = 148,
	EM_MAX_SLOTS = 15,
	EM_MAX_RETRY = 5,
	EM_CTL_RST = 512,
	EM_CTL_TM = 256,
	EM_CTL_MR = 1,
	EM_CTL_ALHD = 67108864,
	EM_CTL_XMT = 33554432,
	EM_CTL_SMB = 16777216,
	EM_CTL_SGPIO = 524288,
	EM_CTL_SES = 262144,
	EM_CTL_SAFTE = 131072,
	EM_CTL_LED = 65536,
	EM_MSG_TYPE_LED = 1,
	EM_MSG_TYPE_SAFTE = 2,
	EM_MSG_TYPE_SES2 = 4,
	EM_MSG_TYPE_SGPIO = 8,
};

struct ata_timing {
	short unsigned int mode;
	short unsigned int setup;
	short unsigned int act8b;
	short unsigned int rec8b;
	short unsigned int cyc8b;
	short unsigned int active;
	short unsigned int recover;
	short unsigned int dmack_hold;
	short unsigned int cycle;
	short unsigned int udma;
};

struct ahci_host_priv {
	unsigned int flags;
	u32 mask_port_map;
	void *mmio;
	u32 cap;
	u32 cap2;
	u32 version;
	u32 port_map;
	u32 saved_cap;
	u32 saved_cap2;
	u32 saved_port_map;
	u32 saved_port_cap[32];
	u32 em_loc;
	u32 em_buf_sz;
	u32 em_msg_type;
	u32 remapped_nvme;
	bool got_runtime_pm;
	unsigned int n_clks;
	struct clk_bulk_data *clks;
	unsigned int f_rsts;
	struct reset_control *rsts;
	struct regulator **target_pwrs;
	struct regulator *ahci_regulator;
	struct regulator *phy_regulator;
	struct phy **phys;
	unsigned int nports;
	void *plat_data;
	unsigned int irq;
	void (*start_engine)(struct ata_port *);
	int (*stop_engine)(struct ata_port *);
	irqreturn_t (*irq_handler)(int, void *);
	int (*get_irq_vector)(struct ata_host *, int);
};

struct ahci_cmd_hdr {
	__le32 opts;
	__le32 status;
	__le32 tbl_addr;
	__le32 tbl_addr_hi;
	__le32 reserved[4];
};

struct ahci_sg {
	__le32 addr;
	__le32 addr_hi;
	__le32 reserved;
	__le32 flags_size;
};

struct ahci_em_priv {
	enum sw_activity blink_policy;
	struct timer_list timer;
	long unsigned int saved_activity;
	long unsigned int activity;
	long unsigned int led_state;
	struct ata_link *link;
};

struct ahci_port_priv {
	struct ata_link *active_link;
	struct ahci_cmd_hdr *cmd_slot;
	dma_addr_t cmd_slot_dma;
	void *cmd_tbl;
	dma_addr_t cmd_tbl_dma;
	void *rx_fis;
	dma_addr_t rx_fis_dma;
	unsigned int ncq_saw_d2h: 1;
	unsigned int ncq_saw_dmas: 1;
	unsigned int ncq_saw_sdb: 1;
	spinlock_t lock;
	u32 intr_mask;
	bool fbs_supported;
	bool fbs_enabled;
	int fbs_last_dev;
	struct ahci_em_priv em_priv[15];
	char *irq_desc;
};

struct sensor_device_attribute {
	struct device_attribute dev_attr;
	int index;
};

enum thermal_device_mode {
	THERMAL_DEVICE_DISABLED = 0,
	THERMAL_DEVICE_ENABLED = 1,
};

enum thermal_trip_type {
	THERMAL_TRIP_ACTIVE = 0,
	THERMAL_TRIP_PASSIVE = 1,
	THERMAL_TRIP_HOT = 2,
	THERMAL_TRIP_CRITICAL = 3,
};

enum thermal_trend {
	THERMAL_TREND_STABLE = 0,
	THERMAL_TREND_RAISING = 1,
	THERMAL_TREND_DROPPING = 2,
};

enum thermal_notify_event {
	THERMAL_EVENT_UNSPECIFIED = 0,
	THERMAL_EVENT_TEMP_SAMPLE = 1,
	THERMAL_TRIP_VIOLATED = 2,
	THERMAL_TRIP_CHANGED = 3,
	THERMAL_DEVICE_DOWN = 4,
	THERMAL_DEVICE_UP = 5,
	THERMAL_DEVICE_POWER_CAPABILITY_CHANGED = 6,
	THERMAL_TABLE_CHANGED = 7,
	THERMAL_EVENT_KEEP_ALIVE = 8,
};

struct thermal_zone_device;

struct thermal_zone_device_ops {
	int (*bind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*unbind)(struct thermal_zone_device *, struct thermal_cooling_device *);
	int (*get_temp)(struct thermal_zone_device *, int *);
	int (*set_trips)(struct thermal_zone_device *, int, int);
	int (*change_mode)(struct thermal_zone_device *, enum thermal_device_mode);
	int (*get_trip_type)(struct thermal_zone_device *, int, enum thermal_trip_type *);
	int (*get_trip_temp)(struct thermal_zone_device *, int, int *);
	int (*set_trip_temp)(struct thermal_zone_device *, int, int);
	int (*get_trip_hyst)(struct thermal_zone_device *, int, int *);
	int (*set_trip_hyst)(struct thermal_zone_device *, int, int);
	int (*get_crit_temp)(struct thermal_zone_device *, int *);
	int (*set_emul_temp)(struct thermal_zone_device *, int);
	int (*get_trend)(struct thermal_zone_device *, int, enum thermal_trend *);
	void (*hot)(struct thermal_zone_device *);
	void (*critical)(struct thermal_zone_device *);
};

struct thermal_attr;

struct thermal_trip;

struct thermal_zone_params;

struct thermal_governor;

struct thermal_zone_device {
	int id;
	char type[20];
	struct device device;
	struct attribute_group trips_attribute_group;
	struct thermal_attr *trip_temp_attrs;
	struct thermal_attr *trip_type_attrs;
	struct thermal_attr *trip_hyst_attrs;
	enum thermal_device_mode mode;
	void *devdata;
	struct thermal_trip *trips;
	int num_trips;
	long unsigned int trips_disabled;
	long unsigned int passive_delay_jiffies;
	long unsigned int polling_delay_jiffies;
	int temperature;
	int last_temperature;
	int emul_temperature;
	int passive;
	int prev_low_trip;
	int prev_high_trip;
	atomic_t need_update;
	struct thermal_zone_device_ops *ops;
	struct thermal_zone_params *tzp;
	struct thermal_governor *governor;
	void *governor_data;
	struct list_head thermal_instances;
	struct ida ida;
	struct mutex lock;
	struct list_head node;
	struct delayed_work poll_queue;
	enum thermal_notify_event notify_event;
};

struct thermal_cooling_device_ops;

struct thermal_cooling_device {
	int id;
	char *type;
	struct device device;
	struct device_node *np;
	void *devdata;
	void *stats;
	const struct thermal_cooling_device_ops *ops;
	bool updated;
	struct mutex lock;
	struct list_head thermal_instances;
	struct list_head node;
};

struct thermal_trip {
	int temperature;
	int hysteresis;
	enum thermal_trip_type type;
};

struct thermal_cooling_device_ops {
	int (*get_max_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*get_cur_state)(struct thermal_cooling_device *, long unsigned int *);
	int (*set_cur_state)(struct thermal_cooling_device *, long unsigned int);
	int (*get_requested_power)(struct thermal_cooling_device *, u32 *);
	int (*state2power)(struct thermal_cooling_device *, long unsigned int, u32 *);
	int (*power2state)(struct thermal_cooling_device *, u32, long unsigned int *);
};

struct thermal_bind_params;

struct thermal_zone_params {
	char governor_name[20];
	bool no_hwmon;
	int num_tbps;
	struct thermal_bind_params *tbp;
	u32 sustainable_power;
	s32 k_po;
	s32 k_pu;
	s32 k_i;
	s32 k_d;
	s32 integral_cutoff;
	int slope;
	int offset;
};

struct thermal_governor {
	char name[20];
	int (*bind_to_tz)(struct thermal_zone_device *);
	void (*unbind_from_tz)(struct thermal_zone_device *);
	int (*throttle)(struct thermal_zone_device *, int);
	struct list_head governor_list;
};

struct thermal_bind_params {
	struct thermal_cooling_device *cdev;
	int weight;
	int trip_mask;
	long unsigned int *binding_limits;
	int (*match)(struct thermal_zone_device *, struct thermal_cooling_device *);
};

enum {
	IMX_TIMER1MS = 224,
	IMX_P0PHYCR = 376,
	IMX_P0PHYCR_TEST_PDDQ = 1048576,
	IMX_P0PHYCR_CR_READ = 524288,
	IMX_P0PHYCR_CR_WRITE = 262144,
	IMX_P0PHYCR_CR_CAP_DATA = 131072,
	IMX_P0PHYCR_CR_CAP_ADDR = 65536,
	IMX_P0PHYSR = 380,
	IMX_P0PHYSR_CR_ACK = 262144,
	IMX_P0PHYSR_CR_DATA_OUT = 65535,
	IMX_LANE0_OUT_STAT = 8195,
	IMX_LANE0_OUT_STAT_RX_PLL_STATE = 2,
	IMX_CLOCK_RESET = 32575,
	IMX_CLOCK_RESET_RESET = 1,
	IMX8QM_SATA_PHY_REG03_RX_IMPED_RATIO = 3,
	IMX8QM_SATA_PHY_REG09_TX_IMPED_RATIO = 9,
	IMX8QM_SATA_PHY_REG10_TX_POST_CURSOR_RATIO = 10,
	IMX8QM_SATA_PHY_GEN1_TX_POST_CURSOR_RATIO = 21,
	IMX8QM_SATA_PHY_IMPED_RATIO_100OHM = 93,
	IMX8QM_SATA_PHY_REG22_TX_POST_CURSOR_RATIO = 22,
	IMX8QM_SATA_PHY_GEN2_TX_POST_CURSOR_RATIO = 0,
	IMX8QM_SATA_PHY_REG24_TX_AMP_RATIO_MARGIN0 = 24,
	IMX8QM_SATA_PHY_TX_AMP_RATIO_MARGIN0 = 100,
	IMX8QM_SATA_PHY_REG25_TX_AMP_RATIO_MARGIN1 = 25,
	IMX8QM_SATA_PHY_TX_AMP_RATIO_MARGIN1 = 112,
	IMX8QM_SATA_PHY_REG26_TX_AMP_RATIO_MARGIN2 = 26,
	IMX8QM_SATA_PHY_TX_AMP_RATIO_MARGIN2 = 105,
	IMX8QM_SATA_PHY_REG48_PMA_STATUS = 48,
	IMX8QM_SATA_PHY_REG48_PMA_RDY = 128,
	IMX8QM_SATA_PHY_REG128_UPDATE_SETTING = 128,
	IMX8QM_SATA_PHY_UPDATE_SETTING = 1,
	IMX8QM_LPCG_PHYX2_OFFSET = 0,
	IMX8QM_CSR_PHYX2_OFFSET = 589824,
	IMX8QM_CSR_PHYX1_OFFSET = 655360,
	IMX8QM_CSR_PHYX_STTS0_OFFSET = 4,
	IMX8QM_CSR_PCIEA_OFFSET = 720896,
	IMX8QM_CSR_PCIEB_OFFSET = 786432,
	IMX8QM_CSR_SATA_OFFSET = 851968,
	IMX8QM_CSR_PCIE_CTRL2_OFFSET = 8,
	IMX8QM_CSR_MISC_OFFSET = 917504,
	IMX8QM_SATA_PPCFG_OFFSET = 168,
	IMX8QM_SATA_PPCFG_FORCE_PHY_RDY = 1048576,
	IMX8QM_SATA_PPCFG_BIST_PATTERN_MASK = 14680064,
	IMX8QM_SATA_PPCFG_BIST_PATTERN_OFFSET = 21,
	IMX8QM_SATA_PPCFG_BIST_PATTERN_EN = 16777216,
	IMX8QM_SATA_PPCFG_BIST_PATTERN_NOALIGNS = 67108864,
	IMX8QM_SATA_PP2CFG_OFFSET = 172,
	IMX8QM_SATA_PP2CFG_COMINIT_NEGATE_MIN = 671088640,
	IMX8QM_SATA_PP2CFG_COMINT_BURST_GAP = 1572864,
	IMX8QM_SATA_PP2CFG_COMINT_BURST_GAP_MAX = 11008,
	IMX8QM_SATA_PP2CFG_COMINT_BURST_GAP_MIN = 27,
	IMX8QM_SATA_PP3CFG_OFFSET = 176,
	IMX8QM_SATA_PP3CFG_COMWAKE_NEGATE_MIN = 234881024,
	IMX8QM_SATA_PP3CFG_COMWAKE_BURST_GAP = 524288,
	IMX8QM_SATA_PP3CFG_COMWAKE_BURST_GAP_MAX = 3840,
	IMX8QM_SATA_PP3CFG_COMWAKE_BURST_GAP_MIN = 1,
	IMX8QM_SATA_AHCI_VEND_PTC = 200,
	IMX8QM_SATA_AHCI_VEND_PTC_RXWM_MASK = 127,
	IMX8QM_SATA_AHCI_VEND_PTC_RXWM = 41,
	IMX8QM_LPCG_PHYX2_PCLK0_MASK = 196608,
	IMX8QM_LPCG_PHYX2_PCLK1_MASK = 3145728,
	IMX8QM_PHY_APB_RSTN_0 = 1,
	IMX8QM_PHY_APB_RSTN_1 = 2,
	IMX8QM_PHY_MODE_SATA = 524288,
	IMX8QM_PHY_MODE_MASK = 1966080,
	IMX8QM_PHY_PIPE_RSTN_0 = 16777216,
	IMX8QM_PHY_PIPE_RSTN_OVERRIDE_0 = 33554432,
	IMX8QM_PHY_PIPE_RSTN_1 = 67108864,
	IMX8QM_PHY_PIPE_RSTN_OVERRIDE_1 = 134217728,
	IMX8QM_STTS0_LANE0_TX_PLL_LOCK = 16,
	IMX8QM_MISC_IOB_RXENA = 1,
	IMX8QM_MISC_IOB_TXENA = 2,
	IMX8QM_MISC_PHYX1_EPCS_SEL = 4096,
	IMX8QM_MISC_CLKREQN_OUT_OVERRIDE_1 = 16777216,
	IMX8QM_MISC_CLKREQN_OUT_OVERRIDE_0 = 33554432,
	IMX8QM_MISC_CLKREQN_IN_OVERRIDE_1 = 268435456,
	IMX8QM_MISC_CLKREQN_IN_OVERRIDE_0 = 536870912,
	IMX8QM_SATA_CTRL_RESET_N = 4096,
	IMX8QM_SATA_CTRL_EPCS_PHYRESET_N = 128,
	IMX8QM_SATA_CTRL_EPCS_TXDEEMP_SEL = 64,
	IMX8QM_SATA_CTRL_EPCS_TXDEEMP = 32,
	IMX8QM_CTRL_BUTTON_RST_N = 2097152,
	IMX8QM_CTRL_PERST_N = 4194304,
	IMX8QM_CTRL_POWER_UP_RST_N = 8388608,
	IMX8QM_CTRL_LTSSM_ENABLE = 16,
};

enum ahci_imx_type {
	AHCI_IMX53 = 0,
	AHCI_IMX6Q = 1,
	AHCI_IMX6QP = 2,
	AHCI_IMX8QM = 3,
};

struct imx_ahci_priv {
	struct platform_device *ahci_pdev;
	enum ahci_imx_type type;
	struct clk *sata_clk;
	struct clk *sata_ref_clk;
	struct clk *ahb_clk;
	struct clk *epcs_tx_clk;
	struct clk *epcs_rx_clk;
	struct clk *phy_apbclk;
	struct clk *phy_pclk0;
	struct clk *phy_pclk1;
	struct clk *per_clk0;
	struct clk *per_clk1;
	struct clk *per_clk2;
	struct clk *per_clk3;
	struct clk *per_clk4;
	struct clk *per_clk5;
	void *phy_base;
	struct gpio_desc *clkreq_gpiod;
	struct regmap *gpr;
	bool no_device;
	bool first_time;
	u32 phy_params;
	u32 imped_ratio;
	u32 ext_osc;
};

enum {
	SATA_PHY_CR_CLOCK_CRCMP_LT_LIMIT = 1,
	SATA_PHY_CR_CLOCK_DAC_CTL = 8,
	SATA_PHY_CR_CLOCK_RTUNE_CTL = 9,
	SATA_PHY_CR_CLOCK_ADC_OUT = 10,
	SATA_PHY_CR_CLOCK_MPLL_TST = 23,
};

struct reg_value {
	u32 of_value;
	u32 reg_value;
};

struct reg_property {
	const char *name;
	const struct reg_value *values;
	size_t num_values;
	u32 def_value;
	u32 set_value;
};

struct pata_imx_priv {
	struct clk *clk;
	void *host_regs;
	u32 ata_ctl;
};

struct mtd_notifier {
	void (*add)(struct mtd_info *);
	void (*remove)(struct mtd_info *);
	struct list_head list;
};

struct mtd_partition {
	const char *name;
	const char * const *types;
	uint64_t size;
	uint64_t offset;
	uint32_t mask_flags;
	uint32_t add_flags;
	struct device_node *of_node;
	int: 32;
};

struct mtd_part_parser_data {
	long unsigned int origin;
};

struct mtd_concat {
	struct mtd_info mtd;
	int num_subdev;
	struct mtd_info **subdev;
};

struct mtd_part_parser {
	struct list_head list;
	struct module *owner;
	const char *name;
	const struct of_device_id *of_match_table;
	int (*parse_fn)(struct mtd_info *, const struct mtd_partition **, struct mtd_part_parser_data *);
	void (*cleanup)(const struct mtd_partition *, int);
};

struct mtd_partitions {
	const struct mtd_partition *parts;
	int nr_parts;
	const struct mtd_part_parser *parser;
};

typedef long unsigned int u_long;

struct erase_info_user {
	__u32 start;
	__u32 length;
};

struct erase_info_user64 {
	__u64 start;
	__u64 length;
};

struct mtd_oob_buf {
	__u32 start;
	__u32 length;
	unsigned char *ptr;
};

struct mtd_oob_buf64 {
	__u64 start;
	__u32 pad;
	__u32 length;
	__u64 usr_ptr;
};

struct mtd_write_req {
	__u64 start;
	__u64 len;
	__u64 ooblen;
	__u64 usr_data;
	__u64 usr_oob;
	__u8 mode;
	__u8 padding[7];
};

struct mtd_read_req_ecc_stats {
	__u32 uncorrectable_errors;
	__u32 corrected_bitflips;
	__u32 max_bitflips;
};

struct mtd_read_req {
	__u64 start;
	__u64 len;
	__u64 ooblen;
	__u64 usr_data;
	__u64 usr_oob;
	__u8 mode;
	__u8 padding[7];
	struct mtd_read_req_ecc_stats ecc_stats;
	int: 32;
};

struct mtd_info_user {
	__u8 type;
	__u32 flags;
	__u32 size;
	__u32 erasesize;
	__u32 writesize;
	__u32 oobsize;
	__u64 padding;
};

struct region_info_user {
	__u32 offset;
	__u32 erasesize;
	__u32 numblocks;
	__u32 regionindex;
};

struct nand_oobinfo {
	__u32 useecc;
	__u32 eccbytes;
	__u32 oobfree[16];
	__u32 eccpos[32];
};

struct nand_oobfree {
	__u32 offset;
	__u32 length;
};

struct nand_ecclayout_user {
	__u32 eccbytes;
	__u32 eccpos[64];
	__u32 oobavail;
	struct nand_oobfree oobfree[8];
};

enum mtd_file_modes {
	MTD_FILE_MODE_NORMAL = 0,
	MTD_FILE_MODE_OTP_FACTORY = 1,
	MTD_FILE_MODE_OTP_USER = 2,
	MTD_FILE_MODE_RAW = 3,
};

struct mtd_chip_driver;

struct map_info___2 {
	const char *name;
	long unsigned int size;
	resource_size_t phys;
	void *virt;
	void *cached;
	int swap;
	int bankwidth;
	void (*inval_cache)(struct map_info___2 *, long unsigned int, ssize_t);
	void (*set_vpp)(struct map_info___2 *, int);
	long unsigned int pfow_base;
	long unsigned int map_priv_1;
	long unsigned int map_priv_2;
	struct device_node *device_node;
	void *fldrv_priv;
	struct mtd_chip_driver *fldrv;
};

struct mtd_chip_driver {
	struct mtd_info * (*probe)(struct map_info___2 *);
	void (*destroy)(struct mtd_info *);
	struct module *module;
	char *name;
	struct list_head list;
};

struct mtd_file_info {
	struct mtd_info *mtd;
	enum mtd_file_modes mode;
};

struct cmdline_mtd_partition {
	struct cmdline_mtd_partition *next;
	char *mtd_id;
	int num_parts;
	struct mtd_partition *parts;
};

struct fixed_partitions_quirks {
	int (*post_parse)(struct mtd_info *, struct mtd_partition *, int);
};

struct mtd_blktrans_ops;

struct mtd_blktrans_dev {
	struct mtd_blktrans_ops *tr;
	struct list_head list;
	struct mtd_info *mtd;
	struct mutex lock;
	int devnum;
	bool bg_stop;
	long unsigned int size;
	int readonly;
	int open;
	struct kref ref;
	struct gendisk *disk;
	struct attribute_group *disk_attributes;
	struct request_queue *rq;
	struct list_head rq_list;
	struct blk_mq_tag_set *tag_set;
	spinlock_t queue_lock;
	void *priv;
	fmode_t file_mode;
};

struct mtd_blktrans_ops {
	char *name;
	int major;
	int part_bits;
	int blksize;
	int blkshift;
	int (*readsect)(struct mtd_blktrans_dev *, long unsigned int, char *);
	int (*writesect)(struct mtd_blktrans_dev *, long unsigned int, char *);
	int (*discard)(struct mtd_blktrans_dev *, long unsigned int, unsigned int);
	void (*background)(struct mtd_blktrans_dev *);
	int (*getgeo)(struct mtd_blktrans_dev *, struct hd_geometry *);
	int (*flush)(struct mtd_blktrans_dev *);
	int (*open)(struct mtd_blktrans_dev *);
	void (*release)(struct mtd_blktrans_dev *);
	void (*add_mtd)(struct mtd_blktrans_ops *, struct mtd_info *);
	void (*remove_dev)(struct mtd_blktrans_dev *);
	struct list_head devs;
	struct list_head list;
	struct module *owner;
};

struct mtdblk_dev {
	struct mtd_blktrans_dev mbd;
	int count;
	struct mutex cache_mutex;
	unsigned char *cache_data;
	long unsigned int cache_offset;
	unsigned int cache_size;
	enum {
		STATE_EMPTY = 0,
		STATE_CLEAN = 1,
		STATE_DIRTY = 2,
	} cache_state;
};

typedef union {
	long unsigned int x[1];
} map_word;

typedef enum {
	FL_READY = 0,
	FL_STATUS = 1,
	FL_CFI_QUERY = 2,
	FL_JEDEC_QUERY = 3,
	FL_ERASING = 4,
	FL_ERASE_SUSPENDING = 5,
	FL_ERASE_SUSPENDED = 6,
	FL_WRITING = 7,
	FL_WRITING_TO_BUFFER = 8,
	FL_OTP_WRITE = 9,
	FL_WRITE_SUSPENDING = 10,
	FL_WRITE_SUSPENDED = 11,
	FL_PM_SUSPENDED = 12,
	FL_SYNCING = 13,
	FL_UNLOADING = 14,
	FL_LOCKING = 15,
	FL_UNLOCKING = 16,
	FL_POINT = 17,
	FL_XIP_WHILE_ERASING = 18,
	FL_XIP_WHILE_WRITING = 19,
	FL_SHUTDOWN = 20,
	FL_READING = 21,
	FL_CACHEDPRG = 22,
	FL_RESETTING = 23,
	FL_OTPING = 24,
	FL_PREPARING_ERASE = 25,
	FL_VERIFYING_ERASE = 26,
	FL_UNKNOWN = 27,
} flstate_t;

struct flchip {
	long unsigned int start;
	int ref_point_counter;
	flstate_t state;
	flstate_t oldstate;
	unsigned int write_suspended: 1;
	unsigned int erase_suspended: 1;
	long unsigned int in_progress_block_addr;
	long unsigned int in_progress_block_mask;
	struct mutex mutex;
	wait_queue_head_t wq;
	int word_write_time;
	int buffer_write_time;
	int erase_time;
	int word_write_time_max;
	int buffer_write_time_max;
	int erase_time_max;
	void *priv;
};

struct cfi_ident {
	uint8_t qry[3];
	uint16_t P_ID;
	uint16_t P_ADR;
	uint16_t A_ID;
	uint16_t A_ADR;
	uint8_t VccMin;
	uint8_t VccMax;
	uint8_t VppMin;
	uint8_t VppMax;
	uint8_t WordWriteTimeoutTyp;
	uint8_t BufWriteTimeoutTyp;
	uint8_t BlockEraseTimeoutTyp;
	uint8_t ChipEraseTimeoutTyp;
	uint8_t WordWriteTimeoutMax;
	uint8_t BufWriteTimeoutMax;
	uint8_t BlockEraseTimeoutMax;
	uint8_t ChipEraseTimeoutMax;
	uint8_t DevSize;
	uint16_t InterfaceDesc;
	uint16_t MaxBufWriteSize;
	uint8_t NumEraseRegions;
	uint32_t EraseRegionInfo[0];
} __attribute__((packed));

struct cfi_private {
	uint16_t cmdset;
	void *cmdset_priv;
	int interleave;
	int device_type;
	int cfi_mode;
	int addr_unlock1;
	int addr_unlock2;
	struct mtd_info * (*cmdset_setup)(struct map_info___2 *);
	struct cfi_ident *cfiq;
	int mfr;
	int id;
	int numchips;
	map_word sector_erase_cmd;
	long unsigned int chipshift;
	const char *im_name;
	long unsigned int quirks;
	struct flchip chips[0];
};

struct chip_probe {
	char *name;
	int (*probe_chip)(struct map_info___2 *, __u32, long unsigned int *, struct cfi_private *);
};

struct cfi_early_fixup {
	uint16_t mfr;
	uint16_t id;
	void (*fixup)(struct cfi_private *);
};

struct cfi_extquery {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
};

struct cfi_fixup {
	uint16_t mfr;
	uint16_t id;
	void (*fixup)(struct mtd_info *);
};

typedef int (*varsize_frob_t)(struct map_info___2 *, struct flchip *, long unsigned int, int, void *);

struct cfi_pri_intelext {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint32_t FeatureSupport;
	uint8_t SuspendCmdSupport;
	uint16_t BlkStatusRegMask;
	uint8_t VccOptimal;
	uint8_t VppOptimal;
	uint8_t NumProtectionFields;
	uint16_t ProtRegAddr;
	uint8_t FactProtRegSize;
	uint8_t UserProtRegSize;
	uint8_t extra[0];
} __attribute__((packed));

struct cfi_pri_amdstd {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint8_t SiliconRevision;
	uint8_t EraseSuspend;
	uint8_t BlkProt;
	uint8_t TmpBlkUnprotect;
	uint8_t BlkProtUnprot;
	uint8_t SimultaneousOps;
	uint8_t BurstMode;
	uint8_t PageMode;
	uint8_t VppMin;
	uint8_t VppMax;
	uint8_t TopBottom;
	uint8_t ProgramSuspend;
	uint8_t UnlockBypass;
	uint8_t SecureSiliconSector;
	uint8_t SoftwareFeatures;
};

struct cfi_pri_atmel {
	uint8_t pri[3];
	uint8_t MajorVersion;
	uint8_t MinorVersion;
	uint8_t Features;
	uint8_t BottomBoot;
	uint8_t BurstMode;
	uint8_t PageMode;
};

enum cfi_quirks {
	CFI_QUIRK_DQ_TRUE_DATA = 1,
};

enum fwh_lock_state {
	FWH_UNLOCKED = 0,
	FWH_DENY_WRITE = 1,
	FWH_IMMUTABLE = 2,
	FWH_DENY_READ = 4,
};

struct fwh_xxlock_thunk {
	enum fwh_lock_state val;
	flstate_t state;
};

typedef int (*otp_op_t)(struct map_info___2 *, struct flchip *, loff_t, size_t, u_char *, size_t);

struct ppb_lock {
	struct flchip *chip;
	long unsigned int adr;
	int locked;
};

struct flchip_shared {
	struct mutex lock;
	struct flchip *writing;
	struct flchip *erasing;
};

struct cfi_intelext_blockinfo {
	uint16_t NumIdentBlocks;
	uint16_t BlockSize;
	uint16_t MinBlockEraseCycles;
	uint8_t BitsPerCell;
	uint8_t BlockCap;
};

struct cfi_intelext_regioninfo {
	uint16_t NumIdentPartitions;
	uint8_t NumOpAllowed;
	uint8_t NumOpAllowedSimProgMode;
	uint8_t NumOpAllowedSimEraMode;
	uint8_t NumBlockTypes;
	struct cfi_intelext_blockinfo BlockTypes[1];
};

struct cfi_intelext_programming_regioninfo {
	uint8_t ProgRegShift;
	uint8_t Reserved1;
	uint8_t ControlValid;
	uint8_t Reserved2;
	uint8_t ControlInvalid;
	uint8_t Reserved3;
};

typedef struct mtd_info *cfi_cmdset_fn_t(struct map_info___2 *, int);

enum uaddr {
	MTD_UADDR_NOT_SUPPORTED = 0,
	MTD_UADDR_0x0555_0x02AA = 1,
	MTD_UADDR_0x0555_0x0AAA = 2,
	MTD_UADDR_0x5555_0x2AAA = 3,
	MTD_UADDR_0x0AAA_0x0554 = 4,
	MTD_UADDR_0x0AAA_0x0555 = 5,
	MTD_UADDR_0xAAAA_0x5555 = 6,
	MTD_UADDR_DONT_CARE = 7,
	MTD_UADDR_UNNECESSARY = 8,
};

struct unlock_addr {
	uint32_t addr1;
	uint32_t addr2;
};

struct amd_flash_info {
	const char *name;
	const uint16_t mfr_id;
	const uint16_t dev_id;
	const uint8_t dev_size;
	const uint8_t nr_regions;
	const uint16_t cmd_set;
	const uint32_t regions[6];
	const uint8_t devtypes;
	const uint8_t uaddr;
};

struct physmap_flash_data {
	unsigned int width;
	int (*init)(struct platform_device *);
	void (*exit)(struct platform_device *);
	void (*set_vpp)(struct platform_device *, int);
	unsigned int nr_parts;
	unsigned int pfow_base;
	char *probe_type;
	struct mtd_partition *parts;
	const char * const *part_probe_types;
};

struct physmap_flash_info {
	unsigned int nmaps;
	struct mtd_info **mtds;
	struct mtd_info *cmtd;
	struct map_info___2 *maps;
	spinlock_t vpp_lock;
	int vpp_refcnt;
	const char *probe_type;
	const char * const *part_types;
	unsigned int nparts;
	const struct mtd_partition *parts;
	struct gpio_descs *gpios;
	unsigned int gpio_values;
	unsigned int win_order;
};

struct flash_platform_data {
	char *name;
	struct mtd_partition *parts;
	unsigned int nr_parts;
	char *type;
};

struct dataflash {
	u8 command[4];
	char name[24];
	short unsigned int page_offset;
	unsigned int page_size;
	struct mutex lock;
	struct spi_device *spi;
	int: 32;
	struct mtd_info mtd;
};

struct flash_info {
	char *name;
	int: 32;
	u64 jedec_id;
	unsigned int nr_pages;
	u16 pagesize;
	u16 pageoffset;
	u16 flags;
	int: 16;
	int: 32;
};

struct sst25l_flash {
	struct spi_device *spi;
	struct mutex lock;
	struct mtd_info mtd;
};

struct flash_info___2 {
	const char *name;
	uint16_t device_id;
	unsigned int page_size;
	unsigned int nr_pages;
	unsigned int erase_size;
};

struct nand_memory_organization {
	unsigned int bits_per_cell;
	unsigned int pagesize;
	unsigned int oobsize;
	unsigned int pages_per_eraseblock;
	unsigned int eraseblocks_per_lun;
	unsigned int max_bad_eraseblocks_per_lun;
	unsigned int planes_per_lun;
	unsigned int luns_per_target;
	unsigned int ntargets;
};

struct nand_row_converter {
	unsigned int lun_addr_shift;
	unsigned int eraseblock_addr_shift;
};

struct nand_pos {
	unsigned int target;
	unsigned int lun;
	unsigned int plane;
	unsigned int eraseblock;
	unsigned int page;
};

enum nand_page_io_req_type {
	NAND_PAGE_READ = 0,
	NAND_PAGE_WRITE = 1,
};

struct nand_page_io_req {
	enum nand_page_io_req_type type;
	struct nand_pos pos;
	unsigned int dataoffs;
	unsigned int datalen;
	union {
		const void *out;
		void *in;
	} databuf;
	unsigned int ooboffs;
	unsigned int ooblen;
	union {
		const void *out;
		void *in;
	} oobbuf;
	int mode;
};

enum nand_ecc_engine_type {
	NAND_ECC_ENGINE_TYPE_INVALID = 0,
	NAND_ECC_ENGINE_TYPE_NONE = 1,
	NAND_ECC_ENGINE_TYPE_SOFT = 2,
	NAND_ECC_ENGINE_TYPE_ON_HOST = 3,
	NAND_ECC_ENGINE_TYPE_ON_DIE = 4,
};

enum nand_ecc_placement {
	NAND_ECC_PLACEMENT_UNKNOWN = 0,
	NAND_ECC_PLACEMENT_OOB = 1,
	NAND_ECC_PLACEMENT_INTERLEAVED = 2,
};

enum nand_ecc_algo {
	NAND_ECC_ALGO_UNKNOWN = 0,
	NAND_ECC_ALGO_HAMMING = 1,
	NAND_ECC_ALGO_BCH = 2,
	NAND_ECC_ALGO_RS = 3,
};

struct nand_ecc_props {
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement placement;
	enum nand_ecc_algo algo;
	unsigned int strength;
	unsigned int step_size;
	unsigned int flags;
};

struct nand_bbt {
	long unsigned int *cache;
};

struct nand_device;

struct nand_ops {
	int (*erase)(struct nand_device *, const struct nand_pos *);
	int (*markbad)(struct nand_device *, const struct nand_pos *);
	bool (*isbad)(struct nand_device *, const struct nand_pos *);
};

struct nand_ecc_context {
	struct nand_ecc_props conf;
	unsigned int nsteps;
	unsigned int total;
	void *priv;
};

struct nand_ecc_engine;

struct nand_ecc {
	struct nand_ecc_props defaults;
	struct nand_ecc_props requirements;
	struct nand_ecc_props user_conf;
	struct nand_ecc_context ctx;
	struct nand_ecc_engine *ondie_engine;
	struct nand_ecc_engine *engine;
};

struct nand_device {
	struct mtd_info mtd;
	struct nand_memory_organization memorg;
	struct nand_ecc ecc;
	struct nand_row_converter rowconv;
	struct nand_bbt bbt;
	const struct nand_ops *ops;
};

struct nand_ecc_engine_ops {
	int (*init_ctx)(struct nand_device *);
	void (*cleanup_ctx)(struct nand_device *);
	int (*prepare_io_req)(struct nand_device *, struct nand_page_io_req *);
	int (*finish_io_req)(struct nand_device *, struct nand_page_io_req *);
};

enum nand_ecc_engine_integration {
	NAND_ECC_ENGINE_INTEGRATION_INVALID = 0,
	NAND_ECC_ENGINE_INTEGRATION_PIPELINED = 1,
	NAND_ECC_ENGINE_INTEGRATION_EXTERNAL = 2,
};

struct nand_ecc_engine {
	struct device *dev;
	struct list_head node;
	struct nand_ecc_engine_ops *ops;
	enum nand_ecc_engine_integration integration;
	void *priv;
};

enum nand_bbt_block_status {
	NAND_BBT_BLOCK_STATUS_UNKNOWN = 0,
	NAND_BBT_BLOCK_GOOD = 1,
	NAND_BBT_BLOCK_WORN = 2,
	NAND_BBT_BLOCK_RESERVED = 3,
	NAND_BBT_BLOCK_FACTORY_BAD = 4,
	NAND_BBT_BLOCK_NUM_STATUS = 5,
};

struct nand_ecc_req_tweak_ctx {
	struct nand_page_io_req orig_req;
	struct nand_device *nand;
	unsigned int page_buffer_size;
	unsigned int oob_buffer_size;
	void *spare_databuf;
	void *spare_oobbuf;
	bool bounce_data;
	bool bounce_oob;
};

struct nand_ecc_sw_hamming_conf {
	struct nand_ecc_req_tweak_ctx req_ctx;
	unsigned int code_size;
	u8 *calc_buf;
	u8 *code_buf;
	unsigned int sm_order;
};

struct nand_bbt_descr {
	int options;
	int pages[8];
	int offs;
	int veroffs;
	uint8_t version[8];
	int len;
	int maxblocks;
	int reserved_block_code;
	uint8_t *pattern;
};

struct nand_onfi_params {
	u8 sig[4];
	__le16 revision;
	__le16 features;
	__le16 opt_cmd;
	u8 reserved0[2];
	__le16 ext_param_page_length;
	u8 num_of_param_pages;
	u8 reserved1[17];
	char manufacturer[12];
	char model[20];
	u8 jedec_id;
	__le16 date_code;
	u8 reserved2[13];
	__le32 byte_per_page;
	__le16 spare_bytes_per_page;
	__le32 data_bytes_per_ppage;
	__le16 spare_bytes_per_ppage;
	__le32 pages_per_block;
	__le32 blocks_per_lun;
	u8 lun_count;
	u8 addr_cycles;
	u8 bits_per_cell;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 guaranteed_good_blocks;
	__le16 guaranteed_block_endurance;
	u8 programs_per_page;
	u8 ppage_attr;
	u8 ecc_bits;
	u8 interleaved_bits;
	u8 interleaved_ops;
	u8 reserved3[13];
	u8 io_pin_capacitance_max;
	__le16 sdr_timing_modes;
	__le16 program_cache_timing_mode;
	__le16 t_prog;
	__le16 t_bers;
	__le16 t_r;
	__le16 t_ccs;
	u8 nvddr_timing_modes;
	u8 nvddr2_timing_modes;
	u8 nvddr_nvddr2_features;
	__le16 clk_pin_capacitance_typ;
	__le16 io_pin_capacitance_typ;
	__le16 input_pin_capacitance_typ;
	u8 input_pin_capacitance_max;
	u8 driver_strength_support;
	__le16 t_int_r;
	__le16 t_adl;
	u8 reserved4[8];
	__le16 vendor_revision;
	u8 vendor[88];
	__le16 crc;
} __attribute__((packed));

struct onfi_params {
	int version;
	u16 tPROG;
	u16 tBERS;
	u16 tR;
	u16 tCCS;
	bool fast_tCAD;
	u16 sdr_timing_modes;
	u16 nvddr_timing_modes;
	u16 vendor_revision;
	u8 vendor[88];
};

struct nand_parameters {
	const char *model;
	bool supports_set_get_features;
	long unsigned int set_feature_list[8];
	long unsigned int get_feature_list[8];
	struct onfi_params *onfi;
};

struct nand_id {
	u8 data[8];
	int len;
};

struct nand_ecc_step_info {
	int stepsize;
	const int *strengths;
	int nstrengths;
};

struct nand_ecc_caps {
	const struct nand_ecc_step_info *stepinfos;
	int nstepinfos;
	int (*calc_ecc_bytes)(int, int);
};

struct nand_chip;

struct nand_ecc_ctrl {
	enum nand_ecc_engine_type engine_type;
	enum nand_ecc_placement placement;
	enum nand_ecc_algo algo;
	int steps;
	int size;
	int bytes;
	int total;
	int strength;
	int prepad;
	int postpad;
	unsigned int options;
	u8 *calc_buf;
	u8 *code_buf;
	void (*hwctl)(struct nand_chip *, int);
	int (*calculate)(struct nand_chip *, const uint8_t *, uint8_t *);
	int (*correct)(struct nand_chip *, uint8_t *, uint8_t *, uint8_t *);
	int (*read_page_raw)(struct nand_chip *, uint8_t *, int, int);
	int (*write_page_raw)(struct nand_chip *, const uint8_t *, int, int);
	int (*read_page)(struct nand_chip *, uint8_t *, int, int);
	int (*read_subpage)(struct nand_chip *, uint32_t, uint32_t, uint8_t *, int);
	int (*write_subpage)(struct nand_chip *, uint32_t, uint32_t, const uint8_t *, int, int);
	int (*write_page)(struct nand_chip *, const uint8_t *, int, int);
	int (*write_oob_raw)(struct nand_chip *, int);
	int (*read_oob_raw)(struct nand_chip *, int);
	int (*read_oob)(struct nand_chip *, int);
	int (*write_oob)(struct nand_chip *, int);
};

struct nand_manufacturer_desc;

struct nand_manufacturer {
	const struct nand_manufacturer_desc *desc;
	void *priv;
};

struct nand_interface_config;

struct nand_chip_ops {
	int (*suspend)(struct nand_chip *);
	void (*resume)(struct nand_chip *);
	int (*lock_area)(struct nand_chip *, loff_t, uint64_t);
	int (*unlock_area)(struct nand_chip *, loff_t, uint64_t);
	int (*setup_read_retry)(struct nand_chip *, int);
	int (*choose_interface_config)(struct nand_chip *, struct nand_interface_config *);
};

struct nand_controller_ops;

struct nand_controller {
	struct mutex lock;
	const struct nand_controller_ops *ops;
};

struct nand_legacy {
	void *IO_ADDR_R;
	void *IO_ADDR_W;
	void (*select_chip)(struct nand_chip *, int);
	u8 (*read_byte)(struct nand_chip *);
	void (*write_byte)(struct nand_chip *, u8);
	void (*write_buf)(struct nand_chip *, const u8 *, int);
	void (*read_buf)(struct nand_chip *, u8 *, int);
	void (*cmd_ctrl)(struct nand_chip *, int, unsigned int);
	void (*cmdfunc)(struct nand_chip *, unsigned int, int, int);
	int (*dev_ready)(struct nand_chip *);
	int (*waitfunc)(struct nand_chip *);
	int (*block_bad)(struct nand_chip *, loff_t);
	int (*block_markbad)(struct nand_chip *, loff_t);
	int (*set_features)(struct nand_chip *, int, u8 *);
	int (*get_features)(struct nand_chip *, int, u8 *);
	int chip_delay;
	struct nand_controller dummy_controller;
};

struct nand_secure_region;

struct nand_chip {
	struct nand_device base;
	struct nand_id id;
	struct nand_parameters parameters;
	struct nand_manufacturer manufacturer;
	struct nand_chip_ops ops;
	struct nand_legacy legacy;
	unsigned int options;
	const struct nand_interface_config *current_interface_config;
	struct nand_interface_config *best_interface_config;
	unsigned int bbt_erase_shift;
	unsigned int bbt_options;
	unsigned int badblockpos;
	unsigned int badblockbits;
	struct nand_bbt_descr *bbt_td;
	struct nand_bbt_descr *bbt_md;
	struct nand_bbt_descr *badblock_pattern;
	u8 *bbt;
	unsigned int page_shift;
	unsigned int phys_erase_shift;
	unsigned int chip_shift;
	unsigned int pagemask;
	unsigned int subpagesize;
	u8 *data_buf;
	u8 *oob_poi;
	struct {
		unsigned int bitflips;
		int page;
	} pagecache;
	long unsigned int buf_align;
	struct mutex lock;
	unsigned int suspended: 1;
	wait_queue_head_t resume_wq;
	int cur_cs;
	int read_retries;
	struct nand_secure_region *secure_regions;
	u8 nr_secure_regions;
	struct nand_controller *controller;
	struct nand_ecc_ctrl ecc;
	void *priv;
};

struct nand_sdr_timings {
	u64 tBERS_max;
	u32 tCCS_min;
	int: 32;
	u64 tPROG_max;
	u64 tR_max;
	u32 tALH_min;
	u32 tADL_min;
	u32 tALS_min;
	u32 tAR_min;
	u32 tCEA_max;
	u32 tCEH_min;
	u32 tCH_min;
	u32 tCHZ_max;
	u32 tCLH_min;
	u32 tCLR_min;
	u32 tCLS_min;
	u32 tCOH_min;
	u32 tCS_min;
	u32 tDH_min;
	u32 tDS_min;
	u32 tFEAT_max;
	u32 tIR_min;
	u32 tITC_max;
	u32 tRC_min;
	u32 tREA_max;
	u32 tREH_min;
	u32 tRHOH_min;
	u32 tRHW_min;
	u32 tRHZ_max;
	u32 tRLOH_min;
	u32 tRP_min;
	u32 tRR_min;
	int: 32;
	u64 tRST_max;
	u32 tWB_max;
	u32 tWC_min;
	u32 tWH_min;
	u32 tWHR_min;
	u32 tWP_min;
	u32 tWW_min;
};

struct nand_nvddr_timings {
	u64 tBERS_max;
	u32 tCCS_min;
	int: 32;
	u64 tPROG_max;
	u64 tR_max;
	u32 tAC_min;
	u32 tAC_max;
	u32 tADL_min;
	u32 tCAD_min;
	u32 tCAH_min;
	u32 tCALH_min;
	u32 tCALS_min;
	u32 tCAS_min;
	u32 tCEH_min;
	u32 tCH_min;
	u32 tCK_min;
	u32 tCS_min;
	u32 tDH_min;
	u32 tDQSCK_min;
	u32 tDQSCK_max;
	u32 tDQSD_min;
	u32 tDQSD_max;
	u32 tDQSHZ_max;
	u32 tDQSQ_max;
	u32 tDS_min;
	u32 tDSC_min;
	u32 tFEAT_max;
	u32 tITC_max;
	u32 tQHS_max;
	u32 tRHW_min;
	u32 tRR_min;
	u32 tRST_max;
	u32 tWB_max;
	u32 tWHR_min;
	u32 tWRCK_min;
	u32 tWW_min;
	int: 32;
};

enum nand_interface_type {
	NAND_SDR_IFACE = 0,
	NAND_NVDDR_IFACE = 1,
};

struct nand_timings {
	unsigned int mode;
	int: 32;
	union {
		struct nand_sdr_timings sdr;
		struct nand_nvddr_timings nvddr;
	};
};

struct nand_interface_config {
	enum nand_interface_type type;
	int: 32;
	struct nand_timings timings;
};

struct nand_op_cmd_instr {
	u8 opcode;
};

struct nand_op_addr_instr {
	unsigned int naddrs;
	const u8 *addrs;
};

struct nand_op_data_instr {
	unsigned int len;
	union {
		void *in;
		const void *out;
	} buf;
	bool force_8bit;
};

struct nand_op_waitrdy_instr {
	unsigned int timeout_ms;
};

enum nand_op_instr_type {
	NAND_OP_CMD_INSTR = 0,
	NAND_OP_ADDR_INSTR = 1,
	NAND_OP_DATA_IN_INSTR = 2,
	NAND_OP_DATA_OUT_INSTR = 3,
	NAND_OP_WAITRDY_INSTR = 4,
};

struct nand_op_instr {
	enum nand_op_instr_type type;
	union {
		struct nand_op_cmd_instr cmd;
		struct nand_op_addr_instr addr;
		struct nand_op_data_instr data;
		struct nand_op_waitrdy_instr waitrdy;
	} ctx;
	unsigned int delay_ns;
};

struct nand_subop {
	unsigned int cs;
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
	unsigned int first_instr_start_off;
	unsigned int last_instr_end_off;
};

struct nand_op_parser_addr_constraints {
	unsigned int maxcycles;
};

struct nand_op_parser_data_constraints {
	unsigned int maxlen;
};

struct nand_op_parser_pattern_elem {
	enum nand_op_instr_type type;
	bool optional;
	union {
		struct nand_op_parser_addr_constraints addr;
		struct nand_op_parser_data_constraints data;
	} ctx;
};

struct nand_op_parser_pattern {
	const struct nand_op_parser_pattern_elem *elems;
	unsigned int nelems;
	int (*exec)(struct nand_chip *, const struct nand_subop *);
};

struct nand_op_parser {
	const struct nand_op_parser_pattern *patterns;
	unsigned int npatterns;
};

struct nand_operation {
	unsigned int cs;
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
};

struct nand_controller_ops {
	int (*attach_chip)(struct nand_chip *);
	void (*detach_chip)(struct nand_chip *);
	int (*exec_op)(struct nand_chip *, const struct nand_operation *, bool);
	int (*setup_interface)(struct nand_chip *, int, const struct nand_interface_config *);
};

struct nand_manufacturer_ops;

struct nand_manufacturer_desc {
	int id;
	char *name;
	const struct nand_manufacturer_ops *ops;
};

struct nand_secure_region {
	u64 offset;
	u64 size;
};

struct nand_flash_dev {
	char *name;
	union {
		struct {
			uint8_t mfr_id;
			uint8_t dev_id;
		};
		uint8_t id[8];
	};
	unsigned int pagesize;
	unsigned int chipsize;
	unsigned int erasesize;
	unsigned int options;
	uint16_t id_len;
	uint16_t oobsize;
	struct {
		uint16_t strength_ds;
		uint16_t step_ds;
	} ecc;
};

struct nand_manufacturer_ops {
	void (*detect)(struct nand_chip *);
	int (*init)(struct nand_chip *);
	void (*cleanup)(struct nand_chip *);
	void (*fixup_onfi_param_page)(struct nand_chip *, struct nand_onfi_params *);
};

struct nand_op_parser_ctx {
	const struct nand_op_instr *instrs;
	unsigned int ninstrs;
	struct nand_subop subop;
};

enum nand_ecc_legacy_mode {
	NAND_ECC_INVALID = 0,
	NAND_ECC_NONE = 1,
	NAND_ECC_SOFT = 2,
	NAND_ECC_SOFT_BCH = 3,
	NAND_ECC_HW = 4,
	NAND_ECC_HW_SYNDROME = 5,
	NAND_ECC_ON_DIE = 6,
};

typedef s8 int8_t;

struct onfi_ext_ecc_info {
	u8 ecc_bits;
	u8 codeword_size;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 reserved[2];
};

struct onfi_ext_section {
	u8 type;
	u8 length;
};

struct onfi_ext_param_page {
	__le16 crc;
	u8 sig[4];
	u8 reserved0[10];
	struct onfi_ext_section sections[8];
};

struct jedec_ecc_info {
	u8 ecc_bits;
	u8 codeword_size;
	__le16 bb_per_lun;
	__le16 block_endurance;
	u8 reserved[2];
};

struct nand_jedec_params {
	u8 sig[4];
	__le16 revision;
	__le16 features;
	u8 opt_cmd[3];
	__le16 sec_cmd;
	u8 num_of_param_pages;
	u8 reserved0[18];
	char manufacturer[12];
	char model[20];
	u8 jedec_id[6];
	u8 reserved1[10];
	__le32 byte_per_page;
	__le16 spare_bytes_per_page;
	u8 reserved2[6];
	__le32 pages_per_block;
	__le32 blocks_per_lun;
	u8 lun_count;
	u8 addr_cycles;
	u8 bits_per_cell;
	u8 programs_per_page;
	u8 multi_plane_addr;
	u8 multi_plane_op_attr;
	u8 reserved3[38];
	__le16 async_sdr_speed_grade;
	__le16 toggle_ddr_speed_grade;
	__le16 sync_ddr_speed_grade;
	u8 async_sdr_features;
	u8 toggle_ddr_features;
	u8 sync_ddr_features;
	__le16 t_prog;
	__le16 t_bers;
	__le16 t_r;
	__le16 t_r_multi_plane;
	__le16 t_ccs;
	__le16 io_pin_capacitance_typ;
	__le16 input_pin_capacitance_typ;
	__le16 clk_pin_capacitance_typ;
	u8 driver_strength_support;
	__le16 t_adl;
	u8 reserved4[36];
	u8 guaranteed_good_blocks;
	__le16 guaranteed_block_endurance;
	struct jedec_ecc_info ecc_info[4];
	u8 reserved5[29];
	u8 reserved6[148];
	__le16 vendor_rev_num;
	u8 reserved7[88];
	__le16 crc;
} __attribute__((packed));

struct hynix_read_retry {
	int nregs;
	const u8 *regs;
	u8 values[0];
};

struct hynix_nand {
	const struct hynix_read_retry *read_retry;
};

struct hynix_read_retry_otp {
	int nregs;
	const u8 *regs;
	const u8 *values;
	int page;
	int size;
};

struct nand_onfi_vendor_macronix {
	u8 reserved;
	u8 reliability_func;
};

struct nand_onfi_vendor_micron {
	u8 two_plane_read;
	u8 read_cache;
	u8 read_unique_id;
	u8 dq_imped;
	u8 dq_imped_num_settings;
	u8 dq_imped_feat_addr;
	u8 rb_pulldown_strength;
	u8 rb_pulldown_strength_feat_addr;
	u8 rb_pulldown_strength_num_settings;
	u8 otp_mode;
	u8 otp_page_start;
	u8 otp_data_prot_addr;
	u8 otp_num_pages;
	u8 otp_feat_addr;
	u8 read_retry_options;
	u8 reserved[72];
	u8 param_revision;
};

struct micron_on_die_ecc {
	bool forced;
	bool enabled;
	void *rawbuf;
};

struct micron_nand {
	struct micron_on_die_ecc ecc;
};

enum {
	MICRON_ON_DIE_UNSUPPORTED = 0,
	MICRON_ON_DIE_SUPPORTED = 1,
	MICRON_ON_DIE_MANDATORY = 2,
};

struct mxc_nand_host;

struct mxc_nand_devtype_data {
	void (*preset)(struct mtd_info *);
	int (*read_page)(struct nand_chip *, void *, void *, bool, int);
	void (*send_cmd)(struct mxc_nand_host *, uint16_t, int);
	void (*send_addr)(struct mxc_nand_host *, uint16_t, int);
	void (*send_page)(struct mtd_info *, unsigned int);
	void (*send_read_id)(struct mxc_nand_host *);
	uint16_t (*get_dev_status)(struct mxc_nand_host *);
	int (*check_int)(struct mxc_nand_host *);
	void (*irq_control)(struct mxc_nand_host *, int);
	u32 (*get_ecc_status)(struct mxc_nand_host *);
	const struct mtd_ooblayout_ops *ooblayout;
	void (*select_chip)(struct nand_chip *, int);
	int (*setup_interface)(struct nand_chip *, int, const struct nand_interface_config *);
	void (*enable_hwecc)(struct nand_chip *, bool);
	int irqpending_quirk;
	int needs_ip;
	size_t regs_offset;
	size_t spare0_offset;
	size_t axi_offset;
	int spare_len;
	int eccbytes;
	int eccsize;
	int ppb_shift;
};

struct mxc_nand_host {
	struct nand_chip nand;
	struct device *dev;
	void *spare0;
	void *main_area0;
	void *base;
	void *regs;
	void *regs_axi;
	void *regs_ip;
	int status_request;
	struct clk *clk;
	int clk_act;
	int irq;
	int eccsize;
	int used_oobsize;
	int active_cs;
	struct completion op_completion;
	uint8_t *data_buf;
	unsigned int buf_start;
	const struct mxc_nand_devtype_data *devtype_data;
	int: 32;
};

struct resources {
	void *gpmi_regs;
	void *bch_regs;
	unsigned int dma_low_channel;
	unsigned int dma_high_channel;
	struct clk *clock[5];
};

struct bch_geometry {
	unsigned int gf_len;
	unsigned int ecc_strength;
	unsigned int page_size;
	unsigned int metadata_size;
	unsigned int ecc0_chunk_size;
	unsigned int eccn_chunk_size;
	unsigned int ecc_chunk_count;
	unsigned int payload_size;
	unsigned int auxiliary_size;
	unsigned int auxiliary_status_offset;
	unsigned int block_mark_byte_offset;
	unsigned int block_mark_bit_offset;
	unsigned int ecc_for_meta;
};

struct boot_rom_geometry {
	unsigned int stride_size_in_pages;
	unsigned int search_area_stride_exponent;
};

enum gpmi_type {
	IS_MX23 = 0,
	IS_MX28 = 1,
	IS_MX6Q = 2,
	IS_MX6QP = 3,
	IS_MX6SX = 4,
	IS_MX7D = 5,
	IS_MX6UL = 6,
	IS_MX6ULL = 7,
	IS_MX8QXP = 8,
};

struct gpmi_devdata {
	enum gpmi_type type;
	int bch_max_ecc_strength;
	int max_chain_delay;
	const char * const *clks;
	const int clks_count;
};

struct gpmi_nfc_hardware_timing {
	bool must_apply_timings;
	long unsigned int clk_rate;
	u32 timing0;
	u32 timing1;
	u32 ctrl1n;
};

struct gpmi_transfer {
	u8 cmdbuf[8];
	struct scatterlist sgl;
	enum dma_data_direction direction;
};

struct gpmi_nand_data {
	const struct gpmi_devdata *devdata;
	struct device *dev;
	struct platform_device *pdev;
	struct resources resources;
	struct gpmi_nfc_hardware_timing hw;
	struct bch_geometry bch_geometry;
	struct completion bch_done;
	bool swap_block_mark;
	struct boot_rom_geometry rom_geometry;
	struct nand_controller base;
	int: 32;
	struct nand_chip nand;
	struct gpmi_transfer transfers[8];
	int ntransfers;
	bool bch;
	uint32_t bch_flashlayout0;
	uint32_t bch_flashlayout1;
	char *data_buffer_dma;
	void *auxiliary_virt;
	dma_addr_t auxiliary_phys;
	void *raw_buffer;
	struct dma_chan *dma_chans[8];
	struct completion dma_done;
};

enum spi_mem_data_dir {
	SPI_MEM_NO_DATA = 0,
	SPI_MEM_DATA_IN = 1,
	SPI_MEM_DATA_OUT = 2,
};

struct spi_mem_op {
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		u16 opcode;
	} cmd;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
		int: 15;
		int: 32;
		u64 val;
	} addr;
	struct {
		u8 nbytes;
		u8 buswidth;
		u8 dtr: 1;
	} dummy;
	struct {
		u8 buswidth;
		u8 dtr: 1;
		u8 ecc: 1;
		enum spi_mem_data_dir dir;
		unsigned int nbytes;
		union {
			void *in;
			const void *out;
		} buf;
	} data;
	int: 32;
};

struct spi_mem_dirmap_info {
	struct spi_mem_op op_tmpl;
	u64 offset;
	u64 length;
};

struct spi_mem_dirmap_desc {
	struct spi_mem *mem;
	int: 32;
	struct spi_mem_dirmap_info info;
	unsigned int nodirmap;
	void *priv;
};

struct spi_mem {
	struct spi_device *spi;
	void *drvpriv;
	const char *name;
};

struct spi_mem_driver {
	struct spi_driver spidrv;
	int (*probe)(struct spi_mem *);
	int (*remove)(struct spi_mem *);
	void (*shutdown)(struct spi_mem *);
};

enum spi_nor_protocol {
	SNOR_PROTO_1_1_1 = 65793,
	SNOR_PROTO_1_1_2 = 65794,
	SNOR_PROTO_1_1_4 = 65796,
	SNOR_PROTO_1_1_8 = 65800,
	SNOR_PROTO_1_2_2 = 66050,
	SNOR_PROTO_1_4_4 = 66564,
	SNOR_PROTO_1_8_8 = 67592,
	SNOR_PROTO_2_2_2 = 131586,
	SNOR_PROTO_4_4_4 = 263172,
	SNOR_PROTO_8_8_8 = 526344,
	SNOR_PROTO_1_1_1_DTR = 16843009,
	SNOR_PROTO_1_2_2_DTR = 16843266,
	SNOR_PROTO_1_4_4_DTR = 16843780,
	SNOR_PROTO_1_8_8_DTR = 16844808,
	SNOR_PROTO_8_8_8_DTR = 17303560,
};

struct spi_nor_hwcaps {
	u32 mask;
};

struct spi_nor;

struct spi_nor_controller_ops {
	int (*prepare)(struct spi_nor *);
	void (*unprepare)(struct spi_nor *);
	int (*read_reg)(struct spi_nor *, u8, u8 *, size_t);
	int (*write_reg)(struct spi_nor *, u8, const u8 *, size_t);
	ssize_t (*read)(struct spi_nor *, loff_t, size_t, u8 *);
	ssize_t (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
	int (*erase)(struct spi_nor *, loff_t);
};

enum spi_nor_cmd_ext {
	SPI_NOR_EXT_NONE = 0,
	SPI_NOR_EXT_REPEAT = 1,
	SPI_NOR_EXT_INVERT = 2,
	SPI_NOR_EXT_HEX = 3,
};

struct flash_info___3;

struct spi_nor_manufacturer;

struct sfdp;

struct spi_nor_flash_parameter;

struct spi_nor {
	struct mtd_info mtd;
	struct mutex lock;
	struct device *dev;
	struct spi_mem *spimem;
	u8 *bouncebuf;
	size_t bouncebuf_size;
	const struct flash_info___3 *info;
	const struct spi_nor_manufacturer *manufacturer;
	u8 addr_nbytes;
	u8 erase_opcode;
	u8 read_opcode;
	u8 read_dummy;
	u8 program_opcode;
	enum spi_nor_protocol read_proto;
	enum spi_nor_protocol write_proto;
	enum spi_nor_protocol reg_proto;
	bool sst_write_second;
	u32 flags;
	enum spi_nor_cmd_ext cmd_ext_type;
	struct sfdp *sfdp;
	struct dentry *debugfs_root;
	const struct spi_nor_controller_ops *controller_ops;
	struct spi_nor_flash_parameter *params;
	struct {
		struct spi_mem_dirmap_desc *rdesc;
		struct spi_mem_dirmap_desc *wdesc;
	} dirmap;
	void *priv;
};

struct spi_nor_otp_organization {
	size_t len;
	int: 32;
	loff_t base;
	loff_t offset;
	unsigned int n_regions;
	int: 32;
};

struct spi_nor_fixups;

struct flash_info___3 {
	char *name;
	u8 id[6];
	u8 id_len;
	unsigned int sector_size;
	u16 n_sectors;
	u16 page_size;
	u8 addr_nbytes;
	bool parse_sfdp;
	u16 flags;
	u8 no_sfdp_flags;
	u8 fixup_flags;
	u8 mfr_flags;
	int: 8;
	int: 32;
	const struct spi_nor_otp_organization otp_org;
	const struct spi_nor_fixups *fixups;
	int: 32;
};

struct spi_nor_manufacturer {
	const char *name;
	const struct flash_info___3 *parts;
	unsigned int nparts;
	const struct spi_nor_fixups *fixups;
};

struct sfdp {
	size_t num_dwords;
	u32 *dwords;
};

struct spi_nor_read_command {
	u8 num_mode_clocks;
	u8 num_wait_states;
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_pp_command {
	u8 opcode;
	enum spi_nor_protocol proto;
};

struct spi_nor_erase_region {
	u64 offset;
	u64 size;
};

struct spi_nor_erase_type {
	u32 size;
	u32 size_shift;
	u32 size_mask;
	u8 opcode;
	u8 idx;
};

struct spi_nor_erase_map {
	struct spi_nor_erase_region *regions;
	int: 32;
	struct spi_nor_erase_region uniform_region;
	struct spi_nor_erase_type erase_type[4];
	u8 uniform_erase_type;
	int: 24;
	int: 32;
};

struct spi_nor_otp_ops;

struct spi_nor_otp {
	const struct spi_nor_otp_organization *org;
	const struct spi_nor_otp_ops *ops;
};

struct spi_nor_locking_ops;

struct spi_nor_flash_parameter {
	u64 size;
	u32 writesize;
	u32 page_size;
	u8 addr_nbytes;
	u8 addr_mode_nbytes;
	u8 rdsr_dummy;
	u8 rdsr_addr_nbytes;
	struct spi_nor_hwcaps hwcaps;
	struct spi_nor_read_command reads[16];
	struct spi_nor_pp_command page_programs[8];
	struct spi_nor_erase_map erase_map;
	struct spi_nor_otp otp;
	int (*octal_dtr_enable)(struct spi_nor *, bool);
	int (*quad_enable)(struct spi_nor *);
	int (*set_4byte_addr_mode)(struct spi_nor *, bool);
	u32 (*convert_addr)(struct spi_nor *, u32);
	int (*setup)(struct spi_nor *, const struct spi_nor_hwcaps *);
	int (*ready)(struct spi_nor *);
	const struct spi_nor_locking_ops *locking_ops;
	int: 32;
};

struct sfdp_bfpt {
	u32 dwords[20];
};

struct sfdp_parameter_header {
	u8 id_lsb;
	u8 minor;
	u8 major;
	u8 length;
	u8 parameter_table_pointer[3];
	u8 id_msb;
};

enum spi_nor_option_flags {
	SNOR_F_HAS_SR_TB = 1,
	SNOR_F_NO_OP_CHIP_ERASE = 2,
	SNOR_F_BROKEN_RESET = 4,
	SNOR_F_4B_OPCODES = 8,
	SNOR_F_HAS_4BAIT = 16,
	SNOR_F_HAS_LOCK = 32,
	SNOR_F_HAS_16BIT_SR = 64,
	SNOR_F_NO_READ_CR = 128,
	SNOR_F_HAS_SR_TB_BIT6 = 256,
	SNOR_F_HAS_4BIT_BP = 512,
	SNOR_F_HAS_SR_BP3_BIT6 = 1024,
	SNOR_F_IO_MODE_EN_VOLATILE = 2048,
	SNOR_F_SOFT_RESET = 4096,
	SNOR_F_SWP_IS_VOLATILE = 8192,
};

enum spi_nor_read_command_index {
	SNOR_CMD_READ = 0,
	SNOR_CMD_READ_FAST = 1,
	SNOR_CMD_READ_1_1_1_DTR = 2,
	SNOR_CMD_READ_1_1_2 = 3,
	SNOR_CMD_READ_1_2_2 = 4,
	SNOR_CMD_READ_2_2_2 = 5,
	SNOR_CMD_READ_1_2_2_DTR = 6,
	SNOR_CMD_READ_1_1_4 = 7,
	SNOR_CMD_READ_1_4_4 = 8,
	SNOR_CMD_READ_4_4_4 = 9,
	SNOR_CMD_READ_1_4_4_DTR = 10,
	SNOR_CMD_READ_1_1_8 = 11,
	SNOR_CMD_READ_1_8_8 = 12,
	SNOR_CMD_READ_8_8_8 = 13,
	SNOR_CMD_READ_1_8_8_DTR = 14,
	SNOR_CMD_READ_8_8_8_DTR = 15,
	SNOR_CMD_READ_MAX = 16,
};

enum spi_nor_pp_command_index {
	SNOR_CMD_PP = 0,
	SNOR_CMD_PP_1_1_4 = 1,
	SNOR_CMD_PP_1_4_4 = 2,
	SNOR_CMD_PP_4_4_4 = 3,
	SNOR_CMD_PP_1_1_8 = 4,
	SNOR_CMD_PP_1_8_8 = 5,
	SNOR_CMD_PP_8_8_8 = 6,
	SNOR_CMD_PP_8_8_8_DTR = 7,
	SNOR_CMD_PP_MAX = 8,
};

struct spi_nor_erase_command {
	struct list_head list;
	u32 count;
	u32 size;
	u8 opcode;
};

struct spi_nor_locking_ops {
	int (*lock)(struct spi_nor *, loff_t, uint64_t);
	int (*unlock)(struct spi_nor *, loff_t, uint64_t);
	int (*is_locked)(struct spi_nor *, loff_t, uint64_t);
};

struct spi_nor_otp_ops {
	int (*read)(struct spi_nor *, loff_t, size_t, u8 *);
	int (*write)(struct spi_nor *, loff_t, size_t, const u8 *);
	int (*lock)(struct spi_nor *, unsigned int);
	int (*erase)(struct spi_nor *, loff_t);
	int (*is_locked)(struct spi_nor *, unsigned int);
};

struct spi_nor_fixups {
	void (*default_init)(struct spi_nor *);
	int (*post_bfpt)(struct spi_nor *, const struct sfdp_parameter_header *, const struct sfdp_bfpt *);
	void (*post_sfdp)(struct spi_nor *);
	void (*late_init)(struct spi_nor *);
};

struct sfdp_header {
	u32 signature;
	u8 minor;
	u8 major;
	u8 nph;
	u8 unused;
	struct sfdp_parameter_header bfpt_header;
};

struct sfdp_bfpt_read {
	u32 hwcaps;
	u32 supported_dword;
	u32 supported_bit;
	u32 settings_dword;
	u32 settings_shift;
	enum spi_nor_protocol proto;
};

struct sfdp_bfpt_erase {
	u32 dword;
	u32 shift;
};

struct sfdp_4bait {
	u32 hwcaps;
	u32 supported_bit;
};

enum {
	UBI_VID_DYNAMIC = 1,
	UBI_VID_STATIC = 2,
};

enum {
	UBI_VTBL_AUTORESIZE_FLG = 1,
	UBI_VTBL_SKIP_CRC_CHECK_FLG = 2,
};

enum {
	UBI_COMPAT_DELETE = 1,
	UBI_COMPAT_RO = 2,
	UBI_COMPAT_PRESERVE = 4,
	UBI_COMPAT_REJECT = 5,
};

struct ubi_ec_hdr {
	__be32 magic;
	__u8 version;
	__u8 padding1[3];
	__be64 ec;
	__be32 vid_hdr_offset;
	__be32 data_offset;
	__be32 image_seq;
	__u8 padding2[32];
	__be32 hdr_crc;
};

struct ubi_vid_hdr {
	__be32 magic;
	__u8 version;
	__u8 vol_type;
	__u8 copy_flag;
	__u8 compat;
	__be32 vol_id;
	__be32 lnum;
	__u8 padding1[4];
	__be32 data_size;
	__be32 used_ebs;
	__be32 data_pad;
	__be32 data_crc;
	__u8 padding2[4];
	__be64 sqnum;
	__u8 padding3[12];
	__be32 hdr_crc;
};

struct ubi_vtbl_record {
	__be32 reserved_pebs;
	__be32 alignment;
	__be32 data_pad;
	__u8 vol_type;
	__u8 upd_marker;
	__be16 name_len;
	__u8 name[128];
	__u8 flags;
	__u8 padding[23];
	__be32 crc;
};

enum {
	UBI_IO_FF = 1,
	UBI_IO_FF_BITFLIPS = 2,
	UBI_IO_BAD_HDR = 3,
	UBI_IO_BAD_HDR_EBADMSG = 4,
	UBI_IO_BITFLIPS = 5,
};

struct ubi_vid_io_buf {
	struct ubi_vid_hdr *hdr;
	void *buffer;
};

struct ubi_wl_entry {
	union {
		struct rb_node rb;
		struct list_head list;
	} u;
	int ec;
	int pnum;
};

struct ubi_volume_desc;

struct ubi_rename_entry {
	int new_name_len;
	char new_name[128];
	int remove;
	struct ubi_volume_desc *desc;
	struct list_head list;
};

struct ubi_volume;

struct ubi_volume_desc {
	struct ubi_volume *vol;
	int mode;
};

struct ubi_fastmap_layout {
	struct ubi_wl_entry *e[32];
	int to_be_tortured[32];
	int used_blocks;
	int max_pool_size;
	int max_wl_pool_size;
};

struct ubi_fm_pool {
	int pebs[256];
	int used;
	int size;
	int max_size;
};

struct ubi_device;

struct ubi_eba_table;

struct ubi_volume {
	struct device dev;
	struct cdev cdev;
	struct ubi_device *ubi;
	int vol_id;
	int ref_count;
	int readers;
	int writers;
	int exclusive;
	int metaonly;
	int reserved_pebs;
	int vol_type;
	int usable_leb_size;
	int used_ebs;
	int last_eb_bytes;
	int: 32;
	long long int used_bytes;
	int alignment;
	int data_pad;
	int name_len;
	char name[128];
	int upd_ebs;
	int ch_lnum;
	int: 32;
	long long int upd_bytes;
	long long int upd_received;
	void *upd_buf;
	struct ubi_eba_table *eba_tbl;
	unsigned int skip_check: 1;
	unsigned int checked: 1;
	unsigned int corrupted: 1;
	unsigned int upd_marker: 1;
	unsigned int updating: 1;
	unsigned int changing_leb: 1;
	unsigned int direct_writes: 1;
	long unsigned int *checkmap;
};

struct ubi_debug_info {
	unsigned int chk_gen: 1;
	unsigned int chk_io: 1;
	unsigned int chk_fastmap: 1;
	unsigned int disable_bgt: 1;
	unsigned int emulate_bitflips: 1;
	unsigned int emulate_io_failures: 1;
	unsigned int emulate_power_cut: 2;
	unsigned int power_cut_counter;
	unsigned int power_cut_min;
	unsigned int power_cut_max;
	char dfs_dir_name[7];
	struct dentry *dfs_dir;
	struct dentry *dfs_chk_gen;
	struct dentry *dfs_chk_io;
	struct dentry *dfs_chk_fastmap;
	struct dentry *dfs_disable_bgt;
	struct dentry *dfs_emulate_bitflips;
	struct dentry *dfs_emulate_io_failures;
	struct dentry *dfs_emulate_power_cut;
	struct dentry *dfs_power_cut_min;
	struct dentry *dfs_power_cut_max;
};

struct ubi_device {
	struct cdev cdev;
	int: 32;
	struct device dev;
	int ubi_num;
	char ubi_name[9];
	int vol_count;
	struct ubi_volume *volumes[129];
	spinlock_t volumes_lock;
	int ref_count;
	int image_seq;
	int rsvd_pebs;
	int avail_pebs;
	int beb_rsvd_pebs;
	int beb_rsvd_level;
	int bad_peb_limit;
	int autoresize_vol_id;
	int vtbl_slots;
	int vtbl_size;
	struct ubi_vtbl_record *vtbl;
	struct mutex device_mutex;
	int max_ec;
	int mean_ec;
	int: 32;
	long long unsigned int global_sqnum;
	spinlock_t ltree_lock;
	struct rb_root ltree;
	struct mutex alc_mutex;
	int fm_disabled;
	struct ubi_fastmap_layout *fm;
	struct ubi_fm_pool fm_pool;
	struct ubi_fm_pool fm_wl_pool;
	struct rw_semaphore fm_eba_sem;
	struct rw_semaphore fm_protect;
	void *fm_buf;
	size_t fm_size;
	struct work_struct fm_work;
	int fm_work_scheduled;
	int fast_attach;
	struct ubi_wl_entry *fm_anchor;
	int fm_do_produce_anchor;
	struct rb_root used;
	struct rb_root erroneous;
	struct rb_root free;
	int free_count;
	struct rb_root scrub;
	struct list_head pq[10];
	int pq_head;
	spinlock_t wl_lock;
	struct mutex move_mutex;
	struct rw_semaphore work_sem;
	int wl_scheduled;
	struct ubi_wl_entry **lookuptbl;
	struct ubi_wl_entry *move_from;
	struct ubi_wl_entry *move_to;
	int move_to_put;
	struct list_head works;
	int works_count;
	struct task_struct *bgt_thread;
	int thread_enabled;
	char bgt_name[13];
	int: 24;
	int: 32;
	long long int flash_size;
	int peb_count;
	int peb_size;
	int bad_peb_count;
	int good_peb_count;
	int corr_peb_count;
	int erroneous_peb_count;
	int max_erroneous;
	int min_io_size;
	int hdrs_min_io_size;
	int ro_mode;
	int leb_size;
	int leb_start;
	int ec_hdr_alsize;
	int vid_hdr_alsize;
	int vid_hdr_offset;
	int vid_hdr_aloffset;
	int vid_hdr_shift;
	unsigned int bad_allowed: 1;
	unsigned int nor_flash: 1;
	int max_write_size;
	struct mtd_info *mtd;
	void *peb_buf;
	struct mutex buf_mutex;
	struct mutex ckvol_mutex;
	struct ubi_debug_info dbg;
	int: 32;
};

struct ubi_ainf_peb {
	int ec;
	int pnum;
	int vol_id;
	int lnum;
	unsigned int scrub: 1;
	unsigned int copy_flag: 1;
	int: 30;
	int: 32;
	long long unsigned int sqnum;
	union {
		struct rb_node rb;
		struct list_head list;
	} u;
	int: 32;
};

struct ubi_ainf_volume {
	int vol_id;
	int highest_lnum;
	int leb_count;
	int vol_type;
	int used_ebs;
	int last_data_size;
	int data_pad;
	int compat;
	struct rb_node rb;
	struct rb_root root;
};

struct ubi_attach_info {
	struct rb_root volumes;
	struct list_head corr;
	struct list_head free;
	struct list_head erase;
	struct list_head alien;
	struct list_head fastmap;
	int corr_peb_count;
	int empty_peb_count;
	int alien_peb_count;
	int bad_peb_count;
	int maybe_bad_peb_count;
	int vols_found;
	int highest_vol_id;
	int is_empty;
	int force_full_scan;
	int min_ec;
	int max_ec;
	long long unsigned int max_sqnum;
	int mean_ec;
	int: 32;
	uint64_t ec_sum;
	int ec_count;
	struct kmem_cache *aeb_slab_cache;
	struct ubi_ec_hdr *ech;
	struct ubi_vid_io_buf *vidb;
};

enum {
	UBI_VOL_SKIP_CRC_CHECK_FLG = 1,
};

struct ubi_mkvol_req {
	__s32 vol_id;
	__s32 alignment;
	__s64 bytes;
	__s8 vol_type;
	__u8 flags;
	__s16 name_len;
	__s8 padding2[4];
	char name[128];
};

enum {
	UBI_VOLUME_ADDED = 0,
	UBI_VOLUME_REMOVED = 1,
	UBI_VOLUME_RESIZED = 2,
	UBI_VOLUME_RENAMED = 3,
	UBI_VOLUME_UPDATED = 4,
};

struct ubi_leb_change_req {
	__s32 lnum;
	__s32 bytes;
	__s8 dtype;
	__s8 padding[7];
};

struct ubi_notification {
	struct ubi_device_info di;
	int: 32;
	struct ubi_volume_info vi;
};

struct mtd_dev_param {
	char name[64];
	int ubi_num;
	int vid_hdr_offs;
	int max_beb_per1024;
};

enum {
	UBI_VOL_PROP_DIRECT_WRITE = 1,
};

struct ubi_attach_req {
	__s32 ubi_num;
	__s32 mtd_num;
	__s32 vid_hdr_offset;
	__s16 max_beb_per1024;
	__s8 disable_fm;
	__s8 padding[9];
};

struct ubi_rsvol_req {
	__s64 bytes;
	__s32 vol_id;
};

struct ubi_rnvol_req {
	__s32 count;
	__s8 padding1[12];
	struct {
		__s32 vol_id;
		__s16 name_len;
		__s8 padding2[2];
		char name[128];
	} ents[32];
};

struct ubi_map_req {
	__s32 lnum;
	__s8 dtype;
	__s8 padding[3];
};

struct ubi_set_vol_prop_req {
	__u8 property;
	__u8 padding[7];
	__u64 value;
};

struct ubi_sgl {
	int list_pos;
	int page_pos;
	struct scatterlist sg[64];
};

enum {
	MOVE_CANCEL_RACE = 1,
	MOVE_SOURCE_RD_ERR = 2,
	MOVE_TARGET_RD_ERR = 3,
	MOVE_TARGET_WR_ERR = 4,
	MOVE_TARGET_BITFLIPS = 5,
	MOVE_RETRY = 6,
};

struct ubi_ltree_entry {
	struct rb_node rb;
	int vol_id;
	int lnum;
	int users;
	struct rw_semaphore mutex;
};

struct ubi_eba_leb_desc {
	int lnum;
	int pnum;
};

struct ubi_eba_entry;

struct ubi_eba_table {
	struct ubi_eba_entry *entries;
};

struct ubi_eba_entry {
	int pnum;
};

enum {
	POWER_CUT_EC_WRITE = 1,
	POWER_CUT_VID_WRITE = 2,
};

struct ubi_work {
	struct list_head list;
	int (*func)(struct ubi_device *, struct ubi_work *, int);
	struct ubi_wl_entry *e;
	int vol_id;
	int lnum;
	int torture;
};

enum {
	UBI_NO_FASTMAP = 1,
	UBI_BAD_FASTMAP = 2,
};

struct ubi_fm_sb {
	__be32 magic;
	__u8 version;
	__u8 padding1[3];
	__be32 data_crc;
	__be32 used_blocks;
	__be32 block_loc[32];
	__be32 block_ec[32];
	__be64 sqnum;
	__u8 padding2[32];
};

struct ubi_fm_hdr {
	__be32 magic;
	__be32 free_peb_count;
	__be32 used_peb_count;
	__be32 scrub_peb_count;
	__be32 bad_peb_count;
	__be32 erase_peb_count;
	__be32 vol_count;
	__u8 padding[4];
};

struct ubi_fm_scan_pool {
	__be32 magic;
	__be16 size;
	__be16 max_size;
	__be32 pebs[256];
	__be32 padding[4];
};

struct ubi_fm_ec {
	__be32 pnum;
	__be32 ec;
};

struct ubi_fm_volhdr {
	__be32 magic;
	__be32 vol_id;
	__u8 vol_type;
	__u8 padding1[3];
	__be32 data_pad;
	__be32 used_ebs;
	__be32 last_eb_bytes;
	__u8 padding2[8];
};

struct ubi_fm_eba {
	__be32 magic;
	__be32 reserved_pebs;
	__be32 pnum[0];
};

struct ubiblock_param {
	int ubi_num;
	int vol_id;
	char name[64];
};

struct ubiblock_pdu {
	struct work_struct work;
	struct ubi_sgl usgl;
};

struct ubiblock {
	struct ubi_volume_desc *desc;
	int ubi_num;
	int vol_id;
	int refcnt;
	int leb_size;
	struct gendisk *gd;
	struct request_queue *rq;
	struct workqueue_struct *wq;
	struct mutex dev_mutex;
	struct list_head list;
	struct blk_mq_tag_set tag_set;
};

typedef void (*spi_res_release_t)(struct spi_controller *, struct spi_message *, void *);

struct spi_res {
	struct list_head entry;
	spi_res_release_t release;
	int: 32;
	long long unsigned int data[0];
};

struct ptp_system_timestamp {
	struct timespec64 pre_ts;
	struct timespec64 post_ts;
};

struct spi_replaced_transfers;

typedef void (*spi_replaced_release_t)(struct spi_controller *, struct spi_message *, struct spi_replaced_transfers *);

struct spi_replaced_transfers {
	spi_replaced_release_t release;
	void *extradata;
	struct list_head replaced_transfers;
	struct list_head *replaced_after;
	size_t inserted;
	struct spi_transfer inserted_transfers[0];
};

struct spi_board_info {
	char modalias[32];
	const void *platform_data;
	const struct software_node *swnode;
	void *controller_data;
	int irq;
	u32 max_speed_hz;
	u16 bus_num;
	u16 chip_select;
	u32 mode;
};

struct trace_event_raw_spi_controller {
	struct trace_entry ent;
	int bus_num;
	char __data[0];
};

struct trace_event_raw_spi_setup {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	long unsigned int mode;
	unsigned int bits_per_word;
	unsigned int max_speed_hz;
	int status;
	char __data[0];
};

struct trace_event_raw_spi_set_cs {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	long unsigned int mode;
	bool enable;
	char __data[0];
};

struct trace_event_raw_spi_message {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	char __data[0];
};

struct trace_event_raw_spi_message_done {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_message *msg;
	unsigned int frame;
	unsigned int actual;
	char __data[0];
};

struct trace_event_raw_spi_transfer {
	struct trace_entry ent;
	int bus_num;
	int chip_select;
	struct spi_transfer *xfer;
	int len;
	u32 __data_loc_rx_buf;
	u32 __data_loc_tx_buf;
	char __data[0];
};

struct trace_event_data_offsets_spi_controller {};

struct trace_event_data_offsets_spi_setup {};

struct trace_event_data_offsets_spi_set_cs {};

struct trace_event_data_offsets_spi_message {};

struct trace_event_data_offsets_spi_message_done {};

struct trace_event_data_offsets_spi_transfer {
	u32 rx_buf;
	u32 tx_buf;
};

typedef void (*btf_trace_spi_controller_idle)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_controller_busy)(void *, struct spi_controller *);

typedef void (*btf_trace_spi_setup)(void *, struct spi_device *, int);

typedef void (*btf_trace_spi_set_cs)(void *, struct spi_device *, bool);

typedef void (*btf_trace_spi_message_submit)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_start)(void *, struct spi_message *);

typedef void (*btf_trace_spi_message_done)(void *, struct spi_message *);

typedef void (*btf_trace_spi_transfer_start)(void *, struct spi_message *, struct spi_transfer *);

typedef void (*btf_trace_spi_transfer_stop)(void *, struct spi_message *, struct spi_transfer *);

struct boardinfo {
	struct list_head list;
	struct spi_board_info board_info;
};

struct spi_ioc_transfer {
	__u64 tx_buf;
	__u64 rx_buf;
	__u32 len;
	__u32 speed_hz;
	__u16 delay_usecs;
	__u8 bits_per_word;
	__u8 cs_change;
	__u8 tx_nbits;
	__u8 rx_nbits;
	__u8 word_delay_usecs;
	__u8 pad;
};

struct spidev_data {
	dev_t devt;
	spinlock_t spi_lock;
	struct spi_device *spi;
	struct list_head device_entry;
	struct mutex buf_lock;
	unsigned int users;
	u8 *tx_buffer;
	u8 *rx_buffer;
	u32 speed_hz;
};

struct spi_bitbang {
	struct mutex lock;
	u8 busy;
	u8 use_dma;
	u16 flags;
	struct spi_controller *master;
	int (*setup_transfer)(struct spi_device *, struct spi_transfer *);
	void (*chipselect)(struct spi_device *, int);
	int (*txrx_bufs)(struct spi_device *, struct spi_transfer *);
	u32 (*txrx_word[4])(struct spi_device *, unsigned int, u32, u8, unsigned int);
	int (*set_line_direction)(struct spi_device *, bool);
};

struct spi_bitbang_cs {
	unsigned int nsecs;
	u32 (*txrx_word)(struct spi_device *, unsigned int, u32, u8, unsigned int);
	unsigned int (*txrx_bufs)(struct spi_device *, u32 (*)(struct spi_device *, unsigned int, u32, u8, unsigned int), unsigned int, struct spi_transfer *, unsigned int);
};

struct lpspi_config {
	u8 bpw;
	u8 chip_select;
	u8 prescale;
	u16 mode;
	u32 speed_hz;
};

struct fsl_lpspi_data {
	struct device *dev;
	void *base;
	long unsigned int base_phys;
	struct clk *clk_ipg;
	struct clk *clk_per;
	bool is_slave;
	u32 num_cs;
	bool is_only_cs1;
	bool is_first_byte;
	void *rx_buf;
	const void *tx_buf;
	void (*tx)(struct fsl_lpspi_data *);
	void (*rx)(struct fsl_lpspi_data *);
	u32 remain;
	u8 watermark;
	u8 txfifosize;
	u8 rxfifosize;
	struct lpspi_config config;
	struct completion xfer_done;
	bool slave_aborted;
	bool usedma;
	struct completion dma_rx_completion;
	struct completion dma_tx_completion;
};

struct fsl_qspi_devtype_data {
	unsigned int rxfifo;
	unsigned int txfifo;
	int invalid_mstrid;
	unsigned int ahb_buf_size;
	unsigned int quirks;
	bool little_endian;
};

struct fsl_qspi {
	void *iobase;
	void *ahb_addr;
	u32 memmap_phy;
	struct clk *clk;
	struct clk *clk_en;
	struct device *dev;
	struct completion c;
	const struct fsl_qspi_devtype_data *devtype_data;
	struct mutex lock;
	struct pm_qos_request pm_qos_req;
	int selected;
};

struct spi_gpio_platform_data {
	u16 num_chipselect;
};

struct spi_gpio {
	struct spi_bitbang bitbang;
	struct gpio_desc *sck;
	struct gpio_desc *miso;
	struct gpio_desc *mosi;
	struct gpio_desc **cs_gpios;
};

enum spi_imx_devtype {
	IMX1_CSPI = 0,
	IMX21_CSPI = 1,
	IMX27_CSPI = 2,
	IMX31_CSPI = 3,
	IMX35_CSPI = 4,
	IMX51_ECSPI = 5,
	IMX53_ECSPI = 6,
};

struct spi_imx_data;

struct spi_imx_devtype_data {
	void (*intctrl)(struct spi_imx_data *, int);
	int (*prepare_message)(struct spi_imx_data *, struct spi_message *);
	int (*prepare_transfer)(struct spi_imx_data *, struct spi_device *);
	void (*trigger)(struct spi_imx_data *);
	int (*rx_available)(struct spi_imx_data *);
	void (*reset)(struct spi_imx_data *);
	void (*setup_wml)(struct spi_imx_data *);
	void (*disable)(struct spi_imx_data *);
	void (*disable_dma)(struct spi_imx_data *);
	bool has_dmamode;
	bool has_slavemode;
	unsigned int fifo_size;
	bool dynamic_burst;
	bool tx_glitch_fixed;
	enum spi_imx_devtype devtype;
};

struct spi_imx_data {
	struct spi_controller *controller;
	struct device *dev;
	struct completion xfer_done;
	void *base;
	long unsigned int base_phys;
	struct clk *clk_per;
	struct clk *clk_ipg;
	long unsigned int spi_clk;
	unsigned int spi_bus_clk;
	unsigned int bits_per_word;
	unsigned int spi_drctl;
	unsigned int count;
	unsigned int remainder;
	void (*tx)(struct spi_imx_data *);
	void (*rx)(struct spi_imx_data *);
	void *rx_buf;
	const void *tx_buf;
	unsigned int txfifo;
	unsigned int dynamic_burst;
	bool rx_only;
	bool slave_mode;
	bool slave_aborted;
	unsigned int slave_burst;
	bool usedma;
	u32 wml;
	struct completion dma_rx_completion;
	struct completion dma_tx_completion;
	const struct spi_imx_devtype_data *devtype_data;
};

struct spi_slave_time_priv {
	struct spi_device *spi;
	struct completion finished;
	struct spi_transfer xfer;
	struct spi_message msg;
	__be32 buf[2];
};

struct spi_slave_system_control_priv {
	struct spi_device *spi;
	struct completion finished;
	struct spi_transfer xfer;
	struct spi_message msg;
	__be16 cmd;
};

struct ethhdr {
	unsigned char h_dest[6];
	unsigned char h_source[6];
	__be16 h_proto;
};

enum netdev_state_t {
	__LINK_STATE_START = 0,
	__LINK_STATE_PRESENT = 1,
	__LINK_STATE_NOCARRIER = 2,
	__LINK_STATE_LINKWATCH_PENDING = 3,
	__LINK_STATE_DORMANT = 4,
	__LINK_STATE_TESTING = 5,
};

struct ethtool_cmd {
	__u32 cmd;
	__u32 supported;
	__u32 advertising;
	__u16 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 transceiver;
	__u8 autoneg;
	__u8 mdio_support;
	__u32 maxtxpkt;
	__u32 maxrxpkt;
	__u16 speed_hi;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__u32 lp_advertising;
	__u32 reserved[2];
};

struct ethtool_drvinfo {
	__u32 cmd;
	char driver[32];
	char version[32];
	char fw_version[32];
	char bus_info[32];
	char erom_version[32];
	char reserved2[12];
	__u32 n_priv_flags;
	__u32 n_stats;
	__u32 testinfo_len;
	__u32 eedump_len;
	__u32 regdump_len;
};

struct ethtool_regs {
	__u32 cmd;
	__u32 version;
	__u32 len;
	__u8 data[0];
};

struct ethtool_eee {
	__u32 cmd;
	__u32 supported;
	__u32 advertised;
	__u32 lp_advertised;
	__u32 eee_active;
	__u32 eee_enabled;
	__u32 tx_lpi_enabled;
	__u32 tx_lpi_timer;
	__u32 reserved[2];
};

struct ethtool_coalesce {
	__u32 cmd;
	__u32 rx_coalesce_usecs;
	__u32 rx_max_coalesced_frames;
	__u32 rx_coalesce_usecs_irq;
	__u32 rx_max_coalesced_frames_irq;
	__u32 tx_coalesce_usecs;
	__u32 tx_max_coalesced_frames;
	__u32 tx_coalesce_usecs_irq;
	__u32 tx_max_coalesced_frames_irq;
	__u32 stats_block_coalesce_usecs;
	__u32 use_adaptive_rx_coalesce;
	__u32 use_adaptive_tx_coalesce;
	__u32 pkt_rate_low;
	__u32 rx_coalesce_usecs_low;
	__u32 rx_max_coalesced_frames_low;
	__u32 tx_coalesce_usecs_low;
	__u32 tx_max_coalesced_frames_low;
	__u32 pkt_rate_high;
	__u32 rx_coalesce_usecs_high;
	__u32 rx_max_coalesced_frames_high;
	__u32 tx_coalesce_usecs_high;
	__u32 tx_max_coalesced_frames_high;
	__u32 rate_sample_interval;
};

struct ethtool_ringparam {
	__u32 cmd;
	__u32 rx_max_pending;
	__u32 rx_mini_max_pending;
	__u32 rx_jumbo_max_pending;
	__u32 tx_max_pending;
	__u32 rx_pending;
	__u32 rx_mini_pending;
	__u32 rx_jumbo_pending;
	__u32 tx_pending;
};

struct ethtool_channels {
	__u32 cmd;
	__u32 max_rx;
	__u32 max_tx;
	__u32 max_other;
	__u32 max_combined;
	__u32 rx_count;
	__u32 tx_count;
	__u32 other_count;
	__u32 combined_count;
};

struct ethtool_pauseparam {
	__u32 cmd;
	__u32 autoneg;
	__u32 rx_pause;
	__u32 tx_pause;
};

enum ethtool_link_ext_state {
	ETHTOOL_LINK_EXT_STATE_AUTONEG = 0,
	ETHTOOL_LINK_EXT_STATE_LINK_TRAINING_FAILURE = 1,
	ETHTOOL_LINK_EXT_STATE_LINK_LOGICAL_MISMATCH = 2,
	ETHTOOL_LINK_EXT_STATE_BAD_SIGNAL_INTEGRITY = 3,
	ETHTOOL_LINK_EXT_STATE_NO_CABLE = 4,
	ETHTOOL_LINK_EXT_STATE_CABLE_ISSUE = 5,
	ETHTOOL_LINK_EXT_STATE_EEPROM_ISSUE = 6,
	ETHTOOL_LINK_EXT_STATE_CALIBRATION_FAILURE = 7,
	ETHTOOL_LINK_EXT_STATE_POWER_BUDGET_EXCEEDED = 8,
	ETHTOOL_LINK_EXT_STATE_OVERHEAT = 9,
	ETHTOOL_LINK_EXT_STATE_MODULE = 10,
};

enum ethtool_link_ext_substate_autoneg {
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_ACK_NOT_RECEIVED = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NEXT_PAGE_EXCHANGE_FAILED = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_PARTNER_DETECTED_FORCE_MODE = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_FEC_MISMATCH_DURING_OVERRIDE = 5,
	ETHTOOL_LINK_EXT_SUBSTATE_AN_NO_HCD = 6,
};

enum ethtool_link_ext_substate_link_training {
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_FRAME_LOCK_NOT_ACQUIRED = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_INHIBIT_TIMEOUT = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_KR_LINK_PARTNER_DID_NOT_SET_RECEIVER_READY = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LT_REMOTE_FAULT = 4,
};

enum ethtool_link_ext_substate_link_logical_mismatch {
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_BLOCK_LOCK = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_ACQUIRE_AM_LOCK = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_PCS_DID_NOT_GET_ALIGN_STATUS = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_FC_FEC_IS_NOT_LOCKED = 4,
	ETHTOOL_LINK_EXT_SUBSTATE_LLM_RS_FEC_IS_NOT_LOCKED = 5,
};

enum ethtool_link_ext_substate_bad_signal_integrity {
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_LARGE_NUMBER_OF_PHYSICAL_ERRORS = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_UNSUPPORTED_RATE = 2,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_REFERENCE_CLOCK_LOST = 3,
	ETHTOOL_LINK_EXT_SUBSTATE_BSI_SERDES_ALOS = 4,
};

enum ethtool_link_ext_substate_cable_issue {
	ETHTOOL_LINK_EXT_SUBSTATE_CI_UNSUPPORTED_CABLE = 1,
	ETHTOOL_LINK_EXT_SUBSTATE_CI_CABLE_TEST_FAILURE = 2,
};

enum ethtool_link_ext_substate_module {
	ETHTOOL_LINK_EXT_SUBSTATE_MODULE_CMIS_NOT_READY = 1,
};

enum ethtool_module_power_mode_policy {
	ETHTOOL_MODULE_POWER_MODE_POLICY_HIGH = 1,
	ETHTOOL_MODULE_POWER_MODE_POLICY_AUTO = 2,
};

enum ethtool_module_power_mode {
	ETHTOOL_MODULE_POWER_MODE_LOW = 1,
	ETHTOOL_MODULE_POWER_MODE_HIGH = 2,
};

struct ethtool_test {
	__u32 cmd;
	__u32 flags;
	__u32 reserved;
	__u32 len;
	__u64 data[0];
};

struct ethtool_tcpip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be16 psrc;
	__be16 pdst;
	__u8 tos;
};

struct ethtool_ah_espip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 spi;
	__u8 tos;
};

struct ethtool_usrip4_spec {
	__be32 ip4src;
	__be32 ip4dst;
	__be32 l4_4_bytes;
	__u8 tos;
	__u8 ip_ver;
	__u8 proto;
};

struct ethtool_tcpip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be16 psrc;
	__be16 pdst;
	__u8 tclass;
};

struct ethtool_ah_espip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 spi;
	__u8 tclass;
};

struct ethtool_usrip6_spec {
	__be32 ip6src[4];
	__be32 ip6dst[4];
	__be32 l4_4_bytes;
	__u8 tclass;
	__u8 l4_proto;
};

union ethtool_flow_union {
	struct ethtool_tcpip4_spec tcp_ip4_spec;
	struct ethtool_tcpip4_spec udp_ip4_spec;
	struct ethtool_tcpip4_spec sctp_ip4_spec;
	struct ethtool_ah_espip4_spec ah_ip4_spec;
	struct ethtool_ah_espip4_spec esp_ip4_spec;
	struct ethtool_usrip4_spec usr_ip4_spec;
	struct ethtool_tcpip6_spec tcp_ip6_spec;
	struct ethtool_tcpip6_spec udp_ip6_spec;
	struct ethtool_tcpip6_spec sctp_ip6_spec;
	struct ethtool_ah_espip6_spec ah_ip6_spec;
	struct ethtool_ah_espip6_spec esp_ip6_spec;
	struct ethtool_usrip6_spec usr_ip6_spec;
	struct ethhdr ether_spec;
	__u8 hdata[52];
};

struct ethtool_flow_ext {
	__u8 padding[2];
	unsigned char h_dest[6];
	__be16 vlan_etype;
	__be16 vlan_tci;
	__be32 data[2];
};

struct ethtool_rx_flow_spec {
	__u32 flow_type;
	union ethtool_flow_union h_u;
	struct ethtool_flow_ext h_ext;
	union ethtool_flow_union m_u;
	struct ethtool_flow_ext m_ext;
	int: 32;
	__u64 ring_cookie;
	__u32 location;
	int: 32;
};

struct ethtool_rxnfc {
	__u32 cmd;
	__u32 flow_type;
	__u64 data;
	struct ethtool_rx_flow_spec fs;
	union {
		__u32 rule_cnt;
		__u32 rss_context;
	};
	__u32 rule_locs[0];
	int: 32;
};

struct ethtool_flash {
	__u32 cmd;
	__u32 region;
	char data[128];
};

struct ethtool_dump {
	__u32 cmd;
	__u32 version;
	__u32 flag;
	__u32 len;
	__u8 data[0];
};

struct ethtool_fecparam {
	__u32 cmd;
	__u32 active_fec;
	__u32 fec;
	__u32 reserved;
};

struct ethtool_link_settings {
	__u32 cmd;
	__u32 speed;
	__u8 duplex;
	__u8 port;
	__u8 phy_address;
	__u8 autoneg;
	__u8 mdio_support;
	__u8 eth_tp_mdix;
	__u8 eth_tp_mdix_ctrl;
	__s8 link_mode_masks_nwords;
	__u8 transceiver;
	__u8 master_slave_cfg;
	__u8 master_slave_state;
	__u8 rate_matching;
	__u32 reserved[7];
	__u32 link_mode_masks[0];
};

struct kernel_ethtool_ringparam {
	u32 rx_buf_len;
	u8 tcp_data_split;
	u8 tx_push;
	u32 cqe_size;
};

struct ethtool_link_ext_state_info {
	enum ethtool_link_ext_state link_ext_state;
	union {
		enum ethtool_link_ext_substate_autoneg autoneg;
		enum ethtool_link_ext_substate_link_training link_training;
		enum ethtool_link_ext_substate_link_logical_mismatch link_logical_mismatch;
		enum ethtool_link_ext_substate_bad_signal_integrity bad_signal_integrity;
		enum ethtool_link_ext_substate_cable_issue cable_issue;
		enum ethtool_link_ext_substate_module module;
		u32 __link_ext_substate;
	};
};

struct ethtool_link_ksettings {
	struct ethtool_link_settings base;
	struct {
		long unsigned int supported[3];
		long unsigned int advertising[3];
		long unsigned int lp_advertising[3];
	} link_modes;
	u32 lanes;
};

struct kernel_ethtool_coalesce {
	u8 use_cqe_mode_tx;
	u8 use_cqe_mode_rx;
};

struct ethtool_eth_mac_stats {
	u64 FramesTransmittedOK;
	u64 SingleCollisionFrames;
	u64 MultipleCollisionFrames;
	u64 FramesReceivedOK;
	u64 FrameCheckSequenceErrors;
	u64 AlignmentErrors;
	u64 OctetsTransmittedOK;
	u64 FramesWithDeferredXmissions;
	u64 LateCollisions;
	u64 FramesAbortedDueToXSColls;
	u64 FramesLostDueToIntMACXmitError;
	u64 CarrierSenseErrors;
	u64 OctetsReceivedOK;
	u64 FramesLostDueToIntMACRcvError;
	u64 MulticastFramesXmittedOK;
	u64 BroadcastFramesXmittedOK;
	u64 FramesWithExcessiveDeferral;
	u64 MulticastFramesReceivedOK;
	u64 BroadcastFramesReceivedOK;
	u64 InRangeLengthErrors;
	u64 OutOfRangeLengthField;
	u64 FrameTooLongErrors;
};

struct ethtool_eth_phy_stats {
	u64 SymbolErrorDuringCarrier;
};

struct ethtool_eth_ctrl_stats {
	u64 MACControlFramesTransmitted;
	u64 MACControlFramesReceived;
	u64 UnsupportedOpcodesReceived;
};

struct ethtool_pause_stats {
	u64 tx_pause_frames;
	u64 rx_pause_frames;
};

struct ethtool_fec_stat {
	u64 total;
	u64 lanes[8];
};

struct ethtool_fec_stats {
	struct ethtool_fec_stat corrected_blocks;
	struct ethtool_fec_stat uncorrectable_blocks;
	struct ethtool_fec_stat corrected_bits;
};

struct ethtool_rmon_hist_range {
	u16 low;
	u16 high;
};

struct ethtool_rmon_stats {
	u64 undersize_pkts;
	u64 oversize_pkts;
	u64 fragments;
	u64 jabbers;
	u64 hist[10];
	u64 hist_tx[10];
};

struct ethtool_module_eeprom {
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
	u8 *data;
};

struct ethtool_module_power_mode_params {
	enum ethtool_module_power_mode_policy policy;
	enum ethtool_module_power_mode mode;
};

struct mii_ioctl_data {
	__u16 phy_id;
	__u16 reg_num;
	__u16 val_in;
	__u16 val_out;
};

struct mii_if_info {
	int phy_id;
	int advertising;
	int phy_id_mask;
	int reg_num_mask;
	unsigned int full_duplex: 1;
	unsigned int force_media: 1;
	unsigned int supports_gmii: 1;
	struct net_device *dev;
	int (*mdio_read)(struct net_device *, int, int);
	void (*mdio_write)(struct net_device *, int, int, int);
};

enum {
	NETIF_F_SG_BIT = 0,
	NETIF_F_IP_CSUM_BIT = 1,
	__UNUSED_NETIF_F_1 = 2,
	NETIF_F_HW_CSUM_BIT = 3,
	NETIF_F_IPV6_CSUM_BIT = 4,
	NETIF_F_HIGHDMA_BIT = 5,
	NETIF_F_FRAGLIST_BIT = 6,
	NETIF_F_HW_VLAN_CTAG_TX_BIT = 7,
	NETIF_F_HW_VLAN_CTAG_RX_BIT = 8,
	NETIF_F_HW_VLAN_CTAG_FILTER_BIT = 9,
	NETIF_F_VLAN_CHALLENGED_BIT = 10,
	NETIF_F_GSO_BIT = 11,
	NETIF_F_LLTX_BIT = 12,
	NETIF_F_NETNS_LOCAL_BIT = 13,
	NETIF_F_GRO_BIT = 14,
	NETIF_F_LRO_BIT = 15,
	NETIF_F_GSO_SHIFT = 16,
	NETIF_F_TSO_BIT = 16,
	NETIF_F_GSO_ROBUST_BIT = 17,
	NETIF_F_TSO_ECN_BIT = 18,
	NETIF_F_TSO_MANGLEID_BIT = 19,
	NETIF_F_TSO6_BIT = 20,
	NETIF_F_FSO_BIT = 21,
	NETIF_F_GSO_GRE_BIT = 22,
	NETIF_F_GSO_GRE_CSUM_BIT = 23,
	NETIF_F_GSO_IPXIP4_BIT = 24,
	NETIF_F_GSO_IPXIP6_BIT = 25,
	NETIF_F_GSO_UDP_TUNNEL_BIT = 26,
	NETIF_F_GSO_UDP_TUNNEL_CSUM_BIT = 27,
	NETIF_F_GSO_PARTIAL_BIT = 28,
	NETIF_F_GSO_TUNNEL_REMCSUM_BIT = 29,
	NETIF_F_GSO_SCTP_BIT = 30,
	NETIF_F_GSO_ESP_BIT = 31,
	NETIF_F_GSO_UDP_BIT = 32,
	NETIF_F_GSO_UDP_L4_BIT = 33,
	NETIF_F_GSO_FRAGLIST_BIT = 34,
	NETIF_F_GSO_LAST = 34,
	NETIF_F_FCOE_CRC_BIT = 35,
	NETIF_F_SCTP_CRC_BIT = 36,
	NETIF_F_FCOE_MTU_BIT = 37,
	NETIF_F_NTUPLE_BIT = 38,
	NETIF_F_RXHASH_BIT = 39,
	NETIF_F_RXCSUM_BIT = 40,
	NETIF_F_NOCACHE_COPY_BIT = 41,
	NETIF_F_LOOPBACK_BIT = 42,
	NETIF_F_RXFCS_BIT = 43,
	NETIF_F_RXALL_BIT = 44,
	NETIF_F_HW_VLAN_STAG_TX_BIT = 45,
	NETIF_F_HW_VLAN_STAG_RX_BIT = 46,
	NETIF_F_HW_VLAN_STAG_FILTER_BIT = 47,
	NETIF_F_HW_L2FW_DOFFLOAD_BIT = 48,
	NETIF_F_HW_TC_BIT = 49,
	NETIF_F_HW_ESP_BIT = 50,
	NETIF_F_HW_ESP_TX_CSUM_BIT = 51,
	NETIF_F_RX_UDP_TUNNEL_PORT_BIT = 52,
	NETIF_F_HW_TLS_TX_BIT = 53,
	NETIF_F_HW_TLS_RX_BIT = 54,
	NETIF_F_GRO_HW_BIT = 55,
	NETIF_F_HW_TLS_RECORD_BIT = 56,
	NETIF_F_GRO_FRAGLIST_BIT = 57,
	NETIF_F_HW_MACSEC_BIT = 58,
	NETIF_F_GRO_UDP_FWD_BIT = 59,
	NETIF_F_HW_HSR_TAG_INS_BIT = 60,
	NETIF_F_HW_HSR_TAG_RM_BIT = 61,
	NETIF_F_HW_HSR_FWD_BIT = 62,
	NETIF_F_HW_HSR_DUP_BIT = 63,
	NETDEV_FEATURE_COUNT = 64,
};

enum {
	SKBTX_HW_TSTAMP = 1,
	SKBTX_SW_TSTAMP = 2,
	SKBTX_IN_PROGRESS = 4,
	SKBTX_HW_TSTAMP_USE_CYCLES = 8,
	SKBTX_WIFI_STATUS = 16,
	SKBTX_HW_TSTAMP_NETDEV = 32,
	SKBTX_SCHED_TSTAMP = 64,
};

struct mdio_board_info {
	const char *bus_id;
	char modalias[32];
	int mdio_addr;
	const void *platform_data;
};

struct mdio_board_entry {
	struct list_head list;
	struct mdio_board_info board_info;
};

struct mdiobus_devres {
	struct mii_bus *mii;
};

struct phylink_link_state {
	long unsigned int advertising[3];
	long unsigned int lp_advertising[3];
	phy_interface_t interface;
	int speed;
	int duplex;
	int pause;
	int rate_matching;
	unsigned int link: 1;
	unsigned int an_enabled: 1;
	unsigned int an_complete: 1;
};

struct phylink_mac_ops;

struct phylink_config;

struct phylink_pcs;

struct phylink {
	struct net_device *netdev;
	const struct phylink_mac_ops *mac_ops;
	struct phylink_config *config;
	struct phylink_pcs *pcs;
	struct device *dev;
	unsigned int old_link_state: 1;
	long unsigned int phylink_disable_state;
	struct phy_device *phydev;
	phy_interface_t link_interface;
	u8 cfg_link_an_mode;
	u8 cur_link_an_mode;
	u8 link_port;
	long unsigned int supported[3];
	struct phylink_link_state link_config;
	phy_interface_t cur_interface;
	struct gpio_desc *link_gpio;
	unsigned int link_irq;
	struct timer_list link_poll;
	void (*get_fixed_state)(struct net_device *, struct phylink_link_state *);
	struct mutex state_mutex;
	struct phylink_link_state phy_state;
	struct work_struct resolve;
	bool mac_link_dropped;
	bool using_mac_select_pcs;
	struct sfp_bus *sfp_bus;
	bool sfp_may_have_phy;
	long unsigned int sfp_interfaces[2];
	long unsigned int sfp_support[3];
	u8 sfp_port;
};

enum phy_inband_aneg {
	PHY_INBAND_ANEG_UNKNOWN = 1,
	PHY_INBAND_ANEG_OFF = 2,
	PHY_INBAND_ANEG_ON = 4,
};

struct phy_setting {
	u32 speed;
	u8 duplex;
	u8 bit;
};

struct fixed_phy_status {
	int link;
	int speed;
	int duplex;
	int pause;
	int asym_pause;
};

enum {
	MLO_PAUSE_NONE = 0,
	MLO_PAUSE_RX = 1,
	MLO_PAUSE_TX = 2,
	MLO_PAUSE_TXRX_MASK = 3,
	MLO_PAUSE_AN = 4,
	MLO_AN_PHY = 0,
	MLO_AN_FIXED = 1,
	MLO_AN_INBAND = 2,
	MAC_SYM_PAUSE = 1,
	MAC_ASYM_PAUSE = 2,
	MAC_10HD = 4,
	MAC_10FD = 8,
	MAC_10 = 12,
	MAC_100HD = 16,
	MAC_100FD = 32,
	MAC_100 = 48,
	MAC_1000HD = 64,
	MAC_1000FD = 128,
	MAC_1000 = 192,
	MAC_2500FD = 256,
	MAC_5000FD = 512,
	MAC_10000FD = 1024,
	MAC_20000FD = 2048,
	MAC_25000FD = 4096,
	MAC_40000FD = 8192,
	MAC_50000FD = 16384,
	MAC_56000FD = 32768,
	MAC_100000FD = 65536,
	MAC_200000FD = 131072,
	MAC_400000FD = 262144,
};

enum phylink_op_type {
	PHYLINK_NETDEV = 0,
	PHYLINK_DEV = 1,
};

struct phylink_config {
	struct device *dev;
	enum phylink_op_type type;
	bool legacy_pre_march2020;
	bool poll_fixed_state;
	bool mac_managed_pm;
	bool ovr_an_inband;
	void (*get_fixed_state)(struct phylink_config *, struct phylink_link_state *);
	long unsigned int supported_interfaces[2];
	long unsigned int mac_capabilities;
};

struct phylink_mac_ops {
	void (*validate)(struct phylink_config *, long unsigned int *, struct phylink_link_state *);
	struct phylink_pcs * (*mac_select_pcs)(struct phylink_config *, phy_interface_t);
	void (*mac_pcs_get_state)(struct phylink_config *, struct phylink_link_state *);
	int (*mac_prepare)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_config)(struct phylink_config *, unsigned int, const struct phylink_link_state *);
	int (*mac_finish)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_an_restart)(struct phylink_config *);
	void (*mac_link_down)(struct phylink_config *, unsigned int, phy_interface_t);
	void (*mac_link_up)(struct phylink_config *, struct phy_device *, unsigned int, phy_interface_t, int, int, bool, bool);
};

struct phylink_pcs_ops;

struct phylink_pcs {
	const struct phylink_pcs_ops *ops;
	bool poll;
};

struct phylink_pcs_ops {
	int (*pcs_validate)(struct phylink_pcs *, long unsigned int *, const struct phylink_link_state *);
	void (*pcs_get_state)(struct phylink_pcs *, struct phylink_link_state *);
	int (*pcs_config)(struct phylink_pcs *, unsigned int, phy_interface_t, const long unsigned int *, bool);
	void (*pcs_an_restart)(struct phylink_pcs *);
	void (*pcs_link_up)(struct phylink_pcs *, unsigned int, phy_interface_t, int, int);
};

struct sfp_eeprom_base {
	u8 phys_id;
	u8 phys_ext_id;
	u8 connector;
	u8 if_1x_copper_passive: 1;
	u8 if_1x_copper_active: 1;
	u8 if_1x_lx: 1;
	u8 if_1x_sx: 1;
	u8 e10g_base_sr: 1;
	u8 e10g_base_lr: 1;
	u8 e10g_base_lrm: 1;
	u8 e10g_base_er: 1;
	u8 sonet_oc3_short_reach: 1;
	u8 sonet_oc3_smf_intermediate_reach: 1;
	u8 sonet_oc3_smf_long_reach: 1;
	u8 unallocated_5_3: 1;
	u8 sonet_oc12_short_reach: 1;
	u8 sonet_oc12_smf_intermediate_reach: 1;
	u8 sonet_oc12_smf_long_reach: 1;
	u8 unallocated_5_7: 1;
	u8 sonet_oc48_short_reach: 1;
	u8 sonet_oc48_intermediate_reach: 1;
	u8 sonet_oc48_long_reach: 1;
	u8 sonet_reach_bit2: 1;
	u8 sonet_reach_bit1: 1;
	u8 sonet_oc192_short_reach: 1;
	u8 escon_smf_1310_laser: 1;
	u8 escon_mmf_1310_led: 1;
	u8 e1000_base_sx: 1;
	u8 e1000_base_lx: 1;
	u8 e1000_base_cx: 1;
	u8 e1000_base_t: 1;
	u8 e100_base_lx: 1;
	u8 e100_base_fx: 1;
	u8 e_base_bx10: 1;
	u8 e_base_px: 1;
	u8 fc_tech_electrical_inter_enclosure: 1;
	u8 fc_tech_lc: 1;
	u8 fc_tech_sa: 1;
	u8 fc_ll_m: 1;
	u8 fc_ll_l: 1;
	u8 fc_ll_i: 1;
	u8 fc_ll_s: 1;
	u8 fc_ll_v: 1;
	u8 unallocated_8_0: 1;
	u8 unallocated_8_1: 1;
	u8 sfp_ct_passive: 1;
	u8 sfp_ct_active: 1;
	u8 fc_tech_ll: 1;
	u8 fc_tech_sl: 1;
	u8 fc_tech_sn: 1;
	u8 fc_tech_electrical_intra_enclosure: 1;
	u8 fc_media_sm: 1;
	u8 unallocated_9_1: 1;
	u8 fc_media_m5: 1;
	u8 fc_media_m6: 1;
	u8 fc_media_tv: 1;
	u8 fc_media_mi: 1;
	u8 fc_media_tp: 1;
	u8 fc_media_tw: 1;
	u8 fc_speed_100: 1;
	u8 unallocated_10_1: 1;
	u8 fc_speed_200: 1;
	u8 fc_speed_3200: 1;
	u8 fc_speed_400: 1;
	u8 fc_speed_1600: 1;
	u8 fc_speed_800: 1;
	u8 fc_speed_1200: 1;
	u8 encoding;
	u8 br_nominal;
	u8 rate_id;
	u8 link_len[6];
	char vendor_name[16];
	u8 extended_cc;
	char vendor_oui[3];
	char vendor_pn[16];
	char vendor_rev[4];
	union {
		__be16 optical_wavelength;
		__be16 cable_compliance;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 reserved60_2: 6;
			u8 reserved61: 8;
		} passive;
		struct {
			u8 sff8431_app_e: 1;
			u8 fc_pi_4_app_h: 1;
			u8 sff8431_lim: 1;
			u8 fc_pi_4_lim: 1;
			u8 reserved60_4: 4;
			u8 reserved61: 8;
		} active;
	};
	u8 reserved62;
	u8 cc_base;
};

struct sfp_eeprom_ext {
	__be16 options;
	u8 br_max;
	u8 br_min;
	char vendor_sn[16];
	char datecode[8];
	u8 diagmon;
	u8 enhopts;
	u8 sff8472_compliance;
	u8 cc_ext;
};

struct sfp_eeprom_id {
	struct sfp_eeprom_base base;
	struct sfp_eeprom_ext ext;
};

struct sfp_upstream_ops {
	void (*attach)(void *, struct sfp_bus *);
	void (*detach)(void *, struct sfp_bus *);
	int (*module_insert)(void *, const struct sfp_eeprom_id *);
	void (*module_remove)(void *);
	int (*module_start)(void *);
	void (*module_stop)(void *);
	void (*link_down)(void *);
	void (*link_up)(void *);
	int (*connect_phy)(void *, struct phy_device *);
	void (*disconnect_phy)(void *);
};

enum {
	PHYLINK_DISABLE_STOPPED = 0,
	PHYLINK_DISABLE_LINK = 1,
	PHYLINK_DISABLE_MAC_WOL = 2,
};

enum {
	ETHTOOL_MSG_KERNEL_NONE = 0,
	ETHTOOL_MSG_STRSET_GET_REPLY = 1,
	ETHTOOL_MSG_LINKINFO_GET_REPLY = 2,
	ETHTOOL_MSG_LINKINFO_NTF = 3,
	ETHTOOL_MSG_LINKMODES_GET_REPLY = 4,
	ETHTOOL_MSG_LINKMODES_NTF = 5,
	ETHTOOL_MSG_LINKSTATE_GET_REPLY = 6,
	ETHTOOL_MSG_DEBUG_GET_REPLY = 7,
	ETHTOOL_MSG_DEBUG_NTF = 8,
	ETHTOOL_MSG_WOL_GET_REPLY = 9,
	ETHTOOL_MSG_WOL_NTF = 10,
	ETHTOOL_MSG_FEATURES_GET_REPLY = 11,
	ETHTOOL_MSG_FEATURES_SET_REPLY = 12,
	ETHTOOL_MSG_FEATURES_NTF = 13,
	ETHTOOL_MSG_PRIVFLAGS_GET_REPLY = 14,
	ETHTOOL_MSG_PRIVFLAGS_NTF = 15,
	ETHTOOL_MSG_RINGS_GET_REPLY = 16,
	ETHTOOL_MSG_RINGS_NTF = 17,
	ETHTOOL_MSG_CHANNELS_GET_REPLY = 18,
	ETHTOOL_MSG_CHANNELS_NTF = 19,
	ETHTOOL_MSG_COALESCE_GET_REPLY = 20,
	ETHTOOL_MSG_COALESCE_NTF = 21,
	ETHTOOL_MSG_PAUSE_GET_REPLY = 22,
	ETHTOOL_MSG_PAUSE_NTF = 23,
	ETHTOOL_MSG_EEE_GET_REPLY = 24,
	ETHTOOL_MSG_EEE_NTF = 25,
	ETHTOOL_MSG_TSINFO_GET_REPLY = 26,
	ETHTOOL_MSG_CABLE_TEST_NTF = 27,
	ETHTOOL_MSG_CABLE_TEST_TDR_NTF = 28,
	ETHTOOL_MSG_TUNNEL_INFO_GET_REPLY = 29,
	ETHTOOL_MSG_FEC_GET_REPLY = 30,
	ETHTOOL_MSG_FEC_NTF = 31,
	ETHTOOL_MSG_MODULE_EEPROM_GET_REPLY = 32,
	ETHTOOL_MSG_STATS_GET_REPLY = 33,
	ETHTOOL_MSG_PHC_VCLOCKS_GET_REPLY = 34,
	ETHTOOL_MSG_MODULE_GET_REPLY = 35,
	ETHTOOL_MSG_MODULE_NTF = 36,
	ETHTOOL_MSG_PSE_GET_REPLY = 37,
	__ETHTOOL_MSG_KERNEL_CNT = 38,
	ETHTOOL_MSG_KERNEL_MAX = 37,
};

enum {
	ETHTOOL_A_STATS_UNSPEC = 0,
	ETHTOOL_A_STATS_PAD = 1,
	ETHTOOL_A_STATS_HEADER = 2,
	ETHTOOL_A_STATS_GROUPS = 3,
	ETHTOOL_A_STATS_GRP = 4,
	__ETHTOOL_A_STATS_CNT = 5,
	ETHTOOL_A_STATS_MAX = 4,
};

struct ethtool_phy_ops {
	int (*get_sset_count)(struct phy_device *);
	int (*get_strings)(struct phy_device *, u8 *);
	int (*get_stats)(struct phy_device *, struct ethtool_stats *, u64 *);
	int (*start_cable_test)(struct phy_device *, struct netlink_ext_ack *);
	int (*start_cable_test_tdr)(struct phy_device *, struct netlink_ext_ack *, const struct phy_tdr_config *);
};

struct phy_fixup {
	struct list_head list;
	char bus_id[64];
	u32 phy_uid;
	u32 phy_uid_mask;
	int (*run)(struct phy_device *);
};

struct mdio_driver {
	struct mdio_driver_common mdiodrv;
	int (*probe)(struct mdio_device *);
	void (*remove)(struct mdio_device *);
	void (*shutdown)(struct mdio_device *);
};

struct trace_event_raw_mdio_access {
	struct trace_entry ent;
	char busid[61];
	char read;
	u8 addr;
	u16 val;
	unsigned int regnum;
	char __data[0];
};

struct trace_event_data_offsets_mdio_access {};

typedef void (*btf_trace_mdio_access)(void *, struct mii_bus *, char, u8, unsigned int, u16, int);

struct mdio_bus_stat_attr {
	int addr;
	unsigned int field_offset;
};

struct swmii_regs {
	u16 bmsr;
	u16 lpa;
	u16 lpagb;
	u16 estat;
};

enum {
	SWMII_SPEED_10 = 0,
	SWMII_SPEED_100 = 1,
	SWMII_SPEED_1000 = 2,
	SWMII_DUPLEX_HALF = 0,
	SWMII_DUPLEX_FULL = 1,
};

enum phy_tunable_id {
	ETHTOOL_PHY_ID_UNSPEC = 0,
	ETHTOOL_PHY_DOWNSHIFT = 1,
	ETHTOOL_PHY_FAST_LINK_DOWN = 2,
	ETHTOOL_PHY_EDPD = 3,
	__ETHTOOL_PHY_TUNABLE_COUNT = 4,
};

struct mdio_device_id {
	__u32 phy_id;
	__u32 phy_id_mask;
};

enum {
	ETHTOOL_A_CABLE_RESULT_CODE_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_CODE_OK = 1,
	ETHTOOL_A_CABLE_RESULT_CODE_OPEN = 2,
	ETHTOOL_A_CABLE_RESULT_CODE_SAME_SHORT = 3,
	ETHTOOL_A_CABLE_RESULT_CODE_CROSS_SHORT = 4,
};

enum {
	ETHTOOL_A_CABLE_PAIR_A = 0,
	ETHTOOL_A_CABLE_PAIR_B = 1,
	ETHTOOL_A_CABLE_PAIR_C = 2,
	ETHTOOL_A_CABLE_PAIR_D = 3,
};

enum stat_access_type {
	PHY = 0,
	MMD = 1,
};

struct at803x_hw_stat {
	const char *string;
	u8 reg;
	u32 mask;
	enum stat_access_type access_type;
};

struct at803x_priv {
	int flags;
	u16 clk_25m_reg;
	u16 clk_25m_mask;
	u8 smarteee_lpi_tw_1g;
	u8 smarteee_lpi_tw_100m;
	bool is_fiber;
	bool is_1000basex;
	struct regulator_dev *vddio_rdev;
	struct regulator_dev *vddh_rdev;
	struct regulator *vddio;
	u64 stats[3];
};

struct at803x_context {
	u16 bmcr;
	u16 advertise;
	u16 control1000;
	u16 int_enable;
	u16 smart_speed;
	u16 led_control;
};

struct fixed_mdio_bus {
	struct mii_bus *mii_bus;
	struct list_head phys;
};

struct fixed_phy {
	int addr;
	struct phy_device *phydev;
	struct fixed_phy_status status;
	bool no_carrier;
	int (*link_update)(struct net_device *, struct fixed_phy_status *);
	struct list_head node;
	struct gpio_desc *link_gpiod;
};

struct ptp_clock_time {
	__s64 sec;
	__u32 nsec;
	__u32 reserved;
};

struct ptp_extts_request {
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct ptp_perout_request {
	union {
		struct ptp_clock_time start;
		struct ptp_clock_time phase;
	};
	struct ptp_clock_time period;
	unsigned int index;
	unsigned int flags;
	union {
		struct ptp_clock_time on;
		unsigned int rsv[4];
	};
};

enum ptp_pin_function {
	PTP_PF_NONE = 0,
	PTP_PF_EXTTS = 1,
	PTP_PF_PEROUT = 2,
	PTP_PF_PHYSYNC = 3,
};

struct ptp_pin_desc {
	char name[64];
	unsigned int index;
	unsigned int func;
	unsigned int chan;
	unsigned int rsv[5];
};

struct ptp_clock_request {
	enum {
		PTP_CLK_REQ_EXTTS = 0,
		PTP_CLK_REQ_PEROUT = 1,
		PTP_CLK_REQ_PPS = 2,
	} type;
	int: 32;
	union {
		struct ptp_extts_request extts;
		struct ptp_perout_request perout;
	};
};

struct ptp_clock_info {
	struct module *owner;
	char name[32];
	s32 max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int n_pins;
	int pps;
	struct ptp_pin_desc *pin_config;
	int (*adjfine)(struct ptp_clock_info *, long int);
	int (*adjfreq)(struct ptp_clock_info *, s32);
	int (*adjphase)(struct ptp_clock_info *, s32);
	int (*adjtime)(struct ptp_clock_info *, s64);
	int (*gettime64)(struct ptp_clock_info *, struct timespec64 *);
	int (*gettimex64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosststamp)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*settime64)(struct ptp_clock_info *, const struct timespec64 *);
	int (*getcycles64)(struct ptp_clock_info *, struct timespec64 *);
	int (*getcyclesx64)(struct ptp_clock_info *, struct timespec64 *, struct ptp_system_timestamp *);
	int (*getcrosscycles)(struct ptp_clock_info *, struct system_device_crosststamp *);
	int (*enable)(struct ptp_clock_info *, struct ptp_clock_request *, int);
	int (*verify)(struct ptp_clock_info *, unsigned int, enum ptp_pin_function, unsigned int);
	long int (*do_aux_work)(struct ptp_clock_info *);
};

struct clock_identity {
	u8 id[8];
};

struct port_identity {
	struct clock_identity clock_identity;
	__be16 port_number;
};

struct ptp_header {
	u8 tsmt;
	u8 ver;
	__be16 message_length;
	u8 domain_number;
	u8 reserved1;
	u8 flag_field[2];
	__be64 correction;
	__be32 reserved2;
	struct port_identity source_port_identity;
	__be16 sequence_id;
	u8 control;
	u8 log_message_interval;
} __attribute__((packed));

enum hwtstamp_rx_filters {
	HWTSTAMP_FILTER_NONE = 0,
	HWTSTAMP_FILTER_ALL = 1,
	HWTSTAMP_FILTER_SOME = 2,
	HWTSTAMP_FILTER_PTP_V1_L4_EVENT = 3,
	HWTSTAMP_FILTER_PTP_V1_L4_SYNC = 4,
	HWTSTAMP_FILTER_PTP_V1_L4_DELAY_REQ = 5,
	HWTSTAMP_FILTER_PTP_V2_L4_EVENT = 6,
	HWTSTAMP_FILTER_PTP_V2_L4_SYNC = 7,
	HWTSTAMP_FILTER_PTP_V2_L4_DELAY_REQ = 8,
	HWTSTAMP_FILTER_PTP_V2_L2_EVENT = 9,
	HWTSTAMP_FILTER_PTP_V2_L2_SYNC = 10,
	HWTSTAMP_FILTER_PTP_V2_L2_DELAY_REQ = 11,
	HWTSTAMP_FILTER_PTP_V2_EVENT = 12,
	HWTSTAMP_FILTER_PTP_V2_SYNC = 13,
	HWTSTAMP_FILTER_PTP_V2_DELAY_REQ = 14,
	HWTSTAMP_FILTER_NTP_ALL = 15,
	__HWTSTAMP_FILTER_CNT = 16,
};

struct kszphy_hw_stat {
	const char *string;
	u8 reg;
	u8 bits;
};

struct kszphy_type {
	u32 led_mode_reg;
	u16 interrupt_level_mask;
	u16 cable_diag_reg;
	long unsigned int pair_mask;
	bool has_broadcast_disable;
	bool has_nand_tree_disable;
	bool has_rmii_ref_clk_sel;
};

struct ptp_clock;

struct lan8814_shared_priv {
	struct phy_device *phydev;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	u8 ref;
	struct mutex shared_lock;
};

struct lan8814_ptp_rx_ts {
	struct list_head list;
	u32 seconds;
	u32 nsec;
	u16 seq_id;
};

struct kszphy_ptp_priv {
	struct mii_timestamper mii_ts;
	struct phy_device *phydev;
	struct sk_buff_head tx_queue;
	struct sk_buff_head rx_queue;
	struct list_head rx_ts_list;
	spinlock_t rx_ts_lock;
	int hwts_tx_type;
	enum hwtstamp_rx_filters rx_filter;
	int layer;
	int version;
};

struct kszphy_priv {
	struct kszphy_ptp_priv ptp_priv;
	const struct kszphy_type *type;
	int led_mode;
	u16 vct_ctrl1000;
	bool rmii_ref_clk_sel;
	bool rmii_ref_clk_sel_val;
	int: 32;
	u64 stats[2];
};

struct lan88xx_priv {
	int chip_id;
	int chip_rev;
	__u32 wolopts;
};

struct smsc_hw_stat {
	const char *string;
	u8 reg;
	u8 bits;
};

struct smsc_phy_priv {
	u16 intmask;
	bool energy_enable;
};

typedef __u16 __sum16;

struct flow_dissector_key_control {
	u16 thoff;
	u16 addr_type;
	u32 flags;
};

struct flow_dissector_key_basic {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
};

struct flow_dissector {
	unsigned int used_keys;
	short unsigned int offset[31];
};

struct flow_keys_basic {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
};

struct nf_conntrack {
	refcount_t use;
};

enum {
	SKB_GSO_TCPV4 = 1,
	SKB_GSO_DODGY = 2,
	SKB_GSO_TCP_ECN = 4,
	SKB_GSO_TCP_FIXEDID = 8,
	SKB_GSO_TCPV6 = 16,
	SKB_GSO_FCOE = 32,
	SKB_GSO_GRE = 64,
	SKB_GSO_GRE_CSUM = 128,
	SKB_GSO_IPXIP4 = 256,
	SKB_GSO_IPXIP6 = 512,
	SKB_GSO_UDP_TUNNEL = 1024,
	SKB_GSO_UDP_TUNNEL_CSUM = 2048,
	SKB_GSO_PARTIAL = 4096,
	SKB_GSO_TUNNEL_REMCSUM = 8192,
	SKB_GSO_SCTP = 16384,
	SKB_GSO_ESP = 32768,
	SKB_GSO_UDP = 65536,
	SKB_GSO_UDP_L4 = 131072,
	SKB_GSO_FRAGLIST = 262144,
};

struct rt6key {
	struct in6_addr addr;
	int plen;
};

struct rtable;

struct fnhe_hash_bucket;

struct fib_nh_common {
	struct net_device *nhc_dev;
	netdevice_tracker nhc_dev_tracker;
	int nhc_oif;
	unsigned char nhc_scope;
	u8 nhc_family;
	u8 nhc_gw_family;
	unsigned char nhc_flags;
	struct lwtunnel_state *nhc_lwtstate;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} nhc_gw;
	int nhc_weight;
	atomic_t nhc_upper_bound;
	struct rtable **nhc_pcpu_rth_output;
	struct rtable *nhc_rth_input;
	struct fnhe_hash_bucket *nhc_exceptions;
};

struct rt6_exception_bucket;

struct fib6_nh {
	struct fib_nh_common nh_common;
	struct rt6_info **rt6i_pcpu;
	struct rt6_exception_bucket *rt6i_exception_bucket;
};

struct fib6_node;

struct dst_metrics;

struct nexthop;

struct fib6_info {
	struct fib6_table *fib6_table;
	struct fib6_info *fib6_next;
	struct fib6_node *fib6_node;
	union {
		struct list_head fib6_siblings;
		struct list_head nh_list;
	};
	unsigned int fib6_nsiblings;
	refcount_t fib6_ref;
	long unsigned int expires;
	struct dst_metrics *fib6_metrics;
	struct rt6key fib6_dst;
	u32 fib6_flags;
	struct rt6key fib6_src;
	struct rt6key fib6_prefsrc;
	u32 fib6_metric;
	u8 fib6_protocol;
	u8 fib6_type;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	u8 should_flush: 1;
	u8 dst_nocount: 1;
	u8 dst_nopolicy: 1;
	u8 fib6_destroying: 1;
	u8 unused: 4;
	struct callback_head rcu;
	struct nexthop *nh;
	struct fib6_nh fib6_nh[0];
};

struct uncached_list;

struct rt6_info {
	struct dst_entry dst;
	struct fib6_info *from;
	int sernum;
	struct rt6key rt6i_dst;
	struct rt6key rt6i_src;
	struct in6_addr rt6i_gateway;
	struct inet6_dev *rt6i_idev;
	u32 rt6i_flags;
	struct list_head rt6i_uncached;
	struct uncached_list *rt6i_uncached_list;
	short unsigned int rt6i_nfheader_len;
};

struct rt6_statistics {
	__u32 fib_nodes;
	__u32 fib_route_nodes;
	__u32 fib_rt_entries;
	__u32 fib_rt_cache;
	__u32 fib_discarded_routes;
	atomic_t fib_rt_alloc;
};

struct fib6_node {
	struct fib6_node *parent;
	struct fib6_node *left;
	struct fib6_node *right;
	struct fib6_info *leaf;
	__u16 fn_bit;
	__u16 fn_flags;
	int fn_sernum;
	struct fib6_info *rr_ptr;
	struct callback_head rcu;
};

struct fib6_table {
	struct hlist_node tb6_hlist;
	u32 tb6_id;
	spinlock_t tb6_lock;
	struct fib6_node tb6_root;
	struct inet_peer_base tb6_peers;
	unsigned int flags;
	unsigned int fib_seq;
};

enum {
	IFLA_TUN_UNSPEC = 0,
	IFLA_TUN_OWNER = 1,
	IFLA_TUN_GROUP = 2,
	IFLA_TUN_TYPE = 3,
	IFLA_TUN_PI = 4,
	IFLA_TUN_VNET_HDR = 5,
	IFLA_TUN_PERSIST = 6,
	IFLA_TUN_MULTI_QUEUE = 7,
	IFLA_TUN_NUM_QUEUES = 8,
	IFLA_TUN_NUM_DISABLED_QUEUES = 9,
	__IFLA_TUN_MAX = 10,
};

struct gro_list {
	struct list_head list;
	int count;
};

struct napi_struct {
	struct list_head poll_list;
	long unsigned int state;
	int weight;
	int defer_hard_irqs_count;
	long unsigned int gro_bitmask;
	int (*poll)(struct napi_struct *, int);
	struct net_device *dev;
	struct gro_list gro_hash[8];
	struct sk_buff *skb;
	struct list_head rx_list;
	int rx_count;
	struct hrtimer timer;
	struct list_head dev_list;
	struct hlist_node napi_hash_node;
	unsigned int napi_id;
	struct task_struct *thread;
};

enum netdev_queue_state_t {
	__QUEUE_STATE_DRV_XOFF = 0,
	__QUEUE_STATE_STACK_XOFF = 1,
	__QUEUE_STATE_FROZEN = 2,
};

struct rps_sock_flow_table {
	u32 mask;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u32 ents[0];
};

struct iphdr {
	__u8 ihl: 4;
	__u8 version: 4;
	__u8 tos;
	__be16 tot_len;
	__be16 id;
	__be16 frag_off;
	__u8 ttl;
	__u8 protocol;
	__sum16 check;
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
		};
		struct {
			__be32 saddr;
			__be32 daddr;
		} addrs;
	};
};

struct ip_tunnel_parm {
	char name[16];
	int link;
	__be16 i_flags;
	__be16 o_flags;
	__be32 i_key;
	__be32 o_key;
	struct iphdr iph;
};

struct tun_pi {
	__u16 flags;
	__be16 proto;
};

struct tun_filter {
	__u16 flags;
	__u16 count;
	__u8 addr[0];
};

struct virtio_net_hdr {
	__u8 flags;
	__u8 gso_type;
	__virtio16 hdr_len;
	__virtio16 gso_size;
	__virtio16 csum_start;
	__virtio16 csum_offset;
};

struct tun_msg_ctl {
	short unsigned int type;
	short unsigned int num;
	void *ptr;
};

struct tun_xdp_hdr {
	int buflen;
	struct virtio_net_hdr gso;
};

struct dst_metrics {
	u32 metrics[17];
	refcount_t refcnt;
};

struct fib_nh_exception {
	struct fib_nh_exception *fnhe_next;
	int fnhe_genid;
	__be32 fnhe_daddr;
	u32 fnhe_pmtu;
	bool fnhe_mtu_locked;
	__be32 fnhe_gw;
	long unsigned int fnhe_expires;
	struct rtable *fnhe_rth_input;
	struct rtable *fnhe_rth_output;
	long unsigned int fnhe_stamp;
	struct callback_head rcu;
};

struct rtable {
	struct dst_entry dst;
	int rt_genid;
	unsigned int rt_flags;
	__u16 rt_type;
	__u8 rt_is_input;
	__u8 rt_uses_gateway;
	int rt_iif;
	u8 rt_gw_family;
	union {
		__be32 rt_gw4;
		struct in6_addr rt_gw6;
	};
	u32 rt_mtu_locked: 1;
	u32 rt_pmtu: 31;
	struct list_head rt_uncached;
	struct uncached_list *rt_uncached_list;
};

struct fnhe_hash_bucket {
	struct fib_nh_exception *chain;
};

struct fib_info;

struct fib_nh {
	struct fib_nh_common nh_common;
	struct hlist_node nh_hash;
	struct fib_info *nh_parent;
	__u32 nh_tclassid;
	__be32 nh_saddr;
	int nh_saddr_genid;
};

struct fib_info {
	struct hlist_node fib_hash;
	struct hlist_node fib_lhash;
	struct list_head nh_list;
	struct net *fib_net;
	refcount_t fib_treeref;
	refcount_t fib_clntref;
	unsigned int fib_flags;
	unsigned char fib_dead;
	unsigned char fib_protocol;
	unsigned char fib_scope;
	unsigned char fib_type;
	__be32 fib_prefsrc;
	u32 fib_tb_id;
	u32 fib_priority;
	struct dst_metrics *fib_metrics;
	int fib_nhs;
	bool fib_nh_is_v6;
	bool nh_updated;
	struct nexthop *nh;
	struct callback_head rcu;
	struct fib_nh fib_nh[0];
};

struct nh_info;

struct nh_group;

struct nexthop {
	struct rb_node rb_node;
	struct list_head fi_list;
	struct list_head f6i_list;
	struct list_head fdb_list;
	struct list_head grp_list;
	struct net *net;
	u32 id;
	u8 protocol;
	u8 nh_flags;
	bool is_group;
	refcount_t refcnt;
	struct callback_head rcu;
	union {
		struct nh_info *nh_info;
		struct nh_group *nh_grp;
	};
};

struct rt6_exception_bucket {
	struct hlist_head chain;
	int depth;
};

struct nh_info {
	struct hlist_node dev_hash;
	struct nexthop *nh_parent;
	u8 family;
	bool reject_nh;
	bool fdb_nh;
	union {
		struct fib_nh_common fib_nhc;
		struct fib_nh fib_nh;
		struct fib6_nh fib6_nh;
	};
};

struct nh_grp_entry;

struct nh_res_bucket {
	struct nh_grp_entry *nh_entry;
	atomic_long_t used_time;
	long unsigned int migrated_time;
	bool occupied;
	u8 nh_flags;
};

struct nh_grp_entry {
	struct nexthop *nh;
	u8 weight;
	union {
		struct {
			atomic_t upper_bound;
		} hthr;
		struct {
			struct list_head uw_nh_entry;
			u16 count_buckets;
			u16 wants_buckets;
		} res;
	};
	struct list_head nh_list;
	struct nexthop *nh_parent;
};

struct nh_res_table {
	struct net *net;
	u32 nhg_id;
	struct delayed_work upkeep_dw;
	struct list_head uw_nh_entries;
	long unsigned int unbalanced_since;
	u32 idle_timer;
	u32 unbalanced_timer;
	u16 num_nh_buckets;
	struct nh_res_bucket nh_buckets[0];
};

struct nh_group {
	struct nh_group *spare;
	u16 num_nh;
	bool is_multipath;
	bool hash_threshold;
	bool resilient;
	bool fdb_nh;
	bool has_v4;
	struct nh_res_table *res_table;
	struct nh_grp_entry nh_entries[0];
};

enum {
	AX25_VALUES_IPDEFMODE = 0,
	AX25_VALUES_AXDEFMODE = 1,
	AX25_VALUES_BACKOFF = 2,
	AX25_VALUES_CONMODE = 3,
	AX25_VALUES_WINDOW = 4,
	AX25_VALUES_EWINDOW = 5,
	AX25_VALUES_T1 = 6,
	AX25_VALUES_T2 = 7,
	AX25_VALUES_T3 = 8,
	AX25_VALUES_IDLE = 9,
	AX25_VALUES_N2 = 10,
	AX25_VALUES_PACLEN = 11,
	AX25_VALUES_PROTOCOL = 12,
	AX25_VALUES_DS_TIMEOUT = 13,
	AX25_MAX_VALUES = 14,
};

struct tap_filter {
	unsigned int count;
	u32 mask[2];
	unsigned char addr[48];
};

struct tun_struct;

struct tun_file {
	struct sock sk;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct socket socket;
	struct tun_struct *tun;
	struct fasync_struct *fasync;
	unsigned int flags;
	union {
		u16 queue_index;
		unsigned int ifindex;
	};
	struct napi_struct napi;
	bool napi_enabled;
	bool napi_frags_enabled;
	struct mutex napi_mutex;
	struct list_head next;
	struct tun_struct *detached;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct ptr_ring tx_ring;
	struct xdp_rxq_info xdp_rxq;
};

struct tun_prog;

struct tun_struct {
	struct tun_file *tfiles[256];
	unsigned int numqueues;
	unsigned int flags;
	kuid_t owner;
	kgid_t group;
	struct net_device *dev;
	int: 32;
	netdev_features_t set_features;
	int align;
	int vnet_hdr_sz;
	int sndbuf;
	struct tap_filter txflt;
	struct sock_fprog fprog;
	bool filter_attached;
	u32 msg_enable;
	spinlock_t lock;
	struct hlist_head flows[1024];
	struct timer_list flow_gc_timer;
	long unsigned int ageing_time;
	unsigned int numdisabled;
	struct list_head disabled;
	void *security;
	u32 flow_count;
	u32 rx_batched;
	atomic_long_t rx_frame_errors;
	struct bpf_prog *xdp_prog;
	struct tun_prog *steering_prog;
	struct tun_prog *filter_prog;
	struct ethtool_link_ksettings link_ksettings;
	struct file *file;
	struct ifreq *ifr;
	int: 32;
};

struct tun_page {
	struct page *page;
	int count;
};

struct tun_flow_entry {
	struct hlist_node hash_link;
	struct callback_head rcu;
	struct tun_struct *tun;
	u32 rxhash;
	u32 rps_rxhash;
	int queue_index;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int updated;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct tun_prog {
	struct callback_head rcu;
	struct bpf_prog *prog;
};

struct veth {
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
};

typedef __u32 canid_t;

struct can_frame {
	canid_t can_id;
	union {
		__u8 len;
		__u8 can_dlc;
	};
	__u8 __pad;
	__u8 __res0;
	__u8 len8_dlc;
	__u8 data[8];
};

struct canfd_frame {
	canid_t can_id;
	__u8 len;
	__u8 flags;
	__u8 __res0;
	__u8 __res1;
	__u8 data[64];
};

struct canxl_frame {
	canid_t prio;
	__u8 flags;
	__u8 sdt;
	__u16 len;
	__u32 af;
	__u8 data[2048];
};

enum skb_free_reason {
	SKB_REASON_CONSUMED = 0,
	SKB_REASON_DROPPED = 1,
};

struct can_bittiming {
	__u32 bitrate;
	__u32 sample_point;
	__u32 tq;
	__u32 prop_seg;
	__u32 phase_seg1;
	__u32 phase_seg2;
	__u32 sjw;
	__u32 brp;
};

struct can_bittiming_const {
	char name[16];
	__u32 tseg1_min;
	__u32 tseg1_max;
	__u32 tseg2_min;
	__u32 tseg2_max;
	__u32 sjw_max;
	__u32 brp_min;
	__u32 brp_max;
	__u32 brp_inc;
};

struct can_clock {
	__u32 freq;
};

enum can_state {
	CAN_STATE_ERROR_ACTIVE = 0,
	CAN_STATE_ERROR_WARNING = 1,
	CAN_STATE_ERROR_PASSIVE = 2,
	CAN_STATE_BUS_OFF = 3,
	CAN_STATE_STOPPED = 4,
	CAN_STATE_SLEEPING = 5,
	CAN_STATE_MAX = 6,
};

struct can_berr_counter {
	__u16 txerr;
	__u16 rxerr;
};

struct can_device_stats {
	__u32 bus_error;
	__u32 error_warning;
	__u32 error_passive;
	__u32 bus_off;
	__u32 arbitration_lost;
	__u32 restarts;
};

struct can_tdc {
	u32 tdcv;
	u32 tdco;
	u32 tdcf;
};

struct can_tdc_const {
	u32 tdcv_min;
	u32 tdcv_max;
	u32 tdco_min;
	u32 tdco_max;
	u32 tdcf_min;
	u32 tdcf_max;
};

struct can_skb_priv {
	int ifindex;
	int skbcnt;
	unsigned int frame_len;
	int: 32;
	struct can_frame cf[0];
};

enum can_mode {
	CAN_MODE_STOP = 0,
	CAN_MODE_START = 1,
	CAN_MODE_SLEEP = 2,
};

enum can_termination_gpio {
	CAN_TERMINATION_GPIO_DISABLED = 0,
	CAN_TERMINATION_GPIO_ENABLED = 1,
	CAN_TERMINATION_GPIO_MAX = 2,
};

struct can_priv {
	struct net_device *dev;
	struct can_device_stats can_stats;
	const struct can_bittiming_const *bittiming_const;
	const struct can_bittiming_const *data_bittiming_const;
	struct can_bittiming bittiming;
	struct can_bittiming data_bittiming;
	const struct can_tdc_const *tdc_const;
	struct can_tdc tdc;
	unsigned int bitrate_const_cnt;
	const u32 *bitrate_const;
	const u32 *data_bitrate_const;
	unsigned int data_bitrate_const_cnt;
	u32 bitrate_max;
	struct can_clock clock;
	unsigned int termination_const_cnt;
	const u16 *termination_const;
	u16 termination;
	struct gpio_desc *termination_gpio;
	u16 termination_gpio_ohms[2];
	unsigned int echo_skb_max;
	struct sk_buff **echo_skb;
	enum can_state state;
	u32 ctrlmode;
	u32 ctrlmode_supported;
	int restart_ms;
	struct delayed_work restart_work;
	int (*do_set_bittiming)(struct net_device *);
	int (*do_set_data_bittiming)(struct net_device *);
	int (*do_set_mode)(struct net_device *, enum can_mode);
	int (*do_set_termination)(struct net_device *, u16);
	int (*do_get_state)(const struct net_device *, enum can_state *);
	int (*do_get_berr_counter)(const struct net_device *, struct can_berr_counter *);
	int (*do_get_auto_tdcv)(const struct net_device *, u32 *);
};

struct can_dev_rcv_lists {
	struct hlist_head rx[4];
	struct hlist_head rx_sff[2048];
	struct hlist_head rx_eff[1024];
	int entries;
};

enum {
	RX_ERR = 0,
	RX_ALL = 1,
	RX_FIL = 2,
	RX_INV = 3,
	RX_MAX = 4,
};

struct j1939_priv;

struct can_ml_priv {
	struct can_dev_rcv_lists dev_rcv_lists;
	struct j1939_priv *j1939_priv;
};

enum {
	SOF_TIMESTAMPING_TX_HARDWARE = 1,
	SOF_TIMESTAMPING_TX_SOFTWARE = 2,
	SOF_TIMESTAMPING_RX_HARDWARE = 4,
	SOF_TIMESTAMPING_RX_SOFTWARE = 8,
	SOF_TIMESTAMPING_SOFTWARE = 16,
	SOF_TIMESTAMPING_SYS_HARDWARE = 32,
	SOF_TIMESTAMPING_RAW_HARDWARE = 64,
	SOF_TIMESTAMPING_OPT_ID = 128,
	SOF_TIMESTAMPING_TX_SCHED = 256,
	SOF_TIMESTAMPING_TX_ACK = 512,
	SOF_TIMESTAMPING_OPT_CMSG = 1024,
	SOF_TIMESTAMPING_OPT_TSONLY = 2048,
	SOF_TIMESTAMPING_OPT_STATS = 4096,
	SOF_TIMESTAMPING_OPT_PKTINFO = 8192,
	SOF_TIMESTAMPING_OPT_TX_SWHW = 16384,
	SOF_TIMESTAMPING_BIND_PHC = 32768,
	SOF_TIMESTAMPING_LAST = 32768,
	SOF_TIMESTAMPING_MASK = 65535,
};

struct hwtstamp_config {
	int flags;
	int tx_type;
	int rx_filter;
};

enum hwtstamp_tx_types {
	HWTSTAMP_TX_OFF = 0,
	HWTSTAMP_TX_ON = 1,
	HWTSTAMP_TX_ONESTEP_SYNC = 2,
	HWTSTAMP_TX_ONESTEP_P2P = 3,
	__HWTSTAMP_TX_CNT = 4,
};

enum {
	IFLA_INFO_UNSPEC = 0,
	IFLA_INFO_KIND = 1,
	IFLA_INFO_DATA = 2,
	IFLA_INFO_XSTATS = 3,
	IFLA_INFO_SLAVE_KIND = 4,
	IFLA_INFO_SLAVE_DATA = 5,
	__IFLA_INFO_MAX = 6,
};

struct can_ctrlmode {
	__u32 mask;
	__u32 flags;
};

enum {
	IFLA_CAN_UNSPEC = 0,
	IFLA_CAN_BITTIMING = 1,
	IFLA_CAN_BITTIMING_CONST = 2,
	IFLA_CAN_CLOCK = 3,
	IFLA_CAN_STATE = 4,
	IFLA_CAN_CTRLMODE = 5,
	IFLA_CAN_RESTART_MS = 6,
	IFLA_CAN_RESTART = 7,
	IFLA_CAN_BERR_COUNTER = 8,
	IFLA_CAN_DATA_BITTIMING = 9,
	IFLA_CAN_DATA_BITTIMING_CONST = 10,
	IFLA_CAN_TERMINATION = 11,
	IFLA_CAN_TERMINATION_CONST = 12,
	IFLA_CAN_BITRATE_CONST = 13,
	IFLA_CAN_DATA_BITRATE_CONST = 14,
	IFLA_CAN_BITRATE_MAX = 15,
	IFLA_CAN_TDC = 16,
	IFLA_CAN_CTRLMODE_EXT = 17,
	__IFLA_CAN_MAX = 18,
	IFLA_CAN_MAX = 17,
};

enum {
	IFLA_CAN_TDC_UNSPEC = 0,
	IFLA_CAN_TDC_TDCV_MIN = 1,
	IFLA_CAN_TDC_TDCV_MAX = 2,
	IFLA_CAN_TDC_TDCO_MIN = 3,
	IFLA_CAN_TDC_TDCO_MAX = 4,
	IFLA_CAN_TDC_TDCF_MIN = 5,
	IFLA_CAN_TDC_TDCF_MAX = 6,
	IFLA_CAN_TDC_TDCV = 7,
	IFLA_CAN_TDC_TDCO = 8,
	IFLA_CAN_TDC_TDCF = 9,
	__IFLA_CAN_TDC = 10,
	IFLA_CAN_TDC_MAX = 9,
};

enum {
	IFLA_CAN_CTRLMODE_UNSPEC = 0,
	IFLA_CAN_CTRLMODE_SUPPORTED = 1,
	__IFLA_CAN_CTRLMODE = 2,
	IFLA_CAN_CTRLMODE_MAX = 1,
};

struct can_rx_offload {
	struct net_device *dev;
	struct sk_buff * (*mailbox_read)(struct can_rx_offload *, unsigned int, u32 *, bool);
	struct sk_buff_head skb_queue;
	struct sk_buff_head skb_irq_queue;
	u32 skb_queue_len_max;
	unsigned int mb_first;
	unsigned int mb_last;
	int: 32;
	struct napi_struct napi;
	bool inc;
	int: 24;
	int: 32;
};

struct can_rx_offload_cb {
	u32 timestamp;
};

struct flexcan_platform_data {
	u32 clock_frequency;
	u8 clk_src;
};

struct flexcan_devtype_data {
	u32 quirks;
};

struct flexcan_stop_mode {
	struct regmap *gpr;
	u8 req_gpr;
	u8 req_bit;
};

struct imx_sc_ipc;

struct flexcan_regs;

struct flexcan_mb;

struct flexcan_priv {
	struct can_priv can;
	struct can_rx_offload offload;
	struct device *dev;
	struct flexcan_regs *regs;
	struct flexcan_mb *tx_mb;
	struct flexcan_mb *tx_mb_reserved;
	u8 tx_mb_idx;
	u8 mb_count;
	u8 mb_size;
	u8 clk_src;
	u8 scu_idx;
	u64 rx_mask;
	u64 tx_mask;
	u32 reg_ctrl_default;
	struct clk *clk_ipg;
	struct clk *clk_per;
	struct flexcan_devtype_data devtype_data;
	struct regulator *reg_xceiver;
	struct flexcan_stop_mode stm;
	int irq_boff;
	int irq_err;
	struct imx_sc_ipc *sc_ipc_handle;
	u32 (*read)(void *);
	void (*write)(u32, void *);
};

struct flexcan_regs {
	u32 mcr;
	u32 ctrl;
	u32 timer;
	u32 tcr;
	u32 rxgmask;
	u32 rx14mask;
	u32 rx15mask;
	u32 ecr;
	u32 esr;
	u32 imask2;
	u32 imask1;
	u32 iflag2;
	u32 iflag1;
	union {
		u32 gfwr_mx28;
		u32 ctrl2;
	};
	u32 esr2;
	u32 imeur;
	u32 lrfr;
	u32 crcr;
	u32 rxfgmask;
	u32 rxfir;
	u32 cbt;
	u32 _reserved2;
	u32 dbg1;
	u32 dbg2;
	u32 _reserved3[8];
	union {
		struct {
			u8 mb[1024];
			u32 _reserved4[256];
			u32 rximr[64];
			u32 _reserved5[24];
			u32 gfwr_mx6;
			u32 _reserved6[39];
			u32 _rxfir[6];
			u32 _reserved8[2];
			u32 _rxmgmask;
			u32 _rxfgmask;
			u32 _rx14mask;
			u32 _rx15mask;
			u32 tx_smb[4];
			u32 rx_smb0[4];
			u32 rx_smb1[4];
		};
		struct {
			u8 mb[1024];
			u32 _reserved4[256];
			u32 rximr[64];
			u32 _reserved5[24];
			u32 gfwr_mx6;
			u32 _reserved6[39];
			u32 _rxfir[6];
			u32 _reserved8[2];
			u32 _rxmgmask;
			u32 _rxfgmask;
			u32 _rx14mask;
			u32 _rx15mask;
			u32 tx_smb[4];
			u32 rx_smb0[4];
			u32 rx_smb1[4];
		} init;
	};
	u32 mecr;
	u32 erriar;
	u32 erridpr;
	u32 errippr;
	u32 rerrar;
	u32 rerrdr;
	u32 rerrsynr;
	u32 errsr;
	u32 _reserved7[64];
	u32 fdctrl;
	u32 fdcbt;
	u32 fdcrc;
	u32 _reserved9[199];
	union {
		struct {
			u32 tx_smb_fd[18];
			u32 rx_smb0_fd[18];
			u32 rx_smb1_fd[18];
		};
		struct {
			u32 tx_smb_fd[18];
			u32 rx_smb0_fd[18];
			u32 rx_smb1_fd[18];
		} init_fd;
	};
};

struct flexcan_mb {
	u32 can_ctrl;
	u32 can_id;
	u32 data[0];
};

enum ethtool_stringset {
	ETH_SS_TEST = 0,
	ETH_SS_STATS = 1,
	ETH_SS_PRIV_FLAGS = 2,
	ETH_SS_NTUPLE_FILTERS = 3,
	ETH_SS_FEATURES = 4,
	ETH_SS_RSS_HASH_FUNCS = 5,
	ETH_SS_TUNABLES = 6,
	ETH_SS_PHY_STATS = 7,
	ETH_SS_PHY_TUNABLES = 8,
	ETH_SS_LINK_MODES = 9,
	ETH_SS_MSG_CLASSES = 10,
	ETH_SS_WOL_MODES = 11,
	ETH_SS_SOF_TIMESTAMPING = 12,
	ETH_SS_TS_TX_TYPES = 13,
	ETH_SS_TS_RX_FILTERS = 14,
	ETH_SS_UDP_TUNNEL_TYPES = 15,
	ETH_SS_STATS_STD = 16,
	ETH_SS_STATS_ETH_PHY = 17,
	ETH_SS_STATS_ETH_MAC = 18,
	ETH_SS_STATS_ETH_CTRL = 19,
	ETH_SS_STATS_RMON = 20,
	ETH_SS_COUNT = 21,
};

struct net_local {
	int chip_type;
	char chip_revision;
	int send_cmd;
	int auto_neg_cnf;
	int adapter_cnf;
	int isa_config;
	int irq_map;
	int rx_mode;
	int curr_rx_cfg;
	int linectl;
	int send_underrun;
	int force;
	spinlock_t lock;
	void *virt_addr;
};

struct page_pool_stats {
	struct page_pool_alloc_stats alloc_stats;
	struct page_pool_recycle_stats recycle_stats;
};

struct netdev_hw_addr {
	struct list_head list;
	struct rb_node node;
	unsigned char addr[32];
	unsigned char type;
	bool global_use;
	int sync_cnt;
	int refcount;
	int synced;
	struct callback_head callback_head;
};

struct tcphdr {
	__be16 source;
	__be16 dest;
	__be32 seq;
	__be32 ack_seq;
	__u16 res1: 4;
	__u16 doff: 4;
	__u16 fin: 1;
	__u16 syn: 1;
	__u16 rst: 1;
	__u16 psh: 1;
	__u16 ack: 1;
	__u16 urg: 1;
	__u16 ece: 1;
	__u16 cwr: 1;
	__be16 window;
	__sum16 check;
	__be16 urg_ptr;
};

enum tunable_id {
	ETHTOOL_ID_UNSPEC = 0,
	ETHTOOL_RX_COPYBREAK = 1,
	ETHTOOL_TX_COPYBREAK = 2,
	ETHTOOL_PFC_PREVENTION_TOUT = 3,
	ETHTOOL_TX_COPYBREAK_BUF_SIZE = 4,
	__ETHTOOL_TUNABLE_COUNT = 5,
};

struct tso_t {
	int next_frag_idx;
	int size;
	void *data;
	u16 ip_id;
	u8 tlen;
	bool ipv6;
	u32 tcp_seq;
};

struct fec_platform_data {
	phy_interface_t phy;
	unsigned char mac[6];
	void (*sleep_mode_enable)(int);
};

struct vlan_hdr {
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct vlan_ethhdr {
	union {
		struct {
			unsigned char h_dest[6];
			unsigned char h_source[6];
		};
		struct {
			unsigned char h_dest[6];
			unsigned char h_source[6];
		} addrs;
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__be16 h_vlan_encapsulated_proto;
};

struct bufdesc {
	__le16 cbd_datlen;
	__le16 cbd_sc;
	__le32 cbd_bufaddr;
};

struct bufdesc_ex {
	struct bufdesc desc;
	__le32 cbd_esc;
	__le32 cbd_prot;
	__le32 cbd_bdu;
	__le32 ts;
	__le16 res0[4];
};

struct bufdesc_prop {
	int qid;
	struct bufdesc *base;
	struct bufdesc *last;
	struct bufdesc *cur;
	void *reg_desc_active;
	dma_addr_t dma;
	short unsigned int ring_size;
	unsigned char dsize;
	unsigned char dsize_log2;
};

struct fec_enet_priv_txrx_info {
	int offset;
	struct page *page;
	struct sk_buff *skb;
};

enum {
	RX_XDP_REDIRECT = 0,
	RX_XDP_PASS = 1,
	RX_XDP_DROP = 2,
	RX_XDP_TX = 3,
	RX_XDP_TX_ERRORS = 4,
	TX_XDP_XMIT = 5,
	TX_XDP_XMIT_ERRORS = 6,
	XDP_STATS_TOTAL = 7,
};

struct fec_enet_priv_tx_q {
	struct bufdesc_prop bd;
	unsigned char *tx_bounce[512];
	struct sk_buff *tx_skbuff[512];
	short unsigned int tx_stop_threshold;
	short unsigned int tx_wake_threshold;
	struct bufdesc *dirty_tx;
	char *tso_hdrs;
	dma_addr_t tso_hdrs_dma;
};

struct fec_enet_priv_rx_q {
	struct bufdesc_prop bd;
	struct fec_enet_priv_txrx_info rx_skb_info[256];
	struct page_pool *page_pool;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct xdp_rxq_info xdp_rxq;
	u32 stats[7];
	u8 id;
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct fec_stop_mode_gpr {
	struct regmap *gpr;
	u8 reg;
	u8 bit;
};

struct fec_enet_private {
	void *hwp;
	struct net_device *netdev;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_ref;
	struct clk *clk_enet_out;
	struct clk *clk_ptp;
	struct clk *clk_2x_txclk;
	bool ptp_clk_on;
	struct mutex ptp_clk_mutex;
	unsigned int num_tx_queues;
	unsigned int num_rx_queues;
	struct fec_enet_priv_tx_q *tx_queue[3];
	struct fec_enet_priv_rx_q *rx_queue[3];
	unsigned int total_tx_ring_size;
	unsigned int total_rx_ring_size;
	struct platform_device *pdev;
	int dev_id;
	struct mii_bus *mii_bus;
	uint phy_speed;
	phy_interface_t phy_interface;
	struct device_node *phy_node;
	bool rgmii_txc_dly;
	bool rgmii_rxc_dly;
	bool rpm_active;
	bool mii_bus_share;
	int link;
	int full_duplex;
	int speed;
	int irq[3];
	bool bufdesc_ex;
	int pause_flag;
	int wol_flag;
	int wake_irq;
	u32 quirks;
	struct napi_struct napi;
	int csum_flags;
	struct work_struct tx_timeout_work;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_caps;
	long unsigned int last_overflow_check;
	spinlock_t tmreg_lock;
	struct cyclecounter cc;
	struct timecounter tc;
	int rx_hwtstamp_filter;
	u32 base_incval;
	u32 cycle_speed;
	int hwts_rx_en;
	int hwts_tx_en;
	struct delayed_work time_keep;
	struct regulator *reg_phy;
	struct fec_stop_mode_gpr stop_gpr;
	struct pm_qos_request pm_qos_req;
	unsigned int tx_align;
	unsigned int rx_align;
	unsigned int rx_pkts_itr;
	unsigned int rx_time_itr;
	unsigned int tx_pkts_itr;
	unsigned int tx_time_itr;
	unsigned int itr_clk_rate;
	struct ethtool_eee eee;
	unsigned int clk_ref_rate;
	u32 rx_copybreak;
	unsigned int ptp_inc;
	int pps_channel;
	unsigned int reload_period;
	int pps_enable;
	unsigned int next_counter;
	int: 32;
	struct hrtimer perout_timer;
	u64 perout_stime;
	struct imx_sc_ipc *ipc_handle;
	struct bpf_prog *xdp_prog;
	u64 ethtool_stats[0];
};

struct fec_devinfo {
	u32 quirks;
};

enum imx_fec_type {
	IMX25_FEC = 1,
	IMX27_FEC = 2,
	IMX28_FEC = 3,
	IMX6Q_FEC = 4,
	MVF600_FEC = 5,
	IMX6SX_FEC = 6,
	IMX6UL_FEC = 7,
	IMX8MQ_FEC = 8,
	IMX8QM_FEC = 9,
	S32V234_FEC = 10,
};

struct fec_stat {
	char name[32];
	u16 offset;
};

struct pps_event_time {
	struct timespec64 ts_real;
};

enum ptp_clock_events {
	PTP_CLOCK_ALARM = 0,
	PTP_CLOCK_EXTTS = 1,
	PTP_CLOCK_PPS = 2,
	PTP_CLOCK_PPSUSR = 3,
};

struct ptp_clock_event {
	int type;
	int index;
	union {
		u64 timestamp;
		struct pps_event_time pps_times;
	};
};

enum e1000_mac_type {
	e1000_82571 = 0,
	e1000_82572 = 1,
	e1000_82573 = 2,
	e1000_82574 = 3,
	e1000_82583 = 4,
	e1000_80003es2lan = 5,
	e1000_ich8lan = 6,
	e1000_ich9lan = 7,
	e1000_ich10lan = 8,
	e1000_pchlan = 9,
	e1000_pch2lan = 10,
	e1000_pch_lpt = 11,
	e1000_pch_spt = 12,
	e1000_pch_cnp = 13,
	e1000_pch_tgp = 14,
	e1000_pch_adp = 15,
	e1000_pch_mtp = 16,
	e1000_pch_lnp = 17,
};

enum e1000_media_type {
	e1000_media_type_unknown = 0,
	e1000_media_type_copper = 1,
	e1000_media_type_fiber = 2,
	e1000_media_type_internal_serdes = 3,
	e1000_num_media_types = 4,
};

enum e1000_nvm_type {
	e1000_nvm_unknown = 0,
	e1000_nvm_none = 1,
	e1000_nvm_eeprom_spi = 2,
	e1000_nvm_flash_hw = 3,
	e1000_nvm_flash_sw = 4,
};

enum e1000_nvm_override {
	e1000_nvm_override_none = 0,
	e1000_nvm_override_spi_small = 1,
	e1000_nvm_override_spi_large = 2,
};

enum e1000_phy_type {
	e1000_phy_unknown = 0,
	e1000_phy_none = 1,
	e1000_phy_m88 = 2,
	e1000_phy_igp = 3,
	e1000_phy_igp_2 = 4,
	e1000_phy_gg82563 = 5,
	e1000_phy_igp_3 = 6,
	e1000_phy_ife = 7,
	e1000_phy_bm = 8,
	e1000_phy_82578 = 9,
	e1000_phy_82577 = 10,
	e1000_phy_82579 = 11,
	e1000_phy_i217 = 12,
};

enum e1000_bus_width {
	e1000_bus_width_unknown = 0,
	e1000_bus_width_pcie_x1 = 1,
	e1000_bus_width_pcie_x2 = 2,
	e1000_bus_width_pcie_x4 = 4,
	e1000_bus_width_pcie_x8 = 8,
	e1000_bus_width_32 = 9,
	e1000_bus_width_64 = 10,
	e1000_bus_width_reserved = 11,
};

enum e1000_1000t_rx_status {
	e1000_1000t_rx_status_not_ok = 0,
	e1000_1000t_rx_status_ok = 1,
	e1000_1000t_rx_status_undefined = 255,
};

enum e1000_rev_polarity {
	e1000_rev_polarity_normal = 0,
	e1000_rev_polarity_reversed = 1,
	e1000_rev_polarity_undefined = 255,
};

enum e1000_fc_mode {
	e1000_fc_none = 0,
	e1000_fc_rx_pause = 1,
	e1000_fc_tx_pause = 2,
	e1000_fc_full = 3,
	e1000_fc_default = 255,
};

enum e1000_ms_type {
	e1000_ms_hw_default = 0,
	e1000_ms_force_master = 1,
	e1000_ms_force_slave = 2,
	e1000_ms_auto = 3,
};

enum e1000_smart_speed {
	e1000_smart_speed_default = 0,
	e1000_smart_speed_on = 1,
	e1000_smart_speed_off = 2,
};

enum e1000_serdes_link_state {
	e1000_serdes_link_down = 0,
	e1000_serdes_link_autoneg_progress = 1,
	e1000_serdes_link_autoneg_complete = 2,
	e1000_serdes_link_forced_up = 3,
};

struct e1000_hw_stats {
	u64 crcerrs;
	u64 algnerrc;
	u64 symerrs;
	u64 rxerrc;
	u64 mpc;
	u64 scc;
	u64 ecol;
	u64 mcc;
	u64 latecol;
	u64 colc;
	u64 dc;
	u64 tncrs;
	u64 sec;
	u64 cexterr;
	u64 rlec;
	u64 xonrxc;
	u64 xontxc;
	u64 xoffrxc;
	u64 xofftxc;
	u64 fcruc;
	u64 prc64;
	u64 prc127;
	u64 prc255;
	u64 prc511;
	u64 prc1023;
	u64 prc1522;
	u64 gprc;
	u64 bprc;
	u64 mprc;
	u64 gptc;
	u64 gorc;
	u64 gotc;
	u64 rnbc;
	u64 ruc;
	u64 rfc;
	u64 roc;
	u64 rjc;
	u64 mgprc;
	u64 mgpdc;
	u64 mgptc;
	u64 tor;
	u64 tot;
	u64 tpr;
	u64 tpt;
	u64 ptc64;
	u64 ptc127;
	u64 ptc255;
	u64 ptc511;
	u64 ptc1023;
	u64 ptc1522;
	u64 mptc;
	u64 bptc;
	u64 tsctc;
	u64 tsctfc;
	u64 iac;
	u64 icrxptc;
	u64 icrxatc;
	u64 ictxptc;
	u64 ictxatc;
	u64 ictxqec;
	u64 ictxqmtc;
	u64 icrxdmtc;
	u64 icrxoc;
};

struct e1000_phy_stats {
	u32 idle_errors;
	u32 receive_errors;
};

struct e1000_host_mng_dhcp_cookie {
	u32 signature;
	u8 status;
	u8 reserved0;
	u16 vlan_id;
	u32 reserved1;
	u16 reserved2;
	u8 reserved3;
	u8 checksum;
};

struct e1000_hw;

struct e1000_mac_operations {
	s32 (*id_led_init)(struct e1000_hw *);
	s32 (*blink_led)(struct e1000_hw *);
	bool (*check_mng_mode)(struct e1000_hw *);
	s32 (*check_for_link)(struct e1000_hw *);
	s32 (*cleanup_led)(struct e1000_hw *);
	void (*clear_hw_cntrs)(struct e1000_hw *);
	void (*clear_vfta)(struct e1000_hw *);
	s32 (*get_bus_info)(struct e1000_hw *);
	void (*set_lan_id)(struct e1000_hw *);
	s32 (*get_link_up_info)(struct e1000_hw *, u16 *, u16 *);
	s32 (*led_on)(struct e1000_hw *);
	s32 (*led_off)(struct e1000_hw *);
	void (*update_mc_addr_list)(struct e1000_hw *, u8 *, u32);
	s32 (*reset_hw)(struct e1000_hw *);
	s32 (*init_hw)(struct e1000_hw *);
	s32 (*setup_link)(struct e1000_hw *);
	s32 (*setup_physical_interface)(struct e1000_hw *);
	s32 (*setup_led)(struct e1000_hw *);
	void (*write_vfta)(struct e1000_hw *, u32, u32);
	void (*config_collision_dist)(struct e1000_hw *);
	int (*rar_set)(struct e1000_hw *, u8 *, u32);
	s32 (*read_mac_addr)(struct e1000_hw *);
	u32 (*rar_get_count)(struct e1000_hw *);
};

struct e1000_mac_info {
	struct e1000_mac_operations ops;
	u8 addr[6];
	u8 perm_addr[6];
	enum e1000_mac_type type;
	u32 collision_delta;
	u32 ledctl_default;
	u32 ledctl_mode1;
	u32 ledctl_mode2;
	u32 mc_filter_type;
	u32 tx_packet_delta;
	u32 txcw;
	u16 current_ifs_val;
	u16 ifs_max_val;
	u16 ifs_min_val;
	u16 ifs_ratio;
	u16 ifs_step_size;
	u16 mta_reg_count;
	u32 mta_shadow[128];
	u16 rar_entry_count;
	u8 forced_speed_duplex;
	bool adaptive_ifs;
	bool has_fwsm;
	bool arc_subsystem_valid;
	bool autoneg;
	bool autoneg_failed;
	bool get_link_status;
	bool in_ifs_mode;
	bool serdes_has_link;
	bool tx_pkt_filtering;
	enum e1000_serdes_link_state serdes_link_state;
};

struct e1000_fc_info {
	u32 high_water;
	u32 low_water;
	u16 pause_time;
	u16 refresh_time;
	bool send_xon;
	bool strict_ieee;
	enum e1000_fc_mode current_mode;
	enum e1000_fc_mode requested_mode;
};

struct e1000_phy_operations {
	s32 (*acquire)(struct e1000_hw *);
	s32 (*cfg_on_link_up)(struct e1000_hw *);
	s32 (*check_polarity)(struct e1000_hw *);
	s32 (*check_reset_block)(struct e1000_hw *);
	s32 (*commit)(struct e1000_hw *);
	s32 (*force_speed_duplex)(struct e1000_hw *);
	s32 (*get_cfg_done)(struct e1000_hw *);
	s32 (*get_cable_length)(struct e1000_hw *);
	s32 (*get_info)(struct e1000_hw *);
	s32 (*set_page)(struct e1000_hw *, u16);
	s32 (*read_reg)(struct e1000_hw *, u32, u16 *);
	s32 (*read_reg_locked)(struct e1000_hw *, u32, u16 *);
	s32 (*read_reg_page)(struct e1000_hw *, u32, u16 *);
	void (*release)(struct e1000_hw *);
	s32 (*reset)(struct e1000_hw *);
	s32 (*set_d0_lplu_state)(struct e1000_hw *, bool);
	s32 (*set_d3_lplu_state)(struct e1000_hw *, bool);
	s32 (*write_reg)(struct e1000_hw *, u32, u16);
	s32 (*write_reg_locked)(struct e1000_hw *, u32, u16);
	s32 (*write_reg_page)(struct e1000_hw *, u32, u16);
	void (*power_up)(struct e1000_hw *);
	void (*power_down)(struct e1000_hw *);
};

struct e1000_phy_info {
	struct e1000_phy_operations ops;
	enum e1000_phy_type type;
	enum e1000_1000t_rx_status local_rx;
	enum e1000_1000t_rx_status remote_rx;
	enum e1000_ms_type ms_type;
	enum e1000_ms_type original_ms_type;
	enum e1000_rev_polarity cable_polarity;
	enum e1000_smart_speed smart_speed;
	u32 addr;
	u32 id;
	u32 reset_delay_us;
	u32 revision;
	enum e1000_media_type media_type;
	u16 autoneg_advertised;
	u16 autoneg_mask;
	u16 cable_length;
	u16 max_cable_length;
	u16 min_cable_length;
	u8 mdix;
	bool disable_polarity_correction;
	bool is_mdix;
	bool polarity_correction;
	bool speed_downgraded;
	bool autoneg_wait_to_complete;
};

struct e1000_nvm_operations {
	s32 (*acquire)(struct e1000_hw *);
	s32 (*read)(struct e1000_hw *, u16, u16, u16 *);
	void (*release)(struct e1000_hw *);
	void (*reload)(struct e1000_hw *);
	s32 (*update)(struct e1000_hw *);
	s32 (*valid_led_default)(struct e1000_hw *, u16 *);
	s32 (*validate)(struct e1000_hw *);
	s32 (*write)(struct e1000_hw *, u16, u16, u16 *);
};

struct e1000_nvm_info {
	struct e1000_nvm_operations ops;
	enum e1000_nvm_type type;
	enum e1000_nvm_override override;
	u32 flash_bank_size;
	u32 flash_base_addr;
	u16 word_size;
	u16 delay_usec;
	u16 address_bits;
	u16 opcode_bits;
	u16 page_size;
};

struct e1000_bus_info {
	enum e1000_bus_width width;
	u16 func;
};

struct e1000_dev_spec_82571 {
	bool laa_is_present;
	u32 smb_counter;
};

struct e1000_dev_spec_80003es2lan {
	bool mdic_wa_enable;
};

struct e1000_shadow_ram {
	u16 value;
	bool modified;
};

enum e1000_ulp_state {
	e1000_ulp_state_unknown = 0,
	e1000_ulp_state_off = 1,
	e1000_ulp_state_on = 2,
};

struct e1000_dev_spec_ich8lan {
	bool kmrn_lock_loss_workaround_enabled;
	struct e1000_shadow_ram shadow_ram[2048];
	bool nvm_k1_enabled;
	bool eee_disable;
	u16 eee_lp_ability;
	enum e1000_ulp_state ulp_state;
};

struct e1000_adapter;

struct e1000_hw {
	struct e1000_adapter *adapter;
	void *hw_addr;
	void *flash_address;
	struct e1000_mac_info mac;
	struct e1000_fc_info fc;
	struct e1000_phy_info phy;
	struct e1000_nvm_info nvm;
	struct e1000_bus_info bus;
	struct e1000_host_mng_dhcp_cookie mng_cookie;
	union {
		struct e1000_dev_spec_82571 e82571;
		struct e1000_dev_spec_80003es2lan e80003es2lan;
		struct e1000_dev_spec_ich8lan ich8lan;
	} dev_spec;
};

struct e1000_phy_regs {
	u16 bmcr;
	u16 bmsr;
	u16 advertise;
	u16 lpa;
	u16 expansion;
	u16 ctrl1000;
	u16 stat1000;
	u16 estatus;
};

struct e1000_buffer;

struct e1000_ring {
	struct e1000_adapter *adapter;
	void *desc;
	dma_addr_t dma;
	unsigned int size;
	unsigned int count;
	u16 next_to_use;
	u16 next_to_clean;
	void *head;
	void *tail;
	struct e1000_buffer *buffer_info;
	char name[21];
	u32 ims_val;
	u32 itr_val;
	void *itr_register;
	int set_itr;
	struct sk_buff *rx_skb_top;
};

struct e1000_info;

struct e1000_adapter {
	struct timer_list watchdog_timer;
	struct timer_list phy_info_timer;
	struct timer_list blink_timer;
	struct work_struct reset_task;
	struct work_struct watchdog_task;
	const struct e1000_info *ei;
	long unsigned int active_vlans[128];
	u32 bd_number;
	u32 rx_buffer_len;
	u16 mng_vlan_id;
	u16 link_speed;
	u16 link_duplex;
	u16 eeprom_vers;
	long unsigned int state;
	u32 itr;
	u32 itr_setting;
	u16 tx_itr;
	u16 rx_itr;
	struct e1000_ring *tx_ring;
	u32 tx_fifo_limit;
	struct napi_struct napi;
	unsigned int uncorr_errors;
	unsigned int corr_errors;
	unsigned int restart_queue;
	u32 txd_cmd;
	bool detect_tx_hung;
	bool tx_hang_recheck;
	u8 tx_timeout_factor;
	u32 tx_int_delay;
	u32 tx_abs_int_delay;
	unsigned int total_tx_bytes;
	unsigned int total_tx_packets;
	unsigned int total_rx_bytes;
	unsigned int total_rx_packets;
	int: 32;
	u64 tpt_old;
	u64 colc_old;
	u32 gotc;
	int: 32;
	u64 gotc_old;
	u32 tx_timeout_count;
	u32 tx_fifo_head;
	u32 tx_head_addr;
	u32 tx_fifo_size;
	u32 tx_dma_failed;
	u32 tx_hwtstamp_timeouts;
	u32 tx_hwtstamp_skipped;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	bool (*clean_rx)(struct e1000_ring *, int *, int);
	void (*alloc_rx_buf)(struct e1000_ring *, int, gfp_t);
	struct e1000_ring *rx_ring;
	u32 rx_int_delay;
	u32 rx_abs_int_delay;
	int: 32;
	u64 hw_csum_err;
	u64 hw_csum_good;
	u64 rx_hdr_split;
	u32 gorc;
	int: 32;
	u64 gorc_old;
	u32 alloc_rx_buff_failed;
	u32 rx_dma_failed;
	u32 rx_hwtstamp_cleared;
	unsigned int rx_ps_pages;
	u16 rx_ps_bsize0;
	u32 max_frame_size;
	u32 min_frame_size;
	struct net_device *netdev;
	struct pci_dev *pdev;
	struct e1000_hw hw;
	spinlock_t stats64_lock;
	struct e1000_hw_stats stats;
	struct e1000_phy_info phy_info;
	struct e1000_phy_stats phy_stats;
	struct e1000_phy_regs phy_regs;
	struct e1000_ring test_tx_ring;
	struct e1000_ring test_rx_ring;
	u32 test_icr;
	u32 msg_enable;
	unsigned int num_vectors;
	struct msix_entry *msix_entries;
	int int_mode;
	u32 eiac_mask;
	u32 eeprom_wol;
	u32 wol;
	u32 pba;
	u32 max_hw_frame_size;
	bool fc_autoneg;
	unsigned int flags;
	unsigned int flags2;
	struct work_struct downshift_task;
	struct work_struct update_phy_task;
	struct work_struct print_hang_task;
	int phy_hang_count;
	u16 tx_ring_count;
	u16 rx_ring_count;
	struct hwtstamp_config hwtstamp_config;
	struct delayed_work systim_overflow_work;
	struct sk_buff *tx_hwtstamp_skb;
	long unsigned int tx_hwtstamp_start;
	struct work_struct tx_hwtstamp_work;
	spinlock_t systim_lock;
	struct cyclecounter cc;
	struct timecounter tc;
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info ptp_clock_info;
	struct pm_qos_request pm_qos_req;
	long int ptp_delta;
	u16 eee_advert;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct e1000_ps_page {
	struct page *page;
	int: 32;
	u64 dma;
};

struct e1000_buffer {
	dma_addr_t dma;
	struct sk_buff *skb;
	union {
		struct {
			long unsigned int time_stamp;
			u16 length;
			u16 next_to_watch;
			unsigned int segs;
			unsigned int bytecount;
			u16 mapped_as_page;
		};
		struct {
			struct e1000_ps_page *ps_pages;
			struct page *page;
		};
	};
};

struct e1000_info {
	enum e1000_mac_type mac;
	unsigned int flags;
	unsigned int flags2;
	u32 pba;
	u32 max_hw_frame_size;
	s32 (*get_variants)(struct e1000_adapter *);
	const struct e1000_mac_operations *mac_ops;
	const struct e1000_phy_operations *phy_ops;
	const struct e1000_nvm_operations *nvm_ops;
};

enum e1000_state_t {
	__E1000_TESTING = 0,
	__E1000_RESETTING = 1,
	__E1000_ACCESS_SHARED_RESOURCE = 2,
	__E1000_DOWN = 3,
};

struct ich8_hsfsts {
	u16 flcdone: 1;
	u16 flcerr: 1;
	u16 dael: 1;
	u16 berasesz: 2;
	u16 flcinprog: 1;
	u16 reserved1: 2;
	u16 reserved2: 6;
	u16 fldesvalid: 1;
	u16 flockdn: 1;
};

union ich8_hws_flash_status {
	struct ich8_hsfsts hsf_status;
	u16 regval;
};

struct ich8_hsflctl {
	u16 flcgo: 1;
	u16 flcycle: 2;
	u16 reserved: 5;
	u16 fldbcount: 2;
	u16 flockdn: 6;
};

union ich8_hws_flash_ctrl {
	struct ich8_hsflctl hsf_ctrl;
	u16 regval;
};

struct ich8_pr {
	u32 base: 13;
	u32 reserved1: 2;
	u32 rpe: 1;
	u32 limit: 13;
	u32 reserved2: 2;
	u32 wpe: 1;
};

union ich8_flash_protected_range {
	struct ich8_pr range;
	u32 regval;
};

struct e1000_host_mng_command_header {
	u8 command_id;
	u8 checksum;
	u16 reserved1;
	u16 reserved2;
	u16 command_length;
};

enum e1000_mng_mode {
	e1000_mng_mode_none = 0,
	e1000_mng_mode_asf = 1,
	e1000_mng_mode_pt = 2,
	e1000_mng_mode_ipmi = 3,
	e1000_mng_mode_host_if_only = 4,
};

struct e1000_opt_list {
	int i;
	char *str;
};

struct e1000_option {
	enum {
		enable_option = 0,
		range_option = 1,
		list_option = 2,
	} type;
	const char *name;
	const char *err;
	int def;
	union {
		struct {
			int min;
			int max;
		} r;
		struct {
			int nr;
			struct e1000_opt_list *p;
		} l;
	} arg;
};

enum ethtool_test_flags {
	ETH_TEST_FL_OFFLINE = 1,
	ETH_TEST_FL_FAILED = 2,
	ETH_TEST_FL_EXTERNAL_LB = 4,
	ETH_TEST_FL_EXTERNAL_LB_DONE = 8,
};

union e1000_rx_desc_extended {
	struct {
		__le64 buffer_addr;
		__le64 reserved;
	} read;
	struct {
		struct {
			__le32 mrq;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length;
			__le16 vlan;
		} upper;
	} wb;
};

struct e1000_tx_desc {
	__le64 buffer_addr;
	union {
		__le32 data;
		struct {
			__le16 length;
			u8 cso;
			u8 cmd;
		} flags;
	} lower;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 css;
			__le16 special;
		} fields;
	} upper;
};

enum {
	NETDEV_STATS = 0,
	E1000_STATS = 1,
};

struct e1000_stats {
	char stat_string[32];
	int type;
	int sizeof_stat;
	int stat_offset;
};

enum pkt_hash_types {
	PKT_HASH_TYPE_NONE = 0,
	PKT_HASH_TYPE_L2 = 1,
	PKT_HASH_TYPE_L3 = 2,
	PKT_HASH_TYPE_L4 = 3,
};

struct sd_flow_limit;

struct softnet_data {
	struct list_head poll_list;
	struct sk_buff_head process_queue;
	unsigned int processed;
	unsigned int time_squeeze;
	unsigned int received_rps;
	struct softnet_data *rps_ipi_list;
	struct sd_flow_limit *flow_limit;
	struct Qdisc *output_queue;
	struct Qdisc **output_queue_tailp;
	struct sk_buff *completion_queue;
	struct {
		u16 recursion;
		u8 more;
		u8 skip_txqueue;
	} xmit;
	int: 32;
	unsigned int input_queue_head;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	call_single_data_t csd;
	struct softnet_data *rps_ipi_next;
	unsigned int cpu;
	unsigned int input_queue_tail;
	unsigned int dropped;
	struct sk_buff_head input_pkt_queue;
	struct napi_struct backlog;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	spinlock_t defer_lock;
	int defer_count;
	int defer_ipi_scheduled;
	struct sk_buff *defer_list;
	call_single_data_t defer_csd;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ipv6hdr {
	__u8 priority: 4;
	__u8 version: 4;
	__u8 flow_lbl[3];
	__be16 payload_len;
	__u8 nexthdr;
	__u8 hop_limit;
	union {
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		};
		struct {
			struct in6_addr saddr;
			struct in6_addr daddr;
		} addrs;
	};
};

struct udphdr {
	__be16 source;
	__be16 dest;
	__be16 len;
	__sum16 check;
};

union e1000_rx_desc_packet_split {
	struct {
		__le64 buffer_addr[4];
	} read;
	struct {
		struct {
			__le32 mrq;
			union {
				__le32 rss;
				struct {
					__le16 ip_id;
					__le16 csum;
				} csum_ip;
			} hi_dword;
		} lower;
		struct {
			__le32 status_error;
			__le16 length0;
			__le16 vlan;
		} middle;
		struct {
			__le16 header_status;
			__le16 length[3];
		} upper;
		__le64 reserved;
	} wb;
};

struct e1000_context_desc {
	union {
		__le32 ip_config;
		struct {
			u8 ipcss;
			u8 ipcso;
			__le16 ipcse;
		} ip_fields;
	} lower_setup;
	union {
		__le32 tcp_config;
		struct {
			u8 tucss;
			u8 tucso;
			__le16 tucse;
		} tcp_fields;
	} upper_setup;
	__le32 cmd_and_length;
	union {
		__le32 data;
		struct {
			u8 status;
			u8 hdr_len;
			__le16 mss;
		} fields;
	} tcp_seg_setup;
};

enum e1000_boards {
	board_82571 = 0,
	board_82572 = 1,
	board_82573 = 2,
	board_82574 = 3,
	board_82583 = 4,
	board_80003es2lan = 5,
	board_ich8lan = 6,
	board_ich9lan = 7,
	board_ich10lan = 8,
	board_pchlan = 9,
	board_pch2lan = 10,
	board_pch_lpt = 11,
	board_pch_spt = 12,
	board_pch_cnp = 13,
	board_pch_tgp = 14,
	board_pch_adp = 15,
};

enum latency_range {
	lowest_latency = 0,
	low_latency = 1,
	bulk_latency = 2,
	latency_invalid = 255,
};

struct e1000_reg_info {
	u32 ofs;
	char *name;
};

struct my_u0 {
	__le64 a;
	__le64 b;
};

struct my_u1 {
	__le64 a;
	__le64 b;
	__le64 c;
	__le64 d;
};

struct smc91x_platdata {
	long unsigned int flags;
	unsigned char leda;
	unsigned char ledb;
	bool pxa_u16_align4;
};

struct smc_local {
	struct sk_buff *pending_tx_skb;
	struct tasklet_struct tx_task;
	struct gpio_desc *power_gpio;
	struct gpio_desc *reset_gpio;
	int version;
	int tcr_cur_mode;
	int rcr_cur_mode;
	int rpc_cur_mode;
	int ctl_rfduplx;
	int ctl_rspeed;
	u32 msg_enable;
	u32 phy_type;
	struct mii_if_info mii;
	struct work_struct phy_configure;
	struct net_device *dev;
	int work_pending;
	spinlock_t lock;
	struct dma_chan *dma_chan;
	void *base;
	void *datacs;
	int io_shift;
	bool half_word_align4;
	struct smc91x_platdata cfg;
};

struct smc911x_platdata {
	long unsigned int flags;
	long unsigned int irq_flags;
	int irq_polarity;
};

struct smc911x_local {
	struct sk_buff *pending_tx_skb;
	u16 version;
	u16 revision;
	int tx_fifo_kb;
	int tx_fifo_size;
	int rx_fifo_size;
	int afc_cfg;
	int ctl_rfduplx;
	int ctl_rspeed;
	u32 msg_enable;
	u32 phy_type;
	struct mii_if_info mii;
	struct work_struct phy_configure;
	int tx_throttle;
	spinlock_t lock;
	struct net_device *netdev;
	void *base;
	struct smc911x_platdata cfg;
};

struct chip_id {
	u16 id;
	char *name;
};

struct smsc911x_platform_config {
	unsigned int irq_polarity;
	unsigned int irq_type;
	unsigned int flags;
	unsigned int shift;
	phy_interface_t phy_interface;
	unsigned char mac[6];
};

struct smsc911x_data;

struct smsc911x_ops {
	u32 (*reg_read)(struct smsc911x_data *, u32);
	void (*reg_write)(struct smsc911x_data *, u32, u32);
	void (*rx_readfifo)(struct smsc911x_data *, unsigned int *, unsigned int);
	void (*tx_writefifo)(struct smsc911x_data *, unsigned int *, unsigned int);
};

struct smsc911x_data {
	void *ioaddr;
	unsigned int idrev;
	unsigned int generation;
	struct smsc911x_platform_config config;
	spinlock_t mac_lock;
	spinlock_t dev_lock;
	struct mii_bus *mii_bus;
	unsigned int using_extphy;
	int last_duplex;
	int last_carrier;
	u32 msg_enable;
	unsigned int gpio_setting;
	unsigned int gpio_orig_setting;
	struct net_device *dev;
	struct napi_struct napi;
	unsigned int software_irq_signal;
	char loopback_tx_pkt[64];
	char loopback_rx_pkt[64];
	unsigned int resetcount;
	unsigned int multicast_update_pending;
	unsigned int set_bits_mask;
	unsigned int clear_bits_mask;
	unsigned int hashhi;
	unsigned int hashlo;
	const struct smsc911x_ops *ops;
	struct regulator_bulk_data supplies[2];
	struct gpio_desc *reset_gpiod;
	struct clk *clk;
};

struct libipw_device;

struct iw_spy_data;

struct iw_public_data {
	struct iw_spy_data *spy_data;
	struct libipw_device *libipw;
};

struct ieee80211_hdr {
	__le16 frame_control;
	__le16 duration_id;
	union {
		struct {
			u8 addr1[6];
			u8 addr2[6];
			u8 addr3[6];
		};
		struct {
			u8 addr1[6];
			u8 addr2[6];
			u8 addr3[6];
		} addrs;
	};
	__le16 seq_ctrl;
	u8 addr4[6];
};

enum ieee80211_eid {
	WLAN_EID_SSID = 0,
	WLAN_EID_SUPP_RATES = 1,
	WLAN_EID_FH_PARAMS = 2,
	WLAN_EID_DS_PARAMS = 3,
	WLAN_EID_CF_PARAMS = 4,
	WLAN_EID_TIM = 5,
	WLAN_EID_IBSS_PARAMS = 6,
	WLAN_EID_COUNTRY = 7,
	WLAN_EID_REQUEST = 10,
	WLAN_EID_QBSS_LOAD = 11,
	WLAN_EID_EDCA_PARAM_SET = 12,
	WLAN_EID_TSPEC = 13,
	WLAN_EID_TCLAS = 14,
	WLAN_EID_SCHEDULE = 15,
	WLAN_EID_CHALLENGE = 16,
	WLAN_EID_PWR_CONSTRAINT = 32,
	WLAN_EID_PWR_CAPABILITY = 33,
	WLAN_EID_TPC_REQUEST = 34,
	WLAN_EID_TPC_REPORT = 35,
	WLAN_EID_SUPPORTED_CHANNELS = 36,
	WLAN_EID_CHANNEL_SWITCH = 37,
	WLAN_EID_MEASURE_REQUEST = 38,
	WLAN_EID_MEASURE_REPORT = 39,
	WLAN_EID_QUIET = 40,
	WLAN_EID_IBSS_DFS = 41,
	WLAN_EID_ERP_INFO = 42,
	WLAN_EID_TS_DELAY = 43,
	WLAN_EID_TCLAS_PROCESSING = 44,
	WLAN_EID_HT_CAPABILITY = 45,
	WLAN_EID_QOS_CAPA = 46,
	WLAN_EID_RSN = 48,
	WLAN_EID_802_15_COEX = 49,
	WLAN_EID_EXT_SUPP_RATES = 50,
	WLAN_EID_AP_CHAN_REPORT = 51,
	WLAN_EID_NEIGHBOR_REPORT = 52,
	WLAN_EID_RCPI = 53,
	WLAN_EID_MOBILITY_DOMAIN = 54,
	WLAN_EID_FAST_BSS_TRANSITION = 55,
	WLAN_EID_TIMEOUT_INTERVAL = 56,
	WLAN_EID_RIC_DATA = 57,
	WLAN_EID_DSE_REGISTERED_LOCATION = 58,
	WLAN_EID_SUPPORTED_REGULATORY_CLASSES = 59,
	WLAN_EID_EXT_CHANSWITCH_ANN = 60,
	WLAN_EID_HT_OPERATION = 61,
	WLAN_EID_SECONDARY_CHANNEL_OFFSET = 62,
	WLAN_EID_BSS_AVG_ACCESS_DELAY = 63,
	WLAN_EID_ANTENNA_INFO = 64,
	WLAN_EID_RSNI = 65,
	WLAN_EID_MEASUREMENT_PILOT_TX_INFO = 66,
	WLAN_EID_BSS_AVAILABLE_CAPACITY = 67,
	WLAN_EID_BSS_AC_ACCESS_DELAY = 68,
	WLAN_EID_TIME_ADVERTISEMENT = 69,
	WLAN_EID_RRM_ENABLED_CAPABILITIES = 70,
	WLAN_EID_MULTIPLE_BSSID = 71,
	WLAN_EID_BSS_COEX_2040 = 72,
	WLAN_EID_BSS_INTOLERANT_CHL_REPORT = 73,
	WLAN_EID_OVERLAP_BSS_SCAN_PARAM = 74,
	WLAN_EID_RIC_DESCRIPTOR = 75,
	WLAN_EID_MMIE = 76,
	WLAN_EID_ASSOC_COMEBACK_TIME = 77,
	WLAN_EID_EVENT_REQUEST = 78,
	WLAN_EID_EVENT_REPORT = 79,
	WLAN_EID_DIAGNOSTIC_REQUEST = 80,
	WLAN_EID_DIAGNOSTIC_REPORT = 81,
	WLAN_EID_LOCATION_PARAMS = 82,
	WLAN_EID_NON_TX_BSSID_CAP = 83,
	WLAN_EID_SSID_LIST = 84,
	WLAN_EID_MULTI_BSSID_IDX = 85,
	WLAN_EID_FMS_DESCRIPTOR = 86,
	WLAN_EID_FMS_REQUEST = 87,
	WLAN_EID_FMS_RESPONSE = 88,
	WLAN_EID_QOS_TRAFFIC_CAPA = 89,
	WLAN_EID_BSS_MAX_IDLE_PERIOD = 90,
	WLAN_EID_TSF_REQUEST = 91,
	WLAN_EID_TSF_RESPOSNE = 92,
	WLAN_EID_WNM_SLEEP_MODE = 93,
	WLAN_EID_TIM_BCAST_REQ = 94,
	WLAN_EID_TIM_BCAST_RESP = 95,
	WLAN_EID_COLL_IF_REPORT = 96,
	WLAN_EID_CHANNEL_USAGE = 97,
	WLAN_EID_TIME_ZONE = 98,
	WLAN_EID_DMS_REQUEST = 99,
	WLAN_EID_DMS_RESPONSE = 100,
	WLAN_EID_LINK_ID = 101,
	WLAN_EID_WAKEUP_SCHEDUL = 102,
	WLAN_EID_CHAN_SWITCH_TIMING = 104,
	WLAN_EID_PTI_CONTROL = 105,
	WLAN_EID_PU_BUFFER_STATUS = 106,
	WLAN_EID_INTERWORKING = 107,
	WLAN_EID_ADVERTISEMENT_PROTOCOL = 108,
	WLAN_EID_EXPEDITED_BW_REQ = 109,
	WLAN_EID_QOS_MAP_SET = 110,
	WLAN_EID_ROAMING_CONSORTIUM = 111,
	WLAN_EID_EMERGENCY_ALERT = 112,
	WLAN_EID_MESH_CONFIG = 113,
	WLAN_EID_MESH_ID = 114,
	WLAN_EID_LINK_METRIC_REPORT = 115,
	WLAN_EID_CONGESTION_NOTIFICATION = 116,
	WLAN_EID_PEER_MGMT = 117,
	WLAN_EID_CHAN_SWITCH_PARAM = 118,
	WLAN_EID_MESH_AWAKE_WINDOW = 119,
	WLAN_EID_BEACON_TIMING = 120,
	WLAN_EID_MCCAOP_SETUP_REQ = 121,
	WLAN_EID_MCCAOP_SETUP_RESP = 122,
	WLAN_EID_MCCAOP_ADVERT = 123,
	WLAN_EID_MCCAOP_TEARDOWN = 124,
	WLAN_EID_GANN = 125,
	WLAN_EID_RANN = 126,
	WLAN_EID_EXT_CAPABILITY = 127,
	WLAN_EID_PREQ = 130,
	WLAN_EID_PREP = 131,
	WLAN_EID_PERR = 132,
	WLAN_EID_PXU = 137,
	WLAN_EID_PXUC = 138,
	WLAN_EID_AUTH_MESH_PEER_EXCH = 139,
	WLAN_EID_MIC = 140,
	WLAN_EID_DESTINATION_URI = 141,
	WLAN_EID_UAPSD_COEX = 142,
	WLAN_EID_WAKEUP_SCHEDULE = 143,
	WLAN_EID_EXT_SCHEDULE = 144,
	WLAN_EID_STA_AVAILABILITY = 145,
	WLAN_EID_DMG_TSPEC = 146,
	WLAN_EID_DMG_AT = 147,
	WLAN_EID_DMG_CAP = 148,
	WLAN_EID_CISCO_VENDOR_SPECIFIC = 150,
	WLAN_EID_DMG_OPERATION = 151,
	WLAN_EID_DMG_BSS_PARAM_CHANGE = 152,
	WLAN_EID_DMG_BEAM_REFINEMENT = 153,
	WLAN_EID_CHANNEL_MEASURE_FEEDBACK = 154,
	WLAN_EID_AWAKE_WINDOW = 157,
	WLAN_EID_MULTI_BAND = 158,
	WLAN_EID_ADDBA_EXT = 159,
	WLAN_EID_NEXT_PCP_LIST = 160,
	WLAN_EID_PCP_HANDOVER = 161,
	WLAN_EID_DMG_LINK_MARGIN = 162,
	WLAN_EID_SWITCHING_STREAM = 163,
	WLAN_EID_SESSION_TRANSITION = 164,
	WLAN_EID_DYN_TONE_PAIRING_REPORT = 165,
	WLAN_EID_CLUSTER_REPORT = 166,
	WLAN_EID_RELAY_CAP = 167,
	WLAN_EID_RELAY_XFER_PARAM_SET = 168,
	WLAN_EID_BEAM_LINK_MAINT = 169,
	WLAN_EID_MULTIPLE_MAC_ADDR = 170,
	WLAN_EID_U_PID = 171,
	WLAN_EID_DMG_LINK_ADAPT_ACK = 172,
	WLAN_EID_MCCAOP_ADV_OVERVIEW = 174,
	WLAN_EID_QUIET_PERIOD_REQ = 175,
	WLAN_EID_QUIET_PERIOD_RESP = 177,
	WLAN_EID_EPAC_POLICY = 182,
	WLAN_EID_CLISTER_TIME_OFF = 183,
	WLAN_EID_INTER_AC_PRIO = 184,
	WLAN_EID_SCS_DESCRIPTOR = 185,
	WLAN_EID_QLOAD_REPORT = 186,
	WLAN_EID_HCCA_TXOP_UPDATE_COUNT = 187,
	WLAN_EID_HL_STREAM_ID = 188,
	WLAN_EID_GCR_GROUP_ADDR = 189,
	WLAN_EID_ANTENNA_SECTOR_ID_PATTERN = 190,
	WLAN_EID_VHT_CAPABILITY = 191,
	WLAN_EID_VHT_OPERATION = 192,
	WLAN_EID_EXTENDED_BSS_LOAD = 193,
	WLAN_EID_WIDE_BW_CHANNEL_SWITCH = 194,
	WLAN_EID_TX_POWER_ENVELOPE = 195,
	WLAN_EID_CHANNEL_SWITCH_WRAPPER = 196,
	WLAN_EID_AID = 197,
	WLAN_EID_QUIET_CHANNEL = 198,
	WLAN_EID_OPMODE_NOTIF = 199,
	WLAN_EID_REDUCED_NEIGHBOR_REPORT = 201,
	WLAN_EID_AID_REQUEST = 210,
	WLAN_EID_AID_RESPONSE = 211,
	WLAN_EID_S1G_BCN_COMPAT = 213,
	WLAN_EID_S1G_SHORT_BCN_INTERVAL = 214,
	WLAN_EID_S1G_TWT = 216,
	WLAN_EID_S1G_CAPABILITIES = 217,
	WLAN_EID_VENDOR_SPECIFIC = 221,
	WLAN_EID_QOS_PARAMETER = 222,
	WLAN_EID_S1G_OPERATION = 232,
	WLAN_EID_CAG_NUMBER = 237,
	WLAN_EID_AP_CSN = 239,
	WLAN_EID_FILS_INDICATION = 240,
	WLAN_EID_DILS = 241,
	WLAN_EID_FRAGMENT = 242,
	WLAN_EID_RSNX = 244,
	WLAN_EID_EXTENSION = 255,
};

struct lib80211_crypto_ops {
	const char *name;
	struct list_head list;
	void * (*init)(int);
	void (*deinit)(void *);
	int (*encrypt_mpdu)(struct sk_buff *, int, void *);
	int (*decrypt_mpdu)(struct sk_buff *, int, void *);
	int (*encrypt_msdu)(struct sk_buff *, int, void *);
	int (*decrypt_msdu)(struct sk_buff *, int, int, void *);
	int (*set_key)(void *, int, u8 *, void *);
	int (*get_key)(void *, int, u8 *, void *);
	void (*print_stats)(struct seq_file *, void *);
	long unsigned int (*get_flags)(void *);
	long unsigned int (*set_flags)(long unsigned int, void *);
	int extra_mpdu_prefix_len;
	int extra_mpdu_postfix_len;
	int extra_msdu_prefix_len;
	int extra_msdu_postfix_len;
	struct module *owner;
};

struct lib80211_crypt_data {
	struct list_head list;
	struct lib80211_crypto_ops *ops;
	void *priv;
	atomic_t refcnt;
};

struct lib80211_crypt_info {
	char *name;
	spinlock_t *lock;
	struct lib80211_crypt_data *crypt[4];
	int tx_keyidx;
	struct list_head crypt_deinit_list;
	struct timer_list crypt_deinit_timer;
	int crypt_quiesced;
};

struct hostap_ieee80211_mgmt {
	__le16 frame_control;
	__le16 duration;
	u8 da[6];
	u8 sa[6];
	u8 bssid[6];
	__le16 seq_ctrl;
	union {
		struct {
			__le16 auth_alg;
			__le16 auth_transaction;
			__le16 status_code;
			u8 variable[0];
		} auth;
		struct {
			__le16 reason_code;
		} deauth;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 variable[0];
		} assoc_req;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} assoc_resp;
		struct {
			__le16 capab_info;
			__le16 status_code;
			__le16 aid;
			u8 variable[0];
		} reassoc_resp;
		struct {
			__le16 capab_info;
			__le16 listen_interval;
			u8 current_ap[6];
			u8 variable[0];
		} reassoc_req;
		struct {
			__le16 reason_code;
		} disassoc;
		struct {		} probe_req;
		struct {
			u8 timestamp[8];
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} beacon;
		struct {
			u8 timestamp[8];
			__le16 beacon_int;
			__le16 capab_info;
			u8 variable[0];
		} probe_resp;
	} u;
};

struct hostap_80211_rx_status {
	u32 mac_time;
	u8 signal;
	u8 noise;
	u16 rate;
};

enum {
	PRISM2_RX_MONITOR = 0,
	PRISM2_RX_MGMT = 1,
	PRISM2_RX_NON_ASSOC = 2,
	PRISM2_RX_NULLFUNC_ACK = 3,
};

struct iw_param {
	__s32 value;
	__u8 fixed;
	__u8 disabled;
	__u16 flags;
};

struct iw_point {
	void *pointer;
	__u16 length;
	__u16 flags;
};

struct iw_freq {
	__s32 m;
	__s16 e;
	__u8 i;
	__u8 flags;
};

struct iw_quality {
	__u8 qual;
	__u8 level;
	__u8 noise;
	__u8 updated;
};

struct iw_discarded {
	__u32 nwid;
	__u32 code;
	__u32 fragment;
	__u32 retries;
	__u32 misc;
};

struct iw_missed {
	__u32 beacon;
};

struct iw_statistics {
	__u16 status;
	struct iw_quality qual;
	struct iw_discarded discard;
	struct iw_missed miss;
};

union iwreq_data {
	char name[16];
	struct iw_point essid;
	struct iw_param nwid;
	struct iw_freq freq;
	struct iw_param sens;
	struct iw_param bitrate;
	struct iw_param txpower;
	struct iw_param rts;
	struct iw_param frag;
	__u32 mode;
	struct iw_param retry;
	struct iw_point encoding;
	struct iw_param power;
	struct iw_quality qual;
	struct sockaddr ap_addr;
	struct sockaddr addr;
	struct iw_param param;
	struct iw_point data;
};

struct iw_priv_args {
	__u32 cmd;
	__u16 set_args;
	__u16 get_args;
	char name[16];
};

struct iw_request_info {
	__u16 cmd;
	__u16 flags;
};

struct iw_spy_data {
	int spy_number;
	u_char spy_address[48];
	struct iw_quality spy_stat[8];
	struct iw_quality spy_thr_low;
	struct iw_quality spy_thr_high;
	u_char spy_thr_under[8];
};

struct ieee80211_radiotap_header {
	uint8_t it_version;
	uint8_t it_pad;
	__le16 it_len;
	__le32 it_present;
	__le32 it_optional[0];
};

enum ieee80211_radiotap_presence {
	IEEE80211_RADIOTAP_TSFT = 0,
	IEEE80211_RADIOTAP_FLAGS = 1,
	IEEE80211_RADIOTAP_RATE = 2,
	IEEE80211_RADIOTAP_CHANNEL = 3,
	IEEE80211_RADIOTAP_FHSS = 4,
	IEEE80211_RADIOTAP_DBM_ANTSIGNAL = 5,
	IEEE80211_RADIOTAP_DBM_ANTNOISE = 6,
	IEEE80211_RADIOTAP_LOCK_QUALITY = 7,
	IEEE80211_RADIOTAP_TX_ATTENUATION = 8,
	IEEE80211_RADIOTAP_DB_TX_ATTENUATION = 9,
	IEEE80211_RADIOTAP_DBM_TX_POWER = 10,
	IEEE80211_RADIOTAP_ANTENNA = 11,
	IEEE80211_RADIOTAP_DB_ANTSIGNAL = 12,
	IEEE80211_RADIOTAP_DB_ANTNOISE = 13,
	IEEE80211_RADIOTAP_RX_FLAGS = 14,
	IEEE80211_RADIOTAP_TX_FLAGS = 15,
	IEEE80211_RADIOTAP_RTS_RETRIES = 16,
	IEEE80211_RADIOTAP_DATA_RETRIES = 17,
	IEEE80211_RADIOTAP_MCS = 19,
	IEEE80211_RADIOTAP_AMPDU_STATUS = 20,
	IEEE80211_RADIOTAP_VHT = 21,
	IEEE80211_RADIOTAP_TIMESTAMP = 22,
	IEEE80211_RADIOTAP_HE = 23,
	IEEE80211_RADIOTAP_HE_MU = 24,
	IEEE80211_RADIOTAP_ZERO_LEN_PSDU = 26,
	IEEE80211_RADIOTAP_LSIG = 27,
	IEEE80211_RADIOTAP_RADIOTAP_NAMESPACE = 29,
	IEEE80211_RADIOTAP_VENDOR_NAMESPACE = 30,
	IEEE80211_RADIOTAP_EXT = 31,
};

enum ieee80211_radiotap_channel_flags {
	IEEE80211_CHAN_CCK = 32,
	IEEE80211_CHAN_OFDM = 64,
	IEEE80211_CHAN_2GHZ = 128,
	IEEE80211_CHAN_5GHZ = 256,
	IEEE80211_CHAN_DYN = 1024,
	IEEE80211_CHAN_HALF = 16384,
	IEEE80211_CHAN_QUARTER = 32768,
};

struct prism2_download_area {
	u32 addr;
	u32 len;
	void *ptr;
};

struct prism2_download_param {
	u32 dl_cmd;
	u32 start_addr;
	u32 num_areas;
	struct prism2_download_area data[0];
};

struct linux_wlan_ng_val {
	u32 did;
	u16 status;
	u16 len;
	u32 data;
};

struct linux_wlan_ng_prism_hdr {
	u32 msgcode;
	u32 msglen;
	char devname[16];
	struct linux_wlan_ng_val hosttime;
	struct linux_wlan_ng_val mactime;
	struct linux_wlan_ng_val channel;
	struct linux_wlan_ng_val rssi;
	struct linux_wlan_ng_val sq;
	struct linux_wlan_ng_val signal;
	struct linux_wlan_ng_val noise;
	struct linux_wlan_ng_val rate;
	struct linux_wlan_ng_val istx;
	struct linux_wlan_ng_val frmlen;
};

struct linux_wlan_ng_cap_hdr {
	__be32 version;
	__be32 length;
	__be64 mactime;
	__be64 hosttime;
	__be32 phytype;
	__be32 channel;
	__be32 datarate;
	__be32 antenna;
	__be32 priority;
	__be32 ssi_type;
	__be32 ssi_signal;
	__be32 ssi_noise;
	__be32 preamble;
	__be32 encoding;
};

struct hostap_radiotap_rx {
	struct ieee80211_radiotap_header hdr;
	__le64 tsft;
	u8 rate;
	u8 padding;
	__le16 chan_freq;
	__le16 chan_flags;
	s8 dbm_antsignal;
	s8 dbm_antnoise;
};

struct hfa384x_hostscan_result {
	__le16 chid;
	__le16 anl;
	__le16 sl;
	u8 bssid[6];
	__le16 beacon_interval;
	__le16 capability;
	__le16 ssid_len;
	u8 ssid[32];
	u8 sup_rates[10];
	__le16 rate;
	__le16 atim;
};

struct comm_tallies_sums {
	unsigned int tx_unicast_frames;
	unsigned int tx_multicast_frames;
	unsigned int tx_fragments;
	unsigned int tx_unicast_octets;
	unsigned int tx_multicast_octets;
	unsigned int tx_deferred_transmissions;
	unsigned int tx_single_retry_frames;
	unsigned int tx_multiple_retry_frames;
	unsigned int tx_retry_limit_exceeded;
	unsigned int tx_discards;
	unsigned int rx_unicast_frames;
	unsigned int rx_multicast_frames;
	unsigned int rx_fragments;
	unsigned int rx_unicast_octets;
	unsigned int rx_multicast_octets;
	unsigned int rx_fcs_errors;
	unsigned int rx_discards_no_buffer;
	unsigned int tx_discards_wrong_sa;
	unsigned int rx_discards_wep_undecryptable;
	unsigned int rx_message_in_msg_fragments;
	unsigned int rx_message_in_bad_msg_fragments;
};

struct hfa384x_regs {
	u16 cmd;
	u16 evstat;
	u16 offset0;
	u16 offset1;
	u16 swsupport0;
};

struct hostap_tx_callback_info {
	u16 idx;
	void (*func)(struct sk_buff *, int, void *);
	void *data;
	struct hostap_tx_callback_info *next;
};

struct prism2_frag_entry {
	long unsigned int first_frag_time;
	unsigned int seq;
	unsigned int last_frag;
	struct sk_buff *skb;
	u8 src_addr[6];
	u8 dst_addr[6];
};

struct ap_data;

struct prism2_helper_functions;

struct prism2_download_data;

struct local_info {
	struct module *hw_module;
	int card_idx;
	int dev_enabled;
	int master_dev_auto_open;
	int num_dev_open;
	struct net_device *dev;
	struct net_device *ddev;
	struct list_head hostap_interfaces;
	rwlock_t iface_lock;
	spinlock_t cmdlock;
	spinlock_t baplock;
	spinlock_t lock;
	spinlock_t irq_init_lock;
	struct mutex rid_bap_mtx;
	u16 infofid;
	spinlock_t txfidlock;
	int txfid_len;
	u16 txfid[8];
	u16 intransmitfid[8];
	int next_txfid;
	int next_alloc;
	long unsigned int bits;
	struct ap_data *ap;
	char essid[33];
	char name[33];
	int name_set;
	u16 channel_mask;
	u16 scan_channel_mask;
	struct comm_tallies_sums comm_tallies;
	struct proc_dir_entry *proc;
	int iw_mode;
	int pseudo_adhoc;
	char bssid[6];
	int channel;
	int beacon_int;
	int dtim_period;
	int mtu;
	int frame_dump;
	int fw_tx_rate_control;
	u16 tx_rate_control;
	u16 basic_rates;
	int hw_resetting;
	int hw_ready;
	int hw_reset_tries;
	int hw_downloading;
	int shutdown;
	int pri_only;
	int no_pri;
	int sram_type;
	enum {
		PRISM2_TXPOWER_AUTO = 0,
		PRISM2_TXPOWER_OFF = 1,
		PRISM2_TXPOWER_FIXED = 2,
		PRISM2_TXPOWER_UNKNOWN = 3,
	} txpower_type;
	int txpower;
	struct list_head cmd_queue;
	int cmd_queue_len;
	struct work_struct reset_queue;
	int is_promisc;
	struct work_struct set_multicast_list_queue;
	struct work_struct set_tim_queue;
	struct list_head set_tim_list;
	spinlock_t set_tim_lock;
	int wds_max_connections;
	int wds_connections;
	u32 wds_type;
	u16 tx_control;
	int manual_retry_count;
	struct iw_statistics wstats;
	long unsigned int scan_timestamp;
	enum {
		PRISM2_MONITOR_80211 = 0,
		PRISM2_MONITOR_PRISM = 1,
		PRISM2_MONITOR_CAPHDR = 2,
		PRISM2_MONITOR_RADIOTAP = 3,
	} monitor_type;
	int monitor_allow_fcserr;
	int hostapd;
	int hostapd_sta;
	struct net_device *apdev;
	struct net_device_stats apdevstats;
	char assoc_ap_addr[6];
	struct net_device *stadev;
	struct net_device_stats stadevstats;
	struct lib80211_crypt_info crypt_info;
	int open_wep;
	int host_encrypt;
	int host_decrypt;
	int privacy_invoked;
	int fw_encrypt_ok;
	int bcrx_sta_key;
	struct prism2_frag_entry frag_cache[4];
	unsigned int frag_next_idx;
	int ieee_802_1x;
	int antsel_tx;
	int antsel_rx;
	int rts_threshold;
	int fragm_threshold;
	int auth_algs;
	int enh_sec;
	int tallies32;
	struct prism2_helper_functions *func;
	u8 *pda;
	int fw_ap;
	u32 sta_fw_ver;
	struct tasklet_struct bap_tasklet;
	struct tasklet_struct info_tasklet;
	struct sk_buff_head info_list;
	struct hostap_tx_callback_info *tx_callback;
	struct tasklet_struct rx_tasklet;
	struct sk_buff_head rx_list;
	struct tasklet_struct sta_tx_exc_tasklet;
	struct sk_buff_head sta_tx_exc_list;
	int host_roaming;
	long unsigned int last_join_time;
	struct hfa384x_hostscan_result *last_scan_results;
	int last_scan_results_count;
	enum {
		PRISM2_SCAN = 0,
		PRISM2_HOSTSCAN = 1,
	} last_scan_type;
	struct work_struct info_queue;
	long unsigned int pending_info;
	int prev_link_status;
	int prev_linkstatus_connected;
	u8 preferred_ap[6];
	wait_queue_head_t hostscan_wq;
	struct timer_list passive_scan_timer;
	int passive_scan_interval;
	int passive_scan_channel;
	enum {
		PASSIVE_SCAN_WAIT = 0,
		PASSIVE_SCAN_LISTEN = 1,
	} passive_scan_state;
	struct timer_list tick_timer;
	long unsigned int last_tick_timer;
	unsigned int sw_tick_stuck;
	long unsigned int last_comms_qual_update;
	int comms_qual;
	int avg_signal;
	int avg_noise;
	struct work_struct comms_qual_update;
	int rssi_to_dBm;
	struct list_head bss_list;
	int num_bss_info;
	int wpa;
	int tkip_countermeasures;
	int drop_unencrypted;
	u8 *generic_elem;
	size_t generic_elem_len;
	struct prism2_download_data *dl_pri;
	struct prism2_download_data *dl_sec;
	void *hw_priv;
};

typedef struct local_info local_info_t;

struct prism2_helper_functions {
	int (*card_present)(local_info_t *);
	void (*cor_sreset)(local_info_t *);
	void (*genesis_reset)(local_info_t *, int);
	int (*cmd)(struct net_device *, u16, u16, u16 *, u16 *);
	void (*read_regs)(struct net_device *, struct hfa384x_regs *);
	int (*get_rid)(struct net_device *, u16, void *, int, int);
	int (*set_rid)(struct net_device *, u16, void *, int);
	int (*hw_enable)(struct net_device *, int);
	int (*hw_config)(struct net_device *, int);
	void (*hw_reset)(struct net_device *);
	void (*hw_shutdown)(struct net_device *, int);
	int (*reset_port)(struct net_device *);
	void (*schedule_reset)(local_info_t *);
	int (*download)(local_info_t *, struct prism2_download_param *);
	int (*tx)(struct sk_buff *, struct net_device *);
	int (*set_tim)(struct net_device *, int, int);
	const struct proc_ops *read_aux_proc_ops;
	int need_tx_headroom;
	enum {
		HOSTAP_HW_PCCARD = 0,
		HOSTAP_HW_PLX = 1,
		HOSTAP_HW_PCI = 2,
	} hw_type;
};

struct prism2_download_data_area {
	u32 addr;
	u32 len;
	u8 *data;
};

struct prism2_download_data {
	u32 dl_cmd;
	u32 start_addr;
	u32 num_areas;
	struct prism2_download_data_area data[0];
};

struct hostap_bss_info {
	struct list_head list;
	long unsigned int last_update;
	unsigned int count;
	u8 bssid[6];
	u16 capab_info;
	u8 ssid[32];
	size_t ssid_len;
	u8 wpa_ie[64];
	size_t wpa_ie_len;
	u8 rsn_ie[64];
	size_t rsn_ie_len;
	int chan;
	int included;
};

typedef enum {
	AP_OTHER_AP_SKIP_ALL = 0,
	AP_OTHER_AP_SAME_SSID = 1,
	AP_OTHER_AP_ALL = 2,
	AP_OTHER_AP_EVEN_IBSS = 3,
} ap_policy_enum;

struct mac_restrictions {
	enum {
		MAC_POLICY_OPEN = 0,
		MAC_POLICY_ALLOW = 1,
		MAC_POLICY_DENY = 2,
	} policy;
	unsigned int entries;
	struct list_head mac_list;
	spinlock_t lock;
};

struct sta_info;

struct add_sta_proc_data;

struct wds_oper_data;

struct ap_data {
	int initialized;
	local_info_t *local;
	int bridge_packets;
	unsigned int bridged_unicast;
	unsigned int bridged_multicast;
	unsigned int tx_drop_nonassoc;
	int nullfunc_ack;
	spinlock_t sta_table_lock;
	int num_sta;
	struct list_head sta_list;
	struct sta_info *sta_hash[256];
	struct proc_dir_entry *proc;
	ap_policy_enum ap_policy;
	unsigned int max_inactivity;
	int autom_ap_wds;
	struct mac_restrictions mac_restrictions;
	int last_tx_rate;
	struct work_struct add_sta_proc_queue;
	struct add_sta_proc_data *add_sta_proc_entries;
	struct work_struct wds_oper_queue;
	struct wds_oper_data *wds_oper_entries;
	u16 tx_callback_idx;
	struct sta_info *sta_aid[128];
	u16 tx_callback_auth;
	u16 tx_callback_assoc;
	u16 tx_callback_poll;
	struct lib80211_crypto_ops *crypt;
	void *crypt_priv;
};

struct hostap_interface_wds {
	u8 remote_addr[6];
};

struct hostap_interface {
	struct list_head list;
	struct net_device *dev;
	struct local_info *local;
	struct net_device_stats stats;
	struct iw_spy_data spy_data;
	struct iw_public_data wireless_data;
	enum {
		HOSTAP_INTERFACE_MASTER = 0,
		HOSTAP_INTERFACE_MAIN = 1,
		HOSTAP_INTERFACE_AP = 2,
		HOSTAP_INTERFACE_STA = 3,
		HOSTAP_INTERFACE_WDS = 4,
	} type;
	union {
		struct hostap_interface_wds wds;
	} u;
};

struct sta_info {
	struct list_head list;
	struct sta_info *hnext;
	atomic_t users;
	struct proc_dir_entry *proc;
	u8 addr[6];
	u16 aid;
	u32 flags;
	u16 capability;
	u16 listen_interval;
	u8 supported_rates[32];
	long unsigned int last_auth;
	long unsigned int last_assoc;
	long unsigned int last_rx;
	long unsigned int last_tx;
	long unsigned int rx_packets;
	long unsigned int tx_packets;
	long unsigned int rx_bytes;
	long unsigned int tx_bytes;
	struct sk_buff_head tx_buf;
	s8 last_rx_silence;
	s8 last_rx_signal;
	u8 last_rx_rate;
	u8 last_rx_updated;
	u8 tx_supp_rates;
	u8 tx_rate;
	u8 tx_rate_idx;
	u8 tx_max_rate;
	u32 tx_count[4];
	u32 rx_count[4];
	u32 tx_since_last_failure;
	u32 tx_consecutive_exc;
	struct lib80211_crypt_data *crypt;
	int ap;
	local_info_t *local;
	union {
		struct {
			char *challenge;
		} sta;
		struct {
			int ssid_len;
			unsigned char ssid[33];
			int channel;
			long unsigned int last_beacon;
		} ap;
	} u;
	struct timer_list timer;
	enum {
		STA_NULLFUNC = 0,
		STA_DISASSOC = 1,
		STA_DEAUTH = 2,
	} timeout_next;
};

struct add_sta_proc_data {
	u8 addr[6];
	struct add_sta_proc_data *next;
};

typedef enum {
	WDS_ADD = 0,
	WDS_DEL = 1,
} wds_oper_type;

struct wds_oper_data {
	wds_oper_type type;
	u8 addr[6];
	struct wds_oper_data *next;
};

struct hostap_skb_tx_data {
	unsigned int __padding_for_default_qdiscs;
	u32 magic;
	u8 rate;
	u8 flags;
	u16 tx_cb_idx;
	struct hostap_interface *iface;
	long unsigned int jiffies;
	short unsigned int ethertype;
};

typedef enum {
	AP_TX_CONTINUE = 0,
	AP_TX_DROP = 1,
	AP_TX_RETRY = 2,
	AP_TX_BUFFERED = 3,
	AP_TX_CONTINUE_NOT_AUTHORIZED = 4,
} ap_tx_ret;

struct hostap_tx_data {
	struct sk_buff *skb;
	int host_encrypt;
	struct lib80211_crypt_data *crypt;
	void *sta_ptr;
};

enum {
	WDS_NO = 0,
	WDS_OWN_FRAME = 1,
	WDS_COMPLIANT_FRAME = 2,
};

struct iw_event {
	__u16 len;
	__u16 cmd;
	union iwreq_data u;
};

enum ieee80211_statuscode {
	WLAN_STATUS_SUCCESS = 0,
	WLAN_STATUS_UNSPECIFIED_FAILURE = 1,
	WLAN_STATUS_CAPS_UNSUPPORTED = 10,
	WLAN_STATUS_REASSOC_NO_ASSOC = 11,
	WLAN_STATUS_ASSOC_DENIED_UNSPEC = 12,
	WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG = 13,
	WLAN_STATUS_UNKNOWN_AUTH_TRANSACTION = 14,
	WLAN_STATUS_CHALLENGE_FAIL = 15,
	WLAN_STATUS_AUTH_TIMEOUT = 16,
	WLAN_STATUS_AP_UNABLE_TO_HANDLE_NEW_STA = 17,
	WLAN_STATUS_ASSOC_DENIED_RATES = 18,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTPREAMBLE = 19,
	WLAN_STATUS_ASSOC_DENIED_NOPBCC = 20,
	WLAN_STATUS_ASSOC_DENIED_NOAGILITY = 21,
	WLAN_STATUS_ASSOC_DENIED_NOSPECTRUM = 22,
	WLAN_STATUS_ASSOC_REJECTED_BAD_POWER = 23,
	WLAN_STATUS_ASSOC_REJECTED_BAD_SUPP_CHAN = 24,
	WLAN_STATUS_ASSOC_DENIED_NOSHORTTIME = 25,
	WLAN_STATUS_ASSOC_DENIED_NODSSSOFDM = 26,
	WLAN_STATUS_ASSOC_REJECTED_TEMPORARILY = 30,
	WLAN_STATUS_ROBUST_MGMT_FRAME_POLICY_VIOLATION = 31,
	WLAN_STATUS_INVALID_IE = 40,
	WLAN_STATUS_INVALID_GROUP_CIPHER = 41,
	WLAN_STATUS_INVALID_PAIRWISE_CIPHER = 42,
	WLAN_STATUS_INVALID_AKMP = 43,
	WLAN_STATUS_UNSUPP_RSN_VERSION = 44,
	WLAN_STATUS_INVALID_RSN_IE_CAP = 45,
	WLAN_STATUS_CIPHER_SUITE_REJECTED = 46,
	WLAN_STATUS_UNSPECIFIED_QOS = 32,
	WLAN_STATUS_ASSOC_DENIED_NOBANDWIDTH = 33,
	WLAN_STATUS_ASSOC_DENIED_LOWACK = 34,
	WLAN_STATUS_ASSOC_DENIED_UNSUPP_QOS = 35,
	WLAN_STATUS_REQUEST_DECLINED = 37,
	WLAN_STATUS_INVALID_QOS_PARAM = 38,
	WLAN_STATUS_CHANGE_TSPEC = 39,
	WLAN_STATUS_WAIT_TS_DELAY = 47,
	WLAN_STATUS_NO_DIRECT_LINK = 48,
	WLAN_STATUS_STA_NOT_PRESENT = 49,
	WLAN_STATUS_STA_NOT_QSTA = 50,
	WLAN_STATUS_ANTI_CLOG_REQUIRED = 76,
	WLAN_STATUS_FCG_NOT_SUPP = 78,
	WLAN_STATUS_STA_NO_TBTT = 78,
	WLAN_STATUS_REJECTED_WITH_SUGGESTED_CHANGES = 39,
	WLAN_STATUS_REJECTED_FOR_DELAY_PERIOD = 47,
	WLAN_STATUS_REJECT_WITH_SCHEDULE = 83,
	WLAN_STATUS_PENDING_ADMITTING_FST_SESSION = 86,
	WLAN_STATUS_PERFORMING_FST_NOW = 87,
	WLAN_STATUS_PENDING_GAP_IN_BA_WINDOW = 88,
	WLAN_STATUS_REJECT_U_PID_SETTING = 89,
	WLAN_STATUS_REJECT_DSE_BAND = 96,
	WLAN_STATUS_DENIED_WITH_SUGGESTED_BAND_AND_CHANNEL = 99,
	WLAN_STATUS_DENIED_DUE_TO_SPECTRUM_MANAGEMENT = 103,
	WLAN_STATUS_FILS_AUTHENTICATION_FAILURE = 108,
	WLAN_STATUS_UNKNOWN_AUTHENTICATION_SERVER = 109,
	WLAN_STATUS_SAE_HASH_TO_ELEMENT = 126,
	WLAN_STATUS_SAE_PK = 127,
};

enum ieee80211_reasoncode {
	WLAN_REASON_UNSPECIFIED = 1,
	WLAN_REASON_PREV_AUTH_NOT_VALID = 2,
	WLAN_REASON_DEAUTH_LEAVING = 3,
	WLAN_REASON_DISASSOC_DUE_TO_INACTIVITY = 4,
	WLAN_REASON_DISASSOC_AP_BUSY = 5,
	WLAN_REASON_CLASS2_FRAME_FROM_NONAUTH_STA = 6,
	WLAN_REASON_CLASS3_FRAME_FROM_NONASSOC_STA = 7,
	WLAN_REASON_DISASSOC_STA_HAS_LEFT = 8,
	WLAN_REASON_STA_REQ_ASSOC_WITHOUT_AUTH = 9,
	WLAN_REASON_DISASSOC_BAD_POWER = 10,
	WLAN_REASON_DISASSOC_BAD_SUPP_CHAN = 11,
	WLAN_REASON_INVALID_IE = 13,
	WLAN_REASON_MIC_FAILURE = 14,
	WLAN_REASON_4WAY_HANDSHAKE_TIMEOUT = 15,
	WLAN_REASON_GROUP_KEY_HANDSHAKE_TIMEOUT = 16,
	WLAN_REASON_IE_DIFFERENT = 17,
	WLAN_REASON_INVALID_GROUP_CIPHER = 18,
	WLAN_REASON_INVALID_PAIRWISE_CIPHER = 19,
	WLAN_REASON_INVALID_AKMP = 20,
	WLAN_REASON_UNSUPP_RSN_VERSION = 21,
	WLAN_REASON_INVALID_RSN_IE_CAP = 22,
	WLAN_REASON_IEEE8021X_FAILED = 23,
	WLAN_REASON_CIPHER_SUITE_REJECTED = 24,
	WLAN_REASON_TDLS_TEARDOWN_UNREACHABLE = 25,
	WLAN_REASON_TDLS_TEARDOWN_UNSPECIFIED = 26,
	WLAN_REASON_DISASSOC_UNSPECIFIED_QOS = 32,
	WLAN_REASON_DISASSOC_QAP_NO_BANDWIDTH = 33,
	WLAN_REASON_DISASSOC_LOW_ACK = 34,
	WLAN_REASON_DISASSOC_QAP_EXCEED_TXOP = 35,
	WLAN_REASON_QSTA_LEAVE_QBSS = 36,
	WLAN_REASON_QSTA_NOT_USE = 37,
	WLAN_REASON_QSTA_REQUIRE_SETUP = 38,
	WLAN_REASON_QSTA_TIMEOUT = 39,
	WLAN_REASON_QSTA_CIPHER_NOT_SUPP = 45,
	WLAN_REASON_MESH_PEER_CANCELED = 52,
	WLAN_REASON_MESH_MAX_PEERS = 53,
	WLAN_REASON_MESH_CONFIG = 54,
	WLAN_REASON_MESH_CLOSE = 55,
	WLAN_REASON_MESH_MAX_RETRIES = 56,
	WLAN_REASON_MESH_CONFIRM_TIMEOUT = 57,
	WLAN_REASON_MESH_INVALID_GTK = 58,
	WLAN_REASON_MESH_INCONSISTENT_PARAM = 59,
	WLAN_REASON_MESH_INVALID_SECURITY = 60,
	WLAN_REASON_MESH_PATH_ERROR = 61,
	WLAN_REASON_MESH_PATH_NOFORWARD = 62,
	WLAN_REASON_MESH_PATH_DEST_UNREACHABLE = 63,
	WLAN_REASON_MAC_EXISTS_IN_MBSS = 64,
	WLAN_REASON_MESH_CHAN_REGULATORY = 65,
	WLAN_REASON_MESH_CHAN = 66,
};

enum {
	PRISM2_HOSTAPD_FLUSH = 1,
	PRISM2_HOSTAPD_ADD_STA = 2,
	PRISM2_HOSTAPD_REMOVE_STA = 3,
	PRISM2_HOSTAPD_GET_INFO_STA = 4,
	PRISM2_SET_ENCRYPTION = 6,
	PRISM2_GET_ENCRYPTION = 7,
	PRISM2_HOSTAPD_SET_FLAGS_STA = 8,
	PRISM2_HOSTAPD_GET_RID = 9,
	PRISM2_HOSTAPD_SET_RID = 10,
	PRISM2_HOSTAPD_SET_ASSOC_AP_ADDR = 11,
	PRISM2_HOSTAPD_SET_GENERIC_ELEMENT = 12,
	PRISM2_HOSTAPD_MLME = 13,
	PRISM2_HOSTAPD_SCAN_REQ = 14,
	PRISM2_HOSTAPD_STA_CLEAR_STATS = 15,
};

struct prism2_hostapd_param {
	u32 cmd;
	u8 sta_addr[6];
	union {
		struct {
			u16 aid;
			u16 capability;
			u8 tx_supp_rates;
		} add_sta;
		struct {
			u32 inactive_sec;
		} get_info_sta;
		struct {
			u8 alg[16];
			u32 flags;
			u32 err;
			u8 idx;
			u8 seq[8];
			u16 key_len;
			u8 key[0];
		} crypt;
		struct {
			u32 flags_and;
			u32 flags_or;
		} set_flags_sta;
		struct {
			u16 rid;
			u16 len;
			u8 data[0];
		} rid;
		struct {
			u8 len;
			u8 data[0];
		} generic_elem;
		struct {
			u16 cmd;
			u16 reason_code;
		} mlme;
		struct {
			u8 ssid_len;
			u8 ssid[32];
		} scan_req;
	} u;
};

struct mac_entry {
	struct list_head list;
	u8 addr[6];
};

typedef enum {
	AP_RX_CONTINUE = 0,
	AP_RX_DROP = 1,
	AP_RX_EXIT = 2,
	AP_RX_CONTINUE_NOT_AUTHORIZED = 3,
} ap_rx_ret;

struct hfa384x_join_request {
	u8 bssid[6];
	__le16 channel;
};

struct hfa384x_info_frame {
	__le16 len;
	__le16 type;
};

struct hfa384x_comm_tallies {
	__le16 tx_unicast_frames;
	__le16 tx_multicast_frames;
	__le16 tx_fragments;
	__le16 tx_unicast_octets;
	__le16 tx_multicast_octets;
	__le16 tx_deferred_transmissions;
	__le16 tx_single_retry_frames;
	__le16 tx_multiple_retry_frames;
	__le16 tx_retry_limit_exceeded;
	__le16 tx_discards;
	__le16 rx_unicast_frames;
	__le16 rx_multicast_frames;
	__le16 rx_fragments;
	__le16 rx_unicast_octets;
	__le16 rx_multicast_octets;
	__le16 rx_fcs_errors;
	__le16 rx_discards_no_buffer;
	__le16 tx_discards_wrong_sa;
	__le16 rx_discards_wep_undecryptable;
	__le16 rx_message_in_msg_fragments;
	__le16 rx_message_in_bad_msg_fragments;
};

struct hfa384x_comm_tallies32 {
	__le32 tx_unicast_frames;
	__le32 tx_multicast_frames;
	__le32 tx_fragments;
	__le32 tx_unicast_octets;
	__le32 tx_multicast_octets;
	__le32 tx_deferred_transmissions;
	__le32 tx_single_retry_frames;
	__le32 tx_multiple_retry_frames;
	__le32 tx_retry_limit_exceeded;
	__le32 tx_discards;
	__le32 rx_unicast_frames;
	__le32 rx_multicast_frames;
	__le32 rx_fragments;
	__le32 rx_unicast_octets;
	__le32 rx_multicast_octets;
	__le32 rx_fcs_errors;
	__le32 rx_discards_no_buffer;
	__le32 tx_discards_wrong_sa;
	__le32 rx_discards_wep_undecryptable;
	__le32 rx_message_in_msg_fragments;
	__le32 rx_message_in_bad_msg_fragments;
};

struct hfa384x_scan_result {
	__le16 chid;
	__le16 anl;
	__le16 sl;
	u8 bssid[6];
	__le16 beacon_interval;
	__le16 capability;
	__le16 ssid_len;
	u8 ssid[32];
	u8 sup_rates[10];
	__le16 rate;
};

enum {
	HFA384X_LINKSTATUS_CONNECTED = 1,
	HFA384X_LINKSTATUS_DISCONNECTED = 2,
	HFA384X_LINKSTATUS_AP_CHANGE = 3,
	HFA384X_LINKSTATUS_AP_OUT_OF_RANGE = 4,
	HFA384X_LINKSTATUS_AP_IN_RANGE = 5,
	HFA384X_LINKSTATUS_ASSOC_FAILED = 6,
};

struct iw_scan_req {
	__u8 scan_type;
	__u8 essid_len;
	__u8 num_channels;
	__u8 flags;
	struct sockaddr bssid;
	__u8 essid[32];
	__u32 min_channel_time;
	__u32 max_channel_time;
	struct iw_freq channel_list[32];
};

struct iw_encode_ext {
	__u32 ext_flags;
	__u8 tx_seq[8];
	__u8 rx_seq[8];
	struct sockaddr addr;
	__u16 alg;
	__u16 key_len;
	__u8 key[0];
};

struct iw_mlme {
	__u16 cmd;
	__u16 reason_code;
	struct sockaddr addr;
};

struct iwreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union iwreq_data u;
};

struct iw_range {
	__u32 throughput;
	__u32 min_nwid;
	__u32 max_nwid;
	__u16 old_num_channels;
	__u8 old_num_frequency;
	__u8 scan_capa;
	__u32 event_capa[6];
	__s32 sensitivity;
	struct iw_quality max_qual;
	struct iw_quality avg_qual;
	__u8 num_bitrates;
	__s32 bitrate[32];
	__s32 min_rts;
	__s32 max_rts;
	__s32 min_frag;
	__s32 max_frag;
	__s32 min_pmp;
	__s32 max_pmp;
	__s32 min_pmt;
	__s32 max_pmt;
	__u16 pmp_flags;
	__u16 pmt_flags;
	__u16 pm_capa;
	__u16 encoding_size[8];
	__u8 num_encoding_sizes;
	__u8 max_encoding_tokens;
	__u8 encoding_login_index;
	__u16 txpower_capa;
	__u8 num_txpower;
	__s32 txpower[8];
	__u8 we_version_compiled;
	__u8 we_version_source;
	__u16 retry_capa;
	__u16 retry_flags;
	__u16 r_time_flags;
	__s32 min_retry;
	__s32 max_retry;
	__s32 min_r_time;
	__s32 max_r_time;
	__u16 num_channels;
	__u8 num_frequency;
	struct iw_freq freq[32];
	__u32 enc_capa;
};

enum {
	PRISM2_PARAM_TXRATECTRL = 2,
	PRISM2_PARAM_BEACON_INT = 3,
	PRISM2_PARAM_PSEUDO_IBSS = 4,
	PRISM2_PARAM_ALC = 5,
	PRISM2_PARAM_DUMP = 7,
	PRISM2_PARAM_OTHER_AP_POLICY = 8,
	PRISM2_PARAM_AP_MAX_INACTIVITY = 9,
	PRISM2_PARAM_AP_BRIDGE_PACKETS = 10,
	PRISM2_PARAM_DTIM_PERIOD = 11,
	PRISM2_PARAM_AP_NULLFUNC_ACK = 12,
	PRISM2_PARAM_MAX_WDS = 13,
	PRISM2_PARAM_AP_AUTOM_AP_WDS = 14,
	PRISM2_PARAM_AP_AUTH_ALGS = 15,
	PRISM2_PARAM_MONITOR_ALLOW_FCSERR = 16,
	PRISM2_PARAM_HOST_ENCRYPT = 17,
	PRISM2_PARAM_HOST_DECRYPT = 18,
	PRISM2_PARAM_HOST_ROAMING = 21,
	PRISM2_PARAM_BCRX_STA_KEY = 22,
	PRISM2_PARAM_IEEE_802_1X = 23,
	PRISM2_PARAM_ANTSEL_TX = 24,
	PRISM2_PARAM_ANTSEL_RX = 25,
	PRISM2_PARAM_MONITOR_TYPE = 26,
	PRISM2_PARAM_WDS_TYPE = 27,
	PRISM2_PARAM_HOSTSCAN = 28,
	PRISM2_PARAM_AP_SCAN = 29,
	PRISM2_PARAM_ENH_SEC = 30,
	PRISM2_PARAM_IO_DEBUG = 31,
	PRISM2_PARAM_BASIC_RATES = 32,
	PRISM2_PARAM_OPER_RATES = 33,
	PRISM2_PARAM_HOSTAPD = 34,
	PRISM2_PARAM_HOSTAPD_STA = 35,
	PRISM2_PARAM_WPA = 36,
	PRISM2_PARAM_PRIVACY_INVOKED = 37,
	PRISM2_PARAM_TKIP_COUNTERMEASURES = 38,
	PRISM2_PARAM_DROP_UNENCRYPTED = 39,
	PRISM2_PARAM_SCAN_CHANNEL_MASK = 40,
};

enum {
	HOSTAP_ANTSEL_DO_NOT_TOUCH = 0,
	HOSTAP_ANTSEL_DIVERSITY = 1,
	HOSTAP_ANTSEL_LOW = 2,
	HOSTAP_ANTSEL_HIGH = 3,
};

enum {
	AP_MAC_CMD_POLICY_OPEN = 0,
	AP_MAC_CMD_POLICY_ALLOW = 1,
	AP_MAC_CMD_POLICY_DENY = 2,
	AP_MAC_CMD_FLUSH = 3,
	AP_MAC_CMD_KICKALL = 4,
};

struct hfa384x_scan_request {
	__le16 channel_list;
	__le16 txrate;
};

struct hfa384x_hostscan_request {
	__le16 channel_list;
	__le16 txrate;
	__le16 target_ssid_len;
	u8 target_ssid[32];
};

enum {
	HFA384X_PORTTYPE_BSS = 1,
	HFA384X_PORTTYPE_WDS = 2,
	HFA384X_PORTTYPE_PSEUDO_IBSS = 3,
	HFA384X_PORTTYPE_IBSS = 0,
	HFA384X_PORTTYPE_HOSTAP = 6,
};

struct hfa384x_comms_quality {
	__le16 comm_qual;
	__le16 signal_level;
	__le16 noise_level;
};

struct hfa384x_rx_frame {
	__le16 status;
	__le32 time;
	u8 silence;
	u8 signal;
	u8 rate;
	u8 rxflow;
	__le32 reserved;
	__le16 frame_control;
	__le16 duration_id;
	u8 addr1[6];
	u8 addr2[6];
	u8 addr3[6];
	__le16 seq_ctrl;
	u8 addr4[6];
	__le16 data_len;
	u8 dst_addr[6];
	u8 src_addr[6];
	__be16 len;
} __attribute__((packed));

struct hfa384x_tx_frame {
	__le16 status;
	__le16 reserved1;
	__le16 reserved2;
	__le32 sw_support;
	u8 retry_count;
	u8 tx_rate;
	__le16 tx_control;
	union {
		struct {
			__le16 frame_control;
			__le16 duration_id;
			u8 addr1[6];
			u8 addr2[6];
			u8 addr3[6];
			__le16 seq_ctrl;
		};
		struct {
			__le16 frame_control;
			__le16 duration_id;
			u8 addr1[6];
			u8 addr2[6];
			u8 addr3[6];
			__le16 seq_ctrl;
		} header;
	};
	u8 addr4[6];
	__le16 data_len;
	u8 dst_addr[6];
	u8 src_addr[6];
	__be16 len;
} __attribute__((packed));

enum {
	NONE = 0,
	WEP = 1,
	OTHER = 2,
};

struct usb_device_id {
	__u16 match_flags;
	__u16 idVendor;
	__u16 idProduct;
	__u16 bcdDevice_lo;
	__u16 bcdDevice_hi;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 bInterfaceNumber;
	kernel_ulong_t driver_info;
};

struct usb_device_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__le16 idVendor;
	__le16 idProduct;
	__le16 bcdDevice;
	__u8 iManufacturer;
	__u8 iProduct;
	__u8 iSerialNumber;
	__u8 bNumConfigurations;
};

struct usb_config_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumInterfaces;
	__u8 bConfigurationValue;
	__u8 iConfiguration;
	__u8 bmAttributes;
	__u8 bMaxPower;
} __attribute__((packed));

struct usb_interface_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bInterfaceNumber;
	__u8 bAlternateSetting;
	__u8 bNumEndpoints;
	__u8 bInterfaceClass;
	__u8 bInterfaceSubClass;
	__u8 bInterfaceProtocol;
	__u8 iInterface;
};

struct usb_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bEndpointAddress;
	__u8 bmAttributes;
	__le16 wMaxPacketSize;
	__u8 bInterval;
	__u8 bRefresh;
	__u8 bSynchAddress;
} __attribute__((packed));

struct usb_ssp_isoc_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wReseved;
	__le32 dwBytesPerInterval;
};

struct usb_ss_ep_comp_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bMaxBurst;
	__u8 bmAttributes;
	__le16 wBytesPerInterval;
};

struct usb_interface_assoc_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bFirstInterface;
	__u8 bInterfaceCount;
	__u8 bFunctionClass;
	__u8 bFunctionSubClass;
	__u8 bFunctionProtocol;
	__u8 iFunction;
};

struct usb_bos_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wTotalLength;
	__u8 bNumDeviceCaps;
} __attribute__((packed));

struct usb_ext_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__le32 bmAttributes;
} __attribute__((packed));

struct usb_ss_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bmAttributes;
	__le16 wSpeedSupported;
	__u8 bFunctionalitySupport;
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
};

struct usb_ss_container_id_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__u8 ContainerID[16];
};

struct usb_ssp_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
	__u8 bReserved;
	__le32 bmAttributes;
	__le16 wFunctionalitySupport;
	__le16 wReserved;
	__le32 bmSublinkSpeedAttr[1];
};

struct usb_ptm_cap_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

enum usb_device_speed {
	USB_SPEED_UNKNOWN = 0,
	USB_SPEED_LOW = 1,
	USB_SPEED_FULL = 2,
	USB_SPEED_HIGH = 3,
	USB_SPEED_WIRELESS = 4,
	USB_SPEED_SUPER = 5,
	USB_SPEED_SUPER_PLUS = 6,
};

enum usb_device_state {
	USB_STATE_NOTATTACHED = 0,
	USB_STATE_ATTACHED = 1,
	USB_STATE_POWERED = 2,
	USB_STATE_RECONNECTING = 3,
	USB_STATE_UNAUTHENTICATED = 4,
	USB_STATE_DEFAULT = 5,
	USB_STATE_ADDRESS = 6,
	USB_STATE_CONFIGURED = 7,
	USB_STATE_SUSPENDED = 8,
};

enum usb_ssp_rate {
	USB_SSP_GEN_UNKNOWN = 0,
	USB_SSP_GEN_2x1 = 1,
	USB_SSP_GEN_1x2 = 2,
	USB_SSP_GEN_2x2 = 3,
};

struct ep_device;

struct usb_host_endpoint {
	struct usb_endpoint_descriptor desc;
	struct usb_ss_ep_comp_descriptor ss_ep_comp;
	struct usb_ssp_isoc_ep_comp_descriptor ssp_isoc_ep_comp;
	char: 8;
	struct list_head urb_list;
	void *hcpriv;
	struct ep_device *ep_dev;
	unsigned char *extra;
	int extralen;
	int enabled;
	int streams;
} __attribute__((packed));

struct usb_host_interface {
	struct usb_interface_descriptor desc;
	int extralen;
	unsigned char *extra;
	struct usb_host_endpoint *endpoint;
	char *string;
};

enum usb_interface_condition {
	USB_INTERFACE_UNBOUND = 0,
	USB_INTERFACE_BINDING = 1,
	USB_INTERFACE_BOUND = 2,
	USB_INTERFACE_UNBINDING = 3,
};

struct usb_interface {
	struct usb_host_interface *altsetting;
	struct usb_host_interface *cur_altsetting;
	unsigned int num_altsetting;
	struct usb_interface_assoc_descriptor *intf_assoc;
	int minor;
	enum usb_interface_condition condition;
	unsigned int sysfs_files_created: 1;
	unsigned int ep_devs_created: 1;
	unsigned int unregistering: 1;
	unsigned int needs_remote_wakeup: 1;
	unsigned int needs_altsetting0: 1;
	unsigned int needs_binding: 1;
	unsigned int resetting_device: 1;
	unsigned int authorized: 1;
	int: 24;
	int: 32;
	struct device dev;
	struct device *usb_dev;
	struct work_struct reset_ws;
	int: 32;
};

struct usb_interface_cache {
	unsigned int num_altsetting;
	struct kref ref;
	struct usb_host_interface altsetting[0];
};

struct usb_host_config {
	struct usb_config_descriptor desc;
	char *string;
	struct usb_interface_assoc_descriptor *intf_assoc[16];
	struct usb_interface *interface[32];
	struct usb_interface_cache *intf_cache[32];
	unsigned char *extra;
	int extralen;
};

struct usb_host_bos {
	struct usb_bos_descriptor *desc;
	struct usb_ext_cap_descriptor *ext_cap;
	struct usb_ss_cap_descriptor *ss_cap;
	struct usb_ssp_cap_descriptor *ssp_cap;
	struct usb_ss_container_id_descriptor *ss_id;
	struct usb_ptm_cap_descriptor *ptm_cap;
};

struct usb_devmap {
	long unsigned int devicemap[4];
};

struct usb_device;

struct usb_bus {
	struct device *controller;
	struct device *sysdev;
	int busnum;
	const char *bus_name;
	u8 uses_pio_for_control;
	u8 otg_port;
	unsigned int is_b_host: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int no_stop_on_short: 1;
	unsigned int no_sg_constraint: 1;
	unsigned int sg_tablesize;
	int devnum_next;
	struct mutex devnum_next_mutex;
	struct usb_devmap devmap;
	struct usb_device *root_hub;
	struct usb_bus *hs_companion;
	int bandwidth_allocated;
	int bandwidth_int_reqs;
	int bandwidth_isoc_reqs;
	unsigned int resuming_ports;
};

struct wusb_dev;

struct usb2_lpm_parameters {
	unsigned int besl;
	int timeout;
};

struct usb3_lpm_parameters {
	unsigned int mel;
	unsigned int pel;
	unsigned int sel;
	int timeout;
};

struct usb_tt;

struct usb_device {
	int devnum;
	char devpath[16];
	u32 route;
	enum usb_device_state state;
	enum usb_device_speed speed;
	unsigned int rx_lanes;
	unsigned int tx_lanes;
	enum usb_ssp_rate ssp_rate;
	struct usb_tt *tt;
	int ttport;
	unsigned int toggle[2];
	struct usb_device *parent;
	struct usb_bus *bus;
	struct usb_host_endpoint ep0;
	int: 32;
	struct device dev;
	struct usb_device_descriptor descriptor;
	struct usb_host_bos *bos;
	struct usb_host_config *config;
	struct usb_host_config *actconfig;
	struct usb_host_endpoint *ep_in[16];
	struct usb_host_endpoint *ep_out[16];
	char **rawdescriptors;
	short unsigned int bus_mA;
	u8 portnum;
	u8 level;
	u8 devaddr;
	unsigned int can_submit: 1;
	unsigned int persist_enabled: 1;
	unsigned int reset_in_progress: 1;
	unsigned int have_langid: 1;
	unsigned int authorized: 1;
	unsigned int authenticated: 1;
	unsigned int wusb: 1;
	unsigned int lpm_capable: 1;
	unsigned int lpm_devinit_allow: 1;
	unsigned int usb2_hw_lpm_capable: 1;
	unsigned int usb2_hw_lpm_besl_capable: 1;
	unsigned int usb2_hw_lpm_enabled: 1;
	unsigned int usb2_hw_lpm_allowed: 1;
	unsigned int usb3_lpm_u1_enabled: 1;
	unsigned int usb3_lpm_u2_enabled: 1;
	int string_langid;
	char *product;
	char *manufacturer;
	char *serial;
	struct list_head filelist;
	int maxchild;
	u32 quirks;
	atomic_t urbnum;
	long unsigned int active_duration;
	long unsigned int connect_time;
	unsigned int do_remote_wakeup: 1;
	unsigned int reset_resume: 1;
	unsigned int port_is_suspended: 1;
	struct wusb_dev *wusb_dev;
	int slot_id;
	struct usb2_lpm_parameters l1_params;
	struct usb3_lpm_parameters u1_params;
	struct usb3_lpm_parameters u2_params;
	unsigned int lpm_disable_count;
	u16 hub_delay;
	unsigned int use_generic_driver: 1;
	int: 15;
	int: 32;
};

struct usb_dynids {
	spinlock_t lock;
	struct list_head list;
};

struct usbdrv_wrap {
	struct device_driver driver;
	int for_devices;
};

struct usb_driver {
	const char *name;
	int (*probe)(struct usb_interface *, const struct usb_device_id *);
	void (*disconnect)(struct usb_interface *);
	int (*unlocked_ioctl)(struct usb_interface *, unsigned int, void *);
	int (*suspend)(struct usb_interface *, pm_message_t);
	int (*resume)(struct usb_interface *);
	int (*reset_resume)(struct usb_interface *);
	int (*pre_reset)(struct usb_interface *);
	int (*post_reset)(struct usb_interface *);
	const struct usb_device_id *id_table;
	const struct attribute_group **dev_groups;
	struct usb_dynids dynids;
	struct usbdrv_wrap drvwrap;
	unsigned int no_dynamic_id: 1;
	unsigned int supports_autosuspend: 1;
	unsigned int disable_hub_initiated_lpm: 1;
	unsigned int soft_unbind: 1;
};

struct usb_iso_packet_descriptor {
	unsigned int offset;
	unsigned int length;
	unsigned int actual_length;
	int status;
};

struct usb_anchor {
	struct list_head urb_list;
	wait_queue_head_t wait;
	spinlock_t lock;
	atomic_t suspend_wakeups;
	unsigned int poisoned: 1;
};

struct urb;

typedef void (*usb_complete_t)(struct urb *);

struct urb {
	struct kref kref;
	int unlinked;
	void *hcpriv;
	atomic_t use_count;
	atomic_t reject;
	struct list_head urb_list;
	struct list_head anchor_list;
	struct usb_anchor *anchor;
	struct usb_device *dev;
	struct usb_host_endpoint *ep;
	unsigned int pipe;
	unsigned int stream_id;
	int status;
	unsigned int transfer_flags;
	void *transfer_buffer;
	dma_addr_t transfer_dma;
	struct scatterlist *sg;
	int num_mapped_sgs;
	int num_sgs;
	u32 transfer_buffer_length;
	u32 actual_length;
	unsigned char *setup_packet;
	dma_addr_t setup_dma;
	int start_frame;
	int number_of_packets;
	int interval;
	int error_count;
	void *context;
	usb_complete_t complete;
	struct usb_iso_packet_descriptor iso_frame_desc[0];
};

typedef u32 acpi_size;

typedef u64 acpi_io_address;

typedef u32 acpi_status;

typedef char *acpi_string;

typedef u32 acpi_object_type;

union acpi_object {
	acpi_object_type type;
	struct {
		acpi_object_type type;
		int: 32;
		u64 value;
	} integer;
	struct {
		acpi_object_type type;
		u32 length;
		char *pointer;
	} string;
	struct {
		acpi_object_type type;
		u32 length;
		u8 *pointer;
	} buffer;
	struct {
		acpi_object_type type;
		u32 count;
		union acpi_object *elements;
	} package;
	struct {
		acpi_object_type type;
		acpi_object_type actual_type;
		acpi_handle handle;
	} reference;
	struct {
		acpi_object_type type;
		u32 proc_id;
		acpi_io_address pblk_address;
		u32 pblk_length;
		int: 32;
	} processor;
	struct {
		acpi_object_type type;
		u32 system_level;
		u32 resource_order;
	} power_resource;
};

struct acpi_object_list {
	u32 count;
	union acpi_object *pointer;
};

struct acpi_buffer {
	acpi_size length;
	void *pointer;
};

enum spd_duplex {
	NWAY_10M_HALF = 0,
	NWAY_10M_FULL = 1,
	NWAY_100M_HALF = 2,
	NWAY_100M_FULL = 3,
	NWAY_1000M_FULL = 4,
	FORCE_10M_HALF = 5,
	FORCE_10M_FULL = 6,
	FORCE_100M_HALF = 7,
	FORCE_100M_FULL = 8,
	FORCE_1000M_FULL = 9,
	NWAY_2500M_FULL = 10,
};

enum rtl_register_content {
	_2500bps = 1024,
	_1250bps = 512,
	_500bps = 256,
	_tx_flow = 64,
	_rx_flow = 32,
	_1000bps = 16,
	_100bps = 8,
	_10bps = 4,
	LINK_STATUS = 2,
	FULL_DUP = 1,
};

enum rtl8152_flags {
	RTL8152_UNPLUG = 0,
	RTL8152_SET_RX_MODE = 1,
	WORK_ENABLE = 2,
	RTL8152_LINK_CHG = 3,
	SELECTIVE_SUSPEND = 4,
	PHY_RESET = 5,
	SCHEDULE_TASKLET = 6,
	GREEN_ETHERNET = 7,
	RX_EPROTO = 8,
};

struct tally_counter {
	__le64 tx_packets;
	__le64 rx_packets;
	__le64 tx_errors;
	__le32 rx_errors;
	__le16 rx_missed;
	__le16 align_errors;
	__le32 tx_one_collision;
	__le32 tx_multi_collision;
	__le64 rx_unicast;
	__le64 rx_broadcast;
	__le32 rx_multicast;
	__le16 tx_aborted;
	__le16 tx_underrun;
};

struct rx_desc {
	__le32 opts1;
	__le32 opts2;
	__le32 opts3;
	__le32 opts4;
	__le32 opts5;
	__le32 opts6;
};

struct tx_desc {
	__le32 opts1;
	__le32 opts2;
};

struct r8152;

struct rx_agg {
	struct list_head list;
	struct list_head info_list;
	struct urb *urb;
	struct r8152 *context;
	struct page *page;
	void *buffer;
};

struct tx_agg {
	struct list_head list;
	struct urb *urb;
	struct r8152 *context;
	void *buffer;
	void *head;
	u32 skb_num;
	u32 skb_len;
};

struct rtl_ops {
	void (*init)(struct r8152 *);
	int (*enable)(struct r8152 *);
	void (*disable)(struct r8152 *);
	void (*up)(struct r8152 *);
	void (*down)(struct r8152 *);
	void (*unload)(struct r8152 *);
	int (*eee_get)(struct r8152 *, struct ethtool_eee *);
	int (*eee_set)(struct r8152 *, struct ethtool_eee *);
	bool (*in_nway)(struct r8152 *);
	void (*hw_phy_cfg)(struct r8152 *);
	void (*autosuspend_en)(struct r8152 *, bool);
	void (*change_mtu)(struct r8152 *);
};

struct ups_info {
	u32 r_tune: 1;
	u32 _10m_ckdiv: 1;
	u32 _250m_ckdiv: 1;
	u32 aldps: 1;
	u32 lite_mode: 2;
	u32 speed_duplex: 4;
	u32 eee: 1;
	u32 eee_lite: 1;
	u32 eee_ckdiv: 1;
	u32 eee_plloff_100: 1;
	u32 eee_plloff_giga: 1;
	u32 eee_cmod_lv: 1;
	u32 green: 1;
	u32 flow_control: 1;
	u32 ctap_short_off: 1;
};

struct rtl_fw {
	const char *fw_name;
	const struct firmware *fw;
	char version[32];
	int (*pre_fw)(struct r8152 *);
	int (*post_fw)(struct r8152 *);
	bool retry;
};

struct r8152 {
	long unsigned int flags;
	struct usb_device *udev;
	struct napi_struct napi;
	struct usb_interface *intf;
	struct net_device *netdev;
	struct urb *intr_urb;
	struct tx_agg tx_info[4];
	struct list_head rx_info;
	struct list_head rx_used;
	struct list_head rx_done;
	struct list_head tx_free;
	struct sk_buff_head tx_queue;
	struct sk_buff_head rx_queue;
	spinlock_t rx_lock;
	spinlock_t tx_lock;
	struct delayed_work schedule;
	struct delayed_work hw_phy_work;
	struct mii_if_info mii;
	struct mutex control;
	struct notifier_block pm_notifier;
	struct tasklet_struct tx_tl;
	struct rtl_ops rtl_ops;
	struct ups_info ups_info;
	struct rtl_fw rtl_fw;
	atomic_t rx_count;
	bool eee_en;
	int intr_interval;
	u32 saved_wolopts;
	u32 msg_enable;
	u32 tx_qlen;
	u32 coalesce;
	u32 advertising;
	u32 rx_buf_sz;
	u32 rx_copybreak;
	u32 rx_pending;
	u32 fc_pause_on;
	u32 fc_pause_off;
	unsigned int pipe_in;
	unsigned int pipe_out;
	unsigned int pipe_intr;
	unsigned int pipe_ctrl_in;
	unsigned int pipe_ctrl_out;
	u32 support_2500full: 1;
	u32 lenovo_macpassthru: 1;
	u32 dell_tb_rx_agg_bug: 1;
	u16 ocp_base;
	u16 speed;
	u16 eee_adv;
	u8 *intr_buff;
	u8 version;
	u8 duplex;
	u8 autoneg;
	int: 8;
	int: 32;
};

struct fw_block {
	__le32 type;
	__le32 length;
};

struct fw_header {
	u8 checksum[32];
	char version[32];
	struct fw_block blocks[0];
};

enum rtl8152_fw_flags {
	FW_FLAGS_USB = 0,
	FW_FLAGS_PLA = 1,
	FW_FLAGS_START = 2,
	FW_FLAGS_STOP = 3,
	FW_FLAGS_NC = 4,
	FW_FLAGS_NC1 = 5,
	FW_FLAGS_NC2 = 6,
	FW_FLAGS_UC2 = 7,
	FW_FLAGS_UC = 8,
	FW_FLAGS_SPEED_UP = 9,
	FW_FLAGS_VER = 10,
};

enum rtl8152_fw_fixup_cmd {
	FW_FIXUP_AND = 0,
	FW_FIXUP_OR = 1,
	FW_FIXUP_NOT = 2,
	FW_FIXUP_XOR = 3,
};

struct fw_phy_set {
	__le16 addr;
	__le16 data;
};

struct fw_phy_speed_up {
	struct fw_block blk_hdr;
	__le16 fw_offset;
	__le16 version;
	__le16 fw_reg;
	__le16 reserved;
	char info[0];
};

struct fw_phy_ver {
	struct fw_block blk_hdr;
	struct fw_phy_set ver;
	__le32 reserved;
};

struct fw_phy_fixup {
	struct fw_block blk_hdr;
	struct fw_phy_set setting;
	__le16 bit_cmd;
	__le16 reserved;
};

struct fw_phy_union {
	struct fw_block blk_hdr;
	__le16 fw_offset;
	__le16 fw_reg;
	struct fw_phy_set pre_set[2];
	struct fw_phy_set bp[8];
	struct fw_phy_set bp_en;
	u8 pre_num;
	u8 bp_num;
	char info[0];
} __attribute__((packed));

struct fw_mac {
	struct fw_block blk_hdr;
	__le16 fw_offset;
	__le16 fw_reg;
	__le16 bp_ba_addr;
	__le16 bp_ba_value;
	__le16 bp_en_addr;
	__le16 bp_en_value;
	__le16 bp_start;
	__le16 bp_num;
	__le16 bp[16];
	__le32 reserved;
	__le16 fw_ver_reg;
	u8 fw_ver_data;
	char info[0];
} __attribute__((packed));

struct fw_phy_patch_key {
	struct fw_block blk_hdr;
	__le16 key_reg;
	__le16 key_data;
	__le32 reserved;
};

struct fw_phy_nc {
	struct fw_block blk_hdr;
	__le16 fw_offset;
	__le16 fw_reg;
	__le16 ba_reg;
	__le16 ba_data;
	__le16 patch_en_addr;
	__le16 patch_en_value;
	__le16 mode_reg;
	__le16 mode_pre;
	__le16 mode_post;
	__le16 reserved;
	__le16 bp_start;
	__le16 bp_num;
	__le16 bp[4];
	char info[0];
};

enum rtl_fw_type {
	RTL_FW_END = 0,
	RTL_FW_PLA = 1,
	RTL_FW_USB = 2,
	RTL_FW_PHY_START = 3,
	RTL_FW_PHY_STOP = 4,
	RTL_FW_PHY_NC = 5,
	RTL_FW_PHY_FIXUP = 6,
	RTL_FW_PHY_UNION_NC = 7,
	RTL_FW_PHY_UNION_NC1 = 8,
	RTL_FW_PHY_UNION_NC2 = 9,
	RTL_FW_PHY_UNION_UC2 = 10,
	RTL_FW_PHY_UNION_UC = 11,
	RTL_FW_PHY_UNION_MISC = 12,
	RTL_FW_PHY_SPEED_UP = 13,
	RTL_FW_PHY_VER = 14,
};

enum rtl_version {
	RTL_VER_UNKNOWN = 0,
	RTL_VER_01 = 1,
	RTL_VER_02 = 2,
	RTL_VER_03 = 3,
	RTL_VER_04 = 4,
	RTL_VER_05 = 5,
	RTL_VER_06 = 6,
	RTL_VER_07 = 7,
	RTL_VER_08 = 8,
	RTL_VER_09 = 9,
	RTL_TEST_01 = 10,
	RTL_VER_10 = 11,
	RTL_VER_11 = 12,
	RTL_VER_12 = 13,
	RTL_VER_13 = 14,
	RTL_VER_14 = 15,
	RTL_VER_15 = 16,
	RTL_VER_MAX = 17,
};

enum tx_csum_stat {
	TX_CSUM_SUCCESS = 0,
	TX_CSUM_TSO = 1,
	TX_CSUM_NONE = 2,
};

struct udp_hslot;

struct udp_table {
	struct udp_hslot *hash;
	struct udp_hslot *hash2;
	unsigned int mask;
	unsigned int log;
};

struct udp_hslot {
	struct hlist_head head;
	int count;
	spinlock_t lock;
	int: 32;
};

struct udp_tunnel_info {
	short unsigned int type;
	sa_family_t sa_family;
	__be16 port;
	u8 hw_priv;
};

struct udp_tunnel_nic_shared {
	struct udp_tunnel_nic *udp_tunnel_nic_info;
	struct list_head devices;
};

struct lan78xx_statstage {
	u32 rx_fcs_errors;
	u32 rx_alignment_errors;
	u32 rx_fragment_errors;
	u32 rx_jabber_errors;
	u32 rx_undersize_frame_errors;
	u32 rx_oversize_frame_errors;
	u32 rx_dropped_frames;
	u32 rx_unicast_byte_count;
	u32 rx_broadcast_byte_count;
	u32 rx_multicast_byte_count;
	u32 rx_unicast_frames;
	u32 rx_broadcast_frames;
	u32 rx_multicast_frames;
	u32 rx_pause_frames;
	u32 rx_64_byte_frames;
	u32 rx_65_127_byte_frames;
	u32 rx_128_255_byte_frames;
	u32 rx_256_511_bytes_frames;
	u32 rx_512_1023_byte_frames;
	u32 rx_1024_1518_byte_frames;
	u32 rx_greater_1518_byte_frames;
	u32 eee_rx_lpi_transitions;
	u32 eee_rx_lpi_time;
	u32 tx_fcs_errors;
	u32 tx_excess_deferral_errors;
	u32 tx_carrier_errors;
	u32 tx_bad_byte_count;
	u32 tx_single_collisions;
	u32 tx_multiple_collisions;
	u32 tx_excessive_collision;
	u32 tx_late_collisions;
	u32 tx_unicast_byte_count;
	u32 tx_broadcast_byte_count;
	u32 tx_multicast_byte_count;
	u32 tx_unicast_frames;
	u32 tx_broadcast_frames;
	u32 tx_multicast_frames;
	u32 tx_pause_frames;
	u32 tx_64_byte_frames;
	u32 tx_65_127_byte_frames;
	u32 tx_128_255_byte_frames;
	u32 tx_256_511_bytes_frames;
	u32 tx_512_1023_byte_frames;
	u32 tx_1024_1518_byte_frames;
	u32 tx_greater_1518_byte_frames;
	u32 eee_tx_lpi_transitions;
	u32 eee_tx_lpi_time;
};

struct lan78xx_statstage64 {
	u64 rx_fcs_errors;
	u64 rx_alignment_errors;
	u64 rx_fragment_errors;
	u64 rx_jabber_errors;
	u64 rx_undersize_frame_errors;
	u64 rx_oversize_frame_errors;
	u64 rx_dropped_frames;
	u64 rx_unicast_byte_count;
	u64 rx_broadcast_byte_count;
	u64 rx_multicast_byte_count;
	u64 rx_unicast_frames;
	u64 rx_broadcast_frames;
	u64 rx_multicast_frames;
	u64 rx_pause_frames;
	u64 rx_64_byte_frames;
	u64 rx_65_127_byte_frames;
	u64 rx_128_255_byte_frames;
	u64 rx_256_511_bytes_frames;
	u64 rx_512_1023_byte_frames;
	u64 rx_1024_1518_byte_frames;
	u64 rx_greater_1518_byte_frames;
	u64 eee_rx_lpi_transitions;
	u64 eee_rx_lpi_time;
	u64 tx_fcs_errors;
	u64 tx_excess_deferral_errors;
	u64 tx_carrier_errors;
	u64 tx_bad_byte_count;
	u64 tx_single_collisions;
	u64 tx_multiple_collisions;
	u64 tx_excessive_collision;
	u64 tx_late_collisions;
	u64 tx_unicast_byte_count;
	u64 tx_broadcast_byte_count;
	u64 tx_multicast_byte_count;
	u64 tx_unicast_frames;
	u64 tx_broadcast_frames;
	u64 tx_multicast_frames;
	u64 tx_pause_frames;
	u64 tx_64_byte_frames;
	u64 tx_65_127_byte_frames;
	u64 tx_128_255_byte_frames;
	u64 tx_256_511_bytes_frames;
	u64 tx_512_1023_byte_frames;
	u64 tx_1024_1518_byte_frames;
	u64 tx_greater_1518_byte_frames;
	u64 eee_tx_lpi_transitions;
	u64 eee_tx_lpi_time;
};

struct lan78xx_net;

struct lan78xx_priv {
	struct lan78xx_net *dev;
	u32 rfe_ctl;
	u32 mchash_table[16];
	u32 pfilter_table[66];
	u32 vlan_table[128];
	struct mutex dataport_mutex;
	spinlock_t rfe_ctl_lock;
	struct work_struct set_multicast;
	struct work_struct set_vlan;
	u32 wol;
};

struct statstage {
	struct mutex access_lock;
	struct lan78xx_statstage saved;
	struct lan78xx_statstage rollover_count;
	struct lan78xx_statstage rollover_max;
	struct lan78xx_statstage64 curr_stat;
};

struct irq_domain_data {
	struct irq_domain *irqdomain;
	unsigned int phyirq;
	struct irq_chip *irqchip;
	irq_flow_handler_t irq_handler;
	u32 irqenable;
	struct mutex irq_lock;
};

struct lan78xx_net {
	struct net_device *net;
	struct usb_device *udev;
	struct usb_interface *intf;
	void *driver_priv;
	unsigned int tx_pend_data_len;
	size_t n_tx_urbs;
	size_t n_rx_urbs;
	size_t tx_urb_size;
	size_t rx_urb_size;
	struct sk_buff_head rxq_free;
	struct sk_buff_head rxq;
	struct sk_buff_head rxq_done;
	struct sk_buff_head rxq_overflow;
	struct sk_buff_head txq_free;
	struct sk_buff_head txq;
	struct sk_buff_head txq_pend;
	int: 32;
	struct napi_struct napi;
	struct delayed_work wq;
	int msg_enable;
	struct urb *urb_intr;
	struct usb_anchor deferred;
	struct mutex dev_mutex;
	struct mutex phy_mutex;
	unsigned int pipe_in;
	unsigned int pipe_out;
	unsigned int pipe_intr;
	unsigned int bulk_in_delay;
	unsigned int burst_cap;
	long unsigned int flags;
	wait_queue_head_t *wait;
	unsigned char suspend_count;
	unsigned int maxpacket;
	struct timer_list stat_monitor;
	long unsigned int data[5];
	int link_on;
	u8 mdix_ctrl;
	u32 chipid;
	u32 chiprev;
	struct mii_bus *mdiobus;
	phy_interface_t interface;
	int fc_autoneg;
	u8 fc_request_control;
	int delta;
	int: 32;
	struct statstage stats;
	struct irq_domain_data domain_data;
};

enum skb_state {
	illegal = 0,
	tx_start = 1,
	tx_done = 2,
	rx_start = 3,
	rx_done = 4,
	rx_cleanup = 5,
	unlink_start = 6,
};

struct skb_data {
	struct urb *urb;
	struct lan78xx_net *dev;
	enum skb_state state;
	size_t length;
	int num_of_packet;
};

struct driver_info;

struct usbnet {
	struct usb_device *udev;
	struct usb_interface *intf;
	const struct driver_info *driver_info;
	const char *driver_name;
	void *driver_priv;
	wait_queue_head_t wait;
	struct mutex phy_mutex;
	unsigned char suspend_count;
	unsigned char pkt_cnt;
	unsigned char pkt_err;
	short unsigned int rx_qlen;
	short unsigned int tx_qlen;
	unsigned int can_dma_sg: 1;
	unsigned int in;
	unsigned int out;
	struct usb_host_endpoint *status;
	unsigned int maxpacket;
	struct timer_list delay;
	const char *padding_pkt;
	struct net_device *net;
	int msg_enable;
	long unsigned int data[5];
	u32 xid;
	u32 hard_mtu;
	size_t rx_urb_size;
	struct mii_if_info mii;
	long int rx_speed;
	long int tx_speed;
	struct sk_buff_head rxq;
	struct sk_buff_head txq;
	struct sk_buff_head done;
	struct sk_buff_head rxq_pause;
	struct urb *interrupt;
	unsigned int interrupt_count;
	struct mutex interrupt_mutex;
	struct usb_anchor deferred;
	struct tasklet_struct bh;
	struct work_struct kevent;
	long unsigned int flags;
};

struct driver_info {
	char *description;
	int flags;
	int (*bind)(struct usbnet *, struct usb_interface *);
	void (*unbind)(struct usbnet *, struct usb_interface *);
	int (*reset)(struct usbnet *);
	int (*stop)(struct usbnet *);
	int (*check_connect)(struct usbnet *);
	int (*manage_power)(struct usbnet *, int);
	void (*status)(struct usbnet *, struct urb *);
	int (*link_reset)(struct usbnet *);
	int (*rx_fixup)(struct usbnet *, struct sk_buff *);
	struct sk_buff * (*tx_fixup)(struct usbnet *, struct sk_buff *, gfp_t);
	void (*recover)(struct usbnet *);
	int (*early_init)(struct usbnet *);
	void (*indication)(struct usbnet *, void *, int);
	void (*set_rx_mode)(struct usbnet *);
	int in;
	int out;
	long unsigned int data;
};

struct asix_data {
	u8 multi_filter[8];
	u8 mac_addr[6];
	u8 phymode;
	u8 ledmode;
	u8 res;
};

struct asix_rx_fixup_info {
	struct sk_buff *ax_skb;
	u32 header;
	u16 remaining;
	bool split_head;
};

struct asix_common_private {
	void (*resume)(struct usbnet *);
	void (*suspend)(struct usbnet *);
	int (*reset)(struct usbnet *, int);
	u16 presvd_phy_advertise;
	u16 presvd_phy_bmcr;
	struct asix_rx_fixup_info rx_fixup_info;
	struct mii_bus *mdio;
	struct phy_device *phydev;
	struct phy_device *phydev_int;
	struct phylink *phylink;
	struct phylink_config phylink_config;
	u16 phy_addr;
	bool embd_phy;
	u8 chipcode;
};

struct ax88172_int_data {
	__le16 res1;
	u8 link;
	__le16 res2;
	u8 status;
	__le16 res3;
} __attribute__((packed));

struct skb_data___2 {
	struct urb *urb;
	struct usbnet *dev;
	enum skb_state state;
	long int length;
	long unsigned int packets;
};

struct ax88172a_private {
	struct mii_bus *mdio;
	struct phy_device *phydev;
	char phy_name[20];
	u16 phy_addr;
	u16 oldmode;
	int use_embdphy;
	struct asix_rx_fixup_info rx_fixup_info;
};

struct ax88179_data {
	u8 eee_enabled;
	u8 eee_active;
	u16 rxctl;
	u8 in_pm;
	u32 wol_supported;
	u32 wolopts;
};

struct ax88179_int_data {
	__le32 intdata1;
	__le32 intdata2;
};

struct usb_cdc_header_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdCDC;
} __attribute__((packed));

struct usb_cdc_call_mgmt_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
	__u8 bDataInterface;
};

struct usb_cdc_acm_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bmCapabilities;
};

struct usb_cdc_union_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bMasterInterface0;
	__u8 bSlaveInterface0;
};

struct usb_cdc_country_functional_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iCountryCodeRelDate;
	__le16 wCountyCode0;
};

struct usb_cdc_network_terminal_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bEntityId;
	__u8 iName;
	__u8 bChannelIndex;
	__u8 bPhysicalInterface;
};

struct usb_cdc_ether_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 iMACAddress;
	__le32 bmEthernetStatistics;
	__le16 wMaxSegmentSize;
	__le16 wNumberMCFilters;
	__u8 bNumberPowerFilters;
} __attribute__((packed));

struct usb_cdc_dmm_desc {
	__u8 bFunctionLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u16 bcdVersion;
	__le16 wMaxCommand;
} __attribute__((packed));

struct usb_cdc_mdlm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
	__u8 bGUID[16];
} __attribute__((packed));

struct usb_cdc_mdlm_detail_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bGuidDescriptorType;
	__u8 bDetailData[0];
};

struct usb_cdc_obex_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdVersion;
} __attribute__((packed));

struct usb_cdc_ncm_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdNcmVersion;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMVersion;
	__le16 wMaxControlMessage;
	__u8 bNumberFilters;
	__u8 bMaxFilterSize;
	__le16 wMaxSegmentSize;
	__u8 bmNetworkCapabilities;
} __attribute__((packed));

struct usb_cdc_mbim_extended_desc {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdMBIMExtendedVersion;
	__u8 bMaxOutstandingCommandMessages;
	__le16 wMTU;
} __attribute__((packed));

struct usb_cdc_notification {
	__u8 bmRequestType;
	__u8 bNotificationType;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

struct usb_cdc_parsed_header {
	struct usb_cdc_union_desc *usb_cdc_union_desc;
	struct usb_cdc_header_desc *usb_cdc_header_desc;
	struct usb_cdc_call_mgmt_descriptor *usb_cdc_call_mgmt_descriptor;
	struct usb_cdc_acm_descriptor *usb_cdc_acm_descriptor;
	struct usb_cdc_country_functional_desc *usb_cdc_country_functional_desc;
	struct usb_cdc_network_terminal_desc *usb_cdc_network_terminal_desc;
	struct usb_cdc_ether_desc *usb_cdc_ether_desc;
	struct usb_cdc_dmm_desc *usb_cdc_dmm_desc;
	struct usb_cdc_mdlm_desc *usb_cdc_mdlm_desc;
	struct usb_cdc_mdlm_detail_desc *usb_cdc_mdlm_detail_desc;
	struct usb_cdc_obex_desc *usb_cdc_obex_desc;
	struct usb_cdc_ncm_desc *usb_cdc_ncm_desc;
	struct usb_cdc_mbim_desc *usb_cdc_mbim_desc;
	struct usb_cdc_mbim_extended_desc *usb_cdc_mbim_extended_desc;
	bool phonet_magic_present;
};

struct cdc_state {
	struct usb_cdc_header_desc *header;
	struct usb_cdc_union_desc *u;
	struct usb_cdc_ether_desc *ether;
	struct usb_interface *control;
	struct usb_interface *data;
};

struct smsc95xx_priv {
	u32 mac_cr;
	u32 hash_hi;
	u32 hash_lo;
	u32 wolopts;
	spinlock_t mac_cr_lock;
	u8 features;
	u8 suspend_flags;
	bool is_internal_phy;
	struct irq_chip irqchip;
	struct irq_domain *irqdomain;
	struct fwnode_handle *irqfwnode;
	struct mii_bus *mdiobus;
	struct phy_device *phydev;
	struct task_struct *pm_task;
};

struct nc_header {
	__le16 hdr_len;
	__le16 packet_len;
	__le16 packet_id;
};

struct nc_trailer {
	__le16 packet_id;
};

enum {
	HIF_REG_MULTICAST_HASH = 0,
	HIF_REG_PACKET_GAP1 = 8,
	HIF_REG_PACKET_GAP2 = 9,
	HIF_REG_PHY_DATA = 10,
	HIF_REG_PHY_CMD1 = 12,
	HIF_REG_PHY_CMD1_READ = 64,
	HIF_REG_PHY_CMD1_WRITE = 32,
	HIF_REG_PHY_CMD1_PHYADDR = 1,
	HIF_REG_PHY_CMD2 = 13,
	HIF_REG_PHY_CMD2_PEND_FLAG_BIT = 128,
	HIF_REG_PHY_CMD2_READY_FLAG_BIT = 64,
	HIF_REG_CONFIG = 14,
	HIF_REG_CONFIG_CFG = 128,
	HIF_REG_CONFIG_SPEED100 = 64,
	HIF_REG_CONFIG_FULLDUPLEX_ENABLE = 32,
	HIF_REG_CONFIG_RXENABLE = 16,
	HIF_REG_CONFIG_TXENABLE = 8,
	HIF_REG_CONFIG_SLEEPMODE = 4,
	HIF_REG_CONFIG_ALLMULTICAST = 2,
	HIF_REG_CONFIG_PROMISCUOUS = 1,
	HIF_REG_ETHERNET_ADDR = 15,
	HIF_REG_FRAME_DROP_COUNTER = 21,
	HIF_REG_PAUSE_THRESHOLD = 22,
	HIF_REG_PAUSE_THRESHOLD_DEFAULT = 0,
};

enum {
	MCS7830_RX_SHORT_FRAME = 1,
	MCS7830_RX_LENGTH_ERROR = 2,
	MCS7830_RX_ALIGNMENT_ERROR = 4,
	MCS7830_RX_CRC_ERROR = 8,
	MCS7830_RX_LARGE_FRAME = 16,
	MCS7830_RX_FRAME_CORRECT = 32,
};

struct mcs7830_data {
	u8 multi_filter[8];
	u8 config;
};

struct usb_ctrlrequest {
	__u8 bRequestType;
	__u8 bRequest;
	__le16 wValue;
	__le16 wIndex;
	__le16 wLength;
};

struct usb_cdc_speed_change {
	__le32 DLBitRRate;
	__le32 ULBitRate;
};

struct usb_cdc_ncm_ntb_parameters {
	__le16 wLength;
	__le16 bmNtbFormatsSupported;
	__le32 dwNtbInMaxSize;
	__le16 wNdpInDivisor;
	__le16 wNdpInPayloadRemainder;
	__le16 wNdpInAlignment;
	__le16 wPadding1;
	__le32 dwNtbOutMaxSize;
	__le16 wNdpOutDivisor;
	__le16 wNdpOutPayloadRemainder;
	__le16 wNdpOutAlignment;
	__le16 wNtbOutMaxDatagrams;
};

struct usb_cdc_ncm_nth16 {
	__le32 dwSignature;
	__le16 wHeaderLength;
	__le16 wSequence;
	__le16 wBlockLength;
	__le16 wNdpIndex;
};

struct usb_cdc_ncm_nth32 {
	__le32 dwSignature;
	__le16 wHeaderLength;
	__le16 wSequence;
	__le32 dwBlockLength;
	__le32 dwNdpIndex;
};

struct usb_cdc_ncm_dpe16 {
	__le16 wDatagramIndex;
	__le16 wDatagramLength;
};

struct usb_cdc_ncm_ndp16 {
	__le32 dwSignature;
	__le16 wLength;
	__le16 wNextNdpIndex;
	struct usb_cdc_ncm_dpe16 dpe16[0];
};

struct usb_cdc_ncm_dpe32 {
	__le32 dwDatagramIndex;
	__le32 dwDatagramLength;
};

struct usb_cdc_ncm_ndp32 {
	__le32 dwSignature;
	__le16 wLength;
	__le16 wReserved6;
	__le32 dwNextNdpIndex;
	__le32 dwReserved12;
	struct usb_cdc_ncm_dpe32 dpe32[0];
};

struct cdc_ncm_ctx {
	struct usb_cdc_ncm_ntb_parameters ncm_parm;
	int: 32;
	struct hrtimer tx_timer;
	struct tasklet_struct bh;
	struct usbnet *dev;
	const struct usb_cdc_ncm_desc *func_desc;
	const struct usb_cdc_mbim_desc *mbim_desc;
	const struct usb_cdc_mbim_extended_desc *mbim_extended_desc;
	const struct usb_cdc_ether_desc *ether_desc;
	struct usb_interface *control;
	struct usb_interface *data;
	struct sk_buff *tx_curr_skb;
	struct sk_buff *tx_rem_skb;
	__le32 tx_rem_sign;
	spinlock_t mtx;
	atomic_t stop;
	int drvflags;
	u32 timer_interval;
	u32 max_ndp_size;
	u8 is_ndp16;
	union {
		struct usb_cdc_ncm_ndp16 *delayed_ndp16;
		struct usb_cdc_ncm_ndp32 *delayed_ndp32;
	};
	u32 tx_timer_pending;
	u32 tx_curr_frame_num;
	u32 rx_max;
	u32 tx_max;
	u32 tx_curr_size;
	u32 tx_low_mem_max_cnt;
	u32 tx_low_mem_val;
	u32 max_datagram_size;
	u16 tx_max_datagrams;
	u16 tx_remainder;
	u16 tx_modulus;
	u16 tx_ndp_modulus;
	u16 tx_seq;
	u16 rx_seq;
	u16 min_tx_pkt;
	u32 tx_curr_frame_payload;
	u32 tx_reason_ntb_full;
	u32 tx_reason_ndp_full;
	u32 tx_reason_timeout;
	u32 tx_reason_max_datagram;
	u64 tx_overhead;
	u64 tx_ntbs;
	u64 rx_overhead;
	u64 rx_ntbs;
};

struct cdc_ncm_stats {
	char stat_string[32];
	int sizeof_stat;
	int stat_offset;
};

enum usb_otg_state {
	OTG_STATE_UNDEFINED = 0,
	OTG_STATE_B_IDLE = 1,
	OTG_STATE_B_SRP_INIT = 2,
	OTG_STATE_B_PERIPHERAL = 3,
	OTG_STATE_B_WAIT_ACON = 4,
	OTG_STATE_B_HOST = 5,
	OTG_STATE_A_IDLE = 6,
	OTG_STATE_A_WAIT_VRISE = 7,
	OTG_STATE_A_WAIT_BCON = 8,
	OTG_STATE_A_HOST = 9,
	OTG_STATE_A_SUSPEND = 10,
	OTG_STATE_A_PERIPHERAL = 11,
	OTG_STATE_A_WAIT_VFALL = 12,
	OTG_STATE_A_VBUS_ERR = 13,
};

struct usb_otg_caps {
	u16 otg_rev;
	bool hnp_support;
	bool srp_support;
	bool adp_support;
};

enum usb_dr_mode {
	USB_DR_MODE_UNKNOWN = 0,
	USB_DR_MODE_HOST = 1,
	USB_DR_MODE_PERIPHERAL = 2,
	USB_DR_MODE_OTG = 3,
};

struct ulpi_ops {
	int (*read)(struct device *, u8);
	int (*write)(struct device *, u8, u8);
};

struct ulpi_device_id {
	__u16 vendor;
	__u16 product;
	kernel_ulong_t driver_data;
};

struct ulpi {
	struct ulpi_device_id id;
	const struct ulpi_ops *ops;
	int: 32;
	struct device dev;
};

struct ulpi_driver {
	const struct ulpi_device_id *id_table;
	int (*probe)(struct ulpi *);
	void (*remove)(struct ulpi *);
	struct device_driver driver;
};

struct usb_descriptor_header {
	__u8 bLength;
	__u8 bDescriptorType;
};

enum usb3_link_state {
	USB3_LPM_U0 = 0,
	USB3_LPM_U1 = 1,
	USB3_LPM_U2 = 2,
	USB3_LPM_U3 = 3,
};

enum usb_port_connect_type {
	USB_PORT_CONNECT_TYPE_UNKNOWN = 0,
	USB_PORT_CONNECT_TYPE_HOT_PLUG = 1,
	USB_PORT_CONNECT_TYPE_HARD_WIRED = 2,
	USB_PORT_NOT_USED = 3,
};

struct usb_tt {
	struct usb_device *hub;
	int multi;
	unsigned int think_time;
	void *hcpriv;
	spinlock_t lock;
	struct list_head clear_list;
	struct work_struct clear_work;
};

struct usb_device_driver {
	const char *name;
	bool (*match)(struct usb_device *);
	int (*probe)(struct usb_device *);
	void (*disconnect)(struct usb_device *);
	int (*suspend)(struct usb_device *, pm_message_t);
	int (*resume)(struct usb_device *, pm_message_t);
	const struct attribute_group **dev_groups;
	struct usbdrv_wrap drvwrap;
	const struct usb_device_id *id_table;
	unsigned int supports_autosuspend: 1;
	unsigned int generic_subclass: 1;
};

struct giveback_urb_bh {
	bool running;
	bool high_prio;
	spinlock_t lock;
	struct list_head head;
	struct tasklet_struct bh;
	struct usb_host_endpoint *completing_ep;
};

enum usb_dev_authorize_policy {
	USB_DEVICE_AUTHORIZE_NONE = 0,
	USB_DEVICE_AUTHORIZE_ALL = 1,
	USB_DEVICE_AUTHORIZE_INTERNAL = 2,
};

struct usb_phy_roothub;

struct hc_driver;

struct usb_phy;

struct usb_hcd {
	struct usb_bus self;
	struct kref kref;
	const char *product_desc;
	int speed;
	char irq_descr[24];
	struct timer_list rh_timer;
	struct urb *status_urb;
	struct work_struct wakeup_work;
	struct work_struct died_work;
	const struct hc_driver *driver;
	struct usb_phy *usb_phy;
	struct usb_phy_roothub *phy_roothub;
	long unsigned int flags;
	enum usb_dev_authorize_policy dev_policy;
	unsigned int rh_registered: 1;
	unsigned int rh_pollable: 1;
	unsigned int msix_enabled: 1;
	unsigned int msi_enabled: 1;
	unsigned int skip_phy_initialization: 1;
	unsigned int uses_new_polling: 1;
	unsigned int wireless: 1;
	unsigned int has_tt: 1;
	unsigned int amd_resume_bug: 1;
	unsigned int can_do_streams: 1;
	unsigned int tpl_support: 1;
	unsigned int cant_recv_wakeups: 1;
	unsigned int irq;
	void *regs;
	resource_size_t rsrc_start;
	resource_size_t rsrc_len;
	unsigned int power_budget;
	struct giveback_urb_bh high_prio_bh;
	struct giveback_urb_bh low_prio_bh;
	struct mutex *address0_mutex;
	struct mutex *bandwidth_mutex;
	struct usb_hcd *shared_hcd;
	struct usb_hcd *primary_hcd;
	struct dma_pool *pool[4];
	int state;
	struct gen_pool *localmem_pool;
	long unsigned int hcd_priv[0];
};

struct hc_driver {
	const char *description;
	const char *product_desc;
	size_t hcd_priv_size;
	irqreturn_t (*irq)(struct usb_hcd *);
	int flags;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*pci_suspend)(struct usb_hcd *, bool);
	int (*pci_resume)(struct usb_hcd *, bool);
	void (*stop)(struct usb_hcd *);
	void (*shutdown)(struct usb_hcd *);
	int (*get_frame_number)(struct usb_hcd *);
	int (*urb_enqueue)(struct usb_hcd *, struct urb *, gfp_t);
	int (*urb_dequeue)(struct usb_hcd *, struct urb *, int);
	int (*map_urb_for_dma)(struct usb_hcd *, struct urb *, gfp_t);
	void (*unmap_urb_for_dma)(struct usb_hcd *, struct urb *);
	void (*endpoint_disable)(struct usb_hcd *, struct usb_host_endpoint *);
	void (*endpoint_reset)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*hub_status_data)(struct usb_hcd *, char *);
	int (*hub_control)(struct usb_hcd *, u16, u16, u16, char *, u16);
	int (*bus_suspend)(struct usb_hcd *);
	int (*bus_resume)(struct usb_hcd *);
	int (*start_port_reset)(struct usb_hcd *, unsigned int);
	long unsigned int (*get_resuming_ports)(struct usb_hcd *);
	void (*relinquish_port)(struct usb_hcd *, int);
	int (*port_handed_over)(struct usb_hcd *, int);
	void (*clear_tt_buffer_complete)(struct usb_hcd *, struct usb_host_endpoint *);
	int (*alloc_dev)(struct usb_hcd *, struct usb_device *);
	void (*free_dev)(struct usb_hcd *, struct usb_device *);
	int (*alloc_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, unsigned int, gfp_t);
	int (*free_streams)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint **, unsigned int, gfp_t);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*address_device)(struct usb_hcd *, struct usb_device *);
	int (*enable_device)(struct usb_hcd *, struct usb_device *);
	int (*update_hub_device)(struct usb_hcd *, struct usb_device *, struct usb_tt *, gfp_t);
	int (*reset_device)(struct usb_hcd *, struct usb_device *);
	int (*update_device)(struct usb_hcd *, struct usb_device *);
	int (*set_usb2_hw_lpm)(struct usb_hcd *, struct usb_device *, int);
	int (*enable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*disable_usb3_lpm_timeout)(struct usb_hcd *, struct usb_device *, enum usb3_link_state);
	int (*find_raw_port_number)(struct usb_hcd *, int);
	int (*port_power)(struct usb_hcd *, int, bool);
	int (*submit_single_step_set_feature)(struct usb_hcd *, struct urb *, int);
};

enum usb_phy_type {
	USB_PHY_TYPE_UNDEFINED = 0,
	USB_PHY_TYPE_USB2 = 1,
	USB_PHY_TYPE_USB3 = 2,
};

enum usb_phy_events {
	USB_EVENT_NONE = 0,
	USB_EVENT_VBUS = 1,
	USB_EVENT_ID = 2,
	USB_EVENT_CHARGER = 3,
	USB_EVENT_ENUMERATED = 4,
};

struct extcon_dev;

enum usb_charger_type {
	UNKNOWN_TYPE = 0,
	SDP_TYPE = 1,
	DCP_TYPE = 2,
	CDP_TYPE = 3,
	ACA_TYPE = 4,
};

enum usb_charger_state {
	USB_CHARGER_DEFAULT = 0,
	USB_CHARGER_PRESENT = 1,
	USB_CHARGER_ABSENT = 2,
};

struct usb_charger_current {
	unsigned int sdp_min;
	unsigned int sdp_max;
	unsigned int dcp_min;
	unsigned int dcp_max;
	unsigned int cdp_min;
	unsigned int cdp_max;
	unsigned int aca_min;
	unsigned int aca_max;
};

enum usb_current_mode {
	CUR_USB_MODE_NONE = 0,
	CUR_USB_MODE_HOST = 1,
	CUR_USB_MODE_DEVICE = 2,
};

struct usb_otg;

struct usb_phy_io_ops;

struct usb_phy {
	struct device *dev;
	const char *label;
	unsigned int flags;
	enum usb_phy_type type;
	enum usb_phy_events last_event;
	struct usb_otg *otg;
	struct device *io_dev;
	struct usb_phy_io_ops *io_ops;
	void *io_priv;
	struct extcon_dev *edev;
	struct extcon_dev *id_edev;
	struct notifier_block vbus_nb;
	struct notifier_block id_nb;
	struct notifier_block type_nb;
	enum usb_charger_type chg_type;
	enum usb_charger_state chg_state;
	struct usb_charger_current chg_cur;
	struct work_struct chg_work;
	struct atomic_notifier_head notifier;
	u16 port_status;
	u16 port_change;
	struct list_head head;
	int (*init)(struct usb_phy *);
	void (*shutdown)(struct usb_phy *);
	int (*set_vbus)(struct usb_phy *, int);
	int (*set_power)(struct usb_phy *, unsigned int);
	int (*set_suspend)(struct usb_phy *, int);
	int (*set_wakeup)(struct usb_phy *, bool);
	int (*notify_connect)(struct usb_phy *, enum usb_device_speed);
	int (*notify_disconnect)(struct usb_phy *, enum usb_device_speed);
	enum usb_charger_type (*charger_detect)(struct usb_phy *);
	int (*notify_suspend)(struct usb_phy *, enum usb_device_speed);
	int (*notify_resume)(struct usb_phy *, enum usb_device_speed);
	int (*set_mode)(struct usb_phy *, enum usb_current_mode);
};

struct usb_port_status {
	__le16 wPortStatus;
	__le16 wPortChange;
	__le32 dwExtPortStatus;
};

struct usb_hub_status {
	__le16 wHubStatus;
	__le16 wHubChange;
};

struct usb_hub_descriptor {
	__u8 bDescLength;
	__u8 bDescriptorType;
	__u8 bNbrPorts;
	__le16 wHubCharacteristics;
	__u8 bPwrOn2PwrGood;
	__u8 bHubContrCurrent;
	union {
		struct {
			__u8 DeviceRemovable[4];
			__u8 PortPwrCtrlMask[4];
		} hs;
		struct {
			__u8 bHubHdrDecLat;
			__le16 wHubDelay;
			__le16 DeviceRemovable;
		} __attribute__((packed)) ss;
	} u;
} __attribute__((packed));

struct usb_phy_io_ops {
	int (*read)(struct usb_phy *, u32);
	int (*write)(struct usb_phy *, u32, u32);
};

struct usb_gadget;

struct usb_otg {
	u8 default_a;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_bus *host;
	struct usb_gadget *gadget;
	enum usb_otg_state state;
	int (*set_host)(struct usb_otg *, struct usb_bus *);
	int (*set_peripheral)(struct usb_otg *, struct usb_gadget *);
	int (*set_vbus)(struct usb_otg *, bool);
	int (*start_srp)(struct usb_otg *);
	int (*start_hnp)(struct usb_otg *);
};

typedef u32 usb_port_location_t;

struct usb_port;

struct usb_hub {
	struct device *intfdev;
	struct usb_device *hdev;
	struct kref kref;
	struct urb *urb;
	u8 (*buffer)[8];
	union {
		struct usb_hub_status hub;
		struct usb_port_status port;
	} *status;
	struct mutex status_mutex;
	int error;
	int nerrors;
	long unsigned int event_bits[1];
	long unsigned int change_bits[1];
	long unsigned int removed_bits[1];
	long unsigned int wakeup_bits[1];
	long unsigned int power_bits[1];
	long unsigned int child_usage_bits[1];
	long unsigned int warm_reset_bits[1];
	struct usb_hub_descriptor *descriptor;
	struct usb_tt tt;
	unsigned int mA_per_port;
	unsigned int wakeup_enabled_descendants;
	unsigned int limited_power: 1;
	unsigned int quiescing: 1;
	unsigned int disconnected: 1;
	unsigned int in_reset: 1;
	unsigned int quirk_disable_autosuspend: 1;
	unsigned int quirk_check_port_auto_suspend: 1;
	unsigned int has_indicators: 1;
	u8 indicator[31];
	struct delayed_work leds;
	struct delayed_work init_work;
	struct work_struct events;
	spinlock_t irq_urb_lock;
	struct timer_list irq_urb_retry;
	struct usb_port **ports;
	struct list_head onboard_hub_devs;
};

struct usb_dev_state;

struct usb_port {
	struct usb_device *child;
	int: 32;
	struct device dev;
	struct usb_dev_state *port_owner;
	struct usb_port *peer;
	struct dev_pm_qos_request *req;
	enum usb_port_connect_type connect_type;
	usb_port_location_t location;
	struct mutex status_lock;
	u32 over_current_count;
	u8 portnum;
	u32 quirks;
	unsigned int is_superspeed: 1;
	unsigned int usb3_lpm_u1_permit: 1;
	unsigned int usb3_lpm_u2_permit: 1;
};

struct find_interface_arg {
	int minor;
	struct device_driver *drv;
};

struct each_dev_arg {
	void *data;
	int (*fn)(struct usb_device *, void *);
};

struct usb_qualifier_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdUSB;
	__u8 bDeviceClass;
	__u8 bDeviceSubClass;
	__u8 bDeviceProtocol;
	__u8 bMaxPacketSize0;
	__u8 bNumConfigurations;
	__u8 bRESERVED;
};

struct usb_set_sel_req {
	__u8 u1_sel;
	__u8 u1_pel;
	__le16 u2_sel;
	__le16 u2_pel;
};

struct usbdevfs_hub_portinfo {
	char nports;
	char port[127];
};

enum hub_led_mode {
	INDICATOR_AUTO = 0,
	INDICATOR_CYCLE = 1,
	INDICATOR_GREEN_BLINK = 2,
	INDICATOR_GREEN_BLINK_OFF = 3,
	INDICATOR_AMBER_BLINK = 4,
	INDICATOR_AMBER_BLINK_OFF = 5,
	INDICATOR_ALT_BLINK = 6,
	INDICATOR_ALT_BLINK_OFF = 7,
};

struct usb_tt_clear {
	struct list_head clear_list;
	unsigned int tt;
	u16 devinfo;
	struct usb_hcd *hcd;
	struct usb_host_endpoint *ep;
};

enum hub_activation_type {
	HUB_INIT = 0,
	HUB_INIT2 = 1,
	HUB_INIT3 = 2,
	HUB_POST_RESET = 3,
	HUB_RESUME = 4,
	HUB_RESET_RESUME = 5,
};

enum hub_quiescing_type {
	HUB_DISCONNECT = 0,
	HUB_PRE_RESET = 1,
	HUB_SUSPEND = 2,
};

enum usb_led_event {
	USB_LED_EVENT_HOST = 0,
	USB_LED_EVENT_GADGET = 1,
};

struct usb_sg_request {
	int status;
	size_t bytes;
	spinlock_t lock;
	struct usb_device *dev;
	int pipe;
	int entries;
	struct urb **urbs;
	int count;
	struct completion complete;
};

struct api_context {
	struct completion done;
	int status;
};

struct set_config_request {
	struct usb_device *udev;
	int config;
	struct work_struct work;
	struct list_head node;
};

struct usb_dynid {
	struct list_head node;
	struct usb_device_id id;
};

struct usb_dev_cap_header {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDevCapabilityType;
};

struct usb_class_driver {
	char *name;
	char * (*devnode)(struct device *, umode_t *);
	const struct file_operations *fops;
	int minor_base;
};

struct usb_class {
	struct kref kref;
	struct class *class;
};

struct ep_device {
	struct usb_endpoint_descriptor *desc;
	struct usb_device *udev;
	struct device dev;
};

struct usbdevfs_ctrltransfer {
	__u8 bRequestType;
	__u8 bRequest;
	__u16 wValue;
	__u16 wIndex;
	__u16 wLength;
	__u32 timeout;
	void *data;
};

struct usbdevfs_bulktransfer {
	unsigned int ep;
	unsigned int len;
	unsigned int timeout;
	void *data;
};

struct usbdevfs_setinterface {
	unsigned int interface;
	unsigned int altsetting;
};

struct usbdevfs_disconnectsignal {
	unsigned int signr;
	void *context;
};

struct usbdevfs_getdriver {
	unsigned int interface;
	char driver[256];
};

struct usbdevfs_connectinfo {
	unsigned int devnum;
	unsigned char slow;
};

struct usbdevfs_conninfo_ex {
	__u32 size;
	__u32 busnum;
	__u32 devnum;
	__u32 speed;
	__u8 num_ports;
	__u8 ports[7];
};

struct usbdevfs_iso_packet_desc {
	unsigned int length;
	unsigned int actual_length;
	unsigned int status;
};

struct usbdevfs_urb {
	unsigned char type;
	unsigned char endpoint;
	int status;
	unsigned int flags;
	void *buffer;
	int buffer_length;
	int actual_length;
	int start_frame;
	union {
		int number_of_packets;
		unsigned int stream_id;
	};
	int error_count;
	unsigned int signr;
	void *usercontext;
	struct usbdevfs_iso_packet_desc iso_frame_desc[0];
};

struct usbdevfs_ioctl {
	int ifno;
	int ioctl_code;
	void *data;
};

struct usbdevfs_disconnect_claim {
	unsigned int interface;
	unsigned int flags;
	char driver[256];
};

struct usbdevfs_streams {
	unsigned int num_streams;
	unsigned int num_eps;
	unsigned char eps[0];
};

struct usb_dev_state {
	struct list_head list;
	struct usb_device *dev;
	struct file *file;
	spinlock_t lock;
	struct list_head async_pending;
	struct list_head async_completed;
	struct list_head memory_list;
	wait_queue_head_t wait;
	wait_queue_head_t wait_for_resume;
	unsigned int discsignr;
	struct pid *disc_pid;
	const struct cred *cred;
	sigval_t disccontext;
	long unsigned int ifclaimed;
	u32 disabled_bulk_eps;
	long unsigned int interface_allowed_mask;
	int not_yet_resumed;
	bool suspend_allowed;
	bool privileges_dropped;
};

struct usb_memory {
	struct list_head memlist;
	int vma_use_count;
	int urb_use_count;
	u32 size;
	void *mem;
	dma_addr_t dma_handle;
	long unsigned int vm_start;
	struct usb_dev_state *ps;
};

struct async {
	struct list_head asynclist;
	struct usb_dev_state *ps;
	struct pid *pid;
	const struct cred *cred;
	unsigned int signr;
	unsigned int ifnum;
	void *userbuffer;
	void *userurb;
	sigval_t userurb_sigval;
	struct urb *urb;
	struct usb_memory *usbm;
	unsigned int mem_usage;
	int status;
	u8 bulk_addr;
	u8 bulk_status;
};

enum snoop_when {
	SUBMIT = 0,
	COMPLETE___2 = 1,
};

struct quirk_entry {
	u16 vid;
	u16 pid;
	u32 flags;
};

struct class_info {
	int class;
	char *class_name;
};

struct usb_phy_roothub {
	struct phy *phy;
	struct list_head list;
};

typedef void (*companion_fn)(struct pci_dev *, struct usb_hcd *, struct pci_dev *, struct usb_hcd *);

struct phy_devm {
	struct usb_phy *phy;
	struct notifier_block *nb;
};

enum usb_phy_interface {
	USBPHY_INTERFACE_MODE_UNKNOWN = 0,
	USBPHY_INTERFACE_MODE_UTMI = 1,
	USBPHY_INTERFACE_MODE_UTMIW = 2,
	USBPHY_INTERFACE_MODE_ULPI = 3,
	USBPHY_INTERFACE_MODE_SERIAL = 4,
	USBPHY_INTERFACE_MODE_HSIC = 5,
};

struct usb_ep;

struct usb_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	struct scatterlist *sg;
	unsigned int num_sgs;
	unsigned int num_mapped_sgs;
	unsigned int stream_id: 16;
	unsigned int is_last: 1;
	unsigned int no_interrupt: 1;
	unsigned int zero: 1;
	unsigned int short_not_ok: 1;
	unsigned int dma_mapped: 1;
	void (*complete)(struct usb_ep *, struct usb_request *);
	void *context;
	struct list_head list;
	unsigned int frame_number;
	int status;
	unsigned int actual;
};

struct usb_ep_caps {
	unsigned int type_control: 1;
	unsigned int type_iso: 1;
	unsigned int type_bulk: 1;
	unsigned int type_int: 1;
	unsigned int dir_in: 1;
	unsigned int dir_out: 1;
};

struct usb_ep_ops;

struct usb_ep {
	void *driver_data;
	const char *name;
	const struct usb_ep_ops *ops;
	struct list_head ep_list;
	struct usb_ep_caps caps;
	bool claimed;
	bool enabled;
	unsigned int maxpacket: 16;
	unsigned int maxpacket_limit: 16;
	unsigned int max_streams: 16;
	unsigned int mult: 2;
	unsigned int maxburst: 5;
	u8 address;
	const struct usb_endpoint_descriptor *desc;
	const struct usb_ss_ep_comp_descriptor *comp_desc;
};

struct usb_ep_ops {
	int (*enable)(struct usb_ep *, const struct usb_endpoint_descriptor *);
	int (*disable)(struct usb_ep *);
	void (*dispose)(struct usb_ep *);
	struct usb_request * (*alloc_request)(struct usb_ep *, gfp_t);
	void (*free_request)(struct usb_ep *, struct usb_request *);
	int (*queue)(struct usb_ep *, struct usb_request *, gfp_t);
	int (*dequeue)(struct usb_ep *, struct usb_request *);
	int (*set_halt)(struct usb_ep *, int);
	int (*set_wedge)(struct usb_ep *);
	int (*fifo_status)(struct usb_ep *);
	void (*fifo_flush)(struct usb_ep *);
};

struct usb_dcd_config_params {
	__u8 bU1devExitLat;
	__le16 bU2DevExitLat;
	__u8 besl_baseline;
	__u8 besl_deep;
};

struct usb_gadget_driver;

struct usb_gadget_ops {
	int (*get_frame)(struct usb_gadget *);
	int (*wakeup)(struct usb_gadget *);
	int (*set_selfpowered)(struct usb_gadget *, int);
	int (*vbus_session)(struct usb_gadget *, int);
	int (*vbus_draw)(struct usb_gadget *, unsigned int);
	int (*pullup)(struct usb_gadget *, int);
	int (*ioctl)(struct usb_gadget *, unsigned int, long unsigned int);
	void (*get_config_params)(struct usb_gadget *, struct usb_dcd_config_params *);
	int (*udc_start)(struct usb_gadget *, struct usb_gadget_driver *);
	int (*udc_stop)(struct usb_gadget *);
	void (*udc_set_speed)(struct usb_gadget *, enum usb_device_speed);
	void (*udc_set_ssp_rate)(struct usb_gadget *, enum usb_ssp_rate);
	void (*udc_async_callbacks)(struct usb_gadget *, bool);
	struct usb_ep * (*match_ep)(struct usb_gadget *, struct usb_endpoint_descriptor *, struct usb_ss_ep_comp_descriptor *);
	int (*check_config)(struct usb_gadget *);
};

struct usb_udc;

struct usb_gadget {
	struct work_struct work;
	struct usb_udc *udc;
	const struct usb_gadget_ops *ops;
	struct usb_ep *ep0;
	struct list_head ep_list;
	enum usb_device_speed speed;
	enum usb_device_speed max_speed;
	enum usb_ssp_rate ssp_rate;
	enum usb_ssp_rate max_ssp_rate;
	enum usb_device_state state;
	const char *name;
	int: 32;
	struct device dev;
	unsigned int isoch_delay;
	unsigned int out_epnum;
	unsigned int in_epnum;
	unsigned int mA;
	struct usb_otg_caps *otg_caps;
	unsigned int sg_supported: 1;
	unsigned int is_otg: 1;
	unsigned int is_a_peripheral: 1;
	unsigned int b_hnp_enable: 1;
	unsigned int a_hnp_support: 1;
	unsigned int a_alt_hnp_support: 1;
	unsigned int hnp_polling_support: 1;
	unsigned int host_request_flag: 1;
	unsigned int quirk_ep_out_aligned_size: 1;
	unsigned int quirk_altset_not_supp: 1;
	unsigned int quirk_stall_not_supp: 1;
	unsigned int quirk_zlp_not_supp: 1;
	unsigned int quirk_avoids_skb_reserve: 1;
	unsigned int is_selfpowered: 1;
	unsigned int deactivated: 1;
	unsigned int connected: 1;
	unsigned int lpm_capable: 1;
	int irq;
	int id_number;
};

struct usb_gadget_driver {
	char *function;
	enum usb_device_speed max_speed;
	int (*bind)(struct usb_gadget *, struct usb_gadget_driver *);
	void (*unbind)(struct usb_gadget *);
	int (*setup)(struct usb_gadget *, const struct usb_ctrlrequest *);
	void (*disconnect)(struct usb_gadget *);
	void (*suspend)(struct usb_gadget *);
	void (*resume)(struct usb_gadget *);
	void (*reset)(struct usb_gadget *);
	struct device_driver driver;
	char *udc_name;
	unsigned int match_existing_only: 1;
	bool is_bound: 1;
};

struct usb_phy_generic {
	struct usb_phy phy;
	struct device *dev;
	struct clk *clk;
	struct regulator *vcc;
	struct gpio_desc *gpiod_reset;
	struct gpio_desc *gpiod_vbus;
	struct regulator *vbus_draw;
	bool vbus_draw_enabled;
	long unsigned int mA;
	unsigned int vbus;
};

struct mxs_phy_data {
	unsigned int flags;
};

struct mxs_phy {
	struct usb_phy phy;
	struct clk *clk;
	const struct mxs_phy_data *data;
	struct regmap *regmap_anatop;
	struct regmap *regmap_sim;
	int port_id;
	u32 tx_reg_set;
	u32 tx_reg_mask;
	struct regulator *phy_3p0;
	bool hardware_control_phy2_clk;
	enum usb_current_mode mode;
	long unsigned int clk_rate;
};

enum amd_chipset_gen {
	NOT_AMD_CHIPSET = 0,
	AMD_CHIPSET_SB600 = 1,
	AMD_CHIPSET_SB700 = 2,
	AMD_CHIPSET_SB800 = 3,
	AMD_CHIPSET_HUDSON2 = 4,
	AMD_CHIPSET_BOLTON = 5,
	AMD_CHIPSET_YANGTZE = 6,
	AMD_CHIPSET_TAISHAN = 7,
	AMD_CHIPSET_UNKNOWN = 8,
};

struct amd_chipset_type {
	enum amd_chipset_gen gen;
	u8 rev;
};

struct amd_chipset_info {
	struct pci_dev *nb_dev;
	struct pci_dev *smbus_dev;
	int nb_type;
	struct amd_chipset_type sb_type;
	int isoc_reqs;
	int probe_count;
	bool need_pll_quirk;
};

struct ehci_per_sched {
	struct usb_device *udev;
	struct usb_host_endpoint *ep;
	struct list_head ps_list;
	u16 tt_usecs;
	u16 cs_mask;
	u16 period;
	u16 phase;
	u8 bw_phase;
	u8 phase_uf;
	u8 usecs;
	u8 c_usecs;
	u8 bw_uperiod;
	u8 bw_period;
};

enum ehci_rh_state {
	EHCI_RH_HALTED = 0,
	EHCI_RH_SUSPENDED = 1,
	EHCI_RH_RUNNING = 2,
	EHCI_RH_STOPPING = 3,
};

enum ehci_hrtimer_event {
	EHCI_HRTIMER_POLL_ASS = 0,
	EHCI_HRTIMER_POLL_PSS = 1,
	EHCI_HRTIMER_POLL_DEAD = 2,
	EHCI_HRTIMER_UNLINK_INTR = 3,
	EHCI_HRTIMER_FREE_ITDS = 4,
	EHCI_HRTIMER_ACTIVE_UNLINK = 5,
	EHCI_HRTIMER_START_UNLINK_INTR = 6,
	EHCI_HRTIMER_ASYNC_UNLINKS = 7,
	EHCI_HRTIMER_IAA_WATCHDOG = 8,
	EHCI_HRTIMER_DISABLE_PERIODIC = 9,
	EHCI_HRTIMER_DISABLE_ASYNC = 10,
	EHCI_HRTIMER_IO_WATCHDOG = 11,
	EHCI_HRTIMER_NUM_EVENTS = 12,
};

struct ehci_caps;

struct ehci_regs;

struct ehci_dbg_port;

struct ehci_qh;

union ehci_shadow;

struct ehci_itd;

struct ehci_sitd;

struct ehci_hcd {
	enum ehci_hrtimer_event next_hrtimer_event;
	unsigned int enabled_hrtimer_events;
	ktime_t hr_timeouts[12];
	struct hrtimer hrtimer;
	int PSS_poll_count;
	int ASS_poll_count;
	int died_poll_count;
	struct ehci_caps *caps;
	struct ehci_regs *regs;
	struct ehci_dbg_port *debug;
	__u32 hcs_params;
	spinlock_t lock;
	enum ehci_rh_state rh_state;
	bool scanning: 1;
	bool need_rescan: 1;
	bool intr_unlinking: 1;
	bool iaa_in_progress: 1;
	bool async_unlinking: 1;
	bool shutdown: 1;
	struct ehci_qh *qh_scan_next;
	struct ehci_qh *async;
	struct ehci_qh *dummy;
	struct list_head async_unlink;
	struct list_head async_idle;
	unsigned int async_unlink_cycle;
	unsigned int async_count;
	__le32 old_current;
	__le32 old_token;
	unsigned int periodic_size;
	__le32 *periodic;
	dma_addr_t periodic_dma;
	struct list_head intr_qh_list;
	unsigned int i_thresh;
	union ehci_shadow *pshadow;
	struct list_head intr_unlink_wait;
	struct list_head intr_unlink;
	unsigned int intr_unlink_wait_cycle;
	unsigned int intr_unlink_cycle;
	unsigned int now_frame;
	unsigned int last_iso_frame;
	unsigned int intr_count;
	unsigned int isoc_count;
	unsigned int periodic_count;
	unsigned int uframe_periodic_max;
	struct list_head cached_itd_list;
	struct ehci_itd *last_itd_to_free;
	struct list_head cached_sitd_list;
	struct ehci_sitd *last_sitd_to_free;
	long unsigned int reset_done[15];
	long unsigned int bus_suspended;
	long unsigned int companion_ports;
	long unsigned int owned_ports;
	long unsigned int port_c_suspend;
	long unsigned int suspended_ports;
	long unsigned int resuming_ports;
	struct dma_pool *qh_pool;
	struct dma_pool *qtd_pool;
	struct dma_pool *itd_pool;
	struct dma_pool *sitd_pool;
	unsigned int random_frame;
	long unsigned int next_statechange;
	int: 32;
	ktime_t last_periodic_enable;
	u32 command;
	unsigned int no_selective_suspend: 1;
	unsigned int has_fsl_port_bug: 1;
	unsigned int has_fsl_hs_errata: 1;
	unsigned int has_fsl_susp_errata: 1;
	unsigned int big_endian_mmio: 1;
	unsigned int big_endian_desc: 1;
	unsigned int big_endian_capbase: 1;
	unsigned int has_amcc_usb23: 1;
	unsigned int need_io_watchdog: 1;
	unsigned int amd_pll_fix: 1;
	unsigned int use_dummy_qh: 1;
	unsigned int has_synopsys_hc_bug: 1;
	unsigned int frame_index_bug: 1;
	unsigned int need_oc_pp_cycle: 1;
	unsigned int imx28_write_fix: 1;
	unsigned int spurious_oc: 1;
	unsigned int is_aspeed: 1;
	unsigned int zx_wakeup_clear_needed: 1;
	__le32 *ohci_hcctrl_reg;
	unsigned int has_hostpc: 1;
	unsigned int has_tdi_phy_lpm: 1;
	unsigned int has_ppcd: 1;
	u8 sbrn;
	u8 bandwidth[64];
	u8 tt_budget[64];
	struct list_head tt_list;
	long unsigned int priv[0];
};

struct ehci_caps {
	u32 hc_capbase;
	u32 hcs_params;
	u32 hcc_params;
	u8 portroute[8];
};

struct ehci_regs {
	u32 command;
	u32 status;
	u32 intr_enable;
	u32 frame_index;
	u32 segment;
	u32 frame_list;
	u32 async_next;
	u32 reserved1[2];
	u32 txfill_tuning;
	u32 reserved2[6];
	u32 configured_flag;
	union {
		u32 port_status[15];
		struct {
			u32 reserved3[9];
			u32 usbmode;
		};
	};
	union {
		struct {
			u32 reserved4;
			u32 hostpc[15];
		};
		u32 brcm_insnreg[4];
	};
	u32 reserved5[2];
	u32 usbmode_ex;
};

struct ehci_dbg_port {
	u32 control;
	u32 pids;
	u32 data03;
	u32 data47;
	u32 address;
};

struct ehci_fstn;

union ehci_shadow {
	struct ehci_qh *qh;
	struct ehci_itd *itd;
	struct ehci_sitd *sitd;
	struct ehci_fstn *fstn;
	__le32 *hw_next;
	void *ptr;
};

struct ehci_qh_hw;

struct ehci_qtd;

struct ehci_qh {
	struct ehci_qh_hw *hw;
	dma_addr_t qh_dma;
	union ehci_shadow qh_next;
	struct list_head qtd_list;
	struct list_head intr_node;
	struct ehci_qtd *dummy;
	struct list_head unlink_node;
	struct ehci_per_sched ps;
	unsigned int unlink_cycle;
	u8 qh_state;
	u8 xacterrs;
	u8 unlink_reason;
	u8 gap_uf;
	unsigned int is_out: 1;
	unsigned int clearing_tt: 1;
	unsigned int dequeue_during_giveback: 1;
	unsigned int should_be_inactive: 1;
};

struct ehci_iso_stream;

struct ehci_itd {
	__le32 hw_next;
	__le32 hw_transaction[8];
	__le32 hw_bufp[7];
	__le32 hw_bufp_hi[7];
	dma_addr_t itd_dma;
	union ehci_shadow itd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head itd_list;
	unsigned int frame;
	unsigned int pg;
	unsigned int index[8];
	int: 32;
};

struct ehci_sitd {
	__le32 hw_next;
	__le32 hw_fullspeed_ep;
	__le32 hw_uframe;
	__le32 hw_results;
	__le32 hw_buf[2];
	__le32 hw_backpointer;
	__le32 hw_buf_hi[2];
	dma_addr_t sitd_dma;
	union ehci_shadow sitd_next;
	struct urb *urb;
	struct ehci_iso_stream *stream;
	struct list_head sitd_list;
	unsigned int frame;
	unsigned int index;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ehci_qtd {
	__le32 hw_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	dma_addr_t qtd_dma;
	struct list_head qtd_list;
	struct urb *urb;
	size_t length;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ehci_fstn {
	__le32 hw_next;
	__le32 hw_prev;
	dma_addr_t fstn_dma;
	union ehci_shadow fstn_next;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ehci_qh_hw {
	__le32 hw_next;
	__le32 hw_info1;
	__le32 hw_info2;
	__le32 hw_current;
	__le32 hw_qtd_next;
	__le32 hw_alt_next;
	__le32 hw_token;
	__le32 hw_buf[5];
	__le32 hw_buf_hi[5];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ehci_iso_packet {
	u64 bufp;
	__le32 transaction;
	u8 cross;
	u32 buf1;
	int: 32;
};

struct ehci_iso_sched {
	struct list_head td_list;
	unsigned int span;
	unsigned int first_packet;
	struct ehci_iso_packet packet[0];
};

struct ehci_iso_stream {
	struct ehci_qh_hw *hw;
	u8 bEndpointAddress;
	u8 highspeed;
	struct list_head td_list;
	struct list_head free_list;
	struct ehci_per_sched ps;
	unsigned int next_uframe;
	__le32 splits;
	u16 uperiod;
	u16 maxp;
	unsigned int bandwidth;
	__le32 buf0;
	__le32 buf1;
	__le32 buf2;
	__le32 address;
};

struct ehci_tt {
	u16 bandwidth[8];
	struct list_head tt_list;
	struct list_head ps_list;
	struct usb_tt *usb_tt;
	int tt_port;
};

struct ehci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*port_power)(struct usb_hcd *, int, bool);
};

struct xhci_cap_regs {
	__le32 hc_capbase;
	__le32 hcs_params1;
	__le32 hcs_params2;
	__le32 hcs_params3;
	__le32 hcc_params;
	__le32 db_off;
	__le32 run_regs_off;
	__le32 hcc_params2;
};

struct xhci_op_regs {
	__le32 command;
	__le32 status;
	__le32 page_size;
	__le32 reserved1;
	__le32 reserved2;
	__le32 dev_notification;
	__le64 cmd_ring;
	__le32 reserved3[4];
	__le64 dcbaa_ptr;
	__le32 config_reg;
	__le32 reserved4[241];
	__le32 port_status_base;
	__le32 port_power_base;
	__le32 port_link_base;
	__le32 reserved5;
	__le32 reserved6[1016];
};

struct xhci_intr_reg {
	__le32 irq_pending;
	__le32 irq_control;
	__le32 erst_size;
	__le32 rsvd;
	__le64 erst_base;
	__le64 erst_dequeue;
};

struct xhci_run_regs {
	__le32 microframe_index;
	__le32 rsvd[7];
	struct xhci_intr_reg ir_set[128];
};

struct xhci_doorbell_array {
	__le32 doorbell[256];
};

struct xhci_container_ctx {
	unsigned int type;
	int size;
	u8 *bytes;
	dma_addr_t dma;
};

struct xhci_slot_ctx {
	__le32 dev_info;
	__le32 dev_info2;
	__le32 tt_info;
	__le32 dev_state;
	__le32 reserved[4];
};

struct xhci_ep_ctx {
	__le32 ep_info;
	__le32 ep_info2;
	__le64 deq;
	__le32 tx_info;
	__le32 reserved[3];
};

struct xhci_input_control_ctx {
	__le32 drop_flags;
	__le32 add_flags;
	__le32 rsvd2[6];
};

union xhci_trb;

struct xhci_command {
	struct xhci_container_ctx *in_ctx;
	u32 status;
	int slot_id;
	struct completion *completion;
	union xhci_trb *command_trb;
	struct list_head cmd_list;
};

struct xhci_link_trb {
	__le64 segment_ptr;
	__le32 intr_target;
	__le32 control;
};

struct xhci_transfer_event {
	__le64 buffer;
	__le32 transfer_len;
	__le32 flags;
};

struct xhci_event_cmd {
	__le64 cmd_trb;
	__le32 status;
	__le32 flags;
};

struct xhci_generic_trb {
	__le32 field[4];
};

union xhci_trb {
	struct xhci_link_trb link;
	struct xhci_transfer_event trans_event;
	struct xhci_event_cmd event_cmd;
	struct xhci_generic_trb generic;
};

struct xhci_stream_ctx {
	__le64 stream_ring;
	__le32 reserved[2];
};

struct xhci_ring;

struct xhci_stream_info {
	struct xhci_ring **stream_rings;
	unsigned int num_streams;
	struct xhci_stream_ctx *stream_ctx_array;
	unsigned int num_stream_ctxs;
	dma_addr_t ctx_array_dma;
	struct xarray trb_address_map;
	struct xhci_command *free_streams_command;
};

enum xhci_ring_type {
	TYPE_CTRL = 0,
	TYPE_ISOC = 1,
	TYPE_BULK = 2,
	TYPE_INTR = 3,
	TYPE_STREAM = 4,
	TYPE_COMMAND = 5,
	TYPE_EVENT = 6,
};

struct xhci_segment;

struct xhci_ring {
	struct xhci_segment *first_seg;
	struct xhci_segment *last_seg;
	union xhci_trb *enqueue;
	struct xhci_segment *enq_seg;
	union xhci_trb *dequeue;
	struct xhci_segment *deq_seg;
	struct list_head td_list;
	u32 cycle_state;
	unsigned int err_count;
	unsigned int stream_id;
	unsigned int num_segs;
	unsigned int num_trbs_free;
	unsigned int num_trbs_free_temp;
	unsigned int bounce_buf_len;
	enum xhci_ring_type type;
	bool last_td_was_short;
	struct xarray *trb_address_map;
};

struct xhci_bw_info {
	unsigned int ep_interval;
	unsigned int mult;
	unsigned int num_packets;
	unsigned int max_packet_size;
	unsigned int max_esit_payload;
	unsigned int type;
};

struct xhci_virt_device;

struct xhci_hcd;

struct xhci_virt_ep {
	struct xhci_virt_device *vdev;
	unsigned int ep_index;
	struct xhci_ring *ring;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *new_ring;
	unsigned int ep_state;
	struct list_head cancelled_td_list;
	struct xhci_hcd *xhci;
	struct xhci_segment *queued_deq_seg;
	union xhci_trb *queued_deq_ptr;
	bool skip;
	struct xhci_bw_info bw_info;
	struct list_head bw_endpoint_list;
	int next_frame_id;
	bool use_extended_tbc;
};

struct xhci_interval_bw_table;

struct xhci_tt_bw_info;

struct xhci_virt_device {
	int slot_id;
	struct usb_device *udev;
	struct xhci_container_ctx *out_ctx;
	struct xhci_container_ctx *in_ctx;
	struct xhci_virt_ep eps[31];
	u8 fake_port;
	u8 real_port;
	struct xhci_interval_bw_table *bw_table;
	struct xhci_tt_bw_info *tt_info;
	long unsigned int flags;
	u16 current_mel;
	void *debugfs_private;
};

struct xhci_erst_entry;

struct xhci_erst {
	struct xhci_erst_entry *entries;
	unsigned int num_entries;
	dma_addr_t erst_dma_addr;
	unsigned int erst_size;
};

struct s3_save {
	u32 command;
	u32 dev_nt;
	u64 dcbaa_ptr;
	u32 config_reg;
	u32 irq_pending;
	u32 irq_control;
	u32 erst_size;
	u64 erst_base;
	u64 erst_dequeue;
};

struct xhci_bus_state {
	long unsigned int bus_suspended;
	long unsigned int next_statechange;
	u32 port_c_suspend;
	u32 suspended_ports;
	u32 port_remote_wakeup;
	long unsigned int resume_done[31];
	long unsigned int resuming_ports;
	long unsigned int rexit_ports;
	struct completion rexit_done[31];
	struct completion u3exit_done[31];
};

struct xhci_port;

struct xhci_hub {
	struct xhci_port **ports;
	unsigned int num_ports;
	struct usb_hcd *hcd;
	struct xhci_bus_state bus_state;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_device_context_array;

struct xhci_scratchpad;

struct xhci_root_port_bw_info;

struct xhci_port_cap;

struct xhci_hcd {
	struct usb_hcd *main_hcd;
	struct usb_hcd *shared_hcd;
	struct xhci_cap_regs *cap_regs;
	struct xhci_op_regs *op_regs;
	struct xhci_run_regs *run_regs;
	struct xhci_doorbell_array *dba;
	struct xhci_intr_reg *ir_set;
	__u32 hcs_params1;
	__u32 hcs_params2;
	__u32 hcs_params3;
	__u32 hcc_params;
	__u32 hcc_params2;
	spinlock_t lock;
	u8 sbrn;
	u16 hci_version;
	u8 max_slots;
	u8 max_interrupters;
	u8 max_ports;
	u8 isoc_threshold;
	u32 imod_interval;
	u32 isoc_bei_interval;
	int event_ring_max;
	int page_size;
	int page_shift;
	int msix_count;
	struct clk *clk;
	struct clk *reg_clk;
	struct reset_control *reset;
	struct xhci_device_context_array *dcbaa;
	struct xhci_ring *cmd_ring;
	unsigned int cmd_ring_state;
	struct list_head cmd_list;
	unsigned int cmd_ring_reserved_trbs;
	struct delayed_work cmd_timer;
	struct completion cmd_ring_stop_completion;
	struct xhci_command *current_cmd;
	struct xhci_ring *event_ring;
	struct xhci_erst erst;
	struct xhci_scratchpad *scratchpad;
	struct mutex mutex;
	struct xhci_virt_device *devs[256];
	struct xhci_root_port_bw_info *rh_bw;
	struct dma_pool *device_pool;
	struct dma_pool *segment_pool;
	struct dma_pool *small_streams_pool;
	struct dma_pool *medium_streams_pool;
	unsigned int xhc_state;
	long unsigned int run_graceperiod;
	struct s3_save s3;
	long long unsigned int quirks;
	unsigned int num_active_eps;
	unsigned int limit_active_eps;
	struct xhci_port *hw_ports;
	struct xhci_hub usb2_rhub;
	struct xhci_hub usb3_rhub;
	unsigned int hw_lpm_support: 1;
	unsigned int broken_suspend: 1;
	unsigned int allow_single_roothub: 1;
	u32 *ext_caps;
	unsigned int num_ext_caps;
	struct xhci_port_cap *port_caps;
	unsigned int num_port_caps;
	struct timer_list comp_mode_recovery_timer;
	u32 port_status_u0;
	u16 test_mode;
	struct dentry *debugfs_root;
	struct dentry *debugfs_slots;
	struct list_head regset_list;
	void *dbc;
	long unsigned int priv[0];
};

struct xhci_segment {
	union xhci_trb *trbs;
	struct xhci_segment *next;
	dma_addr_t dma;
	dma_addr_t bounce_dma;
	void *bounce_buf;
	unsigned int bounce_offs;
	unsigned int bounce_len;
};

enum xhci_overhead_type {
	LS_OVERHEAD_TYPE = 0,
	FS_OVERHEAD_TYPE = 1,
	HS_OVERHEAD_TYPE = 2,
};

struct xhci_interval_bw {
	unsigned int num_packets;
	struct list_head endpoints;
	unsigned int overhead[3];
};

struct xhci_interval_bw_table {
	unsigned int interval0_esit_payload;
	struct xhci_interval_bw interval_bw[16];
	unsigned int bw_used;
	unsigned int ss_bw_in;
	unsigned int ss_bw_out;
};

struct xhci_tt_bw_info {
	struct list_head tt_list;
	int slot_id;
	int ttport;
	struct xhci_interval_bw_table bw_table;
	int active_eps;
};

struct xhci_root_port_bw_info {
	struct list_head tts;
	unsigned int num_active_tts;
	struct xhci_interval_bw_table bw_table;
};

struct xhci_device_context_array {
	__le64 dev_context_ptrs[256];
	dma_addr_t dma;
	int: 32;
};

enum xhci_setup_dev {
	SETUP_CONTEXT_ONLY = 0,
	SETUP_CONTEXT_ADDRESS = 1,
};

enum xhci_cancelled_td_status {
	TD_DIRTY = 0,
	TD_HALTED = 1,
	TD_CLEARING_CACHE = 2,
	TD_CLEARED = 3,
};

struct xhci_td {
	struct list_head td_list;
	struct list_head cancelled_td_list;
	int status;
	enum xhci_cancelled_td_status cancel_status;
	struct urb *urb;
	struct xhci_segment *start_seg;
	union xhci_trb *first_trb;
	union xhci_trb *last_trb;
	struct xhci_segment *last_trb_seg;
	struct xhci_segment *bounce_seg;
	bool urb_length_set;
	unsigned int num_trbs;
};

struct xhci_erst_entry {
	__le64 seg_addr;
	__le32 seg_size;
	__le32 rsvd;
};

struct xhci_scratchpad {
	u64 *sp_array;
	dma_addr_t sp_dma;
	void **sp_buffers;
};

struct urb_priv {
	int num_tds;
	int num_tds_done;
	struct xhci_td td[0];
};

struct xhci_port_cap {
	u32 *psi;
	u8 psi_count;
	u8 psi_uid_count;
	u8 maj_rev;
	u8 min_rev;
};

struct xhci_port {
	__le32 *addr;
	int hw_portnum;
	int hcd_portnum;
	struct xhci_hub *rhub;
	struct xhci_port_cap *port_cap;
};

struct xhci_driver_overrides {
	size_t extra_priv_size;
	int (*reset)(struct usb_hcd *);
	int (*start)(struct usb_hcd *);
	int (*add_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*drop_endpoint)(struct usb_hcd *, struct usb_device *, struct usb_host_endpoint *);
	int (*check_bandwidth)(struct usb_hcd *, struct usb_device *);
	void (*reset_bandwidth)(struct usb_hcd *, struct usb_device *);
	int (*bus_suspend)(struct usb_hcd *);
};

typedef void (*xhci_get_quirks_t)(struct device *, struct xhci_hcd *);

enum xhci_ep_reset_type {
	EP_HARD_RESET = 0,
	EP_SOFT_RESET = 1,
};

struct dbc_regs {
	__le32 capability;
	__le32 doorbell;
	__le32 ersts;
	__le32 __reserved_0;
	__le64 erstba;
	__le64 erdp;
	__le32 control;
	__le32 status;
	__le32 portsc;
	__le32 __reserved_1;
	__le64 dccp;
	__le32 devinfo1;
	__le32 devinfo2;
};

struct dbc_str_descs {
	char string0[64];
	char manufacturer[64];
	char product[64];
	char serial[64];
};

enum dbc_state {
	DS_DISABLED = 0,
	DS_INITIALIZED = 1,
	DS_ENABLED = 2,
	DS_CONNECTED = 3,
	DS_CONFIGURED = 4,
	DS_STALLED = 5,
};

struct xhci_dbc;

struct dbc_ep {
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	struct xhci_ring *ring;
	unsigned int direction: 1;
};

struct dbc_driver;

struct xhci_dbc {
	spinlock_t lock;
	struct device *dev;
	struct xhci_hcd *xhci;
	struct dbc_regs *regs;
	struct xhci_ring *ring_evt;
	struct xhci_ring *ring_in;
	struct xhci_ring *ring_out;
	struct xhci_erst erst;
	struct xhci_container_ctx *ctx;
	struct dbc_str_descs *string;
	dma_addr_t string_dma;
	size_t string_size;
	enum dbc_state state;
	struct delayed_work event_work;
	unsigned int resume_required: 1;
	struct dbc_ep eps[2];
	const struct dbc_driver *driver;
	void *priv;
};

struct dbc_driver {
	int (*configure)(struct xhci_dbc *);
	void (*disconnect)(struct xhci_dbc *);
};

struct dbc_request {
	void *buf;
	unsigned int length;
	dma_addr_t dma;
	void (*complete)(struct xhci_dbc *, struct dbc_request *);
	struct list_head list_pool;
	int status;
	unsigned int actual;
	struct xhci_dbc *dbc;
	struct list_head list_pending;
	dma_addr_t trb_dma;
	union xhci_trb *trb;
	unsigned int direction: 1;
};

struct trace_event_raw_xhci_log_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctx {
	struct trace_entry ent;
	int ctx_64;
	unsigned int ctx_type;
	dma_addr_t ctx_dma;
	u8 *ctx_va;
	unsigned int ctx_ep_num;
	int slot_id;
	u32 __data_loc_ctx_data;
	char __data[0];
};

struct trace_event_raw_xhci_log_trb {
	struct trace_entry ent;
	u32 type;
	u32 field0;
	u32 field1;
	u32 field2;
	u32 field3;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_free_virt_dev {
	struct trace_entry ent;
	void *vdev;
	int: 32;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	u8 fake_port;
	u8 real_port;
	u16 current_mel;
	char __data[0];
	int: 32;
};

struct trace_event_raw_xhci_log_virt_dev {
	struct trace_entry ent;
	void *vdev;
	int: 32;
	long long unsigned int out_ctx;
	long long unsigned int in_ctx;
	int devnum;
	int state;
	int speed;
	u8 portnum;
	u8 level;
	int slot_id;
	char __data[0];
	int: 32;
};

struct trace_event_raw_xhci_log_urb {
	struct trace_entry ent;
	void *urb;
	unsigned int pipe;
	unsigned int stream;
	int status;
	unsigned int flags;
	int num_mapped_sgs;
	int num_sgs;
	int length;
	int actual;
	int epnum;
	int dir_in;
	int type;
	int slot_id;
	char __data[0];
};

struct trace_event_raw_xhci_log_ep_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u64 deq;
	u32 tx_info;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_slot_ctx {
	struct trace_entry ent;
	u32 info;
	u32 info2;
	u32 tt_info;
	u32 state;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_ctrl_ctx {
	struct trace_entry ent;
	u32 drop;
	u32 add;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_ring {
	struct trace_entry ent;
	u32 type;
	void *ring;
	dma_addr_t enq;
	dma_addr_t deq;
	dma_addr_t enq_seg;
	dma_addr_t deq_seg;
	unsigned int num_segs;
	unsigned int stream_id;
	unsigned int cycle_state;
	unsigned int num_trbs_free;
	unsigned int bounce_buf_len;
	char __data[0];
};

struct trace_event_raw_xhci_log_portsc {
	struct trace_entry ent;
	u32 portnum;
	u32 portsc;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_log_doorbell {
	struct trace_entry ent;
	u32 slot;
	u32 doorbell;
	u32 __data_loc_str;
	char __data[0];
};

struct trace_event_raw_xhci_dbc_log_request {
	struct trace_entry ent;
	struct dbc_request *req;
	bool dir;
	unsigned int actual;
	unsigned int length;
	int status;
	char __data[0];
};

struct trace_event_data_offsets_xhci_log_msg {
	u32 msg;
};

struct trace_event_data_offsets_xhci_log_ctx {
	u32 ctx_data;
};

struct trace_event_data_offsets_xhci_log_trb {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_free_virt_dev {};

struct trace_event_data_offsets_xhci_log_virt_dev {};

struct trace_event_data_offsets_xhci_log_urb {};

struct trace_event_data_offsets_xhci_log_ep_ctx {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_slot_ctx {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_ctrl_ctx {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_ring {};

struct trace_event_data_offsets_xhci_log_portsc {
	u32 str;
};

struct trace_event_data_offsets_xhci_log_doorbell {
	u32 str;
};

struct trace_event_data_offsets_xhci_dbc_log_request {};

typedef void (*btf_trace_xhci_dbg_address)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_context_change)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_quirks)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_reset_ep)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_cancel_urb)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_init)(void *, struct va_format *);

typedef void (*btf_trace_xhci_dbg_ring_expansion)(void *, struct va_format *);

typedef void (*btf_trace_xhci_address_ctx)(void *, struct xhci_hcd *, struct xhci_container_ctx *, unsigned int);

typedef void (*btf_trace_xhci_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_command)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_queue_trb)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_event)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_handle_transfer)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_dbc_gadget_ep_queue)(void *, struct xhci_ring *, struct xhci_generic_trb *);

typedef void (*btf_trace_xhci_free_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_alloc_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_setup_addressable_virt_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_stop_device)(void *, struct xhci_virt_device *);

typedef void (*btf_trace_xhci_urb_enqueue)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_giveback)(void *, struct urb *);

typedef void (*btf_trace_xhci_urb_dequeue)(void *, struct urb *);

typedef void (*btf_trace_xhci_handle_cmd_stop_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_config_ep)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_add_endpoint)(void *, struct xhci_ep_ctx *);

typedef void (*btf_trace_xhci_alloc_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_free_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_disable_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_discover_or_reset_device)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_setup_device_slot)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_addr_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_reset_dev)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_handle_cmd_set_deq)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint)(void *, struct xhci_slot_ctx *);

typedef void (*btf_trace_xhci_address_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_configure_endpoint_ctrl_ctx)(void *, struct xhci_input_control_ctx *);

typedef void (*btf_trace_xhci_ring_alloc)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_free)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_ring_expansion)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_enq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_inc_deq)(void *, struct xhci_ring *);

typedef void (*btf_trace_xhci_handle_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_get_port_status)(void *, u32, u32);

typedef void (*btf_trace_xhci_hub_status_data)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_ep_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_ring_host_doorbell)(void *, u32, u32);

typedef void (*btf_trace_xhci_dbc_alloc_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_free_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_queue_request)(void *, struct dbc_request *);

typedef void (*btf_trace_xhci_dbc_giveback_request)(void *, struct dbc_request *);

struct xhci_regset {
	char name[32];
	struct debugfs_regset32 regset;
	size_t nregs;
	struct list_head list;
};

struct xhci_file_map {
	const char *name;
	int (*show)(struct seq_file *, void *);
};

struct xhci_ep_priv {
	char name[32];
	struct dentry *root;
	struct xhci_stream_info *stream_info;
	struct xhci_ring *show_ring;
	unsigned int stream_id;
};

struct xhci_slot_priv {
	char name[32];
	struct dentry *root;
	struct xhci_ep_priv *eps[31];
	struct xhci_virt_device *dev;
};

struct xhci_driver_data {
	u64 quirks;
	const char *firmware;
	int: 32;
};

enum {
	US_FL_SINGLE_LUN = 1,
	US_FL_NEED_OVERRIDE = 2,
	US_FL_SCM_MULT_TARG = 4,
	US_FL_FIX_INQUIRY = 8,
	US_FL_FIX_CAPACITY = 16,
	US_FL_IGNORE_RESIDUE = 32,
	US_FL_BULK32 = 64,
	US_FL_NOT_LOCKABLE = 128,
	US_FL_GO_SLOW = 256,
	US_FL_NO_WP_DETECT = 512,
	US_FL_MAX_SECTORS_64 = 1024,
	US_FL_IGNORE_DEVICE = 2048,
	US_FL_CAPACITY_HEURISTICS = 4096,
	US_FL_MAX_SECTORS_MIN = 8192,
	US_FL_BULK_IGNORE_TAG = 16384,
	US_FL_SANE_SENSE = 32768,
	US_FL_CAPACITY_OK = 65536,
	US_FL_BAD_SENSE = 131072,
	US_FL_NO_READ_DISC_INFO = 262144,
	US_FL_NO_READ_CAPACITY_16 = 524288,
	US_FL_INITIAL_READ10 = 1048576,
	US_FL_WRITE_CACHE = 2097152,
	US_FL_NEEDS_CAP16 = 4194304,
	US_FL_IGNORE_UAS = 8388608,
	US_FL_BROKEN_FUA = 16777216,
	US_FL_NO_ATA_1X = 33554432,
	US_FL_NO_REPORT_OPCODES = 67108864,
	US_FL_MAX_SECTORS_240 = 134217728,
	US_FL_NO_REPORT_LUNS = 268435456,
	US_FL_ALWAYS_SYNC = 536870912,
	US_FL_NO_SAME = 1073741824,
	US_FL_SENSE_AFTER_SYNC = 2147483648,
};

struct us_data;

struct us_unusual_dev {
	const char *vendorName;
	const char *productName;
	__u8 useProtocol;
	__u8 useTransport;
	int (*initFunction)(struct us_data *);
};

typedef int (*trans_cmnd)(struct scsi_cmnd *, struct us_data *);

typedef int (*trans_reset)(struct us_data *);

typedef void (*proto_cmnd)(struct scsi_cmnd *, struct us_data *);

typedef void (*extra_data_destructor)(void *);

typedef void (*pm_hook)(struct us_data *, int);

struct us_data {
	struct mutex dev_mutex;
	struct usb_device *pusb_dev;
	struct usb_interface *pusb_intf;
	const struct us_unusual_dev *unusual_dev;
	long unsigned int fflags;
	long unsigned int dflags;
	unsigned int send_bulk_pipe;
	unsigned int recv_bulk_pipe;
	unsigned int send_ctrl_pipe;
	unsigned int recv_ctrl_pipe;
	unsigned int recv_intr_pipe;
	char *transport_name;
	char *protocol_name;
	__le32 bcs_signature;
	u8 subclass;
	u8 protocol;
	u8 max_lun;
	u8 ifnum;
	u8 ep_bInterval;
	trans_cmnd transport;
	trans_reset transport_reset;
	proto_cmnd proto_handler;
	struct scsi_cmnd *srb;
	unsigned int tag;
	char scsi_name[32];
	struct urb *current_urb;
	struct usb_ctrlrequest *cr;
	struct usb_sg_request current_sg;
	unsigned char *iobuf;
	dma_addr_t iobuf_dma;
	struct task_struct *ctl_thread;
	struct completion cmnd_ready;
	struct completion notify;
	wait_queue_head_t delay_wait;
	struct delayed_work scan_dwork;
	void *extra;
	extra_data_destructor extra_destructor;
	pm_hook suspend_resume_hook;
	int use_last_sector_hacks;
	int last_sector_retries;
};

enum xfer_buf_dir {
	TO_XFER_BUF = 0,
	FROM_XFER_BUF = 1,
};

struct bulk_cb_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 DataTransferLength;
	__u8 Flags;
	__u8 Lun;
	__u8 Length;
	__u8 CDB[16];
};

struct bulk_cs_wrap {
	__le32 Signature;
	__u32 Tag;
	__le32 Residue;
	__u8 Status;
};

struct swoc_info {
	__u8 rev;
	__u8 reserved[8];
	__u16 LinuxSKU;
	__u16 LinuxVer;
	__u8 reserved2[47];
} __attribute__((packed));

struct ignore_entry {
	u16 vid;
	u16 pid;
	u16 bcdmin;
	u16 bcdmax;
};

struct ci_hdrc;

struct ci_hdrc_cable {
	bool connected;
	bool changed;
	bool enabled;
	struct extcon_dev *edev;
	struct ci_hdrc *ci;
	struct notifier_block nb;
};

struct hw_bank {
	unsigned int lpm;
	resource_size_t phys;
	void *abs;
	void *cap;
	void *op;
	size_t size;
	void *regmap[39];
};

enum ci_role {
	CI_ROLE_HOST = 0,
	CI_ROLE_GADGET = 1,
	CI_ROLE_END = 2,
};

struct otg_fsm_ops;

struct otg_fsm {
	int id;
	int adp_change;
	int power_up;
	int a_srp_det;
	int a_vbus_vld;
	int b_conn;
	int a_bus_resume;
	int a_bus_suspend;
	int a_conn;
	int b_se0_srp;
	int b_ssend_srp;
	int b_sess_vld;
	int test_device;
	int a_bus_drop;
	int a_bus_req;
	int b_bus_req;
	int a_sess_vld;
	int b_bus_resume;
	int b_bus_suspend;
	int drv_vbus;
	int loc_conn;
	int loc_sof;
	int adp_prb;
	int adp_sns;
	int data_pulse;
	int a_set_b_hnp_en;
	int b_srp_done;
	int b_hnp_enable;
	int a_clr_err;
	int a_bus_drop_inf;
	int a_bus_req_inf;
	int a_clr_err_inf;
	int b_bus_req_inf;
	int a_suspend_req_inf;
	int a_wait_vrise_tmout;
	int a_wait_vfall_tmout;
	int a_wait_bcon_tmout;
	int a_aidl_bdis_tmout;
	int b_ase0_brst_tmout;
	int a_bidl_adis_tmout;
	struct otg_fsm_ops *ops;
	struct usb_otg *otg;
	int protocol;
	struct mutex lock;
	u8 *host_req_flag;
	struct delayed_work hnp_polling_work;
	bool hnp_work_inited;
	bool state_changed;
};

enum otg_fsm_timer {
	A_WAIT_VRISE = 0,
	A_WAIT_VFALL = 1,
	A_WAIT_BCON = 2,
	A_AIDL_BDIS = 3,
	B_ASE0_BRST = 4,
	A_BIDL_ADIS = 5,
	B_AIDL_BDIS = 6,
	B_SE0_SRP = 7,
	B_SRP_FAIL = 8,
	A_WAIT_ENUM = 9,
	B_DATA_PLS = 10,
	B_SSEND_SRP = 11,
	NUM_OTG_FSM_TIMERS = 12,
};

struct ci_hw_qh;

struct td_node;

struct ci_hw_ep {
	struct usb_ep ep;
	u8 dir;
	u8 num;
	u8 type;
	char name[16];
	struct {
		struct list_head queue;
		struct ci_hw_qh *ptr;
		dma_addr_t dma;
	} qh;
	int wedge;
	struct ci_hdrc *ci;
	spinlock_t *lock;
	struct dma_pool *td_pool;
	struct td_node *pending_td;
};

struct ulpi;

enum ci_revision {
	CI_REVISION_1X = 10,
	CI_REVISION_20 = 20,
	CI_REVISION_21 = 21,
	CI_REVISION_22 = 22,
	CI_REVISION_23 = 23,
	CI_REVISION_24 = 24,
	CI_REVISION_25 = 25,
	CI_REVISION_25_PLUS = 26,
	CI_REVISION_UNKNOWN = 99,
};

struct ci_role_driver;

struct usb_role_switch;

struct ci_hdrc_platform_data;

struct ci_hdrc {
	struct device *dev;
	spinlock_t lock;
	struct hw_bank hw_bank;
	int irq;
	struct ci_role_driver *roles[2];
	enum ci_role role;
	bool is_otg;
	struct usb_otg otg;
	struct otg_fsm fsm;
	struct hrtimer otg_fsm_hrtimer;
	ktime_t hr_timeouts[12];
	unsigned int enabled_otg_timer_bits;
	enum otg_fsm_timer next_otg_timer;
	struct usb_role_switch *role_switch;
	struct work_struct work;
	struct workqueue_struct *wq;
	struct dma_pool *qh_pool;
	struct dma_pool *td_pool;
	struct usb_gadget gadget;
	struct usb_gadget_driver *driver;
	enum usb_device_state resume_state;
	unsigned int hw_ep_max;
	struct ci_hw_ep ci_hw_ep[32];
	u32 ep0_dir;
	struct ci_hw_ep *ep0out;
	struct ci_hw_ep *ep0in;
	struct usb_request *status;
	bool setaddr;
	u8 address;
	u8 remote_wakeup;
	u8 suspended;
	u8 test_mode;
	struct ci_hdrc_platform_data *platdata;
	int vbus_active;
	struct ulpi *ulpi;
	struct ulpi_ops ulpi_ops;
	struct phy *phy;
	struct usb_phy *usb_phy;
	struct usb_hcd *hcd;
	bool id_event;
	bool b_sess_valid_event;
	bool imx28_write_fix;
	bool supports_runtime_pm;
	bool in_lpm;
	bool wakeup_int;
	enum ci_revision rev;
	struct work_struct power_lost_work;
	struct workqueue_struct *power_lost_wq;
	u32 pm_command;
	u32 pm_status;
	u32 pm_intr_enable;
	u32 pm_frame_index;
	u32 pm_segment;
	u32 pm_frame_list;
	u32 pm_async_next;
	u32 pm_configured_flag;
	u32 pm_portsc;
	u32 pm_usbmode;
	struct mutex mutex;
};

struct ci_hdrc_platform_data {
	const char *name;
	uintptr_t capoffset;
	unsigned int power_budget;
	struct phy *phy;
	struct usb_phy *usb_phy;
	enum usb_phy_interface phy_mode;
	long unsigned int flags;
	enum usb_dr_mode dr_mode;
	int (*notify_event)(struct ci_hdrc *, unsigned int);
	struct regulator *reg_vbus;
	struct usb_otg_caps ci_otg_caps;
	bool tpl_support;
	u32 itc_setting;
	u32 ahb_burst_config;
	u32 tx_burst_size;
	u32 rx_burst_size;
	struct ci_hdrc_cable vbus_extcon;
	struct ci_hdrc_cable id_extcon;
	u32 phy_clkgate_delay_us;
	struct pinctrl *pctl;
	struct pinctrl_state *pins_default;
	struct pinctrl_state *pins_host;
	struct pinctrl_state *pins_device;
	int (*hub_control)(struct ci_hdrc *, u16, u16, u16, char *, u16, bool *, long unsigned int *);
	void (*enter_lpm)(struct ci_hdrc *, bool);
};

struct otg_fsm_ops {
	void (*chrg_vbus)(struct otg_fsm *, int);
	void (*drv_vbus)(struct otg_fsm *, int);
	void (*loc_conn)(struct otg_fsm *, int);
	void (*loc_sof)(struct otg_fsm *, int);
	void (*start_pulse)(struct otg_fsm *);
	void (*start_adp_prb)(struct otg_fsm *);
	void (*start_adp_sns)(struct otg_fsm *);
	void (*add_timer)(struct otg_fsm *, enum otg_fsm_timer);
	void (*del_timer)(struct otg_fsm *, enum otg_fsm_timer);
	int (*start_host)(struct otg_fsm *, int);
	int (*start_gadget)(struct otg_fsm *, int);
};

enum usb_role {
	USB_ROLE_NONE = 0,
	USB_ROLE_HOST = 1,
	USB_ROLE_DEVICE = 2,
};

typedef int (*usb_role_switch_set_t)(struct usb_role_switch *, enum usb_role);

typedef enum usb_role (*usb_role_switch_get_t)(struct usb_role_switch *);

struct usb_role_switch_desc {
	struct fwnode_handle *fwnode;
	struct device *usb2_port;
	struct device *usb3_port;
	struct device *udc;
	usb_role_switch_set_t set;
	usb_role_switch_get_t get;
	bool allow_userspace_control;
	void *driver_data;
	const char *name;
};

enum ci_hw_regs {
	CAP_CAPLENGTH = 0,
	CAP_HCCPARAMS = 1,
	CAP_DCCPARAMS = 2,
	CAP_TESTMODE = 3,
	CAP_LAST = 3,
	OP_USBCMD = 4,
	OP_USBSTS = 5,
	OP_USBINTR = 6,
	OP_FRINDEX = 7,
	OP_DEVICEADDR = 8,
	OP_ENDPTLISTADDR = 9,
	OP_TTCTRL = 10,
	OP_BURSTSIZE = 11,
	OP_ULPI_VIEWPORT = 12,
	OP_PORTSC = 13,
	OP_DEVLC = 14,
	OP_OTGSC = 15,
	OP_USBMODE = 16,
	OP_ENDPTSETUPSTAT = 17,
	OP_ENDPTPRIME = 18,
	OP_ENDPTFLUSH = 19,
	OP_ENDPTSTAT = 20,
	OP_ENDPTCOMPLETE = 21,
	OP_ENDPTCTRL = 22,
	OP_LAST = 38,
};

struct ci_hw_td {
	__le32 next;
	__le32 token;
	__le32 page[5];
};

struct ci_hw_qh {
	__le32 cap;
	__le32 curr;
	struct ci_hw_td td;
	__le32 RESERVED;
	struct usb_ctrlrequest setup;
};

struct td_node {
	struct list_head td;
	dma_addr_t dma;
	struct ci_hw_td *ptr;
	int td_remaining_size;
};

struct ci_role_driver {
	int (*start)(struct ci_hdrc *);
	void (*stop)(struct ci_hdrc *);
	void (*suspend)(struct ci_hdrc *);
	void (*resume)(struct ci_hdrc *, bool);
	irqreturn_t (*irq)(struct ci_hdrc *);
	const char *name;
};

struct ci_hw_req {
	struct usb_request req;
	struct list_head queue;
	struct list_head tds;
};

struct trace_event_raw_ci_log {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_ci_log_trb {
	struct trace_entry ent;
	u32 __data_loc_name;
	struct td_node *td;
	struct usb_request *req;
	dma_addr_t dma;
	s32 td_remaining_size;
	u32 next;
	u32 token;
	u32 type;
	char __data[0];
};

struct trace_event_data_offsets_ci_log {
	u32 name;
	u32 msg;
};

struct trace_event_data_offsets_ci_log_trb {
	u32 name;
};

typedef void (*btf_trace_ci_log)(void *, struct ci_hdrc *, struct va_format *);

typedef void (*btf_trace_ci_prepare_td)(void *, struct ci_hw_ep *, struct ci_hw_req *, struct td_node *);

typedef void (*btf_trace_ci_complete_td)(void *, struct ci_hw_ep *, struct ci_hw_req *, struct td_node *);

struct ehci_ci_priv {
	struct regulator *reg_vbus;
	bool enabled;
};

struct ci_hdrc_dma_aligned_buffer {
	void *kmalloc_ptr;
	void *old_xfer_buffer;
	u8 data[0];
};

struct ci_hdrc_usb2_priv {
	struct platform_device *ci_pdev;
	struct clk *clk;
};

struct ci_hdrc_msm {
	struct platform_device *ci;
	struct clk *core_clk;
	struct clk *iface_clk;
	struct clk *fs_clk;
	struct ci_hdrc_platform_data pdata;
	struct reset_controller_dev rcdev;
	bool secondary_phy;
	bool hsic;
	void *base;
};

struct ci_hdrc_pci {
	struct platform_device *ci;
	struct platform_device *phy;
};

struct imx_usbmisc_data {
	struct device *dev;
	int index;
	unsigned int disable_oc: 1;
	unsigned int oc_pol_active_low: 1;
	unsigned int oc_pol_configured: 1;
	unsigned int pwr_pol: 1;
	unsigned int evdo: 1;
	unsigned int ulpi: 1;
	unsigned int hsic: 1;
	unsigned int ext_id: 1;
	unsigned int ext_vbus: 1;
	struct usb_phy *usb_phy;
	enum usb_dr_mode available_role;
	int emp_curr_control;
	int dc_vol_level_adjust;
};

struct ci_hdrc_imx_platform_flag {
	unsigned int flags;
};

struct ci_hdrc_imx_data {
	struct usb_phy *phy;
	struct platform_device *ci_pdev;
	struct clk *clk;
	struct clk *clk_wakeup;
	struct imx_usbmisc_data *usbmisc_data;
	bool supports_runtime_pm;
	bool override_phy_control;
	bool in_lpm;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinctrl_hsic_active;
	struct regulator *hsic_pad_regulator;
	bool need_three_clks;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_per;
	struct pm_qos_request pm_qos_req;
	const struct ci_hdrc_imx_platform_flag *plat_data;
};

struct usbmisc_ops {
	int (*init)(struct imx_usbmisc_data *);
	int (*post)(struct imx_usbmisc_data *);
	int (*set_wakeup)(struct imx_usbmisc_data *, bool);
	int (*hsic_set_connect)(struct imx_usbmisc_data *);
	int (*hsic_set_clk)(struct imx_usbmisc_data *, bool);
	int (*charger_detection)(struct imx_usbmisc_data *);
	int (*power_lost_check)(struct imx_usbmisc_data *);
	void (*vbus_comparator_on)(struct imx_usbmisc_data *, bool);
};

struct imx_usbmisc {
	void *base;
	spinlock_t lock;
	const struct usbmisc_ops *ops;
};

struct tegra_core_opp_params {
	bool init_state;
};

struct tegra_usb_soc_info;

struct tegra_usb {
	struct ci_hdrc_platform_data data;
	struct platform_device *dev;
	const struct tegra_usb_soc_info *soc;
	struct usb_phy *phy;
	struct clk *clk;
	bool needs_double_reset;
};

struct tegra_usb_soc_info {
	long unsigned int flags;
	unsigned int txfifothresh;
	enum usb_dr_mode dr_mode;
};

struct usb_string {
	u8 id;
	const char *s;
};

struct usb_gadget_strings {
	u16 language;
	struct usb_string *strings;
};

struct usb_otg_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bmAttributes;
};

struct usb_otg20_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bmAttributes;
	__le16 bcdOTG;
} __attribute__((packed));

struct usb_os_desc {
	char *ext_compat_id;
	struct list_head ext_prop;
	int ext_prop_len;
	int ext_prop_count;
	struct mutex *opts_mutex;
	struct config_group group;
	struct module *owner;
};

struct usb_os_desc_table {
	int if_id;
	struct usb_os_desc *os_desc;
};

struct usb_configuration;

struct usb_function_instance;

struct usb_function {
	const char *name;
	struct usb_gadget_strings **strings;
	struct usb_descriptor_header **fs_descriptors;
	struct usb_descriptor_header **hs_descriptors;
	struct usb_descriptor_header **ss_descriptors;
	struct usb_descriptor_header **ssp_descriptors;
	struct usb_configuration *config;
	struct usb_os_desc_table *os_desc_table;
	unsigned int os_desc_n;
	int (*bind)(struct usb_configuration *, struct usb_function *);
	void (*unbind)(struct usb_configuration *, struct usb_function *);
	void (*free_func)(struct usb_function *);
	struct module *mod;
	int (*set_alt)(struct usb_function *, unsigned int, unsigned int);
	int (*get_alt)(struct usb_function *, unsigned int);
	void (*disable)(struct usb_function *);
	int (*setup)(struct usb_function *, const struct usb_ctrlrequest *);
	bool (*req_match)(struct usb_function *, const struct usb_ctrlrequest *, bool);
	void (*suspend)(struct usb_function *);
	void (*resume)(struct usb_function *);
	int (*get_status)(struct usb_function *);
	int (*func_suspend)(struct usb_function *, u8);
	struct list_head list;
	long unsigned int endpoints[1];
	const struct usb_function_instance *fi;
	unsigned int bind_deactivated: 1;
};

struct usb_composite_dev;

struct usb_configuration {
	const char *label;
	struct usb_gadget_strings **strings;
	const struct usb_descriptor_header **descriptors;
	void (*unbind)(struct usb_configuration *);
	int (*setup)(struct usb_configuration *, const struct usb_ctrlrequest *);
	u8 bConfigurationValue;
	u8 iConfiguration;
	u8 bmAttributes;
	u16 MaxPower;
	struct usb_composite_dev *cdev;
	struct list_head list;
	struct list_head functions;
	u8 next_interface_id;
	unsigned int superspeed: 1;
	unsigned int highspeed: 1;
	unsigned int fullspeed: 1;
	unsigned int superspeed_plus: 1;
	struct usb_function *interface[16];
};

struct usb_function_driver;

struct usb_function_instance {
	struct config_group group;
	struct list_head cfs_list;
	struct usb_function_driver *fd;
	int (*set_inst_name)(struct usb_function_instance *, const char *);
	void (*free_func_inst)(struct usb_function_instance *);
};

struct usb_composite_driver;

struct usb_composite_dev {
	struct usb_gadget *gadget;
	struct usb_request *req;
	struct usb_request *os_desc_req;
	struct usb_configuration *config;
	u8 qw_sign[14];
	u8 b_vendor_code;
	char: 8;
	struct usb_configuration *os_desc_config;
	unsigned int use_os_string: 1;
	unsigned int suspended: 1;
	struct usb_device_descriptor desc;
	char: 8;
	struct list_head configs;
	struct list_head gstrings;
	struct usb_composite_driver *driver;
	u8 next_string_id;
	int: 24;
	char *def_manufacturer;
	unsigned int deactivations;
	int delayed_status;
	spinlock_t lock;
	unsigned int setup_pending: 1;
	unsigned int os_desc_pending: 1;
	int: 30;
} __attribute__((packed));

struct usb_composite_driver {
	const char *name;
	const struct usb_device_descriptor *dev;
	struct usb_gadget_strings **strings;
	enum usb_device_speed max_speed;
	unsigned int needs_serial: 1;
	int (*bind)(struct usb_composite_dev *);
	int (*unbind)(struct usb_composite_dev *);
	void (*disconnect)(struct usb_composite_dev *);
	void (*suspend)(struct usb_composite_dev *);
	void (*resume)(struct usb_composite_dev *);
	struct usb_gadget_driver gadget_driver;
};

struct usb_function_driver {
	const char *name;
	struct module *mod;
	struct list_head list;
	struct usb_function_instance * (*alloc_inst)();
	struct usb_function * (*alloc_func)(struct usb_function_instance *);
};

struct usb_string_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 wData[1];
};

struct usb_gadget_string_container {
	struct list_head list;
	u8 *stash[0];
};

struct usb_os_desc_ext_prop {
	struct list_head entry;
	u8 type;
	int name_len;
	char *name;
	int data_len;
	char *data;
	struct config_item item;
};

enum {
	USB_GADGET_MANUFACTURER_IDX = 0,
	USB_GADGET_PRODUCT_IDX = 1,
	USB_GADGET_SERIAL_IDX = 2,
	USB_GADGET_FIRST_AVAIL_IDX = 3,
};

struct usb_composite_overwrite {
	u16 idVendor;
	u16 idProduct;
	u16 bcdDevice;
	char *serial_number;
	char *manufacturer;
	char *product;
};

struct usb_os_string {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 qwSignature[14];
	__u8 bMS_VendorCode;
	__u8 bPad;
};

struct gadget_info {
	struct config_group group;
	struct config_group functions_group;
	struct config_group configs_group;
	struct config_group strings_group;
	struct config_group os_desc_group;
	struct mutex lock;
	struct usb_gadget_strings *gstrings[3];
	struct list_head string_list;
	struct list_head available_func;
	struct usb_composite_driver composite;
	struct usb_composite_dev cdev;
	int driver_id_number;
	bool use_os_desc;
	char b_vendor_code;
	char qw_sign[14];
	spinlock_t spinlock;
	bool unbind;
};

struct config_usb_cfg {
	struct config_group group;
	struct config_group strings_group;
	struct list_head string_list;
	struct usb_configuration c;
	struct list_head func_list;
	struct usb_gadget_strings *gstrings[3];
};

struct gadget_strings {
	struct usb_gadget_strings stringtab_dev;
	struct usb_string strings[3];
	char *manufacturer;
	char *product;
	char *serialnumber;
	struct config_group group;
	struct list_head list;
};

struct gadget_config_name {
	struct usb_gadget_strings stringtab_dev;
	struct usb_string strings;
	char *configuration;
	struct config_group group;
	struct list_head list;
};

struct usb_udc {
	struct usb_gadget_driver *driver;
	struct usb_gadget *gadget;
	struct device dev;
	struct list_head list;
	bool vbus;
	bool started;
	int: 16;
	int: 32;
};

struct trace_event_raw_udc_log_gadget {
	struct trace_entry ent;
	enum usb_device_speed speed;
	enum usb_device_speed max_speed;
	enum usb_device_state state;
	unsigned int mA;
	unsigned int sg_supported;
	unsigned int is_otg;
	unsigned int is_a_peripheral;
	unsigned int b_hnp_enable;
	unsigned int a_hnp_support;
	unsigned int hnp_polling_support;
	unsigned int host_request_flag;
	unsigned int quirk_ep_out_aligned_size;
	unsigned int quirk_altset_not_supp;
	unsigned int quirk_stall_not_supp;
	unsigned int quirk_zlp_not_supp;
	unsigned int is_selfpowered;
	unsigned int deactivated;
	unsigned int connected;
	int ret;
	char __data[0];
};

struct trace_event_raw_udc_log_ep {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int maxpacket;
	unsigned int maxpacket_limit;
	unsigned int max_streams;
	unsigned int mult;
	unsigned int maxburst;
	u8 address;
	bool claimed;
	bool enabled;
	int ret;
	char __data[0];
};

struct trace_event_raw_udc_log_req {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int length;
	unsigned int actual;
	unsigned int num_sgs;
	unsigned int num_mapped_sgs;
	unsigned int stream_id;
	unsigned int no_interrupt;
	unsigned int zero;
	unsigned int short_not_ok;
	int status;
	int ret;
	struct usb_request *req;
	char __data[0];
};

struct trace_event_data_offsets_udc_log_gadget {};

struct trace_event_data_offsets_udc_log_ep {
	u32 name;
};

struct trace_event_data_offsets_udc_log_req {
	u32 name;
};

typedef void (*btf_trace_usb_gadget_frame_number)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_wakeup)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_set_selfpowered)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_clear_selfpowered)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_connect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_draw)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_vbus_disconnect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_connect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_disconnect)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_deactivate)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_gadget_activate)(void *, struct usb_gadget *, int);

typedef void (*btf_trace_usb_ep_set_maxpacket_limit)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_enable)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_disable)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_set_halt)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_clear_halt)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_set_wedge)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_fifo_status)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_fifo_flush)(void *, struct usb_ep *, int);

typedef void (*btf_trace_usb_ep_alloc_request)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_free_request)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_queue)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_ep_dequeue)(void *, struct usb_ep *, struct usb_request *, int);

typedef void (*btf_trace_usb_gadget_giveback_request)(void *, struct usb_ep *, struct usb_request *, int);

struct usb_cdc_line_coding {
	__le32 dwDTERate;
	__u8 bCharFormat;
	__u8 bParityType;
	__u8 bDataBits;
} __attribute__((packed));

struct f_serial_opts {
	struct usb_function_instance func_inst;
	u8 port_num;
};

struct gs_port;

struct gserial {
	struct usb_function func;
	struct gs_port *ioport;
	struct usb_ep *in;
	struct usb_ep *out;
	struct usb_cdc_line_coding port_line_coding;
	void (*connect)(struct gserial *);
	void (*disconnect)(struct gserial *);
	int (*send_break)(struct gserial *, int);
};

struct f_acm {
	struct gserial port;
	u8 ctrl_id;
	u8 data_id;
	u8 port_num;
	u8 pending;
	spinlock_t lock;
	struct usb_ep *notify;
	struct usb_request *notify_req;
	struct usb_cdc_line_coding port_line_coding;
	u16 port_handshake_bits;
	u16 serial_state;
};

struct f_lb_opts {
	struct usb_function_instance func_inst;
	unsigned int bulk_buflen;
	unsigned int qlen;
	struct mutex lock;
	int refcnt;
};

struct f_loopback {
	struct usb_function function;
	struct usb_ep *in_ep;
	struct usb_ep *out_ep;
	unsigned int qlen;
	unsigned int buflen;
};

struct f_ss_opts {
	struct usb_function_instance func_inst;
	unsigned int pattern;
	unsigned int isoc_interval;
	unsigned int isoc_maxpacket;
	unsigned int isoc_mult;
	unsigned int isoc_maxburst;
	unsigned int bulk_buflen;
	unsigned int bulk_qlen;
	unsigned int iso_qlen;
	struct mutex lock;
	int refcnt;
};

struct f_sourcesink {
	struct usb_function function;
	struct usb_ep *in_ep;
	struct usb_ep *out_ep;
	struct usb_ep *iso_in_ep;
	struct usb_ep *iso_out_ep;
	int cur_alt;
	unsigned int pattern;
	unsigned int isoc_interval;
	unsigned int isoc_maxpacket;
	unsigned int isoc_mult;
	unsigned int isoc_maxburst;
	unsigned int buflen;
	unsigned int bulk_qlen;
	unsigned int iso_qlen;
};

struct gs_port {
	struct tty_port port;
	spinlock_t port_lock;
	struct gserial *port_usb;
	u8 port_num;
	int: 24;
	struct list_head read_pool;
	int read_started;
	int read_allocated;
	struct list_head read_queue;
	unsigned int n_read;
	struct delayed_work push;
	struct list_head write_pool;
	int write_started;
	int write_allocated;
	struct kfifo port_write_buf;
	wait_queue_head_t drain_wait;
	bool write_busy;
	int: 24;
	wait_queue_head_t close_wait;
	bool suspended;
	bool start_delayed;
	struct usb_cdc_line_coding port_line_coding;
	int: 24;
} __attribute__((packed));

struct portmaster {
	struct mutex lock;
	struct gs_port *port;
};

struct f_gser {
	struct gserial port;
	u8 data_id;
	u8 port_num;
};

struct f_obex {
	struct gserial port;
	u8 ctrl_id;
	u8 data_id;
	u8 cur_alt;
	u8 port_num;
};

struct eth_dev;

struct gether {
	struct usb_function func;
	struct eth_dev *ioport;
	struct usb_ep *in_ep;
	struct usb_ep *out_ep;
	bool is_zlp_ok;
	u16 cdc_filter;
	u32 header_len;
	bool is_fixed;
	u32 fixed_out_len;
	u32 fixed_in_len;
	bool supports_multi_frame;
	struct sk_buff * (*wrap)(struct gether *, struct sk_buff *);
	int (*unwrap)(struct gether *, struct sk_buff *, struct sk_buff_head *);
	void (*open)(struct gether *);
	void (*close)(struct gether *);
};

struct eth_dev {
	spinlock_t lock;
	struct gether *port_usb;
	struct net_device *net;
	struct usb_gadget *gadget;
	spinlock_t req_lock;
	struct list_head tx_reqs;
	struct list_head rx_reqs;
	atomic_t tx_qlen;
	struct sk_buff_head rx_frames;
	unsigned int qmult;
	unsigned int header_len;
	struct sk_buff * (*wrap)(struct gether *, struct sk_buff *);
	int (*unwrap)(struct gether *, struct sk_buff *, struct sk_buff_head *);
	struct work_struct work;
	long unsigned int todo;
	bool zlp;
	bool no_skb_reserve;
	bool ifname_set;
	u8 host_mac[6];
	u8 dev_mac[6];
};

struct f_ncm_opts {
	struct usb_function_instance func_inst;
	struct net_device *net;
	bool bound;
	struct config_group *ncm_interf_group;
	struct usb_os_desc ncm_os_desc;
	char ncm_ext_compat_id[16];
	struct mutex lock;
	int refcnt;
};

enum ncm_notify_state {
	NCM_NOTIFY_NONE = 0,
	NCM_NOTIFY_CONNECT = 1,
	NCM_NOTIFY_SPEED = 2,
};

struct ndp_parser_opts;

struct f_ncm {
	struct gether port;
	u8 ctrl_id;
	u8 data_id;
	char ethaddr[14];
	struct usb_ep *notify;
	struct usb_request *notify_req;
	u8 notify_state;
	atomic_t notify_count;
	bool is_open;
	const struct ndp_parser_opts *parser_opts;
	bool is_crc;
	u32 ndp_sign;
	spinlock_t lock;
	struct net_device *netdev;
	struct sk_buff *skb_tx_data;
	struct sk_buff *skb_tx_ndp;
	u16 ndp_dgram_count;
	int: 16;
	int: 32;
	struct hrtimer task_timer;
};

struct ndp_parser_opts {
	u32 nth_sign;
	u32 ndp_sign;
	unsigned int nth_size;
	unsigned int ndp_size;
	unsigned int dpe_size;
	unsigned int ndplen_align;
	unsigned int dgram_item_len;
	unsigned int block_length;
	unsigned int ndp_index;
	unsigned int reserved1;
	unsigned int reserved2;
	unsigned int next_ndp_index;
};

struct f_ecm_opts {
	struct usb_function_instance func_inst;
	struct net_device *net;
	bool bound;
	struct mutex lock;
	int refcnt;
};

enum ecm_notify_state {
	ECM_NOTIFY_NONE = 0,
	ECM_NOTIFY_CONNECT = 1,
	ECM_NOTIFY_SPEED = 2,
};

struct f_ecm {
	struct gether port;
	u8 ctrl_id;
	u8 data_id;
	char ethaddr[14];
	struct usb_ep *notify;
	struct usb_request *notify_req;
	u8 notify_state;
	atomic_t notify_count;
	bool is_open;
};

struct f_eem_opts {
	struct usb_function_instance func_inst;
	struct net_device *net;
	bool bound;
	struct mutex lock;
	int refcnt;
};

struct f_eem {
	struct gether port;
	u8 ctrl_id;
};

struct in_context {
	struct sk_buff *skb;
	struct usb_ep *ep;
};

struct f_gether_opts {
	struct usb_function_instance func_inst;
	struct net_device *net;
	bool bound;
	struct mutex lock;
	int refcnt;
};

struct f_gether {
	struct gether port;
	char ethaddr[14];
};

struct f_rndis_opts {
	struct usb_function_instance func_inst;
	u32 vendor_id;
	const char *manufacturer;
	struct net_device *net;
	bool bound;
	bool borrowed_net;
	struct config_group *rndis_interf_group;
	struct usb_os_desc rndis_os_desc;
	char rndis_ext_compat_id[16];
	u8 class;
	u8 subclass;
	u8 protocol;
	struct mutex lock;
	int refcnt;
};

enum rndis_state {
	RNDIS_UNINITIALIZED = 0,
	RNDIS_INITIALIZED = 1,
	RNDIS_DATA_INITIALIZED = 2,
};

struct rndis_params {
	int confignr;
	u8 used;
	u16 saved_filter;
	enum rndis_state state;
	u32 medium;
	u32 speed;
	u32 media_state;
	const u8 *host_mac;
	u16 *filter;
	struct net_device *dev;
	u32 vendorID;
	const char *vendorDescr;
	void (*resp_avail)(void *);
	void *v;
	struct list_head resp_queue;
	spinlock_t resp_lock;
};

struct f_rndis {
	struct gether port;
	u8 ctrl_id;
	u8 data_id;
	u8 ethaddr[6];
	u32 vendorID;
	const char *manufacturer;
	struct rndis_params *params;
	struct usb_ep *notify;
	struct usb_request *notify_req;
	atomic_t notify_count;
};

struct rndis_init_msg_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 RequestID;
	__le32 MajorVersion;
	__le32 MinorVersion;
	__le32 MaxTransferSize;
};

typedef struct rndis_init_msg_type rndis_init_msg_type;

struct rndis_init_cmplt_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 RequestID;
	__le32 Status;
	__le32 MajorVersion;
	__le32 MinorVersion;
	__le32 DeviceFlags;
	__le32 Medium;
	__le32 MaxPacketsPerTransfer;
	__le32 MaxTransferSize;
	__le32 PacketAlignmentFactor;
	__le32 AFListOffset;
	__le32 AFListSize;
};

typedef struct rndis_init_cmplt_type rndis_init_cmplt_type;

struct rndis_query_msg_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 RequestID;
	__le32 OID;
	__le32 InformationBufferLength;
	__le32 InformationBufferOffset;
	__le32 DeviceVcHandle;
};

typedef struct rndis_query_msg_type rndis_query_msg_type;

struct rndis_query_cmplt_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 RequestID;
	__le32 Status;
	__le32 InformationBufferLength;
	__le32 InformationBufferOffset;
};

typedef struct rndis_query_cmplt_type rndis_query_cmplt_type;

struct rndis_set_msg_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 RequestID;
	__le32 OID;
	__le32 InformationBufferLength;
	__le32 InformationBufferOffset;
	__le32 DeviceVcHandle;
};

typedef struct rndis_set_msg_type rndis_set_msg_type;

struct rndis_set_cmplt_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 RequestID;
	__le32 Status;
};

typedef struct rndis_set_cmplt_type rndis_set_cmplt_type;

struct rndis_reset_msg_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 Reserved;
};

typedef struct rndis_reset_msg_type rndis_reset_msg_type;

struct rndis_reset_cmplt_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 Status;
	__le32 AddressingReset;
};

typedef struct rndis_reset_cmplt_type rndis_reset_cmplt_type;

struct rndis_indicate_status_msg_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 Status;
	__le32 StatusBufferLength;
	__le32 StatusBufferOffset;
};

typedef struct rndis_indicate_status_msg_type rndis_indicate_status_msg_type;

struct rndis_keepalive_msg_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 RequestID;
};

typedef struct rndis_keepalive_msg_type rndis_keepalive_msg_type;

struct rndis_keepalive_cmplt_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 RequestID;
	__le32 Status;
};

typedef struct rndis_keepalive_cmplt_type rndis_keepalive_cmplt_type;

struct rndis_packet_msg_type {
	__le32 MessageType;
	__le32 MessageLength;
	__le32 DataOffset;
	__le32 DataLength;
	__le32 OOBDataOffset;
	__le32 OOBDataLength;
	__le32 NumOOBDataElements;
	__le32 PerPacketInfoOffset;
	__le32 PerPacketInfoLength;
	__le32 VcHandle;
	__le32 Reserved;
};

struct rndis_resp_t {
	struct list_head list;
	u8 *buf;
	u32 length;
	int send;
};

typedef struct rndis_resp_t rndis_resp_t;

struct fsg_lun {
	struct file *filp;
	int: 32;
	loff_t file_length;
	loff_t num_sectors;
	unsigned int initially_ro: 1;
	unsigned int ro: 1;
	unsigned int removable: 1;
	unsigned int cdrom: 1;
	unsigned int prevent_medium_removal: 1;
	unsigned int registered: 1;
	unsigned int info_valid: 1;
	unsigned int nofua: 1;
	u32 sense_data;
	u32 sense_data_info;
	u32 unit_attention_data;
	unsigned int blkbits;
	unsigned int blksize;
	struct device dev;
	const char *name;
	const char **name_pfx;
	char inquiry_string[29];
};

enum fsg_buffer_state {
	BUF_STATE_SENDING = 4294967294,
	BUF_STATE_RECEIVING = 4294967295,
	BUF_STATE_EMPTY = 0,
	BUF_STATE_FULL = 1,
};

struct fsg_buffhd {
	void *buf;
	enum fsg_buffer_state state;
	struct fsg_buffhd *next;
	unsigned int bulk_out_intended_length;
	struct usb_request *inreq;
	struct usb_request *outreq;
};

enum fsg_state {
	FSG_STATE_NORMAL = 0,
	FSG_STATE_ABORT_BULK_OUT = 1,
	FSG_STATE_PROTOCOL_RESET = 2,
	FSG_STATE_CONFIG_CHANGE = 3,
	FSG_STATE_EXIT = 4,
	FSG_STATE_TERMINATED = 5,
};

enum data_direction {
	DATA_DIR_UNKNOWN = 0,
	DATA_DIR_FROM_HOST = 1,
	DATA_DIR_TO_HOST = 2,
	DATA_DIR_NONE = 3,
};

enum {
	FSG_STRING_INTERFACE = 0,
};

struct fsg_module_parameters {
	char *file[16];
	bool ro[16];
	bool removable[16];
	bool cdrom[16];
	bool nofua[16];
	unsigned int file_count;
	unsigned int ro_count;
	unsigned int removable_count;
	unsigned int cdrom_count;
	unsigned int nofua_count;
	unsigned int luns;
	bool stall;
};

struct fsg_lun_opts {
	struct config_group group;
	struct fsg_lun *lun;
	int lun_id;
};

struct fsg_common;

struct fsg_opts {
	struct fsg_common *common;
	struct usb_function_instance func_inst;
	struct fsg_lun_opts lun0;
	struct config_group *default_groups[2];
	bool no_configfs;
	struct mutex lock;
	int refcnt;
};

struct fsg_dev;

struct fsg_common {
	struct usb_gadget *gadget;
	struct usb_composite_dev *cdev;
	struct fsg_dev *fsg;
	wait_queue_head_t io_wait;
	wait_queue_head_t fsg_wait;
	struct rw_semaphore filesem;
	spinlock_t lock;
	struct usb_ep *ep0;
	struct usb_request *ep0req;
	unsigned int ep0_req_tag;
	struct fsg_buffhd *next_buffhd_to_fill;
	struct fsg_buffhd *next_buffhd_to_drain;
	struct fsg_buffhd *buffhds;
	unsigned int fsg_num_buffers;
	int cmnd_size;
	u8 cmnd[16];
	unsigned int lun;
	struct fsg_lun *luns[16];
	struct fsg_lun *curlun;
	unsigned int bulk_out_maxpacket;
	enum fsg_state state;
	unsigned int exception_req_tag;
	void *exception_arg;
	enum data_direction data_dir;
	u32 data_size;
	u32 data_size_from_cmnd;
	u32 tag;
	u32 residue;
	u32 usb_amount_left;
	unsigned int can_stall: 1;
	unsigned int free_storage_on_release: 1;
	unsigned int phase_error: 1;
	unsigned int short_packet_received: 1;
	unsigned int bad_lun_okay: 1;
	unsigned int running: 1;
	unsigned int sysfs: 1;
	struct completion thread_notifier;
	struct task_struct *thread_task;
	void *private_data;
	char inquiry_string[29];
};

struct fsg_lun_config {
	const char *filename;
	char ro;
	char removable;
	char cdrom;
	char nofua;
	char inquiry_string[29];
};

struct fsg_operations;

struct fsg_config {
	unsigned int nluns;
	struct fsg_lun_config luns[16];
	const struct fsg_operations *ops;
	void *private_data;
	const char *vendor_name;
	const char *product_name;
	char can_stall;
	unsigned int fsg_num_buffers;
};

struct fsg_dev {
	struct usb_function function;
	struct usb_gadget *gadget;
	struct fsg_common *common;
	u16 interface_number;
	unsigned int bulk_in_enabled: 1;
	unsigned int bulk_out_enabled: 1;
	long unsigned int atomic_bitflags;
	struct usb_ep *bulk_in;
	struct usb_ep *bulk_out;
};

enum hid_report_type {
	HID_INPUT_REPORT = 0,
	HID_OUTPUT_REPORT = 1,
	HID_FEATURE_REPORT = 2,
	HID_REPORT_TYPES = 3,
};

enum {
	FUNCTIONFS_DESCRIPTORS_MAGIC = 1,
	FUNCTIONFS_STRINGS_MAGIC = 2,
	FUNCTIONFS_DESCRIPTORS_MAGIC_V2 = 3,
};

enum functionfs_flags {
	FUNCTIONFS_HAS_FS_DESC = 1,
	FUNCTIONFS_HAS_HS_DESC = 2,
	FUNCTIONFS_HAS_SS_DESC = 4,
	FUNCTIONFS_HAS_MS_OS_DESC = 8,
	FUNCTIONFS_VIRTUAL_ADDR = 16,
	FUNCTIONFS_EVENTFD = 32,
	FUNCTIONFS_ALL_CTRL_RECIP = 64,
	FUNCTIONFS_CONFIG0_SETUP = 128,
};

struct usb_os_desc_header {
	__u8 interface;
	__le32 dwLength;
	__le16 bcdVersion;
	__le16 wIndex;
	union {
		struct {
			__u8 bCount;
			__u8 Reserved;
		};
		__le16 wCount;
	};
} __attribute__((packed));

struct usb_ext_compat_desc {
	__u8 bFirstInterfaceNumber;
	__u8 Reserved1;
	__u8 CompatibleID[8];
	__u8 SubCompatibleID[8];
	__u8 Reserved2[6];
};

struct usb_ext_prop_desc {
	__le32 dwSize;
	__le32 dwPropertyDataType;
	__le16 wPropertyNameLength;
} __attribute__((packed));

enum usb_functionfs_event_type {
	FUNCTIONFS_BIND = 0,
	FUNCTIONFS_UNBIND = 1,
	FUNCTIONFS_ENABLE = 2,
	FUNCTIONFS_DISABLE = 3,
	FUNCTIONFS_SETUP = 4,
	FUNCTIONFS_SUSPEND = 5,
	FUNCTIONFS_RESUME = 6,
};

struct usb_functionfs_event {
	union {
		struct usb_ctrlrequest setup;
	} u;
	__u8 type;
	__u8 _pad[3];
};

struct ffs_data;

struct f_fs_opts;

struct ffs_dev {
	struct ffs_data *ffs_data;
	struct f_fs_opts *opts;
	struct list_head entry;
	char name[41];
	bool mounted;
	bool desc_ready;
	bool single;
	int (*ffs_ready_callback)(struct ffs_data *);
	void (*ffs_closed_callback)(struct ffs_data *);
	void * (*ffs_acquire_dev_callback)(struct ffs_dev *);
	void (*ffs_release_dev_callback)(struct ffs_dev *);
};

enum ffs_state {
	FFS_READ_DESCRIPTORS = 0,
	FFS_READ_STRINGS = 1,
	FFS_ACTIVE = 2,
	FFS_DEACTIVATED = 3,
	FFS_CLOSING = 4,
};

enum ffs_setup_state {
	FFS_NO_SETUP = 0,
	FFS_SETUP_PENDING = 1,
	FFS_SETUP_CANCELLED = 2,
};

struct ffs_file_perms {
	umode_t mode;
	kuid_t uid;
	kgid_t gid;
};

struct ffs_function;

struct ffs_epfile;

struct ffs_data {
	struct usb_gadget *gadget;
	struct mutex mutex;
	spinlock_t eps_lock;
	struct usb_request *ep0req;
	struct completion ep0req_completion;
	refcount_t ref;
	atomic_t opened;
	enum ffs_state state;
	enum ffs_setup_state setup_state;
	struct {
		u8 types[4];
		short unsigned int count;
		short unsigned int can_stall;
		struct usb_ctrlrequest setup;
		wait_queue_head_t waitq;
	} ev;
	long unsigned int flags;
	wait_queue_head_t wait;
	struct ffs_function *func;
	const char *dev_name;
	void *private_data;
	const void *raw_descs_data;
	const void *raw_descs;
	unsigned int raw_descs_length;
	unsigned int fs_descs_count;
	unsigned int hs_descs_count;
	unsigned int ss_descs_count;
	unsigned int ms_os_descs_count;
	unsigned int ms_os_descs_ext_prop_count;
	unsigned int ms_os_descs_ext_prop_name_len;
	unsigned int ms_os_descs_ext_prop_data_len;
	void *ms_os_descs_ext_prop_avail;
	void *ms_os_descs_ext_prop_name_avail;
	void *ms_os_descs_ext_prop_data_avail;
	unsigned int user_flags;
	u8 eps_addrmap[31];
	short unsigned int strings_count;
	short unsigned int interfaces_count;
	short unsigned int eps_count;
	short unsigned int _pad1;
	const void *raw_strings;
	struct usb_gadget_strings **stringtabs;
	struct super_block *sb;
	struct ffs_file_perms file_perms;
	struct eventfd_ctx *ffs_eventfd;
	struct workqueue_struct *io_completion_wq;
	bool no_disconnect;
	struct work_struct reset_work;
	struct ffs_epfile *epfiles;
};

struct f_fs_opts {
	struct usb_function_instance func_inst;
	struct ffs_dev *dev;
	unsigned int refcnt;
	bool no_configfs;
};

struct ffs_ep;

struct ffs_function {
	struct usb_configuration *conf;
	struct usb_gadget *gadget;
	struct ffs_data *ffs;
	struct ffs_ep *eps;
	u8 eps_revmap[16];
	short int *interfaces_nums;
	struct usb_function function;
};

struct ffs_buffer;

struct ffs_epfile {
	struct mutex mutex;
	struct ffs_data *ffs;
	struct ffs_ep *ep;
	struct dentry *dentry;
	struct ffs_buffer *read_buffer;
	char name[5];
	unsigned char in;
	unsigned char isoc;
	unsigned char _pad;
};

struct ffs_ep {
	struct usb_ep *ep;
	struct usb_request *req;
	struct usb_endpoint_descriptor *descs[3];
	u8 num;
};

struct ffs_buffer {
	size_t length;
	char *data;
	char storage[0];
};

struct ffs_io_data {
	bool aio;
	bool read;
	struct kiocb *kiocb;
	struct iov_iter data;
	const void *to_free;
	char *buf;
	struct mm_struct *mm;
	struct work_struct work;
	struct usb_ep *ep;
	struct usb_request *req;
	struct sg_table sgt;
	bool use_sg;
	struct ffs_data *ffs;
	int status;
	struct completion done;
	int: 32;
};

struct ffs_desc_helper {
	struct ffs_data *ffs;
	unsigned int interfaces_count;
	unsigned int eps_count;
};

struct ffs_sb_fill_data {
	struct ffs_file_perms perms;
	umode_t root_mode;
	const char *dev_name;
	bool no_disconnect;
	struct ffs_data *ffs_data;
};

enum {
	Opt_no_disconnect = 0,
	Opt_rmode = 1,
	Opt_fmode = 2,
	Opt_mode___5 = 3,
	Opt_uid___6 = 4,
	Opt_gid___7 = 5,
};

enum ffs_entity_type {
	FFS_DESCRIPTOR = 0,
	FFS_INTERFACE = 1,
	FFS_STRING = 2,
	FFS_ENDPOINT = 3,
};

enum ffs_os_desc_type {
	FFS_OS_DESC = 0,
	FFS_OS_DESC_EXT_COMPAT = 1,
	FFS_OS_DESC_EXT_PROP = 2,
};

typedef int (*ffs_entity_callback)(enum ffs_entity_type, u8 *, struct usb_descriptor_header *, void *);

typedef int (*ffs_os_desc_callback)(enum ffs_os_desc_type, struct usb_os_desc_header *, void *, unsigned int, void *);

struct uac_fu_params {
	int id;
	bool mute_present;
	bool volume_present;
	s16 volume_min;
	s16 volume_max;
	s16 volume_res;
};

struct uac_params {
	int p_chmask;
	int p_srates[10];
	int p_ssize;
	struct uac_fu_params p_fu;
	int c_chmask;
	int c_srates[10];
	int c_ssize;
	struct uac_fu_params c_fu;
	int req_number;
	int fb_max;
};

struct snd_uac_chip;

struct g_audio {
	struct usb_function func;
	struct usb_gadget *gadget;
	struct usb_ep *in_ep;
	struct usb_ep *out_ep;
	struct usb_ep *in_ep_fback;
	unsigned int in_ep_maxpsize;
	unsigned int out_ep_maxpsize;
	int (*notify)(struct g_audio *, int, int);
	struct snd_uac_chip *uac;
	struct uac_params params;
};

struct uac_rtd_params {
	struct snd_uac_chip *uac;
	bool ep_enabled;
	struct snd_pcm_substream *ss;
	ssize_t hw_ptr;
	void *rbuf;
	unsigned int pitch;
	unsigned int max_psize;
	struct usb_request **reqs;
	struct usb_request *req_fback;
	bool fb_ep_enabled;
	int fu_id;
	struct snd_kcontrol *snd_kctl_volume;
	struct snd_kcontrol *snd_kctl_mute;
	s16 volume_min;
	s16 volume_max;
	s16 volume_res;
	s16 volume;
	int mute;
	struct snd_kcontrol *snd_kctl_rate;
	int srate;
	int active;
	spinlock_t lock;
};

struct snd_uac_chip {
	struct g_audio *audio_dev;
	struct uac_rtd_params p_prm;
	struct uac_rtd_params c_prm;
	struct snd_card *card;
	struct snd_pcm *pcm;
	int: 32;
	long long unsigned int p_residue_mil;
	unsigned int p_interval;
	unsigned int p_framesize;
};

enum {
	UAC_FBACK_CTRL = 0,
	UAC_P_PITCH_CTRL = 1,
	UAC_MUTE_CTRL = 2,
	UAC_VOLUME_CTRL = 3,
	UAC_RATE_CTRL = 4,
};

struct uac1_ac_header_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__le16 bcdADC;
	__le16 wTotalLength;
	__u8 bInCollection;
	__u8 baInterfaceNr[0];
} __attribute__((packed));

struct uac_input_terminal_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bTerminalID;
	__le16 wTerminalType;
	__u8 bAssocTerminal;
	__u8 bNrChannels;
	__le16 wChannelConfig;
	__u8 iChannelNames;
	__u8 iTerminal;
};

struct uac1_output_terminal_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bTerminalID;
	__le16 wTerminalType;
	__u8 bAssocTerminal;
	__u8 bSourceID;
	__u8 iTerminal;
} __attribute__((packed));

struct uac_feature_unit_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bUnitID;
	__u8 bSourceID;
	__u8 bControlSize;
	__u8 bmaControls[0];
};

struct uac1_as_header_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bTerminalLink;
	__u8 bDelay;
	__le16 wFormatTag;
} __attribute__((packed));

struct uac_iso_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bmAttributes;
	__u8 bLockDelayUnits;
	__le16 wLockDelay;
} __attribute__((packed));

struct uac1_status_word {
	__u8 bStatusType;
	__u8 bOriginator;
};

struct f_uac1_opts {
	struct usb_function_instance func_inst;
	int c_chmask;
	int c_srates[10];
	int c_ssize;
	int p_chmask;
	int p_srates[10];
	int p_ssize;
	bool p_mute_present;
	bool p_volume_present;
	s16 p_volume_min;
	s16 p_volume_max;
	s16 p_volume_res;
	bool c_mute_present;
	bool c_volume_present;
	s16 c_volume_min;
	s16 c_volume_max;
	s16 c_volume_res;
	int req_number;
	unsigned int bound: 1;
	char function_name[32];
	struct mutex lock;
	int refcnt;
};

struct f_uac1 {
	struct g_audio g_audio;
	u8 ac_intf;
	u8 as_in_intf;
	u8 as_out_intf;
	u8 ac_alt;
	u8 as_in_alt;
	u8 as_out_alt;
	struct usb_ctrlrequest setup_cr;
	struct usb_ep *int_ep;
	atomic_t int_count;
	int ctl_id;
	int c_srate;
	int p_srate;
};

struct uac_format_type_i_discrete_descriptor_UAC_MAX_RATES {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bFormatType;
	__u8 bNrChannels;
	__u8 bSubframeSize;
	__u8 bBitResolution;
	__u8 bSamFreqType;
	__u8 tSamFreq[30];
};

enum {
	STR_AC_IF = 0,
	STR_USB_OUT_IT = 1,
	STR_USB_OUT_IT_CH_NAMES = 2,
	STR_IO_OUT_OT = 3,
	STR_IO_IN_IT = 4,
	STR_IO_IN_IT_CH_NAMES = 5,
	STR_USB_IN_OT = 6,
	STR_FU_IN = 7,
	STR_FU_OUT = 8,
	STR_AS_OUT_IF_ALT0 = 9,
	STR_AS_OUT_IF_ALT1 = 10,
	STR_AS_IN_IF_ALT0 = 11,
	STR_AS_IN_IF_ALT1 = 12,
};

struct uac2_ac_header_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__le16 bcdADC;
	__u8 bCategory;
	__le16 wTotalLength;
	__u8 bmControls;
} __attribute__((packed));

struct uac2_format_type_i_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bFormatType;
	__u8 bSubslotSize;
	__u8 bBitResolution;
};

struct uac_clock_source_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bClockID;
	__u8 bmAttributes;
	__u8 bmControls;
	__u8 bAssocTerminal;
	__u8 iClockSource;
};

struct uac2_input_terminal_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bTerminalID;
	__le16 wTerminalType;
	__u8 bAssocTerminal;
	__u8 bCSourceID;
	__u8 bNrChannels;
	__le32 bmChannelConfig;
	__u8 iChannelNames;
	__le16 bmControls;
	__u8 iTerminal;
} __attribute__((packed));

struct uac2_output_terminal_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bTerminalID;
	__le16 wTerminalType;
	__u8 bAssocTerminal;
	__u8 bSourceID;
	__u8 bCSourceID;
	__le16 bmControls;
	__u8 iTerminal;
} __attribute__((packed));

struct uac2_feature_unit_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bUnitID;
	__u8 bSourceID;
	__u8 bmaControls[0];
};

struct uac2_as_header_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bTerminalLink;
	__u8 bmControls;
	__u8 bFormatType;
	__le32 bmFormats;
	__u8 bNrChannels;
	__le32 bmChannelConfig;
	__u8 iChannelNames;
} __attribute__((packed));

struct uac2_iso_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bmAttributes;
	__u8 bmControls;
	__u8 bLockDelayUnits;
	__le16 wLockDelay;
};

struct uac2_interrupt_data_msg {
	__u8 bInfo;
	__u8 bAttribute;
	__le16 wValue;
	__le16 wIndex;
};

struct f_uac2_opts {
	struct usb_function_instance func_inst;
	int p_chmask;
	int p_srates[10];
	int p_ssize;
	u8 p_hs_bint;
	int c_chmask;
	int c_srates[10];
	int c_ssize;
	int c_sync;
	u8 c_hs_bint;
	bool p_mute_present;
	bool p_volume_present;
	s16 p_volume_min;
	s16 p_volume_max;
	s16 p_volume_res;
	bool c_mute_present;
	bool c_volume_present;
	s16 c_volume_min;
	s16 c_volume_max;
	s16 c_volume_res;
	int req_number;
	int fb_max;
	bool bound;
	char function_name[32];
	struct mutex lock;
	int refcnt;
};

struct f_uac2 {
	struct g_audio g_audio;
	u8 ac_intf;
	u8 as_in_intf;
	u8 as_out_intf;
	u8 ac_alt;
	u8 as_in_alt;
	u8 as_out_alt;
	struct usb_ctrlrequest setup_cr;
	struct usb_ep *int_ep;
	atomic_t int_count;
	int clock_id;
};

enum {
	STR_ASSOC = 0,
	STR_IF_CTRL = 1,
	STR_CLKSRC_IN = 2,
	STR_CLKSRC_OUT = 3,
	STR_USB_IT = 4,
	STR_IO_IT = 5,
	STR_USB_OT = 6,
	STR_IO_OT = 7,
	STR_FU_IN___2 = 8,
	STR_FU_OUT___2 = 9,
	STR_AS_OUT_ALT0 = 10,
	STR_AS_OUT_ALT1 = 11,
	STR_AS_IN_ALT0 = 12,
	STR_AS_IN_ALT1 = 13,
};

struct cntrl_cur_lay2 {
	__le16 wCUR;
};

struct cntrl_range_lay2 {
	__le16 wNumSubRanges;
	__le16 wMIN;
	__le16 wMAX;
	__le16 wRES;
};

struct cntrl_cur_lay3 {
	__le32 dCUR;
};

struct cntrl_subrange_lay3 {
	__le32 dMIN;
	__le32 dMAX;
	__le32 dRES;
};

struct cntrl_ranges_lay3_srates {
	__le16 wNumSubRanges;
	struct cntrl_subrange_lay3 r[10];
} __attribute__((packed));

struct uvc_request_data {
	__s32 length;
	__u8 data[60];
};

struct uvc_event {
	union {
		enum usb_device_speed speed;
		struct usb_ctrlrequest req;
		struct uvc_request_data data;
	};
};

struct uvc_descriptor_header {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
};

struct uvc_header_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdUVC;
	__le16 wTotalLength;
	__le32 dwClockFrequency;
	__u8 bInCollection;
	__u8 baInterfaceNr[0];
} __attribute__((packed));

struct uvc_output_terminal_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bTerminalID;
	__le16 wTerminalType;
	__u8 bAssocTerminal;
	__u8 bSourceID;
	__u8 iTerminal;
} __attribute__((packed));

struct uvc_camera_terminal_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bTerminalID;
	__le16 wTerminalType;
	__u8 bAssocTerminal;
	__u8 iTerminal;
	__le16 wObjectiveFocalLengthMin;
	__le16 wObjectiveFocalLengthMax;
	__le16 wOcularFocalLength;
	__u8 bControlSize;
	__u8 bmControls[3];
};

struct uvc_processing_unit_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bUnitID;
	__u8 bSourceID;
	__le16 wMaxMultiplier;
	__u8 bControlSize;
	__u8 bmControls[2];
	__u8 iProcessing;
	__u8 bmVideoStandards;
} __attribute__((packed));

struct uvc_control_endpoint_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 wMaxTransferSize;
} __attribute__((packed));

struct uvc_input_header_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bNumFormats;
	__le16 wTotalLength;
	__u8 bEndpointAddress;
	__u8 bmInfo;
	__u8 bTerminalLink;
	__u8 bStillCaptureMethod;
	__u8 bTriggerSupport;
	__u8 bTriggerUsage;
	__u8 bControlSize;
	__u8 bmaControls[0];
} __attribute__((packed));

struct uvc_color_matching_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bColorPrimaries;
	__u8 bTransferCharacteristics;
	__u8 bMatrixCoefficients;
};

struct v4l2_edid {
	__u32 pad;
	__u32 start_block;
	__u32 blocks;
	__u32 reserved[5];
	__u8 *edid;
};

enum v4l2_priority {
	V4L2_PRIORITY_UNSET = 0,
	V4L2_PRIORITY_BACKGROUND = 1,
	V4L2_PRIORITY_INTERACTIVE = 2,
	V4L2_PRIORITY_RECORD = 3,
	V4L2_PRIORITY_DEFAULT = 2,
};

struct v4l2_rect {
	__s32 left;
	__s32 top;
	__u32 width;
	__u32 height;
};

struct v4l2_fract {
	__u32 numerator;
	__u32 denominator;
};

struct v4l2_timecode {
	__u32 type;
	__u32 flags;
	__u8 frames;
	__u8 seconds;
	__u8 minutes;
	__u8 hours;
	__u8 userbits[4];
};

struct v4l2_captureparm {
	__u32 capability;
	__u32 capturemode;
	struct v4l2_fract timeperframe;
	__u32 extendedmode;
	__u32 readbuffers;
	__u32 reserved[4];
};

struct v4l2_outputparm {
	__u32 capability;
	__u32 outputmode;
	struct v4l2_fract timeperframe;
	__u32 extendedmode;
	__u32 writebuffers;
	__u32 reserved[4];
};

typedef __u64 v4l2_std_id;

struct v4l2_bt_timings {
	__u32 width;
	__u32 height;
	__u32 interlaced;
	__u32 polarities;
	__u64 pixelclock;
	__u32 hfrontporch;
	__u32 hsync;
	__u32 hbackporch;
	__u32 vfrontporch;
	__u32 vsync;
	__u32 vbackporch;
	__u32 il_vfrontporch;
	__u32 il_vsync;
	__u32 il_vbackporch;
	__u32 standards;
	__u32 flags;
	struct v4l2_fract picture_aspect;
	__u8 cea861_vic;
	__u8 hdmi_vic;
	__u8 reserved[46];
};

struct v4l2_dv_timings {
	__u32 type;
	union {
		struct v4l2_bt_timings bt;
		__u32 reserved[32];
	};
};

struct v4l2_enum_dv_timings {
	__u32 index;
	__u32 pad;
	__u32 reserved[2];
	struct v4l2_dv_timings timings;
};

struct v4l2_bt_timings_cap {
	__u32 min_width;
	__u32 max_width;
	__u32 min_height;
	__u32 max_height;
	__u64 min_pixelclock;
	__u64 max_pixelclock;
	__u32 standards;
	__u32 capabilities;
	__u32 reserved[16];
};

struct v4l2_dv_timings_cap {
	__u32 type;
	__u32 pad;
	__u32 reserved[2];
	union {
		struct v4l2_bt_timings_cap bt;
		__u32 raw_data[32];
	};
};

struct v4l2_tuner {
	__u32 index;
	__u8 name[32];
	__u32 type;
	__u32 capability;
	__u32 rangelow;
	__u32 rangehigh;
	__u32 rxsubchans;
	__u32 audmode;
	__s32 signal;
	__s32 afc;
	__u32 reserved[4];
};

struct v4l2_modulator {
	__u32 index;
	__u8 name[32];
	__u32 capability;
	__u32 rangelow;
	__u32 rangehigh;
	__u32 txsubchans;
	__u32 type;
	__u32 reserved[3];
};

struct v4l2_frequency {
	__u32 tuner;
	__u32 type;
	__u32 frequency;
	__u32 reserved[8];
};

struct v4l2_frequency_band {
	__u32 tuner;
	__u32 type;
	__u32 index;
	__u32 capability;
	__u32 rangelow;
	__u32 rangehigh;
	__u32 modulation;
	__u32 reserved[9];
};

struct v4l2_vbi_format {
	__u32 sampling_rate;
	__u32 offset;
	__u32 samples_per_line;
	__u32 sample_format;
	__s32 start[2];
	__u32 count[2];
	__u32 flags;
	__u32 reserved[2];
};

struct v4l2_sliced_vbi_format {
	__u16 service_set;
	__u16 service_lines[48];
	__u32 io_size;
	__u32 reserved[2];
};

struct v4l2_sliced_vbi_cap {
	__u16 service_set;
	__u16 service_lines[48];
	__u32 type;
	__u32 reserved[3];
};

struct v4l2_sliced_vbi_data {
	__u32 id;
	__u32 field;
	__u32 line;
	__u32 reserved;
	__u8 data[48];
};

struct v4l2_streamparm {
	__u32 type;
	union {
		struct v4l2_captureparm capture;
		struct v4l2_outputparm output;
		__u8 raw_data[200];
	} parm;
};

struct v4l2_event_vsync {
	__u8 field;
};

struct v4l2_event_ctrl {
	__u32 changes;
	__u32 type;
	union {
		__s32 value;
		__s64 value64;
	};
	__u32 flags;
	__s32 minimum;
	__s32 maximum;
	__s32 step;
	__s32 default_value;
	int: 32;
};

struct v4l2_event_frame_sync {
	__u32 frame_sequence;
};

struct v4l2_event_src_change {
	__u32 changes;
};

struct v4l2_event_motion_det {
	__u32 flags;
	__u32 frame_sequence;
	__u32 region_mask;
};

struct v4l2_event {
	__u32 type;
	int: 32;
	union {
		struct v4l2_event_vsync vsync;
		struct v4l2_event_ctrl ctrl;
		struct v4l2_event_frame_sync frame_sync;
		struct v4l2_event_src_change src_change;
		struct v4l2_event_motion_det motion_det;
		__u8 data[64];
	} u;
	__u32 pending;
	__u32 sequence;
	struct __kernel_timespec timestamp;
	__u32 id;
	__u32 reserved[8];
	int: 32;
};

struct v4l2_event_subscription {
	__u32 type;
	__u32 id;
	__u32 flags;
	__u32 reserved[5];
};

struct v4l2_dbg_match {
	__u32 type;
	union {
		__u32 addr;
		char name[32];
	};
};

struct v4l2_dbg_chip_ident {
	struct v4l2_dbg_match match;
	__u32 ident;
	__u32 revision;
};

struct media_device;

struct media_gobj {
	struct media_device *mdev;
	u32 id;
	struct list_head list;
};

struct media_entity_enum {
	long unsigned int *bmap;
	int idx_max;
};

struct media_entity;

struct media_graph {
	struct {
		struct media_entity *entity;
		struct list_head *link;
	} stack[16];
	struct media_entity_enum ent_enum;
	int top;
};

struct media_devnode;

struct media_pipeline;

struct media_device_ops;

struct media_device {
	struct device *dev;
	struct media_devnode *devnode;
	char model[32];
	char driver_name[32];
	char serial[40];
	char bus_info[32];
	u32 hw_revision;
	int: 32;
	u64 topology_version;
	u32 id;
	struct ida entity_internal_idx;
	int entity_internal_idx_max;
	struct list_head entities;
	struct list_head interfaces;
	struct list_head pads;
	struct list_head links;
	struct list_head entity_notify;
	struct mutex graph_mutex;
	struct media_graph pm_count_walk;
	void *source_priv;
	int (*enable_source)(struct media_entity *, struct media_pipeline *);
	void (*disable_source)(struct media_entity *);
	const struct media_device_ops *ops;
	struct mutex req_queue_mutex;
	atomic_t request_id;
	int: 32;
};

enum media_entity_type {
	MEDIA_ENTITY_TYPE_BASE = 0,
	MEDIA_ENTITY_TYPE_VIDEO_DEVICE = 1,
	MEDIA_ENTITY_TYPE_V4L2_SUBDEV = 2,
};

struct media_pad;

struct media_entity_operations;

struct media_entity {
	struct media_gobj graph_obj;
	const char *name;
	enum media_entity_type obj_type;
	u32 function;
	long unsigned int flags;
	u16 num_pads;
	u16 num_links;
	u16 num_backlinks;
	int internal_idx;
	struct media_pad *pads;
	struct list_head links;
	const struct media_entity_operations *ops;
	int use_count;
	union {
		struct {
			u32 major;
			u32 minor;
		} dev;
	} info;
};

struct media_pipeline {
	bool allocated;
	struct media_device *mdev;
	struct list_head pads;
	int start_count;
};

enum media_pad_signal_type {
	PAD_SIGNAL_DEFAULT = 0,
	PAD_SIGNAL_ANALOG = 1,
	PAD_SIGNAL_DV = 2,
	PAD_SIGNAL_AUDIO = 3,
};

struct media_pad {
	struct media_gobj graph_obj;
	struct media_entity *entity;
	u16 index;
	enum media_pad_signal_type sig_type;
	long unsigned int flags;
	struct media_pipeline *pipe;
};

struct media_interface {
	struct media_gobj graph_obj;
	struct list_head links;
	u32 type;
	u32 flags;
};

struct media_link {
	struct media_gobj graph_obj;
	struct list_head list;
	union {
		struct media_gobj *gobj0;
		struct media_pad *source;
		struct media_interface *intf;
	};
	union {
		struct media_gobj *gobj1;
		struct media_pad *sink;
		struct media_entity *entity;
	};
	struct media_link *reverse;
	long unsigned int flags;
	bool is_backlink;
};

struct media_entity_operations {
	int (*get_fwnode_pad)(struct media_entity *, struct fwnode_endpoint *);
	int (*link_setup)(struct media_entity *, const struct media_pad *, const struct media_pad *, u32);
	int (*link_validate)(struct media_link *);
	bool (*has_pad_interdep)(struct media_entity *, unsigned int, unsigned int);
};

struct media_intf_devnode {
	struct media_interface intf;
	u32 major;
	u32 minor;
};

enum vfl_devnode_type {
	VFL_TYPE_VIDEO = 0,
	VFL_TYPE_VBI = 1,
	VFL_TYPE_RADIO = 2,
	VFL_TYPE_SUBDEV = 3,
	VFL_TYPE_SDR = 4,
	VFL_TYPE_TOUCH = 5,
	VFL_TYPE_MAX = 6,
};

enum vfl_devnode_direction {
	VFL_DIR_RX = 0,
	VFL_DIR_TX = 1,
	VFL_DIR_M2M = 2,
};

struct v4l2_prio_state {
	atomic_t prios[4];
};

struct v4l2_file_operations {
	struct module *owner;
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*unlocked_ioctl)(struct file *, unsigned int, long unsigned int);
	long unsigned int (*get_unmapped_area)(struct file *, long unsigned int, long unsigned int, long unsigned int, long unsigned int);
	int (*mmap)(struct file *, struct vm_area_struct *);
	int (*open)(struct file *);
	int (*release)(struct file *);
};

struct v4l2_device;

struct v4l2_ctrl_handler;

struct vb2_queue;

struct v4l2_ioctl_ops;

struct video_device {
	struct media_entity entity;
	struct media_intf_devnode *intf_devnode;
	struct media_pipeline pipe;
	const struct v4l2_file_operations *fops;
	u32 device_caps;
	struct device dev;
	struct cdev *cdev;
	struct v4l2_device *v4l2_dev;
	struct device *dev_parent;
	struct v4l2_ctrl_handler *ctrl_handler;
	struct vb2_queue *queue;
	struct v4l2_prio_state *prio;
	char name[32];
	enum vfl_devnode_type vfl_type;
	enum vfl_devnode_direction vfl_dir;
	int minor;
	u16 num;
	long unsigned int flags;
	int index;
	spinlock_t fh_lock;
	struct list_head fh_list;
	int dev_debug;
	v4l2_std_id tvnorms;
	void (*release)(struct video_device *);
	const struct v4l2_ioctl_ops *ioctl_ops;
	long unsigned int valid_ioctls[6];
	struct mutex *lock;
	int: 32;
};

struct v4l2_subdev;

struct v4l2_device {
	struct device *dev;
	struct media_device *mdev;
	struct list_head subdevs;
	spinlock_t lock;
	char name[36];
	void (*notify)(struct v4l2_subdev *, unsigned int, void *);
	struct v4l2_ctrl_handler *ctrl_handler;
	struct v4l2_prio_state prio;
	struct kref ref;
	void (*release)(struct v4l2_device *);
};

struct vb2_ops;

struct vb2_mem_ops;

struct vb2_buf_ops;

struct vb2_buffer;

struct vb2_fileio_data;

struct vb2_threadio_data;

struct vb2_queue {
	unsigned int type;
	unsigned int io_modes;
	struct device *dev;
	long unsigned int dma_attrs;
	unsigned int bidirectional: 1;
	unsigned int fileio_read_once: 1;
	unsigned int fileio_write_immediately: 1;
	unsigned int allow_zero_bytesused: 1;
	unsigned int quirk_poll_must_check_waiting_for_buffers: 1;
	unsigned int supports_requests: 1;
	unsigned int requires_requests: 1;
	unsigned int uses_qbuf: 1;
	unsigned int uses_requests: 1;
	unsigned int allow_cache_hints: 1;
	unsigned int non_coherent_mem: 1;
	struct mutex *lock;
	void *owner;
	const struct vb2_ops *ops;
	const struct vb2_mem_ops *mem_ops;
	const struct vb2_buf_ops *buf_ops;
	void *drv_priv;
	u32 subsystem_flags;
	unsigned int buf_struct_size;
	u32 timestamp_flags;
	gfp_t gfp_flags;
	u32 min_buffers_needed;
	struct device *alloc_devs[8];
	struct mutex mmap_lock;
	unsigned int memory;
	enum dma_data_direction dma_dir;
	struct vb2_buffer *bufs[32];
	unsigned int num_buffers;
	struct list_head queued_list;
	unsigned int queued_count;
	atomic_t owned_by_drv_count;
	struct list_head done_list;
	spinlock_t done_lock;
	wait_queue_head_t done_wq;
	unsigned int streaming: 1;
	unsigned int start_streaming_called: 1;
	unsigned int error: 1;
	unsigned int waiting_for_buffers: 1;
	unsigned int waiting_in_dqbuf: 1;
	unsigned int is_multiplanar: 1;
	unsigned int is_output: 1;
	unsigned int copy_timestamp: 1;
	unsigned int last_buffer_dequeued: 1;
	struct vb2_fileio_data *fileio;
	struct vb2_threadio_data *threadio;
	char name[32];
};

enum v4l2_buf_type {
	V4L2_BUF_TYPE_VIDEO_CAPTURE = 1,
	V4L2_BUF_TYPE_VIDEO_OUTPUT = 2,
	V4L2_BUF_TYPE_VIDEO_OVERLAY = 3,
	V4L2_BUF_TYPE_VBI_CAPTURE = 4,
	V4L2_BUF_TYPE_VBI_OUTPUT = 5,
	V4L2_BUF_TYPE_SLICED_VBI_CAPTURE = 6,
	V4L2_BUF_TYPE_SLICED_VBI_OUTPUT = 7,
	V4L2_BUF_TYPE_VIDEO_OUTPUT_OVERLAY = 8,
	V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE = 9,
	V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE = 10,
	V4L2_BUF_TYPE_SDR_CAPTURE = 11,
	V4L2_BUF_TYPE_SDR_OUTPUT = 12,
	V4L2_BUF_TYPE_META_CAPTURE = 13,
	V4L2_BUF_TYPE_META_OUTPUT = 14,
	V4L2_BUF_TYPE_PRIVATE = 128,
};

struct v4l2_capability;

struct v4l2_fmtdesc;

struct v4l2_format;

struct v4l2_requestbuffers;

struct v4l2_buffer;

struct v4l2_exportbuffer;

struct v4l2_create_buffers;

struct v4l2_framebuffer;

struct v4l2_input;

struct v4l2_output;

struct v4l2_queryctrl;

struct v4l2_query_ext_ctrl;

struct v4l2_control;

struct v4l2_ext_controls;

struct v4l2_querymenu;

struct v4l2_audio;

struct v4l2_audioout;

struct v4l2_selection;

struct v4l2_jpegcompression;

struct v4l2_enc_idx;

struct v4l2_encoder_cmd;

struct v4l2_decoder_cmd;

struct v4l2_hw_freq_seek;

struct v4l2_frmsizeenum;

struct v4l2_frmivalenum;

struct v4l2_fh;

struct v4l2_ioctl_ops {
	int (*vidioc_querycap)(struct file *, void *, struct v4l2_capability *);
	int (*vidioc_enum_fmt_vid_cap)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_vid_overlay)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_vid_out)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_sdr_cap)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_sdr_out)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_meta_cap)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_enum_fmt_meta_out)(struct file *, void *, struct v4l2_fmtdesc *);
	int (*vidioc_g_fmt_vid_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_out_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_sliced_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_sliced_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_cap_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_vid_out_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_sdr_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_sdr_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_meta_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_g_fmt_meta_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_out_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_sliced_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_sliced_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_cap_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_vid_out_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_sdr_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_sdr_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_meta_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_s_fmt_meta_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_out_overlay)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_sliced_vbi_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_sliced_vbi_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_cap_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_vid_out_mplane)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_sdr_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_sdr_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_meta_cap)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_try_fmt_meta_out)(struct file *, void *, struct v4l2_format *);
	int (*vidioc_reqbufs)(struct file *, void *, struct v4l2_requestbuffers *);
	int (*vidioc_querybuf)(struct file *, void *, struct v4l2_buffer *);
	int (*vidioc_qbuf)(struct file *, void *, struct v4l2_buffer *);
	int (*vidioc_expbuf)(struct file *, void *, struct v4l2_exportbuffer *);
	int (*vidioc_dqbuf)(struct file *, void *, struct v4l2_buffer *);
	int (*vidioc_create_bufs)(struct file *, void *, struct v4l2_create_buffers *);
	int (*vidioc_prepare_buf)(struct file *, void *, struct v4l2_buffer *);
	int (*vidioc_overlay)(struct file *, void *, unsigned int);
	int (*vidioc_g_fbuf)(struct file *, void *, struct v4l2_framebuffer *);
	int (*vidioc_s_fbuf)(struct file *, void *, const struct v4l2_framebuffer *);
	int (*vidioc_streamon)(struct file *, void *, enum v4l2_buf_type);
	int (*vidioc_streamoff)(struct file *, void *, enum v4l2_buf_type);
	int (*vidioc_g_std)(struct file *, void *, v4l2_std_id *);
	int (*vidioc_s_std)(struct file *, void *, v4l2_std_id);
	int (*vidioc_querystd)(struct file *, void *, v4l2_std_id *);
	int (*vidioc_enum_input)(struct file *, void *, struct v4l2_input *);
	int (*vidioc_g_input)(struct file *, void *, unsigned int *);
	int (*vidioc_s_input)(struct file *, void *, unsigned int);
	int (*vidioc_enum_output)(struct file *, void *, struct v4l2_output *);
	int (*vidioc_g_output)(struct file *, void *, unsigned int *);
	int (*vidioc_s_output)(struct file *, void *, unsigned int);
	int (*vidioc_queryctrl)(struct file *, void *, struct v4l2_queryctrl *);
	int (*vidioc_query_ext_ctrl)(struct file *, void *, struct v4l2_query_ext_ctrl *);
	int (*vidioc_g_ctrl)(struct file *, void *, struct v4l2_control *);
	int (*vidioc_s_ctrl)(struct file *, void *, struct v4l2_control *);
	int (*vidioc_g_ext_ctrls)(struct file *, void *, struct v4l2_ext_controls *);
	int (*vidioc_s_ext_ctrls)(struct file *, void *, struct v4l2_ext_controls *);
	int (*vidioc_try_ext_ctrls)(struct file *, void *, struct v4l2_ext_controls *);
	int (*vidioc_querymenu)(struct file *, void *, struct v4l2_querymenu *);
	int (*vidioc_enumaudio)(struct file *, void *, struct v4l2_audio *);
	int (*vidioc_g_audio)(struct file *, void *, struct v4l2_audio *);
	int (*vidioc_s_audio)(struct file *, void *, const struct v4l2_audio *);
	int (*vidioc_enumaudout)(struct file *, void *, struct v4l2_audioout *);
	int (*vidioc_g_audout)(struct file *, void *, struct v4l2_audioout *);
	int (*vidioc_s_audout)(struct file *, void *, const struct v4l2_audioout *);
	int (*vidioc_g_modulator)(struct file *, void *, struct v4l2_modulator *);
	int (*vidioc_s_modulator)(struct file *, void *, const struct v4l2_modulator *);
	int (*vidioc_g_pixelaspect)(struct file *, void *, int, struct v4l2_fract *);
	int (*vidioc_g_selection)(struct file *, void *, struct v4l2_selection *);
	int (*vidioc_s_selection)(struct file *, void *, struct v4l2_selection *);
	int (*vidioc_g_jpegcomp)(struct file *, void *, struct v4l2_jpegcompression *);
	int (*vidioc_s_jpegcomp)(struct file *, void *, const struct v4l2_jpegcompression *);
	int (*vidioc_g_enc_index)(struct file *, void *, struct v4l2_enc_idx *);
	int (*vidioc_encoder_cmd)(struct file *, void *, struct v4l2_encoder_cmd *);
	int (*vidioc_try_encoder_cmd)(struct file *, void *, struct v4l2_encoder_cmd *);
	int (*vidioc_decoder_cmd)(struct file *, void *, struct v4l2_decoder_cmd *);
	int (*vidioc_try_decoder_cmd)(struct file *, void *, struct v4l2_decoder_cmd *);
	int (*vidioc_g_parm)(struct file *, void *, struct v4l2_streamparm *);
	int (*vidioc_s_parm)(struct file *, void *, struct v4l2_streamparm *);
	int (*vidioc_g_tuner)(struct file *, void *, struct v4l2_tuner *);
	int (*vidioc_s_tuner)(struct file *, void *, const struct v4l2_tuner *);
	int (*vidioc_g_frequency)(struct file *, void *, struct v4l2_frequency *);
	int (*vidioc_s_frequency)(struct file *, void *, const struct v4l2_frequency *);
	int (*vidioc_enum_freq_bands)(struct file *, void *, struct v4l2_frequency_band *);
	int (*vidioc_g_sliced_vbi_cap)(struct file *, void *, struct v4l2_sliced_vbi_cap *);
	int (*vidioc_log_status)(struct file *, void *);
	int (*vidioc_s_hw_freq_seek)(struct file *, void *, const struct v4l2_hw_freq_seek *);
	int (*vidioc_g_chip_ident)(struct file *, void *, struct v4l2_dbg_chip_ident *);
	int (*vidioc_enum_framesizes)(struct file *, void *, struct v4l2_frmsizeenum *);
	int (*vidioc_enum_frameintervals)(struct file *, void *, struct v4l2_frmivalenum *);
	int (*vidioc_s_dv_timings)(struct file *, void *, struct v4l2_dv_timings *);
	int (*vidioc_g_dv_timings)(struct file *, void *, struct v4l2_dv_timings *);
	int (*vidioc_query_dv_timings)(struct file *, void *, struct v4l2_dv_timings *);
	int (*vidioc_enum_dv_timings)(struct file *, void *, struct v4l2_enum_dv_timings *);
	int (*vidioc_dv_timings_cap)(struct file *, void *, struct v4l2_dv_timings_cap *);
	int (*vidioc_g_edid)(struct file *, void *, struct v4l2_edid *);
	int (*vidioc_s_edid)(struct file *, void *, struct v4l2_edid *);
	int (*vidioc_subscribe_event)(struct v4l2_fh *, const struct v4l2_event_subscription *);
	int (*vidioc_unsubscribe_event)(struct v4l2_fh *, const struct v4l2_event_subscription *);
	long int (*vidioc_default)(struct file *, void *, bool, unsigned int, void *);
};

struct v4l2_m2m_ctx;

struct v4l2_fh {
	struct list_head list;
	struct video_device *vdev;
	struct v4l2_ctrl_handler *ctrl_handler;
	enum v4l2_priority prio;
	wait_queue_head_t wait;
	struct mutex subscribe_lock;
	struct list_head subscribed;
	struct list_head available;
	unsigned int navailable;
	u32 sequence;
	struct v4l2_m2m_ctx *m2m_ctx;
};

struct media_file_operations {
	struct module *owner;
	ssize_t (*read)(struct file *, char *, size_t, loff_t *);
	ssize_t (*write)(struct file *, const char *, size_t, loff_t *);
	__poll_t (*poll)(struct file *, struct poll_table_struct *);
	long int (*ioctl)(struct file *, unsigned int, long unsigned int);
	long int (*compat_ioctl)(struct file *, unsigned int, long unsigned int);
	int (*open)(struct file *);
	int (*release)(struct file *);
};

struct media_devnode {
	struct media_device *media_dev;
	const struct media_file_operations *fops;
	struct device dev;
	struct cdev cdev;
	struct device *parent;
	int minor;
	long unsigned int flags;
	void (*release)(struct media_devnode *);
	int: 32;
};

struct media_request;

struct media_device_ops {
	int (*link_notify)(struct media_link *, u32, unsigned int);
	struct media_request * (*req_alloc)(struct media_device *);
	void (*req_free)(struct media_request *);
	int (*req_validate)(struct media_request *);
	void (*req_queue)(struct media_request *);
};

enum media_request_state {
	MEDIA_REQUEST_STATE_IDLE = 0,
	MEDIA_REQUEST_STATE_VALIDATING = 1,
	MEDIA_REQUEST_STATE_QUEUED = 2,
	MEDIA_REQUEST_STATE_COMPLETE = 3,
	MEDIA_REQUEST_STATE_CLEANING = 4,
	MEDIA_REQUEST_STATE_UPDATING = 5,
	NR_OF_MEDIA_REQUEST_STATE = 6,
};

struct media_request {
	struct media_device *mdev;
	struct kref kref;
	char debug_str[27];
	enum media_request_state state;
	unsigned int updating_count;
	unsigned int access_count;
	struct list_head objects;
	unsigned int num_incomplete_objects;
	wait_queue_head_t poll_wait;
	spinlock_t lock;
};

struct v4l2_mbus_framefmt {
	__u32 width;
	__u32 height;
	__u32 code;
	__u32 field;
	__u32 colorspace;
	union {
		__u16 ycbcr_enc;
		__u16 hsv_enc;
	};
	__u16 quantization;
	__u16 xfer_func;
	__u16 flags;
	__u16 reserved[10];
};

struct v4l2_subdev_format {
	__u32 which;
	__u32 pad;
	struct v4l2_mbus_framefmt format;
	__u32 reserved[8];
};

struct v4l2_subdev_mbus_code_enum {
	__u32 pad;
	__u32 index;
	__u32 code;
	__u32 which;
	__u32 flags;
	__u32 reserved[7];
};

struct v4l2_subdev_frame_size_enum {
	__u32 index;
	__u32 pad;
	__u32 code;
	__u32 min_width;
	__u32 max_width;
	__u32 min_height;
	__u32 max_height;
	__u32 which;
	__u32 reserved[8];
};

struct v4l2_subdev_frame_interval {
	__u32 pad;
	struct v4l2_fract interval;
	__u32 reserved[9];
};

struct v4l2_subdev_frame_interval_enum {
	__u32 index;
	__u32 pad;
	__u32 code;
	__u32 width;
	__u32 height;
	struct v4l2_fract interval;
	__u32 which;
	__u32 reserved[8];
};

struct v4l2_subdev_selection {
	__u32 which;
	__u32 pad;
	__u32 target;
	__u32 flags;
	struct v4l2_rect r;
	__u32 reserved[8];
};

enum v4l2_async_match_type {
	V4L2_ASYNC_MATCH_I2C = 0,
	V4L2_ASYNC_MATCH_FWNODE = 1,
};

struct v4l2_async_subdev {
	enum v4l2_async_match_type match_type;
	union {
		struct fwnode_handle *fwnode;
		struct {
			int adapter_id;
			short unsigned int address;
		} i2c;
	} match;
	struct list_head list;
	struct list_head asd_list;
};

struct v4l2_async_notifier;

struct v4l2_async_notifier_operations {
	int (*bound)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *);
	int (*complete)(struct v4l2_async_notifier *);
	void (*unbind)(struct v4l2_async_notifier *, struct v4l2_subdev *, struct v4l2_async_subdev *);
	void (*destroy)(struct v4l2_async_subdev *);
};

struct v4l2_async_notifier {
	const struct v4l2_async_notifier_operations *ops;
	struct v4l2_device *v4l2_dev;
	struct v4l2_subdev *sd;
	struct v4l2_async_notifier *parent;
	struct list_head asd_list;
	struct list_head waiting;
	struct list_head done;
	struct list_head list;
};

struct v4l2_subdev_ops;

struct v4l2_subdev_internal_ops;

struct v4l2_subdev_platform_data;

struct v4l2_subdev_state;

struct v4l2_subdev {
	struct media_entity entity;
	struct list_head list;
	struct module *owner;
	bool owner_v4l2_dev;
	u32 flags;
	struct v4l2_device *v4l2_dev;
	const struct v4l2_subdev_ops *ops;
	const struct v4l2_subdev_internal_ops *internal_ops;
	struct v4l2_ctrl_handler *ctrl_handler;
	char name[32];
	u32 grp_id;
	void *dev_priv;
	void *host_priv;
	struct video_device *devnode;
	struct device *dev;
	struct fwnode_handle *fwnode;
	struct list_head async_list;
	struct v4l2_async_subdev *asd;
	struct v4l2_async_notifier *notifier;
	struct v4l2_async_notifier *subdev_notifier;
	struct v4l2_subdev_platform_data *pdata;
	struct mutex *state_lock;
	struct v4l2_subdev_state *active_state;
};

struct v4l2_priv_tun_config {
	int tuner;
	void *priv;
};

struct v4l2_mbus_config_mipi_csi2 {
	unsigned int flags;
	unsigned char data_lanes[8];
	unsigned char clock_lane;
	unsigned char num_data_lanes;
	bool lane_polarities[9];
};

struct v4l2_mbus_config_parallel {
	unsigned int flags;
	unsigned char bus_width;
	unsigned char data_shift;
};

struct v4l2_mbus_config_mipi_csi1 {
	unsigned char clock_inv: 1;
	unsigned char strobe: 1;
	bool lane_polarity[2];
	unsigned char data_lane;
	unsigned char clock_lane;
};

enum v4l2_mbus_type {
	V4L2_MBUS_UNKNOWN = 0,
	V4L2_MBUS_PARALLEL = 1,
	V4L2_MBUS_BT656 = 2,
	V4L2_MBUS_CSI1 = 3,
	V4L2_MBUS_CCP2 = 4,
	V4L2_MBUS_CSI2_DPHY = 5,
	V4L2_MBUS_CSI2_CPHY = 6,
	V4L2_MBUS_DPI = 7,
	V4L2_MBUS_INVALID = 8,
};

struct v4l2_mbus_config {
	enum v4l2_mbus_type type;
	union {
		struct v4l2_mbus_config_parallel parallel;
		struct v4l2_mbus_config_mipi_csi1 mipi_csi1;
		struct v4l2_mbus_config_mipi_csi2 mipi_csi2;
	} bus;
};

struct v4l2_decode_vbi_line {
	u32 is_second_field;
	u8 *p;
	u32 line;
	u32 type;
};

struct v4l2_subdev_io_pin_config {
	u32 flags;
	u8 pin;
	u8 function;
	u8 value;
	u8 strength;
};

struct v4l2_subdev_core_ops {
	int (*g_chip_ident)(struct v4l2_subdev *, struct v4l2_dbg_chip_ident *);
	int (*log_status)(struct v4l2_subdev *);
	int (*s_io_pin_config)(struct v4l2_subdev *, size_t, struct v4l2_subdev_io_pin_config *);
	int (*init)(struct v4l2_subdev *, u32);
	int (*load_fw)(struct v4l2_subdev *);
	int (*reset)(struct v4l2_subdev *, u32);
	int (*s_gpio)(struct v4l2_subdev *, u32);
	long int (*command)(struct v4l2_subdev *, unsigned int, void *);
	long int (*ioctl)(struct v4l2_subdev *, unsigned int, void *);
	int (*s_power)(struct v4l2_subdev *, int);
	int (*interrupt_service_routine)(struct v4l2_subdev *, u32, bool *);
	int (*subscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *);
	int (*unsubscribe_event)(struct v4l2_subdev *, struct v4l2_fh *, struct v4l2_event_subscription *);
};

struct tuner_setup;

struct v4l2_subdev_tuner_ops {
	int (*standby)(struct v4l2_subdev *);
	int (*s_radio)(struct v4l2_subdev *);
	int (*s_frequency)(struct v4l2_subdev *, const struct v4l2_frequency *);
	int (*g_frequency)(struct v4l2_subdev *, struct v4l2_frequency *);
	int (*enum_freq_bands)(struct v4l2_subdev *, struct v4l2_frequency_band *);
	int (*g_tuner)(struct v4l2_subdev *, struct v4l2_tuner *);
	int (*s_tuner)(struct v4l2_subdev *, const struct v4l2_tuner *);
	int (*g_modulator)(struct v4l2_subdev *, struct v4l2_modulator *);
	int (*s_modulator)(struct v4l2_subdev *, const struct v4l2_modulator *);
	int (*s_type_addr)(struct v4l2_subdev *, struct tuner_setup *);
	int (*s_config)(struct v4l2_subdev *, const struct v4l2_priv_tun_config *);
};

struct v4l2_subdev_audio_ops {
	int (*s_clock_freq)(struct v4l2_subdev *, u32);
	int (*s_i2s_clock_freq)(struct v4l2_subdev *, u32);
	int (*s_routing)(struct v4l2_subdev *, u32, u32, u32);
	int (*s_stream)(struct v4l2_subdev *, int);
};

struct v4l2_mbus_frame_desc_entry_csi2 {
	u8 vc;
	u8 dt;
};

enum v4l2_mbus_frame_desc_flags {
	V4L2_MBUS_FRAME_DESC_FL_LEN_MAX = 1,
	V4L2_MBUS_FRAME_DESC_FL_BLOB = 2,
};

struct v4l2_mbus_frame_desc_entry {
	enum v4l2_mbus_frame_desc_flags flags;
	u32 pixelcode;
	u32 length;
	union {
		struct v4l2_mbus_frame_desc_entry_csi2 csi2;
	} bus;
};

enum v4l2_mbus_frame_desc_type {
	V4L2_MBUS_FRAME_DESC_TYPE_UNDEFINED = 0,
	V4L2_MBUS_FRAME_DESC_TYPE_PARALLEL = 1,
	V4L2_MBUS_FRAME_DESC_TYPE_CSI2 = 2,
};

struct v4l2_mbus_frame_desc {
	enum v4l2_mbus_frame_desc_type type;
	struct v4l2_mbus_frame_desc_entry entry[8];
	short unsigned int num_entries;
};

struct v4l2_subdev_video_ops {
	int (*s_routing)(struct v4l2_subdev *, u32, u32, u32);
	int (*s_crystal_freq)(struct v4l2_subdev *, u32, u32);
	int (*g_std)(struct v4l2_subdev *, v4l2_std_id *);
	int (*s_std)(struct v4l2_subdev *, v4l2_std_id);
	int (*s_std_output)(struct v4l2_subdev *, v4l2_std_id);
	int (*g_std_output)(struct v4l2_subdev *, v4l2_std_id *);
	int (*querystd)(struct v4l2_subdev *, v4l2_std_id *);
	int (*g_tvnorms)(struct v4l2_subdev *, v4l2_std_id *);
	int (*g_tvnorms_output)(struct v4l2_subdev *, v4l2_std_id *);
	int (*g_input_status)(struct v4l2_subdev *, u32 *);
	int (*s_stream)(struct v4l2_subdev *, int);
	int (*g_pixelaspect)(struct v4l2_subdev *, struct v4l2_fract *);
	int (*g_parm)(struct v4l2_subdev *, struct v4l2_streamparm *);
	int (*s_parm)(struct v4l2_subdev *, struct v4l2_streamparm *);
	int (*g_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *);
	int (*s_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_frame_interval *);
	int (*s_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *);
	int (*g_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *);
	int (*query_dv_timings)(struct v4l2_subdev *, struct v4l2_dv_timings *);
	int (*s_rx_buffer)(struct v4l2_subdev *, void *, unsigned int *);
	int (*pre_streamon)(struct v4l2_subdev *, u32);
	int (*post_streamoff)(struct v4l2_subdev *);
};

struct v4l2_subdev_vbi_ops {
	int (*decode_vbi_line)(struct v4l2_subdev *, struct v4l2_decode_vbi_line *);
	int (*s_vbi_data)(struct v4l2_subdev *, const struct v4l2_sliced_vbi_data *);
	int (*g_vbi_data)(struct v4l2_subdev *, struct v4l2_sliced_vbi_data *);
	int (*g_sliced_vbi_cap)(struct v4l2_subdev *, struct v4l2_sliced_vbi_cap *);
	int (*s_raw_fmt)(struct v4l2_subdev *, struct v4l2_vbi_format *);
	int (*g_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *);
	int (*s_sliced_fmt)(struct v4l2_subdev *, struct v4l2_sliced_vbi_format *);
};

struct v4l2_subdev_sensor_ops {
	int (*g_skip_top_lines)(struct v4l2_subdev *, u32 *);
	int (*g_skip_frames)(struct v4l2_subdev *, u32 *);
};

enum v4l2_subdev_ir_mode {
	V4L2_SUBDEV_IR_MODE_PULSE_WIDTH = 0,
};

struct v4l2_subdev_ir_parameters {
	unsigned int bytes_per_data_element;
	enum v4l2_subdev_ir_mode mode;
	bool enable;
	bool interrupt_enable;
	bool shutdown;
	bool modulation;
	u32 max_pulse_width;
	unsigned int carrier_freq;
	unsigned int duty_cycle;
	bool invert_level;
	bool invert_carrier_sense;
	u32 noise_filter_min_width;
	unsigned int carrier_range_lower;
	unsigned int carrier_range_upper;
	u32 resolution;
};

struct v4l2_subdev_ir_ops {
	int (*rx_read)(struct v4l2_subdev *, u8 *, size_t, ssize_t *);
	int (*rx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *);
	int (*rx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *);
	int (*tx_write)(struct v4l2_subdev *, u8 *, size_t, ssize_t *);
	int (*tx_g_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *);
	int (*tx_s_parameters)(struct v4l2_subdev *, struct v4l2_subdev_ir_parameters *);
};

struct v4l2_subdev_pad_config {
	struct v4l2_mbus_framefmt try_fmt;
	struct v4l2_rect try_crop;
	struct v4l2_rect try_compose;
};

struct v4l2_subdev_state {
	struct mutex _lock;
	struct mutex *lock;
	struct v4l2_subdev_pad_config *pads;
};

struct v4l2_subdev_pad_ops {
	int (*init_cfg)(struct v4l2_subdev *, struct v4l2_subdev_state *);
	int (*enum_mbus_code)(struct v4l2_subdev *, struct v4l2_subdev_state *, struct v4l2_subdev_mbus_code_enum *);
	int (*enum_frame_size)(struct v4l2_subdev *, struct v4l2_subdev_state *, struct v4l2_subdev_frame_size_enum *);
	int (*enum_frame_interval)(struct v4l2_subdev *, struct v4l2_subdev_state *, struct v4l2_subdev_frame_interval_enum *);
	int (*get_fmt)(struct v4l2_subdev *, struct v4l2_subdev_state *, struct v4l2_subdev_format *);
	int (*set_fmt)(struct v4l2_subdev *, struct v4l2_subdev_state *, struct v4l2_subdev_format *);
	int (*get_selection)(struct v4l2_subdev *, struct v4l2_subdev_state *, struct v4l2_subdev_selection *);
	int (*set_selection)(struct v4l2_subdev *, struct v4l2_subdev_state *, struct v4l2_subdev_selection *);
	int (*get_edid)(struct v4l2_subdev *, struct v4l2_edid *);
	int (*set_edid)(struct v4l2_subdev *, struct v4l2_edid *);
	int (*dv_timings_cap)(struct v4l2_subdev *, struct v4l2_dv_timings_cap *);
	int (*enum_dv_timings)(struct v4l2_subdev *, struct v4l2_enum_dv_timings *);
	int (*link_validate)(struct v4l2_subdev *, struct media_link *, struct v4l2_subdev_format *, struct v4l2_subdev_format *);
	int (*get_frame_desc)(struct v4l2_subdev *, unsigned int, struct v4l2_mbus_frame_desc *);
	int (*set_frame_desc)(struct v4l2_subdev *, unsigned int, struct v4l2_mbus_frame_desc *);
	int (*get_mbus_config)(struct v4l2_subdev *, unsigned int, struct v4l2_mbus_config *);
};

struct v4l2_subdev_ops {
	const struct v4l2_subdev_core_ops *core;
	const struct v4l2_subdev_tuner_ops *tuner;
	const struct v4l2_subdev_audio_ops *audio;
	const struct v4l2_subdev_video_ops *video;
	const struct v4l2_subdev_vbi_ops *vbi;
	const struct v4l2_subdev_ir_ops *ir;
	const struct v4l2_subdev_sensor_ops *sensor;
	const struct v4l2_subdev_pad_ops *pad;
};

struct v4l2_subdev_fh;

struct v4l2_subdev_internal_ops {
	int (*registered)(struct v4l2_subdev *);
	void (*unregistered)(struct v4l2_subdev *);
	int (*open)(struct v4l2_subdev *, struct v4l2_subdev_fh *);
	int (*close)(struct v4l2_subdev *, struct v4l2_subdev_fh *);
	void (*release)(struct v4l2_subdev *);
};

struct v4l2_subdev_fh {
	struct v4l2_fh vfh;
	struct module *owner;
	struct v4l2_subdev_state *state;
};

struct v4l2_subdev_platform_data {
	struct regulator_bulk_data *regulators;
	int num_regulators;
	void *host_priv;
};

struct media_request_object;

struct media_request_object_ops {
	int (*prepare)(struct media_request_object *);
	void (*unprepare)(struct media_request_object *);
	void (*queue)(struct media_request_object *);
	void (*unbind)(struct media_request_object *);
	void (*release)(struct media_request_object *);
};

struct media_request_object {
	const struct media_request_object_ops *ops;
	void *priv;
	struct media_request *req;
	struct list_head list;
	struct kref kref;
	bool completed;
};

struct vb2_mem_ops {
	void * (*alloc)(struct vb2_buffer *, struct device *, long unsigned int);
	void (*put)(void *);
	struct dma_buf * (*get_dmabuf)(struct vb2_buffer *, void *, long unsigned int);
	void * (*get_userptr)(struct vb2_buffer *, struct device *, long unsigned int, long unsigned int);
	void (*put_userptr)(void *);
	void (*prepare)(void *);
	void (*finish)(void *);
	void * (*attach_dmabuf)(struct vb2_buffer *, struct device *, struct dma_buf *, long unsigned int);
	void (*detach_dmabuf)(void *);
	int (*map_dmabuf)(void *);
	void (*unmap_dmabuf)(void *);
	void * (*vaddr)(struct vb2_buffer *, void *);
	void * (*cookie)(struct vb2_buffer *, void *);
	unsigned int (*num_users)(void *);
	int (*mmap)(void *, struct vm_area_struct *);
};

enum vb2_buffer_state {
	VB2_BUF_STATE_DEQUEUED = 0,
	VB2_BUF_STATE_IN_REQUEST = 1,
	VB2_BUF_STATE_PREPARING = 2,
	VB2_BUF_STATE_QUEUED = 3,
	VB2_BUF_STATE_ACTIVE = 4,
	VB2_BUF_STATE_DONE = 5,
	VB2_BUF_STATE_ERROR = 6,
};

struct vb2_plane {
	void *mem_priv;
	struct dma_buf *dbuf;
	unsigned int dbuf_mapped;
	unsigned int bytesused;
	unsigned int length;
	unsigned int min_length;
	union {
		unsigned int offset;
		long unsigned int userptr;
		int fd;
	} m;
	unsigned int data_offset;
};

struct vb2_buffer {
	struct vb2_queue *vb2_queue;
	unsigned int index;
	unsigned int type;
	unsigned int memory;
	unsigned int num_planes;
	int: 32;
	u64 timestamp;
	struct media_request *request;
	struct media_request_object req_obj;
	enum vb2_buffer_state state;
	unsigned int synced: 1;
	unsigned int prepared: 1;
	unsigned int copied_timestamp: 1;
	unsigned int skip_cache_sync_on_prepare: 1;
	unsigned int skip_cache_sync_on_finish: 1;
	struct vb2_plane planes[8];
	struct list_head queued_entry;
	struct list_head done_entry;
};

struct vb2_ops {
	int (*queue_setup)(struct vb2_queue *, unsigned int *, unsigned int *, unsigned int *, struct device **);
	void (*wait_prepare)(struct vb2_queue *);
	void (*wait_finish)(struct vb2_queue *);
	int (*buf_out_validate)(struct vb2_buffer *);
	int (*buf_init)(struct vb2_buffer *);
	int (*buf_prepare)(struct vb2_buffer *);
	void (*buf_finish)(struct vb2_buffer *);
	void (*buf_cleanup)(struct vb2_buffer *);
	int (*start_streaming)(struct vb2_queue *, unsigned int);
	void (*stop_streaming)(struct vb2_queue *);
	void (*buf_queue)(struct vb2_buffer *);
	void (*buf_request_complete)(struct vb2_buffer *);
};

struct vb2_buf_ops {
	int (*verify_planes_array)(struct vb2_buffer *, const void *);
	void (*init_buffer)(struct vb2_buffer *);
	void (*fill_user_buffer)(struct vb2_buffer *, void *);
	int (*fill_vb2_buffer)(struct vb2_buffer *, struct vb2_plane *);
	void (*copy_timestamp)(struct vb2_buffer *, const void *);
};

struct vb2_v4l2_buffer {
	struct vb2_buffer vb2_buf;
	__u32 flags;
	__u32 field;
	struct v4l2_timecode timecode;
	__u32 sequence;
	__s32 request_fd;
	bool is_held;
	struct vb2_plane planes[8];
	int: 32;
};

enum uvc_buffer_state {
	UVC_BUF_STATE_IDLE = 0,
	UVC_BUF_STATE_QUEUED = 1,
	UVC_BUF_STATE_ACTIVE = 2,
	UVC_BUF_STATE_DONE = 3,
	UVC_BUF_STATE_ERROR = 4,
};

struct uvc_buffer {
	struct vb2_v4l2_buffer buf;
	struct list_head queue;
	enum uvc_buffer_state state;
	void *mem;
	struct sg_table *sgt;
	struct scatterlist *sg;
	unsigned int offset;
	unsigned int length;
	unsigned int bytesused;
	int: 32;
};

struct uvc_video_queue {
	struct vb2_queue queue;
	unsigned int flags;
	__u32 sequence;
	unsigned int buf_used;
	bool use_sg;
	spinlock_t irqlock;
	struct list_head irqqueue;
};

struct uvc_video;

struct uvc_request {
	struct usb_request *req;
	u8 *req_buffer;
	struct uvc_video *video;
	struct sg_table sgt;
	u8 header[12];
	struct uvc_buffer *last_buf;
};

struct uvc_device;

struct uvc_video {
	struct uvc_device *uvc;
	struct usb_ep *ep;
	struct work_struct pump;
	struct workqueue_struct *async_wq;
	u8 bpp;
	u32 fcc;
	unsigned int width;
	unsigned int height;
	unsigned int imagesize;
	struct mutex mutex;
	unsigned int uvc_num_requests;
	unsigned int req_size;
	struct uvc_request *ureq;
	struct list_head req_free;
	spinlock_t req_lock;
	unsigned int req_int_count;
	void (*encode)(struct usb_request *, struct uvc_video *, struct uvc_buffer *);
	__u32 payload_size;
	__u32 max_payload_size;
	struct uvc_video_queue queue;
	unsigned int fid;
};

enum uvc_state {
	UVC_STATE_DISCONNECTED = 0,
	UVC_STATE_CONNECTED = 1,
	UVC_STATE_STREAMING = 2,
};

struct uvcg_streaming_header;

struct uvc_device {
	struct video_device vdev;
	struct v4l2_device v4l2_dev;
	enum uvc_state state;
	struct usb_function func;
	struct uvc_video video;
	bool func_connected;
	wait_queue_head_t func_connected_queue;
	struct uvcg_streaming_header *header;
	struct {
		const struct uvc_descriptor_header * const *fs_control;
		const struct uvc_descriptor_header * const *ss_control;
		const struct uvc_descriptor_header * const *fs_streaming;
		const struct uvc_descriptor_header * const *hs_streaming;
		const struct uvc_descriptor_header * const *ss_streaming;
	} desc;
	unsigned int control_intf;
	struct usb_ep *control_ep;
	struct usb_request *control_req;
	void *control_buf;
	unsigned int streaming_intf;
	unsigned int event_length;
	unsigned int event_setup_out: 1;
	int: 31;
	int: 32;
};

struct uvcg_streaming_header {
	struct config_item item;
	struct uvc_input_header_descriptor desc;
	unsigned int linked;
	struct list_head formats;
	unsigned int num_fmt;
};

struct f_uvc_opts {
	struct usb_function_instance func_inst;
	unsigned int streaming_interval;
	unsigned int streaming_maxpacket;
	unsigned int streaming_maxburst;
	unsigned int control_interface;
	unsigned int streaming_interface;
	char function_name[32];
	const struct uvc_descriptor_header * const *fs_control;
	const struct uvc_descriptor_header * const *ss_control;
	const struct uvc_descriptor_header * const *fs_streaming;
	const struct uvc_descriptor_header * const *hs_streaming;
	const struct uvc_descriptor_header * const *ss_streaming;
	struct uvc_camera_terminal_descriptor uvc_camera_terminal;
	struct uvc_processing_unit_descriptor uvc_processing;
	struct uvc_output_terminal_descriptor uvc_output_terminal;
	struct uvc_color_matching_descriptor uvc_color_matching;
	struct uvc_descriptor_header *uvc_fs_control_cls[5];
	struct uvc_descriptor_header *uvc_ss_control_cls[5];
	struct uvc_descriptor_header **uvc_fs_streaming_cls;
	struct uvc_descriptor_header **uvc_hs_streaming_cls;
	struct uvc_descriptor_header **uvc_ss_streaming_cls;
	struct mutex lock;
	int refcnt;
};

struct __kernel_v4l2_timeval {
	long long int tv_sec;
	long long int tv_usec;
};

struct v4l2_requestbuffers {
	__u32 count;
	__u32 type;
	__u32 memory;
	__u32 capabilities;
	__u8 flags;
	__u8 reserved[3];
};

struct v4l2_plane {
	__u32 bytesused;
	__u32 length;
	union {
		__u32 mem_offset;
		long unsigned int userptr;
		__s32 fd;
	} m;
	__u32 data_offset;
	__u32 reserved[11];
};

struct v4l2_buffer {
	__u32 index;
	__u32 type;
	__u32 bytesused;
	__u32 flags;
	__u32 field;
	int: 32;
	struct __kernel_v4l2_timeval timestamp;
	struct v4l2_timecode timecode;
	__u32 sequence;
	__u32 memory;
	union {
		__u32 offset;
		long unsigned int userptr;
		struct v4l2_plane *planes;
		__s32 fd;
	} m;
	__u32 length;
	__u32 reserved2;
	union {
		__s32 request_fd;
		__u32 reserved;
	};
};

enum vb2_io_modes {
	VB2_MMAP = 1,
	VB2_USERPTR = 2,
	VB2_READ = 4,
	VB2_WRITE = 8,
	VB2_DMABUF = 16,
};

struct v4l2_ctrl_h264_sps {
	__u8 profile_idc;
	__u8 constraint_set_flags;
	__u8 level_idc;
	__u8 seq_parameter_set_id;
	__u8 chroma_format_idc;
	__u8 bit_depth_luma_minus8;
	__u8 bit_depth_chroma_minus8;
	__u8 log2_max_frame_num_minus4;
	__u8 pic_order_cnt_type;
	__u8 log2_max_pic_order_cnt_lsb_minus4;
	__u8 max_num_ref_frames;
	__u8 num_ref_frames_in_pic_order_cnt_cycle;
	__s32 offset_for_ref_frame[255];
	__s32 offset_for_non_ref_pic;
	__s32 offset_for_top_to_bottom_field;
	__u16 pic_width_in_mbs_minus1;
	__u16 pic_height_in_map_units_minus1;
	__u32 flags;
};

struct v4l2_ctrl_h264_pps {
	__u8 pic_parameter_set_id;
	__u8 seq_parameter_set_id;
	__u8 num_slice_groups_minus1;
	__u8 num_ref_idx_l0_default_active_minus1;
	__u8 num_ref_idx_l1_default_active_minus1;
	__u8 weighted_bipred_idc;
	__s8 pic_init_qp_minus26;
	__s8 pic_init_qs_minus26;
	__s8 chroma_qp_index_offset;
	__s8 second_chroma_qp_index_offset;
	__u16 flags;
};

struct v4l2_ctrl_h264_scaling_matrix {
	__u8 scaling_list_4x4[96];
	__u8 scaling_list_8x8[384];
};

struct v4l2_h264_weight_factors {
	__s16 luma_weight[32];
	__s16 luma_offset[32];
	__s16 chroma_weight[64];
	__s16 chroma_offset[64];
};

struct v4l2_ctrl_h264_pred_weights {
	__u16 luma_log2_weight_denom;
	__u16 chroma_log2_weight_denom;
	struct v4l2_h264_weight_factors weight_factors[2];
};

struct v4l2_h264_reference {
	__u8 fields;
	__u8 index;
};

struct v4l2_ctrl_h264_slice_params {
	__u32 header_bit_size;
	__u32 first_mb_in_slice;
	__u8 slice_type;
	__u8 colour_plane_id;
	__u8 redundant_pic_cnt;
	__u8 cabac_init_idc;
	__s8 slice_qp_delta;
	__s8 slice_qs_delta;
	__u8 disable_deblocking_filter_idc;
	__s8 slice_alpha_c0_offset_div2;
	__s8 slice_beta_offset_div2;
	__u8 num_ref_idx_l0_active_minus1;
	__u8 num_ref_idx_l1_active_minus1;
	__u8 reserved;
	struct v4l2_h264_reference ref_pic_list0[32];
	struct v4l2_h264_reference ref_pic_list1[32];
	__u32 flags;
};

struct v4l2_h264_dpb_entry {
	__u64 reference_ts;
	__u32 pic_num;
	__u16 frame_num;
	__u8 fields;
	__u8 reserved[5];
	__s32 top_field_order_cnt;
	__s32 bottom_field_order_cnt;
	__u32 flags;
};

struct v4l2_ctrl_h264_decode_params {
	struct v4l2_h264_dpb_entry dpb[16];
	__u16 nal_ref_idc;
	__u16 frame_num;
	__s32 top_field_order_cnt;
	__s32 bottom_field_order_cnt;
	__u16 idr_pic_id;
	__u16 pic_order_cnt_lsb;
	__s32 delta_pic_order_cnt_bottom;
	__s32 delta_pic_order_cnt0;
	__s32 delta_pic_order_cnt1;
	__u32 dec_ref_pic_marking_bit_size;
	__u32 pic_order_cnt_bit_size;
	__u32 slice_group_change_cycle;
	__u32 reserved;
	__u32 flags;
};

struct v4l2_ctrl_fwht_params {
	__u64 backward_ref_ts;
	__u32 version;
	__u32 width;
	__u32 height;
	__u32 flags;
	__u32 colorspace;
	__u32 xfer_func;
	__u32 ycbcr_enc;
	__u32 quantization;
};

struct v4l2_vp8_segment {
	__s8 quant_update[4];
	__s8 lf_update[4];
	__u8 segment_probs[3];
	__u8 padding;
	__u32 flags;
};

struct v4l2_vp8_loop_filter {
	__s8 ref_frm_delta[4];
	__s8 mb_mode_delta[4];
	__u8 sharpness_level;
	__u8 level;
	__u16 padding;
	__u32 flags;
};

struct v4l2_vp8_quantization {
	__u8 y_ac_qi;
	__s8 y_dc_delta;
	__s8 y2_dc_delta;
	__s8 y2_ac_delta;
	__s8 uv_dc_delta;
	__s8 uv_ac_delta;
	__u16 padding;
};

struct v4l2_vp8_entropy {
	__u8 coeff_probs[1056];
	__u8 y_mode_probs[4];
	__u8 uv_mode_probs[3];
	__u8 mv_probs[38];
	__u8 padding[3];
};

struct v4l2_vp8_entropy_coder_state {
	__u8 range;
	__u8 value;
	__u8 bit_count;
	__u8 padding;
};

struct v4l2_ctrl_vp8_frame {
	struct v4l2_vp8_segment segment;
	struct v4l2_vp8_loop_filter lf;
	struct v4l2_vp8_quantization quant;
	struct v4l2_vp8_entropy entropy;
	struct v4l2_vp8_entropy_coder_state coder_state;
	__u16 width;
	__u16 height;
	__u8 horizontal_scale;
	__u8 vertical_scale;
	__u8 version;
	__u8 prob_skip_false;
	__u8 prob_intra;
	__u8 prob_last;
	__u8 prob_gf;
	__u8 num_dct_parts;
	__u32 first_part_size;
	__u32 first_part_header_bits;
	__u32 dct_part_sizes[8];
	__u64 last_frame_ts;
	__u64 golden_frame_ts;
	__u64 alt_frame_ts;
	__u64 flags;
};

struct v4l2_ctrl_mpeg2_sequence {
	__u16 horizontal_size;
	__u16 vertical_size;
	__u32 vbv_buffer_size;
	__u16 profile_and_level_indication;
	__u8 chroma_format;
	__u8 flags;
};

struct v4l2_ctrl_mpeg2_picture {
	__u64 backward_ref_ts;
	__u64 forward_ref_ts;
	__u32 flags;
	__u8 f_code[4];
	__u8 picture_coding_type;
	__u8 picture_structure;
	__u8 intra_dc_precision;
	__u8 reserved[5];
};

struct v4l2_ctrl_mpeg2_quantisation {
	__u8 intra_quantiser_matrix[64];
	__u8 non_intra_quantiser_matrix[64];
	__u8 chroma_intra_quantiser_matrix[64];
	__u8 chroma_non_intra_quantiser_matrix[64];
};

struct v4l2_ctrl_hevc_sps {
	__u8 video_parameter_set_id;
	__u8 seq_parameter_set_id;
	__u16 pic_width_in_luma_samples;
	__u16 pic_height_in_luma_samples;
	__u8 bit_depth_luma_minus8;
	__u8 bit_depth_chroma_minus8;
	__u8 log2_max_pic_order_cnt_lsb_minus4;
	__u8 sps_max_dec_pic_buffering_minus1;
	__u8 sps_max_num_reorder_pics;
	__u8 sps_max_latency_increase_plus1;
	__u8 log2_min_luma_coding_block_size_minus3;
	__u8 log2_diff_max_min_luma_coding_block_size;
	__u8 log2_min_luma_transform_block_size_minus2;
	__u8 log2_diff_max_min_luma_transform_block_size;
	__u8 max_transform_hierarchy_depth_inter;
	__u8 max_transform_hierarchy_depth_intra;
	__u8 pcm_sample_bit_depth_luma_minus1;
	__u8 pcm_sample_bit_depth_chroma_minus1;
	__u8 log2_min_pcm_luma_coding_block_size_minus3;
	__u8 log2_diff_max_min_pcm_luma_coding_block_size;
	__u8 num_short_term_ref_pic_sets;
	__u8 num_long_term_ref_pics_sps;
	__u8 chroma_format_idc;
	__u8 sps_max_sub_layers_minus1;
	__u8 reserved[6];
	__u64 flags;
};

struct v4l2_ctrl_hevc_pps {
	__u8 pic_parameter_set_id;
	__u8 num_extra_slice_header_bits;
	__u8 num_ref_idx_l0_default_active_minus1;
	__u8 num_ref_idx_l1_default_active_minus1;
	__s8 init_qp_minus26;
	__u8 diff_cu_qp_delta_depth;
	__s8 pps_cb_qp_offset;
	__s8 pps_cr_qp_offset;
	__u8 num_tile_columns_minus1;
	__u8 num_tile_rows_minus1;
	__u8 column_width_minus1[20];
	__u8 row_height_minus1[22];
	__s8 pps_beta_offset_div2;
	__s8 pps_tc_offset_div2;
	__u8 log2_parallel_merge_level_minus2;
	__u8 reserved;
	__u64 flags;
};

struct v4l2_hevc_dpb_entry {
	__u64 timestamp;
	__u8 flags;
	__u8 field_pic;
	__u16 reserved;
	__s32 pic_order_cnt_val;
};

struct v4l2_hevc_pred_weight_table {
	__s8 delta_luma_weight_l0[16];
	__s8 luma_offset_l0[16];
	__s8 delta_chroma_weight_l0[32];
	__s8 chroma_offset_l0[32];
	__s8 delta_luma_weight_l1[16];
	__s8 luma_offset_l1[16];
	__s8 delta_chroma_weight_l1[32];
	__s8 chroma_offset_l1[32];
	__u8 luma_log2_weight_denom;
	__s8 delta_chroma_log2_weight_denom;
};

struct v4l2_ctrl_hevc_slice_params {
	__u32 bit_size;
	__u32 data_byte_offset;
	__u32 num_entry_point_offsets;
	__u8 nal_unit_type;
	__u8 nuh_temporal_id_plus1;
	__u8 slice_type;
	__u8 colour_plane_id;
	__s32 slice_pic_order_cnt;
	__u8 num_ref_idx_l0_active_minus1;
	__u8 num_ref_idx_l1_active_minus1;
	__u8 collocated_ref_idx;
	__u8 five_minus_max_num_merge_cand;
	__s8 slice_qp_delta;
	__s8 slice_cb_qp_offset;
	__s8 slice_cr_qp_offset;
	__s8 slice_act_y_qp_offset;
	__s8 slice_act_cb_qp_offset;
	__s8 slice_act_cr_qp_offset;
	__s8 slice_beta_offset_div2;
	__s8 slice_tc_offset_div2;
	__u8 pic_struct;
	__u8 reserved0[3];
	__u32 slice_segment_addr;
	__u8 ref_idx_l0[16];
	__u8 ref_idx_l1[16];
	__u16 short_term_ref_pic_set_size;
	__u16 long_term_ref_pic_set_size;
	struct v4l2_hevc_pred_weight_table pred_weight_table;
	__u8 reserved1[2];
	__u64 flags;
};

struct v4l2_ctrl_hevc_decode_params {
	__s32 pic_order_cnt_val;
	__u16 short_term_ref_pic_set_size;
	__u16 long_term_ref_pic_set_size;
	__u8 num_active_dpb_entries;
	__u8 num_poc_st_curr_before;
	__u8 num_poc_st_curr_after;
	__u8 num_poc_lt_curr;
	__u8 poc_st_curr_before[16];
	__u8 poc_st_curr_after[16];
	__u8 poc_lt_curr[16];
	__u8 reserved[4];
	struct v4l2_hevc_dpb_entry dpb[16];
	__u64 flags;
};

struct v4l2_ctrl_hevc_scaling_matrix {
	__u8 scaling_list_4x4[96];
	__u8 scaling_list_8x8[384];
	__u8 scaling_list_16x16[384];
	__u8 scaling_list_32x32[128];
	__u8 scaling_list_dc_coef_16x16[6];
	__u8 scaling_list_dc_coef_32x32[2];
};

struct v4l2_vp9_loop_filter {
	__s8 ref_deltas[4];
	__s8 mode_deltas[2];
	__u8 level;
	__u8 sharpness;
	__u8 flags;
	__u8 reserved[7];
};

struct v4l2_vp9_quantization {
	__u8 base_q_idx;
	__s8 delta_q_y_dc;
	__s8 delta_q_uv_dc;
	__s8 delta_q_uv_ac;
	__u8 reserved[4];
};

struct v4l2_vp9_segmentation {
	__s16 feature_data[32];
	__u8 feature_enabled[8];
	__u8 tree_probs[7];
	__u8 pred_probs[3];
	__u8 flags;
	__u8 reserved[5];
};

struct v4l2_ctrl_vp9_frame {
	struct v4l2_vp9_loop_filter lf;
	struct v4l2_vp9_quantization quant;
	struct v4l2_vp9_segmentation seg;
	__u32 flags;
	__u16 compressed_header_size;
	__u16 uncompressed_header_size;
	__u16 frame_width_minus_1;
	__u16 frame_height_minus_1;
	__u16 render_width_minus_1;
	__u16 render_height_minus_1;
	__u64 last_frame_ts;
	__u64 golden_frame_ts;
	__u64 alt_frame_ts;
	__u8 ref_frame_sign_bias;
	__u8 reset_frame_context;
	__u8 frame_context_idx;
	__u8 profile;
	__u8 bit_depth;
	__u8 interpolation_filter;
	__u8 tile_cols_log2;
	__u8 tile_rows_log2;
	__u8 reference_mode;
	__u8 reserved[7];
};

struct v4l2_vp9_mv_probs {
	__u8 joint[3];
	__u8 sign[2];
	__u8 classes[20];
	__u8 class0_bit[2];
	__u8 bits[20];
	__u8 class0_fr[12];
	__u8 fr[6];
	__u8 class0_hp[2];
	__u8 hp[2];
};

struct v4l2_ctrl_vp9_compressed_hdr {
	__u8 tx_mode;
	__u8 tx8[2];
	__u8 tx16[4];
	__u8 tx32[6];
	__u8 coef[1728];
	__u8 skip[3];
	__u8 inter_mode[21];
	__u8 interp_filter[8];
	__u8 is_inter[4];
	__u8 comp_mode[5];
	__u8 single_ref[10];
	__u8 comp_ref[5];
	__u8 y_mode[36];
	__u8 uv_mode[90];
	__u8 partition[48];
	struct v4l2_vp9_mv_probs mv;
};

enum v4l2_colorspace {
	V4L2_COLORSPACE_DEFAULT = 0,
	V4L2_COLORSPACE_SMPTE170M = 1,
	V4L2_COLORSPACE_SMPTE240M = 2,
	V4L2_COLORSPACE_REC709 = 3,
	V4L2_COLORSPACE_BT878 = 4,
	V4L2_COLORSPACE_470_SYSTEM_M = 5,
	V4L2_COLORSPACE_470_SYSTEM_BG = 6,
	V4L2_COLORSPACE_JPEG = 7,
	V4L2_COLORSPACE_SRGB = 8,
	V4L2_COLORSPACE_OPRGB = 9,
	V4L2_COLORSPACE_BT2020 = 10,
	V4L2_COLORSPACE_RAW = 11,
	V4L2_COLORSPACE_DCI_P3 = 12,
	V4L2_COLORSPACE_LAST = 13,
};

struct v4l2_area {
	__u32 width;
	__u32 height;
};

struct v4l2_capability {
	__u8 driver[16];
	__u8 card[32];
	__u8 bus_info[32];
	__u32 version;
	__u32 capabilities;
	__u32 device_caps;
	__u32 reserved[3];
};

struct v4l2_pix_format {
	__u32 width;
	__u32 height;
	__u32 pixelformat;
	__u32 field;
	__u32 bytesperline;
	__u32 sizeimage;
	__u32 colorspace;
	__u32 priv;
	__u32 flags;
	union {
		__u32 ycbcr_enc;
		__u32 hsv_enc;
	};
	__u32 quantization;
	__u32 xfer_func;
};

struct v4l2_fmtdesc {
	__u32 index;
	__u32 type;
	__u32 flags;
	__u8 description[32];
	__u32 pixelformat;
	__u32 mbus_code;
	__u32 reserved[3];
};

enum v4l2_frmsizetypes {
	V4L2_FRMSIZE_TYPE_DISCRETE = 1,
	V4L2_FRMSIZE_TYPE_CONTINUOUS = 2,
	V4L2_FRMSIZE_TYPE_STEPWISE = 3,
};

struct v4l2_frmsize_discrete {
	__u32 width;
	__u32 height;
};

struct v4l2_frmsize_stepwise {
	__u32 min_width;
	__u32 max_width;
	__u32 step_width;
	__u32 min_height;
	__u32 max_height;
	__u32 step_height;
};

struct v4l2_frmsizeenum {
	__u32 index;
	__u32 pixel_format;
	__u32 type;
	union {
		struct v4l2_frmsize_discrete discrete;
		struct v4l2_frmsize_stepwise stepwise;
	};
	__u32 reserved[2];
};

enum v4l2_frmivaltypes {
	V4L2_FRMIVAL_TYPE_DISCRETE = 1,
	V4L2_FRMIVAL_TYPE_CONTINUOUS = 2,
	V4L2_FRMIVAL_TYPE_STEPWISE = 3,
};

struct v4l2_frmival_stepwise {
	struct v4l2_fract min;
	struct v4l2_fract max;
	struct v4l2_fract step;
};

struct v4l2_frmivalenum {
	__u32 index;
	__u32 pixel_format;
	__u32 width;
	__u32 height;
	__u32 type;
	union {
		struct v4l2_fract discrete;
		struct v4l2_frmival_stepwise stepwise;
	};
	__u32 reserved[2];
};

struct v4l2_jpegcompression {
	int quality;
	int APPn;
	int APP_len;
	char APP_data[60];
	int COM_len;
	char COM_data[60];
	__u32 jpeg_markers;
};

struct v4l2_exportbuffer {
	__u32 type;
	__u32 index;
	__u32 plane;
	__u32 flags;
	__s32 fd;
	__u32 reserved[11];
};

struct v4l2_framebuffer {
	__u32 capability;
	__u32 flags;
	void *base;
	struct {
		__u32 width;
		__u32 height;
		__u32 pixelformat;
		__u32 field;
		__u32 bytesperline;
		__u32 sizeimage;
		__u32 colorspace;
		__u32 priv;
	} fmt;
};

struct v4l2_clip {
	struct v4l2_rect c;
	struct v4l2_clip *next;
};

struct v4l2_window {
	struct v4l2_rect w;
	__u32 field;
	__u32 chromakey;
	struct v4l2_clip *clips;
	__u32 clipcount;
	void *bitmap;
	__u8 global_alpha;
};

struct v4l2_selection {
	__u32 type;
	__u32 target;
	__u32 flags;
	struct v4l2_rect r;
	__u32 reserved[9];
};

struct v4l2_input {
	__u32 index;
	__u8 name[32];
	__u32 type;
	__u32 audioset;
	__u32 tuner;
	v4l2_std_id std;
	__u32 status;
	__u32 capabilities;
	__u32 reserved[3];
	int: 32;
};

struct v4l2_output {
	__u32 index;
	__u8 name[32];
	__u32 type;
	__u32 audioset;
	__u32 modulator;
	v4l2_std_id std;
	__u32 capabilities;
	__u32 reserved[3];
};

struct v4l2_control {
	__u32 id;
	__s32 value;
};

struct v4l2_ext_control {
	__u32 id;
	__u32 size;
	__u32 reserved2[1];
	union {
		__s32 value;
		__s64 value64;
		char *string;
		__u8 *p_u8;
		__u16 *p_u16;
		__u32 *p_u32;
		struct v4l2_area *p_area;
		struct v4l2_ctrl_h264_sps *p_h264_sps;
		struct v4l2_ctrl_h264_pps *p_h264_pps;
		struct v4l2_ctrl_h264_scaling_matrix *p_h264_scaling_matrix;
		struct v4l2_ctrl_h264_pred_weights *p_h264_pred_weights;
		struct v4l2_ctrl_h264_slice_params *p_h264_slice_params;
		struct v4l2_ctrl_h264_decode_params *p_h264_decode_params;
		struct v4l2_ctrl_fwht_params *p_fwht_params;
		struct v4l2_ctrl_vp8_frame *p_vp8_frame;
		struct v4l2_ctrl_mpeg2_sequence *p_mpeg2_sequence;
		struct v4l2_ctrl_mpeg2_picture *p_mpeg2_picture;
		struct v4l2_ctrl_mpeg2_quantisation *p_mpeg2_quantisation;
		struct v4l2_ctrl_vp9_compressed_hdr *p_vp9_compressed_hdr_probs;
		struct v4l2_ctrl_vp9_frame *p_vp9_frame;
		struct v4l2_ctrl_hevc_sps *p_hevc_sps;
		struct v4l2_ctrl_hevc_pps *p_hevc_pps;
		struct v4l2_ctrl_hevc_slice_params *p_hevc_slice_params;
		struct v4l2_ctrl_hevc_scaling_matrix *p_hevc_scaling_matrix;
		struct v4l2_ctrl_hevc_decode_params *p_hevc_decode_params;
		void *ptr;
	};
};

struct v4l2_ext_controls {
	union {
		__u32 which;
	};
	__u32 count;
	__u32 error_idx;
	__s32 request_fd;
	__u32 reserved[1];
	struct v4l2_ext_control *controls;
};

struct v4l2_queryctrl {
	__u32 id;
	__u32 type;
	__u8 name[32];
	__s32 minimum;
	__s32 maximum;
	__s32 step;
	__s32 default_value;
	__u32 flags;
	__u32 reserved[2];
};

struct v4l2_query_ext_ctrl {
	__u32 id;
	__u32 type;
	char name[32];
	__s64 minimum;
	__s64 maximum;
	__u64 step;
	__s64 default_value;
	__u32 flags;
	__u32 elem_size;
	__u32 elems;
	__u32 nr_of_dims;
	__u32 dims[4];
	__u32 reserved[32];
};

struct v4l2_querymenu {
	__u32 id;
	__u32 index;
	union {
		__u8 name[32];
		__s64 value;
	};
	__u32 reserved;
};

struct v4l2_hw_freq_seek {
	__u32 tuner;
	__u32 type;
	__u32 seek_upward;
	__u32 wrap_around;
	__u32 spacing;
	__u32 rangelow;
	__u32 rangehigh;
	__u32 reserved[5];
};

struct v4l2_audio {
	__u32 index;
	__u8 name[32];
	__u32 capability;
	__u32 mode;
	__u32 reserved[2];
};

struct v4l2_audioout {
	__u32 index;
	__u8 name[32];
	__u32 capability;
	__u32 mode;
	__u32 reserved[2];
};

struct v4l2_enc_idx_entry {
	__u64 offset;
	__u64 pts;
	__u32 length;
	__u32 flags;
	__u32 reserved[2];
};

struct v4l2_enc_idx {
	__u32 entries;
	__u32 entries_cap;
	__u32 reserved[4];
	struct v4l2_enc_idx_entry entry[64];
};

struct v4l2_encoder_cmd {
	__u32 cmd;
	__u32 flags;
	union {
		struct {
			__u32 data[8];
		} raw;
	};
};

struct v4l2_decoder_cmd {
	__u32 cmd;
	__u32 flags;
	union {
		struct {
			__u64 pts;
		} stop;
		struct {
			__s32 speed;
			__u32 format;
		} start;
		struct {
			__u32 data[16];
		} raw;
	};
};

struct v4l2_plane_pix_format {
	__u32 sizeimage;
	__u32 bytesperline;
	__u16 reserved[6];
};

struct v4l2_pix_format_mplane {
	__u32 width;
	__u32 height;
	__u32 pixelformat;
	__u32 field;
	__u32 colorspace;
	struct v4l2_plane_pix_format plane_fmt[8];
	__u8 num_planes;
	__u8 flags;
	union {
		__u8 ycbcr_enc;
		__u8 hsv_enc;
	};
	__u8 quantization;
	__u8 xfer_func;
	__u8 reserved[7];
};

struct v4l2_sdr_format {
	__u32 pixelformat;
	__u32 buffersize;
	__u8 reserved[24];
};

struct v4l2_meta_format {
	__u32 dataformat;
	__u32 buffersize;
};

struct v4l2_format {
	__u32 type;
	union {
		struct v4l2_pix_format pix;
		struct v4l2_pix_format_mplane pix_mp;
		struct v4l2_window win;
		struct v4l2_vbi_format vbi;
		struct v4l2_sliced_vbi_format sliced;
		struct v4l2_sdr_format sdr;
		struct v4l2_meta_format meta;
		__u8 raw_data[200];
	} fmt;
};

struct v4l2_create_buffers {
	__u32 index;
	__u32 count;
	__u32 memory;
	struct v4l2_format format;
	__u32 capabilities;
	__u32 flags;
	__u32 reserved[6];
};

struct uvc_format_desc {
	char *name;
	u8 guid[16];
	u32 fcc;
};

struct uvc_file_handle {
	struct v4l2_fh vfh;
	struct uvc_video *device;
	bool is_uvc_app_handle;
};

struct uvc_format_uncompressed {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bFormatIndex;
	__u8 bNumFrameDescriptors;
	__u8 guidFormat[16];
	__u8 bBitsPerPixel;
	__u8 bDefaultFrameIndex;
	__u8 bAspectRatioX;
	__u8 bAspectRatioY;
	__u8 bmInterfaceFlags;
	__u8 bCopyProtect;
};

enum uvcg_format_type {
	UVCG_UNCOMPRESSED = 0,
	UVCG_MJPEG = 1,
};

struct uvcg_format {
	struct config_group group;
	enum uvcg_format_type type;
	unsigned int linked;
	struct list_head frames;
	unsigned int num_frames;
	__u8 bmaControls[1];
};

struct uvcg_format_ptr {
	struct uvcg_format *fmt;
	struct list_head entry;
};

struct uvcg_frame;

struct uvcg_frame_ptr {
	struct uvcg_frame *frm;
	struct list_head entry;
};

struct uvcg_frame {
	struct config_item item;
	enum uvcg_format_type fmt_type;
	struct {
		u8 b_length;
		u8 b_descriptor_type;
		u8 b_descriptor_subtype;
		u8 b_frame_index;
		u8 bm_capabilities;
		u16 w_width;
		u16 w_height;
		u32 dw_min_bit_rate;
		u32 dw_max_bit_rate;
		u32 dw_max_video_frame_buffer_size;
		u32 dw_default_frame_interval;
		u8 b_frame_interval_type;
	} __attribute__((packed)) frame;
	u32 *dw_frame_interval;
};

struct uvcg_uncompressed {
	struct uvcg_format fmt;
	struct uvc_format_uncompressed desc;
};

struct uvc_format_mjpeg {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__u8 bFormatIndex;
	__u8 bNumFrameDescriptors;
	__u8 bmFlags;
	__u8 bDefaultFrameIndex;
	__u8 bAspectRatioX;
	__u8 bAspectRatioY;
	__u8 bmInterfaceFlags;
	__u8 bCopyProtect;
};

struct uvc_header_descriptor_1 {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubType;
	__le16 bcdUVC;
	__le16 wTotalLength;
	__le32 dwClockFrequency;
	__u8 bInCollection;
	__u8 baInterfaceNr[1];
} __attribute__((packed));

struct uvcg_control_header {
	struct config_item item;
	struct uvc_header_descriptor_1 desc;
	unsigned int linked;
};

struct uvcg_mjpeg {
	struct uvcg_format fmt;
	struct uvc_format_mjpeg desc;
};

struct uvcg_config_group_type {
	struct config_item_type type;
	const char *name;
	const struct uvcg_config_group_type **children;
	int (*create_children)(struct config_group *);
};

struct uvcg_control_class_group {
	struct config_group group;
	const char *name;
};

struct uvcg_streaming_class_group {
	struct config_group group;
	const char *name;
};

enum uvcg_strm_type {
	UVCG_HEADER = 0,
	UVCG_FORMAT = 1,
	UVCG_FRAME = 2,
};

enum snd_device_type {
	SNDRV_DEV_LOWLEVEL = 0,
	SNDRV_DEV_INFO = 1,
	SNDRV_DEV_BUS = 2,
	SNDRV_DEV_CODEC = 3,
	SNDRV_DEV_PCM = 4,
	SNDRV_DEV_COMPRESS = 5,
	SNDRV_DEV_RAWMIDI = 6,
	SNDRV_DEV_TIMER = 7,
	SNDRV_DEV_SEQUENCER = 8,
	SNDRV_DEV_HWDEP = 9,
	SNDRV_DEV_JACK = 10,
	SNDRV_DEV_CONTROL = 11,
};

enum snd_device_state {
	SNDRV_DEV_BUILD = 0,
	SNDRV_DEV_REGISTERED = 1,
	SNDRV_DEV_DISCONNECTED = 2,
};

struct snd_device;

struct snd_device_ops {
	int (*dev_free)(struct snd_device *);
	int (*dev_register)(struct snd_device *);
	int (*dev_disconnect)(struct snd_device *);
};

struct snd_device {
	struct list_head list;
	struct snd_card *card;
	enum snd_device_state state;
	enum snd_device_type type;
	void *device_data;
	const struct snd_device_ops *ops;
};

enum {
	SNDRV_RAWMIDI_STREAM_OUTPUT = 0,
	SNDRV_RAWMIDI_STREAM_INPUT = 1,
	SNDRV_RAWMIDI_STREAM_LAST = 1,
};

struct snd_rawmidi_substream;

struct snd_rawmidi_ops {
	int (*open)(struct snd_rawmidi_substream *);
	int (*close)(struct snd_rawmidi_substream *);
	void (*trigger)(struct snd_rawmidi_substream *, int);
	void (*drain)(struct snd_rawmidi_substream *);
};

struct snd_rawmidi;

struct snd_rawmidi_str;

struct snd_rawmidi_runtime;

struct snd_rawmidi_substream {
	struct list_head list;
	int stream;
	int number;
	bool opened;
	bool append;
	bool active_sensing;
	unsigned int framing;
	unsigned int clock_type;
	int use_count;
	size_t bytes;
	spinlock_t lock;
	struct snd_rawmidi *rmidi;
	struct snd_rawmidi_str *pstr;
	char name[32];
	struct snd_rawmidi_runtime *runtime;
	struct pid *pid;
	const struct snd_rawmidi_ops *ops;
};

struct snd_seq_port_info;

struct snd_rawmidi_global_ops {
	int (*dev_register)(struct snd_rawmidi *);
	int (*dev_unregister)(struct snd_rawmidi *);
	void (*get_port_info)(struct snd_rawmidi *, int, struct snd_seq_port_info *);
};

struct snd_rawmidi_str {
	unsigned int substream_count;
	unsigned int substream_opened;
	struct list_head substreams;
};

struct snd_rawmidi {
	struct snd_card *card;
	struct list_head list;
	unsigned int device;
	unsigned int info_flags;
	char id[64];
	char name[80];
	const struct snd_rawmidi_global_ops *ops;
	struct snd_rawmidi_str streams[2];
	void *private_data;
	void (*private_free)(struct snd_rawmidi *);
	struct mutex open_mutex;
	wait_queue_head_t open_wait;
	struct device dev;
	struct snd_info_entry *proc_entry;
	int: 32;
};

struct snd_rawmidi_runtime {
	struct snd_rawmidi_substream *substream;
	unsigned int drain: 1;
	unsigned int oss: 1;
	unsigned char *buffer;
	size_t buffer_size;
	size_t appl_ptr;
	size_t hw_ptr;
	size_t avail_min;
	size_t avail;
	size_t xruns;
	int buffer_ref;
	wait_queue_head_t sleep;
	void (*event)(struct snd_rawmidi_substream *);
	struct work_struct event_work;
	void *private_data;
	void (*private_free)(struct snd_rawmidi_substream *);
};

struct usb_ms_header_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__le16 bcdMSC;
	__le16 wTotalLength;
} __attribute__((packed));

struct usb_midi_in_jack_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bJackType;
	__u8 bJackID;
	__u8 iJack;
};

struct usb_midi_source_pin {
	__u8 baSourceID;
	__u8 baSourcePin;
};

struct f_midi_opts {
	struct usb_function_instance func_inst;
	int index;
	char *id;
	bool id_allocated;
	unsigned int in_ports;
	unsigned int out_ports;
	unsigned int buflen;
	unsigned int qlen;
	struct mutex lock;
	int refcnt;
};

enum {
	STATE_INITIAL = 0,
	STATE_1PARAM = 1,
	STATE_2PARAM_1 = 2,
	STATE_2PARAM_2 = 3,
	STATE_SYSEX_0 = 4,
	STATE_SYSEX_1 = 5,
	STATE_SYSEX_2 = 6,
	STATE_REAL_TIME = 7,
	STATE_FINISHED = 8,
};

struct gmidi_in_port {
	struct snd_rawmidi_substream *substream;
	int active;
	uint8_t cable;
	uint8_t state;
	uint8_t data[2];
};

struct f_midi {
	struct usb_function func;
	struct usb_gadget *gadget;
	struct usb_ep *in_ep;
	struct usb_ep *out_ep;
	struct snd_card *card;
	struct snd_rawmidi *rmidi;
	u8 ms_id;
	struct snd_rawmidi_substream *out_substream[16];
	long unsigned int out_triggered;
	struct work_struct work;
	unsigned int in_ports;
	unsigned int out_ports;
	int index;
	char *id;
	unsigned int buflen;
	unsigned int qlen;
	struct {
		union {
			struct __kfifo kfifo;
			struct usb_request **type;
			const struct usb_request **const_type;
			char (*rectype)[0];
			struct usb_request **ptr;
			struct usb_request * const *ptr_const;
		};
		struct usb_request *buf[0];
	} in_req_fifo;
	spinlock_t transmit_lock;
	unsigned int in_last_port;
	unsigned char free_ref;
	struct gmidi_in_port in_ports_array[0];
};

struct uac1_ac_header_descriptor_1 {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__le16 bcdADC;
	__le16 wTotalLength;
	__u8 bInCollection;
	__u8 baInterfaceNr[1];
} __attribute__((packed));

struct usb_midi_out_jack_descriptor_1 {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bJackType;
	__u8 bJackID;
	__u8 bNrInputPins;
	struct usb_midi_source_pin pins[1];
	__u8 iJack;
};

struct usb_ms_endpoint_descriptor_16 {
	__u8 bLength;
	__u8 bDescriptorType;
	__u8 bDescriptorSubtype;
	__u8 bNumEmbMIDIJack;
	__u8 baAssocJackID[16];
};

enum hid_class_request {
	HID_REQ_GET_REPORT = 1,
	HID_REQ_GET_IDLE = 2,
	HID_REQ_GET_PROTOCOL = 3,
	HID_REQ_SET_REPORT = 9,
	HID_REQ_SET_IDLE = 10,
	HID_REQ_SET_PROTOCOL = 11,
};

struct hid_class_descriptor {
	__u8 bDescriptorType;
	__le16 wDescriptorLength;
} __attribute__((packed));

struct hid_descriptor {
	__u8 bLength;
	__u8 bDescriptorType;
	__le16 bcdHID;
	__u8 bCountryCode;
	__u8 bNumDescriptors;
	struct hid_class_descriptor desc[1];
} __attribute__((packed));

struct f_hid_opts {
	struct usb_function_instance func_inst;
	int minor;
	unsigned char subclass;
	unsigned char protocol;
	unsigned char no_out_endpoint;
	short unsigned int report_length;
	short unsigned int report_desc_length;
	unsigned char *report_desc;
	bool report_desc_alloc;
	struct mutex lock;
	int refcnt;
};

struct f_hidg_req_list {
	struct usb_request *req;
	unsigned int pos;
	struct list_head list;
};

struct f_hidg {
	unsigned char bInterfaceSubClass;
	unsigned char bInterfaceProtocol;
	unsigned char protocol;
	unsigned char idle;
	short unsigned int report_desc_length;
	char *report_desc;
	short unsigned int report_length;
	bool use_out_ep;
	spinlock_t read_spinlock;
	wait_queue_head_t read_queue;
	struct list_head completed_out_req;
	unsigned int qlen;
	char *set_report_buf;
	unsigned int set_report_length;
	spinlock_t write_spinlock;
	bool write_pending;
	wait_queue_head_t write_queue;
	struct usb_request *req;
	int minor;
	struct cdev cdev;
	struct usb_function func;
	struct usb_ep *in_ep;
	struct usb_ep *out_ep;
};

struct f_printer_opts {
	struct usb_function_instance func_inst;
	int minor;
	char *pnp_string;
	bool pnp_string_allocated;
	unsigned int q_len;
	struct mutex lock;
	int refcnt;
};

struct printer_dev {
	spinlock_t lock;
	struct mutex lock_printer_io;
	struct usb_gadget *gadget;
	s8 interface;
	struct usb_ep *in_ep;
	struct usb_ep *out_ep;
	struct kref kref;
	struct list_head rx_reqs;
	struct list_head rx_reqs_active;
	struct list_head rx_buffers;
	wait_queue_head_t rx_wait;
	struct list_head tx_reqs;
	struct list_head tx_reqs_active;
	wait_queue_head_t tx_wait;
	wait_queue_head_t tx_flush_wait;
	struct usb_request *current_rx_req;
	size_t current_rx_bytes;
	u8 *current_rx_buf;
	u8 printer_status;
	u8 reset_printer;
	int minor;
	struct cdev printer_cdev;
	u8 printer_cdev_open;
	wait_queue_head_t wait;
	unsigned int q_len;
	char **pnp_string;
	struct usb_function function;
};

struct usb_role_switch {
	struct device dev;
	struct mutex lock;
	enum usb_role role;
	struct device *usb2_port;
	struct device *usb3_port;
	struct device *udc;
	usb_role_switch_set_t set;
	usb_role_switch_get_t get;
	bool allow_userspace_control;
};

struct serio_device_id {
	__u8 type;
	__u8 extra;
	__u8 id;
	__u8 proto;
};

struct serio_driver;

struct serio {
	void *port_data;
	char name[32];
	char phys[32];
	char firmware_id[128];
	bool manual_bind;
	struct serio_device_id id;
	spinlock_t lock;
	int (*write)(struct serio *, unsigned char);
	int (*open)(struct serio *);
	void (*close)(struct serio *);
	int (*start)(struct serio *);
	void (*stop)(struct serio *);
	struct serio *parent;
	struct list_head child_node;
	struct list_head children;
	unsigned int depth;
	struct serio_driver *drv;
	struct mutex drv_mutex;
	int: 32;
	struct device dev;
	struct list_head node;
	struct mutex *ps2_cmd_mutex;
	int: 32;
};

struct serio_driver {
	const char *description;
	const struct serio_device_id *id_table;
	bool manual_bind;
	void (*write_wakeup)(struct serio *);
	irqreturn_t (*interrupt)(struct serio *, unsigned char, unsigned int);
	int (*connect)(struct serio *, struct serio_driver *);
	int (*reconnect)(struct serio *);
	int (*fast_reconnect)(struct serio *);
	void (*disconnect)(struct serio *);
	void (*cleanup)(struct serio *);
	struct device_driver driver;
};

enum serio_event_type {
	SERIO_RESCAN_PORT = 0,
	SERIO_RECONNECT_PORT = 1,
	SERIO_RECONNECT_SUBTREE = 2,
	SERIO_REGISTER_PORT = 3,
	SERIO_ATTACH_DRIVER = 4,
};

struct serio_event {
	enum serio_event_type type;
	void *object;
	struct module *owner;
	struct list_head node;
};

struct ps2dev {
	struct serio *serio;
	struct mutex cmd_mutex;
	wait_queue_head_t wait;
	long unsigned int flags;
	u8 cmdbuf[8];
	u8 cmdcnt;
	u8 nak;
};

struct input_mt_slot {
	int abs[14];
	unsigned int frame;
	unsigned int key;
};

struct input_mt {
	int trkid;
	int num_slots;
	int slot;
	unsigned int flags;
	unsigned int frame;
	int *red;
	struct input_mt_slot slots[0];
};

union input_seq_state {
	struct {
		short unsigned int pos;
		bool mutex_acquired;
	};
	void *p;
};

struct input_devres {
	struct input_dev *input;
};

struct input_event {
	__kernel_ulong_t __sec;
	__kernel_ulong_t __usec;
	__u16 type;
	__u16 code;
	__s32 value;
};

struct input_mt_pos {
	s16 x;
	s16 y;
};

struct input_dev_poller {
	void (*poll)(struct input_dev *);
	unsigned int poll_interval;
	unsigned int poll_interval_max;
	unsigned int poll_interval_min;
	struct input_dev *input;
	struct delayed_work work;
};

struct touchscreen_properties {
	unsigned int max_x;
	unsigned int max_y;
	bool invert_x;
	bool invert_y;
	bool swap_x_y;
};

struct matrix_keymap_data {
	const uint32_t *keymap;
	unsigned int keymap_size;
};

struct vivaldi_data {
	u32 function_row_physmap[24];
	unsigned int num_function_row_keys;
};

struct input_led {
	struct led_classdev cdev;
	struct input_handle *handle;
	unsigned int code;
};

struct input_leds {
	struct input_handle handle;
	unsigned int num_leds;
	struct input_led leds[0];
};

struct input_mask {
	__u32 type;
	__u32 codes_size;
	__u64 codes_ptr;
};

struct evdev_client;

struct evdev {
	int open;
	struct input_handle handle;
	struct evdev_client *grab;
	struct list_head client_list;
	spinlock_t client_lock;
	struct mutex mutex;
	int: 32;
	struct device dev;
	struct cdev cdev;
	bool exist;
};

struct evdev_client {
	unsigned int head;
	unsigned int tail;
	unsigned int packet_head;
	spinlock_t buffer_lock;
	wait_queue_head_t wait;
	struct fasync_struct *fasync;
	struct evdev *evdev;
	struct list_head node;
	enum input_clock_type clk_type;
	bool revoked;
	long unsigned int *evmasks[32];
	unsigned int bufsize;
	struct input_event buffer[0];
};

struct atkbd {
	struct ps2dev ps2dev;
	struct input_dev *dev;
	char name[64];
	char phys[32];
	short unsigned int id;
	short unsigned int keycode[512];
	long unsigned int force_release_mask[16];
	unsigned char set;
	bool translated;
	bool extra;
	bool write;
	bool softrepeat;
	bool softraw;
	bool scroll;
	bool enabled;
	unsigned char emul;
	bool resend;
	bool release;
	long unsigned int xl_bit;
	unsigned int last;
	long unsigned int time;
	long unsigned int err_count;
	struct delayed_work event_work;
	long unsigned int event_jiffies;
	long unsigned int event_mask;
	struct mutex mutex;
	struct vivaldi_data vdata;
};

struct gpio_keys_button {
	unsigned int code;
	int gpio;
	int active_low;
	const char *desc;
	unsigned int type;
	int wakeup;
	int wakeup_event_action;
	int debounce_interval;
	bool can_disable;
	int value;
	unsigned int irq;
};

struct gpio_keys_platform_data {
	const struct gpio_keys_button *buttons;
	int nbuttons;
	unsigned int poll_interval;
	unsigned int rep: 1;
	int (*enable)(struct device *);
	void (*disable)(struct device *);
	const char *name;
};

struct gpio_button_data {
	const struct gpio_keys_button *button;
	struct input_dev *input;
	struct gpio_desc *gpiod;
	short unsigned int *code;
	struct hrtimer release_timer;
	unsigned int release_delay;
	struct delayed_work work;
	struct hrtimer debounce_timer;
	unsigned int software_debounce;
	unsigned int irq;
	unsigned int wakeup_trigger_type;
	spinlock_t lock;
	bool disabled;
	bool key_pressed;
	bool suspended;
	bool debounce_use_hrtimer;
	int: 32;
};

struct gpio_keys_drvdata {
	const struct gpio_keys_platform_data *pdata;
	struct input_dev *input;
	struct mutex disable_lock;
	short unsigned int *keymap;
	struct gpio_button_data data[0];
};

struct imx_keypad {
	struct clk *clk;
	struct input_dev *input_dev;
	void *mmio_base;
	int irq;
	struct timer_list check_matrix_timer;
	int stable_count;
	bool enabled;
	short unsigned int rows_en_mask;
	short unsigned int cols_en_mask;
	short unsigned int keycodes[64];
	short unsigned int matrix_stable_state[8];
	short unsigned int matrix_unstable_state[8];
};

enum key_cmd_type {
	KEY_RPMSG_SETUP = 0,
	KEY_RPMSG_REPLY = 1,
	KEY_RPMSG_NOTIFY = 2,
};

enum keys_type {
	KEY_PRESS = 1,
	KEY_RELEASE = 2,
	KEY_BOTH = 3,
};

struct key_rpmsg_data {
	struct imx_rpmsg_head header;
	u8 key_index;
	union {
		u8 event;
		u8 retcode;
	};
	u8 wakeup;
};

struct rpmsg_keys_button {
	unsigned int code;
	enum keys_type type;
	int wakeup;
	struct input_dev *input;
};

struct rpmsg_keys_drvdata {
	struct input_dev *input;
	struct rpmsg_device *rpdev;
	struct device *dev;
	struct key_rpmsg_data *msg;
	bool ack;
	struct pm_qos_request pm_qos_req;
	struct delayed_work keysetup_work;
	struct completion cmd_complete;
	int nbuttons;
	struct rpmsg_keys_button buttons[0];
};

struct pwrkey_drv_data {
	struct regmap *snvs;
	int irq;
	int keycode;
	int keystate;
	int wakeup;
	bool suspended;
	struct clk *clk;
	struct timer_list check_timer;
	struct input_dev *input;
	bool emulate_press;
};

enum {
	AD7879_SEQ_YPOS = 0,
	AD7879_SEQ_XPOS = 1,
	AD7879_SEQ_Z1 = 2,
	AD7879_SEQ_Z2 = 3,
	AD7879_NR_SENSE = 4,
};

struct ad7879 {
	struct regmap *regmap;
	struct device *dev;
	struct input_dev *input;
	struct timer_list timer;
	struct gpio_chip gc;
	struct mutex mutex;
	unsigned int irq;
	bool disabled;
	bool suspended;
	bool swap_xy;
	u16 conversion_data[4];
	char phys[32];
	u8 first_conversion_delay;
	u8 acquisition_time;
	u8 averaging;
	u8 pen_down_acc_interval;
	u8 median;
	u16 x_plate_ohms;
	u16 cmd_crtl1;
	u16 cmd_crtl2;
	u16 cmd_crtl3;
	int x;
	int y;
	int Rt;
};

struct ads7846_platform_data {
	u16 model;
	u16 vref_delay_usecs;
	u16 vref_mv;
	bool keep_vref_on;
	bool swap_xy;
	u16 settle_delay_usecs;
	u16 penirq_recheck_delay_usecs;
	u16 x_plate_ohms;
	u16 y_plate_ohms;
	u16 x_min;
	u16 x_max;
	u16 y_min;
	u16 y_max;
	u16 pressure_min;
	u16 pressure_max;
	u16 debounce_max;
	u16 debounce_tol;
	u16 debounce_rep;
	int gpio_pendown;
	int gpio_pendown_debounce;
	int (*get_pendown_state)();
	void (*wait_for_sync)();
	bool wakeup;
	long unsigned int irq_flags;
};

struct ads7846_buf {
	u8 cmd;
	__be16 data;
} __attribute__((packed));

struct ads7846_buf_layout {
	unsigned int offset;
	unsigned int count;
	unsigned int skip;
};

struct ads7846_packet {
	unsigned int count;
	unsigned int count_skip;
	unsigned int cmds;
	unsigned int last_cmd_idx;
	struct ads7846_buf_layout l[5];
	struct ads7846_buf *rx;
	struct ads7846_buf *tx;
	struct ads7846_buf pwrdown_cmd;
	bool ignore;
	u16 x;
	u16 y;
	u16 z1;
	u16 z2;
};

struct ads7846 {
	struct input_dev *input;
	char phys[32];
	char name[32];
	struct spi_device *spi;
	struct regulator *reg;
	u16 model;
	u16 vref_mv;
	u16 vref_delay_usecs;
	u16 x_plate_ohms;
	u16 pressure_max;
	bool swap_xy;
	bool use_internal;
	struct ads7846_packet *packet;
	struct spi_transfer xfer[18];
	struct spi_message msg[5];
	int msg_count;
	wait_queue_head_t wait;
	bool pendown;
	int read_cnt;
	int read_rep;
	int last_read;
	u16 debounce_max;
	u16 debounce_tol;
	u16 debounce_rep;
	u16 penirq_recheck_delay_usecs;
	struct touchscreen_properties core_prop;
	struct mutex lock;
	bool stopped;
	bool disabled;
	bool suspended;
	int (*filter)(void *, int, int *);
	void *filter_data;
	int (*get_pendown_state)();
	int gpio_pendown;
	void (*wait_for_sync)();
};

enum ads7846_filter {
	ADS7846_FILTER_OK = 0,
	ADS7846_FILTER_REPEAT = 1,
	ADS7846_FILTER_IGNORE = 2,
};

enum ads7846_cmds {
	ADS7846_X = 0,
	ADS7846_Y = 1,
	ADS7846_Z1 = 2,
	ADS7846_Z2 = 3,
	ADS7846_PWDOWN = 4,
};

struct ser_req {
	u8 ref_on;
	u8 command;
	u8 ref_off;
	u16 scratch;
	struct spi_message msg;
	struct spi_transfer xfer[6];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	__be16 sample;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct ads7845_ser_req {
	u8 command[3];
	struct spi_message msg;
	struct spi_transfer xfer[2];
	u8 sample[3];
	int: 8;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct t7_config {
	u8 idle;
	u8 active;
};

struct t9_range {
	__le16 x;
	__le16 y;
};

struct t37_debug {};

enum t100_type {
	MXT_T100_TYPE_FINGER = 1,
	MXT_T100_TYPE_PASSIVE_STYLUS = 2,
	MXT_T100_TYPE_HOVERING_FINGER = 4,
	MXT_T100_TYPE_GLOVE = 5,
	MXT_T100_TYPE_LARGE_TOUCH = 6,
};

struct mxt_info {
	u8 family_id;
	u8 variant_id;
	u8 version;
	u8 build;
	u8 matrix_xsize;
	u8 matrix_ysize;
	u8 object_num;
};

struct mxt_object {
	u8 type;
	u16 start_address;
	u8 size_minus_one;
	u8 instances_minus_one;
	u8 num_report_ids;
} __attribute__((packed));

struct mxt_dbg {
	u16 t37_address;
	u16 diag_cmd_address;
	struct t37_debug *t37_buf;
	unsigned int t37_pages;
	unsigned int t37_nodes;
	struct v4l2_device v4l2;
	struct v4l2_pix_format format;
	struct video_device vdev;
	struct vb2_queue queue;
	struct mutex lock;
	int input;
	int: 32;
};

enum mxt_suspend_mode {
	MXT_SUSPEND_DEEP_SLEEP = 0,
	MXT_SUSPEND_T9_CTRL = 1,
};

struct mxt_cfg {
	u8 *raw;
	size_t raw_size;
	off_t raw_pos;
	u8 *mem;
	size_t mem_size;
	int start_ofs;
	struct mxt_info info;
};

struct mxt_data {
	struct i2c_client *client;
	struct input_dev *input_dev;
	char phys[64];
	struct mxt_object *object_table;
	struct mxt_info *info;
	void *raw_info_block;
	unsigned int irq;
	unsigned int max_x;
	unsigned int max_y;
	bool invertx;
	bool inverty;
	bool xy_switch;
	u8 xsize;
	u8 ysize;
	bool in_bootloader;
	u16 mem_size;
	u8 t100_aux_ampl;
	u8 t100_aux_area;
	u8 t100_aux_vect;
	u8 max_reportid;
	u32 config_crc;
	u32 info_crc;
	u8 bootloader_addr;
	u8 *msg_buf;
	u8 t6_status;
	bool update_input;
	u8 last_message_count;
	u8 num_touchids;
	u8 multitouch;
	struct t7_config t7_cfg;
	int: 8;
	int: 32;
	struct mxt_dbg dbg;
	struct regulator_bulk_data regulators[2];
	struct gpio_desc *reset_gpio;
	struct gpio_desc *wake_gpio;
	bool use_retrigen_workaround;
	u16 T5_address;
	u8 T5_msg_size;
	u8 T6_reportid;
	u16 T6_address;
	u16 T7_address;
	u16 T71_address;
	u8 T9_reportid_min;
	u8 T9_reportid_max;
	u16 T18_address;
	u8 T19_reportid;
	u16 T44_address;
	u8 T100_reportid_min;
	u8 T100_reportid_max;
	struct completion bl_completion;
	struct completion reset_completion;
	struct completion crc_completion;
	u32 *t19_keymap;
	unsigned int t19_num_keys;
	enum mxt_suspend_mode suspend_mode;
	u32 wakeup_method;
};

struct xy_data {
	unsigned char xhi;
	unsigned char yhi;
	unsigned char ylo: 4;
	unsigned char xlo: 4;
	unsigned char status: 3;
	unsigned char id: 5;
	unsigned char area;
	unsigned char pressure;
};

union ts_xy_data {
	struct xy_data point[1];
	unsigned char buf[6];
};

struct ts_driver {
	struct i2c_client *client;
	struct input_dev *input_dev;
	struct proc_dir_entry *proc_entry;
	struct work_struct event_work;
	struct workqueue_struct *workqueue;
};

struct ts_config_info {
	unsigned int screen_max_x;
	unsigned int screen_max_y;
	unsigned int irq_gpio_number;
	unsigned int irq_number;
	unsigned int rst_gpio_number;
	unsigned char touch_point_number;
	unsigned char ctp_used;
	unsigned char i2c_bus_number;
	unsigned char revert_x_flag;
	unsigned char revert_y_flag;
	unsigned char exchange_x_y_flag;
	int (*tp_enter_init)();
	void (*tp_exit_init)(int);
};

struct ts_chip_info {
	unsigned char chip_id;
};

struct ts_info {
	struct ts_driver *driver;
	struct ts_config_info config_info;
	struct ts_chip_info chip_info;
	union ts_xy_data xy_data;
};

struct da9052_tsi {
	struct da9052 *da9052;
	struct input_dev *dev;
	struct delayed_work ts_pen_work;
	bool stopped;
	bool adc_on;
};

enum edt_pmode {
	EDT_PMODE_NOT_SUPPORTED = 0,
	EDT_PMODE_HIBERNATE = 1,
	EDT_PMODE_POWEROFF = 2,
};

enum edt_ver {
	EDT_M06 = 0,
	EDT_M09 = 1,
	EDT_M12 = 2,
	EV_FT = 3,
	GENERIC_FT = 4,
};

struct edt_reg_addr {
	int reg_threshold;
	int reg_report_rate;
	int reg_gain;
	int reg_offset;
	int reg_offset_x;
	int reg_offset_y;
	int reg_num_x;
	int reg_num_y;
};

struct edt_ft5x06_ts_data {
	struct i2c_client *client;
	struct input_dev *input;
	struct touchscreen_properties prop;
	u16 num_x;
	u16 num_y;
	struct regulator *vcc;
	struct regulator *iovcc;
	struct gpio_desc *reset_gpio;
	struct gpio_desc *wake_gpio;
	struct dentry *debug_dir;
	u8 *raw_buffer;
	size_t raw_bufsize;
	struct mutex mutex;
	bool factory_mode;
	enum edt_pmode suspend_mode;
	int threshold;
	int gain;
	int offset;
	int offset_x;
	int offset_y;
	int report_rate;
	int max_support_points;
	char name[23];
	char fw_version[23];
	struct edt_reg_addr reg_addr;
	enum edt_ver version;
	unsigned int crc_errors;
	unsigned int header_errors;
};

struct edt_i2c_chip_data {
	int max_support_points;
};

struct edt_ft5x06_attribute {
	struct device_attribute dattr;
	size_t field_offset;
	u8 limit_low;
	u8 limit_high;
	u8 addr_m06;
	u8 addr_m09;
	u8 addr_ev;
};

enum {
	hello_packet = 85,
	idx_coordinate_packet = 90,
};

enum {
	idx_finger_state = 7,
};

struct elan_data {
	int intr_gpio;
	int use_irq;
	struct hrtimer timer;
	struct work_struct work;
	struct i2c_client *client;
	struct input_dev *input;
	wait_queue_head_t wait;
	int: 32;
};

struct egalax_ts {
	struct i2c_client *client;
	struct input_dev *input_dev;
};

struct fts_ts_platform_data {
	u32 fts_chip_type;
	u32 irq_gpio;
	u32 irq_gpio_flags;
	u32 reset_gpio;
	u32 reset_gpio_flags;
	bool have_key;
	u32 key_number;
	u32 keys[4];
	u32 key_y_coord;
	u32 key_x_coords[4];
	u32 x_max;
	u32 y_max;
	u32 x_min;
	u32 y_min;
	u32 max_touch_number;
	bool swap;
	bool scaling_down_half;
};

struct ts_event {
	u16 au16_x[10];
	u16 au16_y[10];
	u16 pressure[10];
	u8 au8_touch_event[10];
	u8 au8_finger_id[10];
	u8 area[10];
	u8 touch_point;
	u8 point_num;
};

struct fts_ts_data {
	struct i2c_client *client;
	struct input_dev *input_dev;
	struct ts_event event;
	const struct fts_ts_platform_data *pdata;
	struct work_struct touch_event_work;
	struct workqueue_struct *ts_workqueue;
	struct regulator *vdd;
	struct regulator *vcc_i2c;
	spinlock_t irq_lock;
	u16 addr;
	bool suspended;
	u8 fw_ver[3];
	u8 fw_vendor_id;
	int touchs;
	int irq_disable;
	struct notifier_block fb_notif;
};

struct fts_mode_flag {
	int fts_glove_mode_flag;
	int fts_cover_mode_flag;
	int fts_charger_mode_flag;
};

enum goodix_irq_pin_access_method {
	IRQ_PIN_ACCESS_NONE = 0,
	IRQ_PIN_ACCESS_GPIO = 1,
	IRQ_PIN_ACCESS_ACPI_GPIO = 2,
	IRQ_PIN_ACCESS_ACPI_METHOD = 3,
};

struct goodix_ts_data;

struct goodix_chip_data {
	u16 config_addr;
	int config_len;
	int (*check_config)(struct goodix_ts_data *, const u8 *, int);
	void (*calc_config_checksum)(struct goodix_ts_data *);
};

struct goodix_ts_data {
	struct i2c_client *client;
	struct input_dev *input_dev;
	struct input_dev *input_pen;
	const struct goodix_chip_data *chip;
	const char *firmware_name;
	struct touchscreen_properties prop;
	unsigned int max_touch_num;
	unsigned int int_trigger_type;
	struct regulator *avdd28;
	struct regulator *vddio;
	struct gpio_desc *gpiod_int;
	struct gpio_desc *gpiod_rst;
	int gpio_count;
	int gpio_int_idx;
	enum gpiod_flags gpiod_rst_flags;
	char id[5];
	char cfg_name[64];
	u16 version;
	bool reset_controller_at_probe;
	bool load_cfg_from_disk;
	int pen_input_registered;
	struct completion firmware_loading_complete;
	long unsigned int irq_flags;
	enum goodix_irq_pin_access_method irq_pin_access_method;
	unsigned int contact_size;
	u8 config[240];
	short unsigned int keymap[7];
	u8 main_clk[6];
	int bak_ref_len;
	u8 *bak_ref;
};

struct goodix_chip_id {
	const char *id;
	const struct goodix_chip_data *data;
};

struct goodix_fw_header {
	u8 hw_info[4];
	u8 pid[8];
	u8 vid[2];
};

struct ihex_binrec {
	__be32 addr;
	__be16 len;
	uint8_t data[0];
} __attribute__((packed));

struct ili2xxx_chip {
	int (*read_reg)(struct i2c_client *, u8, void *, size_t);
	int (*get_touch_data)(struct i2c_client *, u8 *);
	bool (*parse_touch_data)(const u8 *, unsigned int, unsigned int *, unsigned int *, unsigned int *);
	bool (*continue_polling)(const u8 *, bool);
	unsigned int max_touches;
	unsigned int resolution;
	bool has_calibrate_reg;
	bool has_firmware_proto;
	bool has_pressure_reg;
};

struct ili210x {
	struct i2c_client *client;
	struct input_dev *input;
	struct gpio_desc *reset_gpio;
	struct touchscreen_properties prop;
	const struct ili2xxx_chip *chip;
	u8 version_firmware[8];
	u8 version_kernel[5];
	u8 version_proto[2];
	u8 ic_mode[2];
	bool stop;
};

struct imx6ul_tsc {
	struct device *dev;
	struct input_dev *input;
	void *tsc_regs;
	void *adc_regs;
	struct clk *tsc_clk;
	struct clk *adc_clk;
	struct gpio_desc *xnur_gpio;
	u32 measure_delay_time;
	u32 pre_charge_time;
	bool average_enable;
	u32 average_select;
	struct completion completion;
};

enum {
	EVENT_INIT = 0,
	EVENT_MIDDLE = 1,
	EVENT_RELEASE = 2,
	EVENT_FIFO_END = 3,
};

struct max11801_data {
	struct i2c_client *client;
	struct input_dev *input_dev;
};

struct mc13783_ts_priv {
	struct input_dev *idev;
	struct mc13xxx *mc13xxx;
	struct delayed_work work;
	unsigned int sample[4];
	struct mc13xxx_ts_platform_data *touch;
};

struct stmpe_touch {
	struct stmpe *stmpe;
	struct input_dev *idev;
	struct delayed_work work;
	struct device *dev;
	struct touchscreen_properties prop;
	u8 ave_ctrl;
	u8 touch_det_delay;
	u8 settling;
	u8 fraction_z;
	u8 i_drive;
};

struct tsc200x_data {
	u16 x;
	u16 y;
	u16 z1;
	u16 z2;
};

struct tsc200x {
	struct device *dev;
	struct regmap *regmap;
	__u16 bustype;
	struct input_dev *idev;
	char phys[32];
	struct mutex mutex;
	int in_x;
	int in_y;
	int in_z1;
	int in_z2;
	struct touchscreen_properties prop;
	spinlock_t lock;
	struct timer_list penup_timer;
	unsigned int esd_timeout;
	struct delayed_work esd_work;
	long unsigned int last_valid_interrupt;
	unsigned int x_plate_ohm;
	bool opened;
	bool suspended;
	bool pen_down;
	struct regulator *vio;
	struct gpio_desc *reset_gpio;
	int (*tsc200x_cmd)(struct device *, u8);
	int irq;
};

struct tsc2007_platform_data {
	u16 model;
	u16 x_plate_ohms;
	u16 max_rt;
	long unsigned int poll_period;
	int fuzzx;
	int fuzzy;
	int fuzzz;
	int (*get_pendown_state)(struct device *);
	void (*clear_penirq)();
	int (*init_platform_hw)();
	void (*exit_platform_hw)();
};

struct ts_event___2 {
	u16 x;
	u16 y;
	u16 z1;
	u16 z2;
};

struct tsc2007 {
	struct input_dev *input;
	char phys[32];
	struct i2c_client *client;
	u16 model;
	u16 x_plate_ohms;
	u16 max_rt;
	long unsigned int poll_period;
	int fuzzx;
	int fuzzy;
	int fuzzz;
	struct gpio_desc *gpiod;
	int irq;
	wait_queue_head_t wait;
	bool stopped;
	int (*get_pendown_state)(struct device *);
	void (*clear_penirq)();
	struct mutex mlock;
};

struct sx865x_data {
	u8 cmd_manual;
	u8 chan_mask;
	bool has_irq_penrelease;
	bool has_reg_irqmask;
	irq_handler_t irqh;
};

struct sx8654 {
	struct input_dev *input;
	struct i2c_client *client;
	struct gpio_desc *gpio_reset;
	spinlock_t lock;
	struct timer_list timer;
	struct touchscreen_properties props;
	const struct sx865x_data *data;
};

struct iio_dev;

struct iio_chan_spec;

struct iio_channel {
	struct iio_dev *indio_dev;
	const struct iio_chan_spec *channel;
	void *data;
};

enum iio_chan_type {
	IIO_VOLTAGE = 0,
	IIO_CURRENT = 1,
	IIO_POWER = 2,
	IIO_ACCEL = 3,
	IIO_ANGL_VEL = 4,
	IIO_MAGN = 5,
	IIO_LIGHT = 6,
	IIO_INTENSITY = 7,
	IIO_PROXIMITY = 8,
	IIO_TEMP = 9,
	IIO_INCLI = 10,
	IIO_ROT = 11,
	IIO_ANGL = 12,
	IIO_TIMESTAMP = 13,
	IIO_CAPACITANCE = 14,
	IIO_ALTVOLTAGE = 15,
	IIO_CCT = 16,
	IIO_PRESSURE = 17,
	IIO_HUMIDITYRELATIVE = 18,
	IIO_ACTIVITY = 19,
	IIO_STEPS = 20,
	IIO_ENERGY = 21,
	IIO_DISTANCE = 22,
	IIO_VELOCITY = 23,
	IIO_CONCENTRATION = 24,
	IIO_RESISTANCE = 25,
	IIO_PH = 26,
	IIO_UVINDEX = 27,
	IIO_ELECTRICALCONDUCTIVITY = 28,
	IIO_COUNT = 29,
	IIO_INDEX = 30,
	IIO_GRAVITY = 31,
	IIO_POSITIONRELATIVE = 32,
	IIO_PHASE = 33,
	IIO_MASSCONCENTRATION = 34,
};

enum iio_endian {
	IIO_CPU = 0,
	IIO_BE = 1,
	IIO_LE = 2,
};

struct iio_event_spec;

struct iio_chan_spec_ext_info;

struct iio_chan_spec {
	enum iio_chan_type type;
	int channel;
	int channel2;
	long unsigned int address;
	int scan_index;
	struct {
		char sign;
		u8 realbits;
		u8 storagebits;
		u8 shift;
		u8 repeat;
		enum iio_endian endianness;
	} scan_type;
	long int info_mask_separate;
	long int info_mask_separate_available;
	long int info_mask_shared_by_type;
	long int info_mask_shared_by_type_available;
	long int info_mask_shared_by_dir;
	long int info_mask_shared_by_dir_available;
	long int info_mask_shared_by_all;
	long int info_mask_shared_by_all_available;
	const struct iio_event_spec *event_spec;
	unsigned int num_event_specs;
	const struct iio_chan_spec_ext_info *ext_info;
	const char *extend_name;
	const char *datasheet_name;
	unsigned int modified: 1;
	unsigned int indexed: 1;
	unsigned int output: 1;
	unsigned int differential: 1;
};

struct vf50_touch_device {
	struct platform_device *pdev;
	struct input_dev *ts_input;
	struct iio_channel *channels;
	struct gpio_desc *gpio_xp;
	struct gpio_desc *gpio_xm;
	struct gpio_desc *gpio_yp;
	struct gpio_desc *gpio_ym;
	int pen_irq;
	int min_pressure;
	bool stop_touchscreen;
};

struct trace_event_raw_rtc_time_alarm_class {
	struct trace_entry ent;
	time64_t secs;
	int err;
	char __data[0];
	int: 32;
};

struct trace_event_raw_rtc_irq_set_freq {
	struct trace_entry ent;
	int freq;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_irq_set_state {
	struct trace_entry ent;
	int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_alarm_irq_enable {
	struct trace_entry ent;
	unsigned int enabled;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_offset_class {
	struct trace_entry ent;
	long int offset;
	int err;
	char __data[0];
};

struct trace_event_raw_rtc_timer_class {
	struct trace_entry ent;
	struct rtc_timer *timer;
	int: 32;
	ktime_t expires;
	ktime_t period;
	char __data[0];
};

struct trace_event_data_offsets_rtc_time_alarm_class {};

struct trace_event_data_offsets_rtc_irq_set_freq {};

struct trace_event_data_offsets_rtc_irq_set_state {};

struct trace_event_data_offsets_rtc_alarm_irq_enable {};

struct trace_event_data_offsets_rtc_offset_class {};

struct trace_event_data_offsets_rtc_timer_class {};

typedef void (*btf_trace_rtc_set_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_time)(void *, time64_t, int);

typedef void (*btf_trace_rtc_set_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_read_alarm)(void *, time64_t, int);

typedef void (*btf_trace_rtc_irq_set_freq)(void *, int, int);

typedef void (*btf_trace_rtc_irq_set_state)(void *, int, int);

typedef void (*btf_trace_rtc_alarm_irq_enable)(void *, unsigned int, int);

typedef void (*btf_trace_rtc_set_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_read_offset)(void *, long int, int);

typedef void (*btf_trace_rtc_timer_enqueue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_dequeue)(void *, struct rtc_timer *);

typedef void (*btf_trace_rtc_timer_fired)(void *, struct rtc_timer *);

enum {
	none = 0,
	day = 1,
	month = 2,
	year = 3,
};

enum {
	RTC_SEC = 0,
	RTC_MIN = 1,
	RTC_HOUR = 2,
	RTC_DAY = 3,
	RTC_MONTH = 4,
	RTC_YEAR = 5,
	RTC_DATA_LEN = 6,
};

struct da9063_compatible_rtc_regmap {
	int rtc_enable_reg;
	int rtc_enable_32k_crystal_reg;
	int rtc_alarm_secs_reg;
	int rtc_alarm_year_reg;
	int rtc_count_secs_reg;
	int rtc_count_year_reg;
	int rtc_event_reg;
	int rtc_enable_mask;
	int rtc_crystal_mask;
	int rtc_event_alarm_mask;
	int rtc_alarm_on_mask;
	int rtc_alarm_status_mask;
	int rtc_tick_on_mask;
	int rtc_ready_to_read_mask;
	int rtc_count_sec_mask;
	int rtc_count_min_mask;
	int rtc_count_hour_mask;
	int rtc_count_day_mask;
	int rtc_count_month_mask;
	int rtc_count_year_mask;
	int rtc_data_start;
	int rtc_alarm_len;
};

struct da9063_compatible_rtc {
	struct rtc_device *rtc_dev;
	struct rtc_time alarm_time;
	struct regmap *regmap;
	const struct da9063_compatible_rtc_regmap *config;
	bool rtc_sync;
};

struct ds1307_platform_data {
	u8 trickle_charger_setup;
};

struct watchdog_info {
	__u32 options;
	__u32 firmware_version;
	__u8 identity[32];
};

struct watchdog_device;

struct watchdog_ops {
	struct module *owner;
	int (*start)(struct watchdog_device *);
	int (*stop)(struct watchdog_device *);
	int (*ping)(struct watchdog_device *);
	unsigned int (*status)(struct watchdog_device *);
	int (*set_timeout)(struct watchdog_device *, unsigned int);
	int (*set_pretimeout)(struct watchdog_device *, unsigned int);
	unsigned int (*get_timeleft)(struct watchdog_device *);
	int (*restart)(struct watchdog_device *, long unsigned int, void *);
	long int (*ioctl)(struct watchdog_device *, unsigned int, long unsigned int);
};

struct watchdog_governor;

struct watchdog_core_data;

struct watchdog_device {
	int id;
	struct device *parent;
	const struct attribute_group **groups;
	const struct watchdog_info *info;
	const struct watchdog_ops *ops;
	const struct watchdog_governor *gov;
	unsigned int bootstatus;
	unsigned int timeout;
	unsigned int pretimeout;
	unsigned int min_timeout;
	unsigned int max_timeout;
	unsigned int min_hw_heartbeat_ms;
	unsigned int max_hw_heartbeat_ms;
	struct notifier_block reboot_nb;
	struct notifier_block restart_nb;
	struct notifier_block pm_nb;
	void *driver_data;
	struct watchdog_core_data *wd_data;
	long unsigned int status;
	struct list_head deferred;
};

struct watchdog_governor {
	const char name[20];
	void (*pretimeout)(struct watchdog_device *);
};

enum ds_type {
	unknown_ds_type = 0,
	ds_1307 = 1,
	ds_1308 = 2,
	ds_1337 = 3,
	ds_1338 = 4,
	ds_1339 = 5,
	ds_1340 = 6,
	ds_1341 = 7,
	ds_1388 = 8,
	ds_3231 = 9,
	m41t0 = 10,
	m41t00 = 11,
	m41t11 = 12,
	mcp794xx = 13,
	rx_8025 = 14,
	rx_8130 = 15,
	last_ds_type = 16,
};

struct ds1307 {
	enum ds_type type;
	struct device *dev;
	struct regmap *regmap;
	const char *name;
	struct rtc_device *rtc;
	struct clk_hw clks[2];
};

struct chip_desc {
	unsigned int alarm: 1;
	u16 nvram_offset;
	u16 nvram_size;
	u8 offset;
	u8 century_reg;
	u8 century_enable_bit;
	u8 century_bit;
	u8 bbsqi_bit;
	irq_handler_t irq_handler;
	const struct rtc_class_ops *rtc_ops;
	u16 trickle_charger_reg;
	u8 (*do_trickle_setup)(struct ds1307 *, u32, bool);
	bool requires_trickle_resistor;
	bool charge_default;
};

enum {
	DS3231_CLK_SQW = 0,
	DS3231_CLK_32KHZ = 1,
};

enum rtc_rpmsg_cmd {
	RTC_RPMSG_SET_TIME = 0,
	RTC_RPMSG_GET_TIME = 1,
	RTC_RPMSG_SET_ALARM = 2,
	RTC_RPMSG_GET_ALARM = 3,
	RTC_RPMSG_ENABLE_ALARM = 4,
};

struct rtc_rpmsg_data {
	struct imx_rpmsg_head header;
	u8 reserved0;
	union {
		u8 reserved1;
		u8 ret;
	};
	union {
		u32 reserved2;
		u32 sec;
	};
	union {
		u8 enable;
		u8 reserved3;
	};
	union {
		u8 pending;
		u8 reserved4;
	};
} __attribute__((packed));

struct rtc_rpmsg_info {
	struct rpmsg_device *rpdev;
	struct device *dev;
	struct rtc_rpmsg_data *msg;
	struct pm_qos_request pm_qos_req;
	struct completion cmd_complete;
	struct mutex lock;
};

struct imx_rpmsg_rtc_data {
	struct rtc_device *rtc;
	spinlock_t lock;
};

enum isl1208_id {
	TYPE_ISL1208 = 0,
	TYPE_ISL1209 = 1,
	TYPE_ISL1218 = 2,
	TYPE_ISL1219 = 3,
	ISL_LAST_ID = 4,
};

struct isl1208_config {
	const char name[8];
	unsigned int nvmem_length;
	unsigned int has_tamper: 1;
	unsigned int has_timestamp: 1;
};

struct isl1208_state {
	struct nvmem_config nvmem_config;
	struct rtc_device *rtc;
	const struct isl1208_config *config;
};

struct m41t80_data {
	long unsigned int features;
	struct i2c_client *client;
	struct rtc_device *rtc;
	struct clk_hw sqw;
	long unsigned int freq;
	unsigned int sqwe;
};

struct mc13xxx_rtc {
	struct rtc_device *rtc;
	struct mc13xxx *mc13xxx;
	int valid;
};

enum imx_rtc_type {
	IMX1_RTC = 0,
	IMX21_RTC = 1,
};

struct rtc_plat_data {
	struct rtc_device *rtc;
	void *ioaddr;
	int irq;
	struct clk *clk_ref;
	struct clk *clk_ipg;
	struct rtc_time g_rtc_alarm;
	enum imx_rtc_type devtype;
};

struct mxc_rtc_data {
	struct rtc_device *rtc;
	void *ioaddr;
	struct clk *clk;
	spinlock_t lock;
	int irq;
};

struct pcf8523 {
	struct rtc_device *rtc;
	struct regmap *regmap;
};

struct pcf8563 {
	struct rtc_device *rtc;
	int c_polarity;
	struct i2c_client *client;
	struct clk_hw clkout_hw;
};

struct rc5t619_rtc {
	int irq;
	struct rtc_device *rtc;
	struct rn5t618 *rn5t618;
};

struct snvs_rtc_data {
	struct rtc_device *rtc;
	struct regmap *regmap;
	int offset;
	int irq;
	struct clk *clk;
};

struct i2c_devinfo {
	struct list_head list;
	int busnum;
	struct i2c_board_info board_info;
};

struct i2c_device_identity {
	u16 manufacturer_id;
	u16 part_id;
	u8 die_revision;
};

struct i2c_timings {
	u32 bus_freq_hz;
	u32 scl_rise_ns;
	u32 scl_fall_ns;
	u32 scl_int_delay_ns;
	u32 sda_fall_ns;
	u32 sda_hold_ns;
	u32 digital_filter_width_ns;
	u32 analog_filter_cutoff_freq_hz;
};

struct trace_event_raw_i2c_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	char __data[0];
};

struct trace_event_raw_i2c_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 msg_nr;
	__u16 addr;
	__u16 flags;
	__u16 len;
	u32 __data_loc_buf;
	char __data[0];
};

struct trace_event_raw_i2c_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 nr_msgs;
	__s16 ret;
	char __data[0];
};

struct trace_event_data_offsets_i2c_write {
	u32 buf;
};

struct trace_event_data_offsets_i2c_read {};

struct trace_event_data_offsets_i2c_reply {
	u32 buf;
};

struct trace_event_data_offsets_i2c_result {};

typedef void (*btf_trace_i2c_write)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_read)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_reply)(void *, const struct i2c_adapter *, const struct i2c_msg *, int);

typedef void (*btf_trace_i2c_result)(void *, const struct i2c_adapter *, int, int);

struct i2c_cmd_arg {
	unsigned int cmd;
	void *arg;
};

struct i2c_smbus_alert_setup {
	int irq;
};

struct trace_event_raw_smbus_write {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_read {
	struct trace_entry ent;
	int adapter_nr;
	__u16 flags;
	__u16 addr;
	__u8 command;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_reply {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 command;
	__u8 len;
	__u32 protocol;
	__u8 buf[34];
	char __data[0];
};

struct trace_event_raw_smbus_result {
	struct trace_entry ent;
	int adapter_nr;
	__u16 addr;
	__u16 flags;
	__u8 read_write;
	__u8 command;
	__s16 res;
	__u32 protocol;
	char __data[0];
};

struct trace_event_data_offsets_smbus_write {};

struct trace_event_data_offsets_smbus_read {};

struct trace_event_data_offsets_smbus_reply {};

struct trace_event_data_offsets_smbus_result {};

typedef void (*btf_trace_smbus_write)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *);

typedef void (*btf_trace_smbus_read)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int);

typedef void (*btf_trace_smbus_reply)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, const union i2c_smbus_data *, int);

typedef void (*btf_trace_smbus_result)(void *, const struct i2c_adapter *, u16, short unsigned int, char, u8, int, int);

struct trace_event_raw_i2c_slave {
	struct trace_entry ent;
	int adapter_nr;
	int ret;
	__u16 addr;
	__u16 len;
	enum i2c_slave_event event;
	__u8 buf[1];
	char __data[0];
};

struct trace_event_data_offsets_i2c_slave {};

typedef void (*btf_trace_i2c_slave)(void *, const struct i2c_client *, enum i2c_slave_event, __u8 *, int);

struct i2c_smbus_ioctl_data {
	__u8 read_write;
	__u8 command;
	__u32 size;
	union i2c_smbus_data *data;
};

struct i2c_rdwr_ioctl_data {
	struct i2c_msg *msgs;
	__u32 nmsgs;
};

struct i2c_dev {
	struct list_head list;
	struct i2c_adapter *adap;
	int: 32;
	struct device dev;
	struct cdev cdev;
	int: 32;
};

struct i2c_mux_core {
	struct i2c_adapter *parent;
	struct device *dev;
	unsigned int mux_locked: 1;
	unsigned int arbitrator: 1;
	unsigned int gate: 1;
	void *priv;
	int (*select)(struct i2c_mux_core *, u32);
	int (*deselect)(struct i2c_mux_core *, u32);
	int num_adapters;
	int max_adapters;
	struct i2c_adapter *adapter[0];
};

struct i2c_mux_priv {
	struct i2c_adapter adap;
	struct i2c_algorithm algo;
	struct i2c_mux_core *muxc;
	u32 chan_id;
	int: 32;
};

struct i2c_algo_bit_data {
	void *data;
	void (*setsda)(void *, int);
	void (*setscl)(void *, int);
	int (*getsda)(void *);
	int (*getscl)(void *);
	int (*pre_xfer)(struct i2c_adapter *);
	void (*post_xfer)(struct i2c_adapter *);
	int udelay;
	int timeout;
	bool can_do_atomic;
};

struct i2c_gpio_platform_data {
	int udelay;
	int timeout;
	unsigned int sda_is_open_drain: 1;
	unsigned int scl_is_open_drain: 1;
	unsigned int scl_is_output_only: 1;
};

struct i2c_gpio_private_data {
	struct gpio_desc *sda;
	struct gpio_desc *scl;
	struct i2c_adapter adap;
	struct i2c_algo_bit_data bit_data;
	struct i2c_gpio_platform_data pdata;
	int: 32;
};

struct imxi2c_platform_data {
	u32 bitrate;
};

enum pinmux_endian_type {
	BIG_ENDIAN = 0,
	LITTLE_ENDIAN = 1,
};

struct pinmux_cfg {
	enum pinmux_endian_type endian;
	u32 pmuxcr_offset;
	u32 pmuxcr_set_bit;
};

struct imx_i2c_clk_pair {
	u16 div;
	u16 val;
};

enum imx_i2c_type {
	IMX1_I2C = 0,
	IMX21_I2C = 1,
	VF610_I2C = 2,
	IMX7D_I2C = 3,
};

struct imx_i2c_hwdata {
	enum imx_i2c_type devtype;
	unsigned int regshift;
	struct imx_i2c_clk_pair *clk_div;
	unsigned int ndivs;
	unsigned int i2sr_clr_opcode;
	unsigned int i2cr_ien_opcode;
	bool has_err007805;
};

struct imx_i2c_dma {
	struct dma_chan *chan_tx;
	struct dma_chan *chan_rx;
	struct dma_chan *chan_using;
	struct completion cmd_complete;
	dma_addr_t dma_buf;
	unsigned int dma_len;
	enum dma_transfer_direction dma_transfer_dir;
	enum dma_data_direction dma_data_dir;
};

struct imx_i2c_struct {
	struct i2c_adapter adapter;
	struct clk *clk;
	struct notifier_block clk_change_nb;
	void *base;
	wait_queue_head_t queue;
	long unsigned int i2csr;
	unsigned int disable_delay;
	int stopped;
	unsigned int ifdr;
	unsigned int cur_clk;
	unsigned int bitrate;
	const struct imx_i2c_hwdata *hwdata;
	struct i2c_bus_recovery_info rinfo;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinctrl_pins_default;
	struct pinctrl_state *pinctrl_pins_gpio;
	struct imx_i2c_dma *dma;
	int layerscape_bus_recover;
	int gpio;
	int need_set_pmuxcr;
	int pmuxcr_set;
	int pmuxcr_endian;
	void *pmuxcr_addr;
	struct i2c_client *slave;
	enum i2c_slave_event last_slave_event;
	spinlock_t slave_lock;
	int: 32;
	struct hrtimer slave_timer;
};

enum lpi2c_imx_mode {
	STANDARD = 0,
	FAST = 1,
	FAST_PLUS = 2,
	HS = 3,
	ULTRA_FAST = 4,
};

enum lpi2c_imx_pincfg {
	TWO_PIN_OD = 0,
	TWO_PIN_OO = 1,
	TWO_PIN_PP = 2,
	FOUR_PIN_PP = 3,
};

struct lpi2c_imx_struct {
	struct i2c_adapter adapter;
	int num_clks;
	struct clk_bulk_data *clks;
	resource_size_t phy_addr;
	int irq;
	void *base;
	__u8 *rx_buf;
	__u8 *tx_buf;
	struct completion complete;
	unsigned int msglen;
	unsigned int delivered;
	unsigned int block_data;
	unsigned int bitrate;
	unsigned int txfifosize;
	unsigned int rxfifosize;
	enum lpi2c_imx_mode mode;
	struct i2c_bus_recovery_info rinfo;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pinctrl_pins_default;
	struct pinctrl_state *pinctrl_pins_gpio;
	bool can_use_dma;
	bool using_dma;
	bool xferred;
	bool is_ndf;
	struct i2c_msg *msg;
	dma_addr_t dma_addr;
	struct dma_chan *dma_tx;
	struct dma_chan *dma_rx;
	enum dma_data_direction dma_direction;
	u8 *dma_buf;
	unsigned int dma_len;
};

struct flexio_control {
	bool dozen;
	bool dbge;
	bool fastacc;
	bool swrst;
	bool flexen;
};

struct flexio_shifter_control {
	u8 timsel;
	u8 timpol;
	u8 pincfg;
	u8 pinsel;
	u8 pinpol;
	u8 smod;
};

struct flexio_shifter_config {
	u8 pwidth;
	u8 sszie;
	u8 latst;
	u8 insrc;
	u8 sstop;
	u8 sstart;
};

struct flexio_timer_control {
	u8 trgsel;
	u8 trgpol;
	u8 trgsrc;
	u8 pincfg;
	u8 pinsel;
	u8 pinpol;
	u8 timod;
};

struct flexio_timer_config {
	u8 timout;
	u8 timdec;
	u8 timrst;
	u8 timdis;
	u8 timena;
	u8 tstop;
	u8 tstart;
};

enum transfer_state {
	START_ADDRESS_WRITE = 0,
	WRITE_DATA = 1,
	WRITE_END = 2,
	START_ADDRESS_READ = 3,
	READ_NOT_LAST_DATA = 4,
	READ_LAST_DATA = 5,
	READ_END = 6,
};

enum stop_position {
	NOT_LAST_8_BIT = 0,
	LAST_8_BIT = 1,
};

struct imx_flexio_i2c_master_dev {
	void *base;
	struct device *dev;
	struct clk *clk;
	int: 32;
	struct i2c_adapter adapter;
	struct completion complete;
	enum transfer_state state;
	enum stop_position stop;
	spinlock_t lock;
	unsigned int irq;
	unsigned int baudrate;
	unsigned int src_clock;
	u8 shifters[2];
	u8 timers[2];
	u8 sda_pin;
	u8 scl_pin;
	u8 slave_addr;
	u8 *data;
	u16 len;
	bool need_check_ack;
	bool nack;
	bool read;
	bool repeated_start;
	int: 16;
	int: 32;
};

enum shifter_flags {
	TX_EMPTY_F = 1,
	RX_FULL_F = 2,
	TX_ERR_F = 4,
	RX_NAK_F = 8,
};

struct i2c_mux_gpio_platform_data {
	int parent;
	int base_nr;
	const unsigned int *values;
	int n_values;
	const unsigned int *classes;
	unsigned int idle;
};

struct gpiomux {
	struct i2c_mux_gpio_platform_data data;
	int ngpios;
	struct gpio_desc **gpios;
};

enum rc_proto {
	RC_PROTO_UNKNOWN = 0,
	RC_PROTO_OTHER = 1,
	RC_PROTO_RC5 = 2,
	RC_PROTO_RC5X_20 = 3,
	RC_PROTO_RC5_SZ = 4,
	RC_PROTO_JVC = 5,
	RC_PROTO_SONY12 = 6,
	RC_PROTO_SONY15 = 7,
	RC_PROTO_SONY20 = 8,
	RC_PROTO_NEC = 9,
	RC_PROTO_NECX = 10,
	RC_PROTO_NEC32 = 11,
	RC_PROTO_SANYO = 12,
	RC_PROTO_MCIR2_KBD = 13,
	RC_PROTO_MCIR2_MSE = 14,
	RC_PROTO_RC6_0 = 15,
	RC_PROTO_RC6_6A_20 = 16,
	RC_PROTO_RC6_6A_24 = 17,
	RC_PROTO_RC6_6A_32 = 18,
	RC_PROTO_RC6_MCE = 19,
	RC_PROTO_SHARP = 20,
	RC_PROTO_XMP = 21,
	RC_PROTO_CEC = 22,
	RC_PROTO_IMON = 23,
	RC_PROTO_RCMM12 = 24,
	RC_PROTO_RCMM24 = 25,
	RC_PROTO_RCMM32 = 26,
	RC_PROTO_XBOX_DVD = 27,
	RC_PROTO_MAX = 27,
};

struct rc_map_table {
	u64 scancode;
	u32 keycode;
	int: 32;
};

struct rc_map {
	struct rc_map_table *scan;
	unsigned int size;
	unsigned int len;
	unsigned int alloc;
	enum rc_proto rc_proto;
	const char *name;
	spinlock_t lock;
};

enum rc_driver_type {
	RC_DRIVER_SCANCODE = 0,
	RC_DRIVER_IR_RAW = 1,
	RC_DRIVER_IR_RAW_TX = 2,
};

struct rc_scancode_filter {
	u32 data;
	u32 mask;
};

struct ir_raw_event_ctrl;

struct rc_dev {
	struct device dev;
	bool managed_alloc;
	const struct attribute_group *sysfs_groups[5];
	const char *device_name;
	const char *input_phys;
	struct input_id input_id;
	const char *driver_name;
	const char *map_name;
	struct rc_map rc_map;
	struct mutex lock;
	unsigned int minor;
	struct ir_raw_event_ctrl *raw;
	struct input_dev *input_dev;
	enum rc_driver_type driver_type;
	bool idle;
	bool encode_wakeup;
	int: 16;
	int: 32;
	u64 allowed_protocols;
	u64 enabled_protocols;
	u64 allowed_wakeup_protocols;
	enum rc_proto wakeup_protocol;
	struct rc_scancode_filter scancode_filter;
	struct rc_scancode_filter scancode_wakeup_filter;
	u32 scancode_mask;
	u32 users;
	void *priv;
	spinlock_t keylock;
	bool keypressed;
	long unsigned int keyup_jiffies;
	struct timer_list timer_keyup;
	struct timer_list timer_repeat;
	u32 last_keycode;
	enum rc_proto last_protocol;
	int: 32;
	u64 last_scancode;
	u8 last_toggle;
	u32 timeout;
	u32 min_timeout;
	u32 max_timeout;
	u32 rx_resolution;
	u32 tx_resolution;
	bool registered;
	int (*change_protocol)(struct rc_dev *, u64 *);
	int (*open)(struct rc_dev *);
	void (*close)(struct rc_dev *);
	int (*s_tx_mask)(struct rc_dev *, u32);
	int (*s_tx_carrier)(struct rc_dev *, u32);
	int (*s_tx_duty_cycle)(struct rc_dev *, u32);
	int (*s_rx_carrier_range)(struct rc_dev *, u32, u32);
	int (*tx_ir)(struct rc_dev *, unsigned int *, unsigned int);
	void (*s_idle)(struct rc_dev *, bool);
	int (*s_wideband_receiver)(struct rc_dev *, int);
	int (*s_carrier_report)(struct rc_dev *, int);
	int (*s_filter)(struct rc_dev *, struct rc_scancode_filter *);
	int (*s_wakeup_filter)(struct rc_dev *, struct rc_scancode_filter *);
	int (*s_timeout)(struct rc_dev *, unsigned int);
	int: 32;
};

struct IR_i2c {
	char *ir_codes;
	struct i2c_client *c;
	struct rc_dev *rc;
	unsigned char old;
	u32 polling_interval;
	struct delayed_work work;
	char phys[32];
	int (*get_key)(struct IR_i2c *, enum rc_proto *, u32 *, u8 *);
	struct i2c_client *tx_c;
	struct mutex lock;
	unsigned int carrier;
	unsigned int duty_cycle;
};

enum ir_kbd_get_key_fn {
	IR_KBD_GET_KEY_CUSTOM = 0,
	IR_KBD_GET_KEY_PIXELVIEW = 1,
	IR_KBD_GET_KEY_HAUP = 2,
	IR_KBD_GET_KEY_KNC1 = 3,
	IR_KBD_GET_KEY_GENIATECH = 4,
	IR_KBD_GET_KEY_FUSIONHDTV = 5,
	IR_KBD_GET_KEY_HAUP_XVR = 6,
	IR_KBD_GET_KEY_AVERMEDIA_CARDBUS = 7,
};

struct IR_i2c_init_data {
	char *ir_codes;
	const char *name;
	u64 type;
	u32 polling_interval;
	int (*get_key)(struct IR_i2c *, enum rc_proto *, u32 *, u8 *);
	enum ir_kbd_get_key_fn internal_get_key_func;
	struct rc_dev *rc_dev;
};

struct code_block {
	u8 length;
	u16 pulse[7];
	u8 carrier_pulse;
	u8 carrier_space;
	u16 space[8];
	u8 codes[61];
	u8 csum[2];
} __attribute__((packed));

struct media_device_info {
	char driver[16];
	char model[32];
	char serial[40];
	char bus_info[32];
	__u32 media_version;
	__u32 hw_revision;
	__u32 driver_version;
	__u32 reserved[31];
};

struct media_entity_desc {
	__u32 id;
	char name[32];
	__u32 type;
	__u32 revision;
	__u32 flags;
	__u32 group_id;
	__u16 pads;
	__u16 links;
	__u32 reserved[4];
	union {
		struct {
			__u32 major;
			__u32 minor;
		} dev;
		__u8 raw[184];
	};
};

struct media_pad_desc {
	__u32 entity;
	__u16 index;
	__u32 flags;
	__u32 reserved[2];
};

struct media_link_desc {
	struct media_pad_desc source;
	struct media_pad_desc sink;
	__u32 flags;
	__u32 reserved[2];
};

struct media_links_enum {
	__u32 entity;
	struct media_pad_desc *pads;
	struct media_link_desc *links;
	__u32 reserved[4];
};

struct media_v2_entity {
	__u32 id;
	char name[64];
	__u32 function;
	__u32 flags;
	__u32 reserved[5];
};

struct media_v2_intf_devnode {
	__u32 major;
	__u32 minor;
};

struct media_v2_interface {
	__u32 id;
	__u32 intf_type;
	__u32 flags;
	__u32 reserved[9];
	union {
		struct media_v2_intf_devnode devnode;
		__u32 raw[16];
	};
};

struct media_v2_pad {
	__u32 id;
	__u32 entity_id;
	__u32 flags;
	__u32 index;
	__u32 reserved[4];
};

struct media_v2_link {
	__u32 id;
	__u32 source_id;
	__u32 sink_id;
	__u32 flags;
	__u32 reserved[6];
};

struct media_v2_topology {
	__u64 topology_version;
	__u32 num_entities;
	__u32 reserved1;
	__u64 ptr_entities;
	__u32 num_interfaces;
	__u32 reserved2;
	__u64 ptr_interfaces;
	__u32 num_pads;
	__u32 reserved3;
	__u64 ptr_pads;
	__u32 num_links;
	__u32 reserved4;
	__u64 ptr_links;
};

enum media_gobj_type {
	MEDIA_GRAPH_ENTITY = 0,
	MEDIA_GRAPH_PAD = 1,
	MEDIA_GRAPH_LINK = 2,
	MEDIA_GRAPH_INTF_DEVNODE = 3,
};

struct media_entity_notify {
	struct list_head list;
	void *notify_data;
	void (*notify)(struct media_entity *, void *);
};

struct media_ioctl_info {
	unsigned int cmd;
	short unsigned int flags;
	long int (*fn)(struct media_device *, void *);
	long int (*arg_from_user)(void *, void *, unsigned int);
	long int (*arg_to_user)(void *, void *, unsigned int);
};

struct media_pipeline_pad {
	struct list_head list;
	struct media_pipeline *pipe;
	struct media_pad *pad;
};

struct media_pipeline_walk_entry {
	struct media_pad *pad;
	struct list_head *links;
};

struct media_pipeline_walk {
	struct media_device *mdev;
	struct {
		unsigned int size;
		int top;
		struct media_pipeline_walk_entry *entries;
	} stack;
};

struct media_device_instance {
	struct media_device mdev;
	struct module *owner;
	struct list_head list;
	struct kref refcount;
};

struct v4l2_fwnode_endpoint {
	struct fwnode_endpoint base;
	enum v4l2_mbus_type bus_type;
	struct {
		struct v4l2_mbus_config_parallel parallel;
		struct v4l2_mbus_config_mipi_csi1 mipi_csi1;
		struct v4l2_mbus_config_mipi_csi2 mipi_csi2;
	} bus;
	u64 *link_frequencies;
	unsigned int nr_of_link_frequencies;
};

enum v4l2_fwnode_orientation {
	V4L2_FWNODE_ORIENTATION_FRONT = 0,
	V4L2_FWNODE_ORIENTATION_BACK = 1,
	V4L2_FWNODE_ORIENTATION_EXTERNAL = 2,
};

struct v4l2_fwnode_device_properties {
	enum v4l2_fwnode_orientation orientation;
	unsigned int rotation;
};

struct v4l2_fwnode_link {
	struct fwnode_handle *local_node;
	unsigned int local_port;
	unsigned int local_id;
	struct fwnode_handle *remote_node;
	unsigned int remote_port;
	unsigned int remote_id;
};

enum v4l2_connector_type {
	V4L2_CONN_UNKNOWN = 0,
	V4L2_CONN_COMPOSITE = 1,
	V4L2_CONN_SVIDEO = 2,
};

struct v4l2_connector_link {
	struct list_head head;
	struct v4l2_fwnode_link fwnode_link;
};

struct v4l2_fwnode_connector_analog {
	v4l2_std_id sdtv_stds;
};

struct v4l2_fwnode_connector {
	const char *name;
	const char *label;
	enum v4l2_connector_type type;
	struct list_head links;
	unsigned int nr_of_links;
	union {
		struct v4l2_fwnode_connector_analog analog;
	} connector;
};

enum v4l2_fwnode_bus_type {
	V4L2_FWNODE_BUS_TYPE_GUESS = 0,
	V4L2_FWNODE_BUS_TYPE_CSI2_CPHY = 1,
	V4L2_FWNODE_BUS_TYPE_CSI1 = 2,
	V4L2_FWNODE_BUS_TYPE_CCP2 = 3,
	V4L2_FWNODE_BUS_TYPE_CSI2_DPHY = 4,
	V4L2_FWNODE_BUS_TYPE_PARALLEL = 5,
	V4L2_FWNODE_BUS_TYPE_BT656 = 6,
	V4L2_FWNODE_BUS_TYPE_DPI = 7,
	NR_OF_V4L2_FWNODE_BUS_TYPE = 8,
};

typedef int (*parse_endpoint_func)(struct device *, struct v4l2_fwnode_endpoint *, struct v4l2_async_subdev *);

struct v4l2_fwnode_bus_conv {
	enum v4l2_fwnode_bus_type fwnode_bus_type;
	enum v4l2_mbus_type mbus_type;
	const char *name;
};

struct v4l2_fwnode_connector_conv {
	enum v4l2_connector_type type;
	const char *compatible;
};

struct v4l2_fwnode_int_props {
	const char *name;
	const char * const *props;
	unsigned int nprops;
};

enum v4l2_memory {
	V4L2_MEMORY_MMAP = 1,
	V4L2_MEMORY_USERPTR = 2,
	V4L2_MEMORY_OVERLAY = 3,
	V4L2_MEMORY_DMABUF = 4,
};

struct v4l2_m2m_ops {
	void (*device_run)(void *);
	int (*job_ready)(void *);
	void (*job_abort)(void *);
};

struct v4l2_m2m_queue_ctx {
	struct vb2_queue q;
	struct list_head rdy_queue;
	spinlock_t rdy_spinlock;
	u8 num_rdy;
	bool buffered;
};

struct v4l2_m2m_dev;

struct v4l2_m2m_ctx {
	struct mutex *q_lock;
	bool new_frame;
	bool is_draining;
	struct vb2_v4l2_buffer *last_src_buf;
	bool next_buf_last;
	bool has_stopped;
	struct v4l2_m2m_dev *m2m_dev;
	struct v4l2_m2m_queue_ctx cap_q_ctx;
	struct v4l2_m2m_queue_ctx out_q_ctx;
	struct list_head queue;
	long unsigned int job_flags;
	wait_queue_head_t finished;
	void *priv;
};

struct v4l2_m2m_dev {
	struct v4l2_m2m_ctx *curr_ctx;
	struct media_entity *source;
	struct media_pad source_pad;
	struct media_entity sink;
	struct media_pad sink_pad;
	struct media_entity proc;
	struct media_pad proc_pads[2];
	struct media_intf_devnode *intf_devnode;
	struct list_head job_queue;
	spinlock_t job_spinlock;
	struct work_struct job_work;
	long unsigned int job_queue_flags;
	const struct v4l2_m2m_ops *m2m_ops;
};

struct v4l2_m2m_buffer {
	struct vb2_v4l2_buffer vb;
	struct list_head list;
};

enum v4l2_video_device_flags {
	V4L2_FL_REGISTERED = 0,
	V4L2_FL_USES_V4L2_FH = 1,
	V4L2_FL_QUIRK_INVERTED_CROP = 2,
	V4L2_FL_SUBDEV_RO_DEVNODE = 3,
};

enum v4l2_m2m_entity_type {
	MEM2MEM_ENT_TYPE_SOURCE = 0,
	MEM2MEM_ENT_TYPE_SINK = 1,
	MEM2MEM_ENT_TYPE_PROC = 2,
};

struct videobuf_queue;

struct videobuf_mapping {
	unsigned int count;
	struct videobuf_queue *q;
};

struct videobuf_buffer;

struct videobuf_queue_ops;

struct videobuf_qtype_ops;

struct videobuf_queue {
	struct mutex vb_lock;
	struct mutex *ext_lock;
	spinlock_t *irqlock;
	struct device *dev;
	wait_queue_head_t wait;
	enum v4l2_buf_type type;
	unsigned int msize;
	enum v4l2_field field;
	enum v4l2_field last;
	struct videobuf_buffer *bufs[32];
	const struct videobuf_queue_ops *ops;
	struct videobuf_qtype_ops *int_ops;
	unsigned int streaming: 1;
	unsigned int reading: 1;
	struct list_head stream;
	unsigned int read_off;
	struct videobuf_buffer *read_buf;
	void *priv_data;
};

enum videobuf_state {
	VIDEOBUF_NEEDS_INIT = 0,
	VIDEOBUF_PREPARED = 1,
	VIDEOBUF_QUEUED = 2,
	VIDEOBUF_ACTIVE = 3,
	VIDEOBUF_DONE = 4,
	VIDEOBUF_ERROR = 5,
	VIDEOBUF_IDLE = 6,
};

struct videobuf_buffer {
	unsigned int i;
	u32 magic;
	unsigned int width;
	unsigned int height;
	unsigned int bytesperline;
	long unsigned int size;
	enum v4l2_field field;
	enum videobuf_state state;
	struct list_head stream;
	struct list_head queue;
	wait_queue_head_t done;
	unsigned int field_count;
	u64 ts;
	enum v4l2_memory memory;
	size_t bsize;
	size_t boff;
	long unsigned int baddr;
	struct videobuf_mapping *map;
	int privsize;
	void *priv;
	int: 32;
};

struct videobuf_queue_ops {
	int (*buf_setup)(struct videobuf_queue *, unsigned int *, unsigned int *);
	int (*buf_prepare)(struct videobuf_queue *, struct videobuf_buffer *, enum v4l2_field);
	void (*buf_queue)(struct videobuf_queue *, struct videobuf_buffer *);
	void (*buf_release)(struct videobuf_queue *, struct videobuf_buffer *);
};

struct videobuf_qtype_ops {
	u32 magic;
	struct videobuf_buffer * (*alloc_vb)(size_t);
	void * (*vaddr)(struct videobuf_buffer *);
	int (*iolock)(struct videobuf_queue *, struct videobuf_buffer *, struct v4l2_framebuffer *);
	int (*sync)(struct videobuf_queue *, struct videobuf_buffer *);
	int (*mmap_mapper)(struct videobuf_queue *, struct videobuf_buffer *, struct vm_area_struct *);
};

struct videobuf_dma_contig_memory {
	u32 magic;
	void *vaddr;
	dma_addr_t dma_handle;
	long unsigned int size;
};

enum v4l2_xfer_func {
	V4L2_XFER_FUNC_DEFAULT = 0,
	V4L2_XFER_FUNC_709 = 1,
	V4L2_XFER_FUNC_SRGB = 2,
	V4L2_XFER_FUNC_OPRGB = 3,
	V4L2_XFER_FUNC_SMPTE240M = 4,
	V4L2_XFER_FUNC_NONE = 5,
	V4L2_XFER_FUNC_DCI_P3 = 6,
	V4L2_XFER_FUNC_SMPTE2084 = 7,
	V4L2_XFER_FUNC_LAST = 8,
};

enum v4l2_ycbcr_encoding {
	V4L2_YCBCR_ENC_DEFAULT = 0,
	V4L2_YCBCR_ENC_601 = 1,
	V4L2_YCBCR_ENC_709 = 2,
	V4L2_YCBCR_ENC_XV601 = 3,
	V4L2_YCBCR_ENC_XV709 = 4,
	V4L2_YCBCR_ENC_BT2020 = 6,
	V4L2_YCBCR_ENC_BT2020_CONST_LUM = 7,
	V4L2_YCBCR_ENC_SMPTE240M = 8,
	V4L2_YCBCR_ENC_LAST = 9,
};

enum v4l2_quantization {
	V4L2_QUANTIZATION_DEFAULT = 0,
	V4L2_QUANTIZATION_FULL_RANGE = 1,
	V4L2_QUANTIZATION_LIM_RANGE = 2,
};

typedef bool v4l2_check_dv_timings_fnc(const struct v4l2_dv_timings *, void *);

struct v4l2_hdmi_colorimetry {
	enum v4l2_colorspace colorspace;
	enum v4l2_ycbcr_encoding ycbcr_enc;
	enum v4l2_quantization quantization;
	enum v4l2_xfer_func xfer_func;
};

struct v4l2_ctrl_hdr10_cll_info {
	__u16 max_content_light_level;
	__u16 max_pic_average_light_level;
};

struct v4l2_ctrl_hdr10_mastering_display {
	__u16 display_primaries_x[3];
	__u16 display_primaries_y[3];
	__u16 white_point_x;
	__u16 white_point_y;
	__u32 max_display_mastering_luminance;
	__u32 min_display_mastering_luminance;
};

enum v4l2_tuner_type {
	V4L2_TUNER_RADIO = 1,
	V4L2_TUNER_ANALOG_TV = 2,
	V4L2_TUNER_DIGITAL_TV = 3,
	V4L2_TUNER_SDR = 4,
	V4L2_TUNER_RF = 5,
};

enum v4l2_hsv_encoding {
	V4L2_HSV_ENC_180 = 128,
	V4L2_HSV_ENC_256 = 129,
};

struct v4l2_cropcap {
	__u32 type;
	struct v4l2_rect bounds;
	struct v4l2_rect defrect;
	struct v4l2_fract pixelaspect;
};

struct v4l2_crop {
	__u32 type;
	struct v4l2_rect c;
};

struct v4l2_standard {
	__u32 index;
	int: 32;
	v4l2_std_id id;
	__u8 name[24];
	struct v4l2_fract frameperiod;
	__u32 framelines;
	__u32 reserved[4];
	int: 32;
};

enum v4l2_ctrl_type {
	V4L2_CTRL_TYPE_INTEGER = 1,
	V4L2_CTRL_TYPE_BOOLEAN = 2,
	V4L2_CTRL_TYPE_MENU = 3,
	V4L2_CTRL_TYPE_BUTTON = 4,
	V4L2_CTRL_TYPE_INTEGER64 = 5,
	V4L2_CTRL_TYPE_CTRL_CLASS = 6,
	V4L2_CTRL_TYPE_STRING = 7,
	V4L2_CTRL_TYPE_BITMASK = 8,
	V4L2_CTRL_TYPE_INTEGER_MENU = 9,
	V4L2_CTRL_COMPOUND_TYPES = 256,
	V4L2_CTRL_TYPE_U8 = 256,
	V4L2_CTRL_TYPE_U16 = 257,
	V4L2_CTRL_TYPE_U32 = 258,
	V4L2_CTRL_TYPE_AREA = 262,
	V4L2_CTRL_TYPE_HDR10_CLL_INFO = 272,
	V4L2_CTRL_TYPE_HDR10_MASTERING_DISPLAY = 273,
	V4L2_CTRL_TYPE_H264_SPS = 512,
	V4L2_CTRL_TYPE_H264_PPS = 513,
	V4L2_CTRL_TYPE_H264_SCALING_MATRIX = 514,
	V4L2_CTRL_TYPE_H264_SLICE_PARAMS = 515,
	V4L2_CTRL_TYPE_H264_DECODE_PARAMS = 516,
	V4L2_CTRL_TYPE_H264_PRED_WEIGHTS = 517,
	V4L2_CTRL_TYPE_FWHT_PARAMS = 544,
	V4L2_CTRL_TYPE_VP8_FRAME = 576,
	V4L2_CTRL_TYPE_MPEG2_QUANTISATION = 592,
	V4L2_CTRL_TYPE_MPEG2_SEQUENCE = 593,
	V4L2_CTRL_TYPE_MPEG2_PICTURE = 594,
	V4L2_CTRL_TYPE_VP9_COMPRESSED_HDR = 608,
	V4L2_CTRL_TYPE_VP9_FRAME = 609,
	V4L2_CTRL_TYPE_HEVC_SPS = 624,
	V4L2_CTRL_TYPE_HEVC_PPS = 625,
	V4L2_CTRL_TYPE_HEVC_SLICE_PARAMS = 626,
	V4L2_CTRL_TYPE_HEVC_SCALING_MATRIX = 627,
	V4L2_CTRL_TYPE_HEVC_DECODE_PARAMS = 628,
};

struct v4l2_dbg_register {
	struct v4l2_dbg_match match;
	__u32 size;
	__u64 reg;
	__u64 val;
};

struct v4l2_dbg_chip_info {
	struct v4l2_dbg_match match;
	char name[32];
	__u32 flags;
	__u32 reserved[32];
};

struct v4l2_ctrl;

typedef void (*v4l2_ctrl_notify_fnc)(struct v4l2_ctrl *, void *);

struct v4l2_ctrl_ref;

struct v4l2_ctrl_handler {
	struct mutex _lock;
	struct mutex *lock;
	struct list_head ctrls;
	struct list_head ctrl_refs;
	struct v4l2_ctrl_ref *cached;
	struct v4l2_ctrl_ref **buckets;
	v4l2_ctrl_notify_fnc notify;
	void *notify_priv;
	u16 nr_of_buckets;
	int error;
	bool request_is_queued;
	struct list_head requests;
	struct list_head requests_queued;
	struct media_request_object req_obj;
};

typedef long int (*v4l2_kioctl)(struct file *, unsigned int, void *);

struct v4l2_event_time32 {
	__u32 type;
	int: 32;
	union {
		struct v4l2_event_vsync vsync;
		struct v4l2_event_ctrl ctrl;
		struct v4l2_event_frame_sync frame_sync;
		struct v4l2_event_src_change src_change;
		struct v4l2_event_motion_det motion_det;
		__u8 data[64];
	} u;
	__u32 pending;
	__u32 sequence;
	struct old_timespec32 timestamp;
	__u32 id;
	__u32 reserved[8];
	int: 32;
};

struct v4l2_buffer_time32 {
	__u32 index;
	__u32 type;
	__u32 bytesused;
	__u32 flags;
	__u32 field;
	struct old_timeval32 timestamp;
	struct v4l2_timecode timecode;
	__u32 sequence;
	__u32 memory;
	union {
		__u32 offset;
		long unsigned int userptr;
		struct v4l2_plane *planes;
		__s32 fd;
	} m;
	__u32 length;
	__u32 reserved2;
	union {
		__s32 request_fd;
		__u32 reserved;
	};
};

union v4l2_ctrl_ptr {
	s32 *p_s32;
	s64 *p_s64;
	u8 *p_u8;
	u16 *p_u16;
	u32 *p_u32;
	char *p_char;
	struct v4l2_ctrl_mpeg2_sequence *p_mpeg2_sequence;
	struct v4l2_ctrl_mpeg2_picture *p_mpeg2_picture;
	struct v4l2_ctrl_mpeg2_quantisation *p_mpeg2_quantisation;
	struct v4l2_ctrl_fwht_params *p_fwht_params;
	struct v4l2_ctrl_h264_sps *p_h264_sps;
	struct v4l2_ctrl_h264_pps *p_h264_pps;
	struct v4l2_ctrl_h264_scaling_matrix *p_h264_scaling_matrix;
	struct v4l2_ctrl_h264_slice_params *p_h264_slice_params;
	struct v4l2_ctrl_h264_decode_params *p_h264_decode_params;
	struct v4l2_ctrl_h264_pred_weights *p_h264_pred_weights;
	struct v4l2_ctrl_vp8_frame *p_vp8_frame;
	struct v4l2_ctrl_hevc_sps *p_hevc_sps;
	struct v4l2_ctrl_hevc_pps *p_hevc_pps;
	struct v4l2_ctrl_hevc_slice_params *p_hevc_slice_params;
	struct v4l2_ctrl_vp9_compressed_hdr *p_vp9_compressed_hdr_probs;
	struct v4l2_ctrl_vp9_frame *p_vp9_frame;
	struct v4l2_ctrl_hdr10_cll_info *p_hdr10_cll;
	struct v4l2_ctrl_hdr10_mastering_display *p_hdr10_mastering;
	struct v4l2_area *p_area;
	void *p;
	const void *p_const;
};

struct v4l2_ctrl_ops {
	int (*g_volatile_ctrl)(struct v4l2_ctrl *);
	int (*try_ctrl)(struct v4l2_ctrl *);
	int (*s_ctrl)(struct v4l2_ctrl *);
};

struct v4l2_ctrl_type_ops;

struct v4l2_ctrl {
	struct list_head node;
	struct list_head ev_subs;
	struct v4l2_ctrl_handler *handler;
	struct v4l2_ctrl **cluster;
	unsigned int ncontrols;
	unsigned int done: 1;
	unsigned int is_new: 1;
	unsigned int has_changed: 1;
	unsigned int is_private: 1;
	unsigned int is_auto: 1;
	unsigned int is_int: 1;
	unsigned int is_string: 1;
	unsigned int is_ptr: 1;
	unsigned int is_array: 1;
	unsigned int is_dyn_array: 1;
	unsigned int has_volatiles: 1;
	unsigned int call_notify: 1;
	unsigned int manual_mode_value: 8;
	const struct v4l2_ctrl_ops *ops;
	const struct v4l2_ctrl_type_ops *type_ops;
	u32 id;
	const char *name;
	enum v4l2_ctrl_type type;
	int: 32;
	s64 minimum;
	s64 maximum;
	s64 default_value;
	u32 elems;
	u32 elem_size;
	u32 new_elems;
	u32 dims[4];
	u32 nr_of_dims;
	union {
		u64 step;
		u64 menu_skip_mask;
	};
	union {
		const char * const *qmenu;
		const s64 *qmenu_int;
	};
	long unsigned int flags;
	void *priv;
	void *p_array;
	u32 p_array_alloc_elems;
	s32 val;
	struct {
		s32 val;
	} cur;
	union v4l2_ctrl_ptr p_def;
	union v4l2_ctrl_ptr p_new;
	union v4l2_ctrl_ptr p_cur;
};

struct v4l2_ctrl_type_ops {
	bool (*equal)(const struct v4l2_ctrl *, union v4l2_ctrl_ptr, union v4l2_ctrl_ptr);
	void (*init)(const struct v4l2_ctrl *, u32, union v4l2_ctrl_ptr);
	void (*log)(const struct v4l2_ctrl *);
	int (*validate)(const struct v4l2_ctrl *, union v4l2_ctrl_ptr);
};

struct v4l2_ctrl_helper;

struct v4l2_ctrl_ref {
	struct list_head node;
	struct v4l2_ctrl_ref *next;
	struct v4l2_ctrl *ctrl;
	struct v4l2_ctrl_helper *helper;
	bool from_other_dev;
	bool req_done;
	bool p_req_valid;
	bool p_req_array_enomem;
	u32 p_req_array_alloc_elems;
	u32 p_req_elems;
	union v4l2_ctrl_ptr p_req;
};

enum {
	V4L2_IDENT_NONE = 0,
	V4L2_IDENT_AMBIGUOUS = 1,
	V4L2_IDENT_UNKNOWN = 2,
	V4L2_IDENT_TVAUDIO = 50,
	V4L2_IDENT_IMX074 = 74,
	V4L2_IDENT_SAA7110 = 100,
	V4L2_IDENT_SAA7111 = 101,
	V4L2_IDENT_SAA7111A = 102,
	V4L2_IDENT_SAA7113 = 103,
	V4L2_IDENT_SAA7114 = 104,
	V4L2_IDENT_SAA7115 = 105,
	V4L2_IDENT_SAA7118 = 108,
	V4L2_IDENT_GM7113C = 140,
	V4L2_IDENT_SAA7127 = 157,
	V4L2_IDENT_SAA7129 = 159,
	V4L2_IDENT_CX25836 = 236,
	V4L2_IDENT_CX25837 = 237,
	V4L2_IDENT_CX25840 = 240,
	V4L2_IDENT_CX25841 = 241,
	V4L2_IDENT_CX25842 = 242,
	V4L2_IDENT_CX25843 = 243,
	V4L2_IDENT_OV7670 = 250,
	V4L2_IDENT_OV7720 = 251,
	V4L2_IDENT_OV7725 = 252,
	V4L2_IDENT_OV7660 = 253,
	V4L2_IDENT_OV9650 = 254,
	V4L2_IDENT_OV9655 = 255,
	V4L2_IDENT_SOI968 = 256,
	V4L2_IDENT_OV9640 = 257,
	V4L2_IDENT_OV6650 = 258,
	V4L2_IDENT_OV2640 = 259,
	V4L2_IDENT_OV9740 = 260,
	V4L2_IDENT_OV5642 = 261,
	V4L2_IDENT_SAA7146 = 300,
	V4L2_IDENT_CX23418_843 = 403,
	V4L2_IDENT_CX23415 = 415,
	V4L2_IDENT_CX23416 = 416,
	V4L2_IDENT_CX23417 = 417,
	V4L2_IDENT_CX23418 = 418,
	V4L2_IDENT_BT815A = 815,
	V4L2_IDENT_BT817A = 817,
	V4L2_IDENT_BT819A = 819,
	V4L2_IDENT_AU0828 = 828,
	V4L2_IDENT_BT848 = 848,
	V4L2_IDENT_BT849 = 849,
	V4L2_IDENT_BT856 = 856,
	V4L2_IDENT_BT866 = 866,
	V4L2_IDENT_BT878 = 878,
	V4L2_IDENT_BT879 = 879,
	V4L2_IDENT_KS0122S = 1122,
	V4L2_IDENT_KS0127 = 1127,
	V4L2_IDENT_KS0127B = 1128,
	V4L2_IDENT_INDYCAM = 2000,
	V4L2_IDENT_VP27SMPX = 2700,
	V4L2_IDENT_VPX3214C = 3214,
	V4L2_IDENT_VPX3216B = 3216,
	V4L2_IDENT_VPX3220A = 3220,
	V4L2_IDENT_VIA_VX855 = 3409,
	V4L2_IDENT_TVP5150 = 5150,
	V4L2_IDENT_SAA5246A = 5246,
	V4L2_IDENT_SAA5249 = 5249,
	V4L2_IDENT_CS5345 = 5345,
	V4L2_IDENT_TEA6415C = 6415,
	V4L2_IDENT_TEA6420 = 6420,
	V4L2_IDENT_SAA6588 = 6588,
	V4L2_IDENT_VS6624 = 6624,
	V4L2_IDENT_SAA6752HS = 6752,
	V4L2_IDENT_SAA6752HS_AC3 = 6753,
	V4L2_IDENT_TEF6862 = 6862,
	V4L2_IDENT_TVP7002 = 7002,
	V4L2_IDENT_ADV7170 = 7170,
	V4L2_IDENT_ADV7175 = 7175,
	V4L2_IDENT_ADV7180 = 7180,
	V4L2_IDENT_ADV7183 = 7183,
	V4L2_IDENT_SAA7185 = 7185,
	V4L2_IDENT_SAA7191 = 7191,
	V4L2_IDENT_THS7303 = 7303,
	V4L2_IDENT_ADV7343 = 7343,
	V4L2_IDENT_THS7353 = 7353,
	V4L2_IDENT_ADV7393 = 7393,
	V4L2_IDENT_ADV7604 = 7604,
	V4L2_IDENT_SAA7706H = 7706,
	V4L2_IDENT_MT9V011 = 8243,
	V4L2_IDENT_WM8739 = 8739,
	V4L2_IDENT_WM8775 = 8775,
	V4L2_IDENT_CAFE = 8801,
	V4L2_IDENT_ARMADA610 = 8802,
	V4L2_IDENT_AK8813 = 8813,
	V4L2_IDENT_AK8814 = 8814,
	V4L2_IDENT_CX23885 = 8850,
	V4L2_IDENT_CX23885_AV = 8851,
	V4L2_IDENT_CX23887 = 8870,
	V4L2_IDENT_CX23887_AV = 8871,
	V4L2_IDENT_CX23888 = 8880,
	V4L2_IDENT_CX23888_AV = 8881,
	V4L2_IDENT_CX23888_IR = 8882,
	V4L2_IDENT_AD9389B = 9389,
	V4L2_IDENT_TDA9840 = 9840,
	V4L2_IDENT_TW9910 = 9910,
	V4L2_IDENT_SN9C20X = 10000,
	V4L2_IDENT_CX2310X_AV = 23099,
	V4L2_IDENT_CX23100 = 23100,
	V4L2_IDENT_CX23101 = 23101,
	V4L2_IDENT_CX23102 = 23102,
	V4L2_IDENT_MSPX4XX = 34000,
	V4L2_IDENT_MSP3400B = 34002,
	V4L2_IDENT_MSP3400C = 34003,
	V4L2_IDENT_MSP3400D = 34004,
	V4L2_IDENT_MSP3400G = 34007,
	V4L2_IDENT_MSP3401G = 34017,
	V4L2_IDENT_MSP3402G = 34027,
	V4L2_IDENT_MSP3405D = 34054,
	V4L2_IDENT_MSP3405G = 34057,
	V4L2_IDENT_MSP3407D = 34074,
	V4L2_IDENT_MSP3407G = 34077,
	V4L2_IDENT_MSP3410B = 34102,
	V4L2_IDENT_MSP3410C = 34103,
	V4L2_IDENT_MSP3410D = 34104,
	V4L2_IDENT_MSP3410G = 34107,
	V4L2_IDENT_MSP3411G = 34117,
	V4L2_IDENT_MSP3412G = 34127,
	V4L2_IDENT_MSP3415D = 34154,
	V4L2_IDENT_MSP3415G = 34157,
	V4L2_IDENT_MSP3417D = 34174,
	V4L2_IDENT_MSP3417G = 34177,
	V4L2_IDENT_MSP3420G = 34207,
	V4L2_IDENT_MSP3421G = 34217,
	V4L2_IDENT_MSP3422G = 34227,
	V4L2_IDENT_MSP3425G = 34257,
	V4L2_IDENT_MSP3427G = 34277,
	V4L2_IDENT_MSP3430G = 34307,
	V4L2_IDENT_MSP3431G = 34317,
	V4L2_IDENT_MSP3435G = 34357,
	V4L2_IDENT_MSP3437G = 34377,
	V4L2_IDENT_MSP3440G = 34407,
	V4L2_IDENT_MSP3441G = 34417,
	V4L2_IDENT_MSP3442G = 34427,
	V4L2_IDENT_MSP3445G = 34457,
	V4L2_IDENT_MSP3447G = 34477,
	V4L2_IDENT_MSP3450G = 34507,
	V4L2_IDENT_MSP3451G = 34517,
	V4L2_IDENT_MSP3452G = 34527,
	V4L2_IDENT_MSP3455G = 34557,
	V4L2_IDENT_MSP3457G = 34577,
	V4L2_IDENT_MSP3460G = 34607,
	V4L2_IDENT_MSP3461G = 34617,
	V4L2_IDENT_MSP3465G = 34657,
	V4L2_IDENT_MSP3467G = 34677,
	V4L2_IDENT_MSP4400G = 44007,
	V4L2_IDENT_MSP4408G = 44087,
	V4L2_IDENT_MSP4410G = 44107,
	V4L2_IDENT_MSP4418G = 44187,
	V4L2_IDENT_MSP4420G = 44207,
	V4L2_IDENT_MSP4428G = 44287,
	V4L2_IDENT_MSP4440G = 44407,
	V4L2_IDENT_MSP4448G = 44487,
	V4L2_IDENT_MSP4450G = 44507,
	V4L2_IDENT_MSP4458G = 44587,
	V4L2_IDENT_MT9M001C12ST = 45000,
	V4L2_IDENT_MT9M001C12STM = 45005,
	V4L2_IDENT_MT9M111 = 45007,
	V4L2_IDENT_MT9M112 = 45008,
	V4L2_IDENT_MT9V022IX7ATC = 45010,
	V4L2_IDENT_MT9V022IX7ATM = 45015,
	V4L2_IDENT_MT9T031 = 45020,
	V4L2_IDENT_MT9T111 = 45021,
	V4L2_IDENT_MT9T112 = 45022,
	V4L2_IDENT_MT9V111 = 45031,
	V4L2_IDENT_MT9V112 = 45032,
	V4L2_IDENT_HV7131R = 46000,
	V4L2_IDENT_RJ54N1CB0C = 51980,
	V4L2_IDENT_M52790 = 52790,
	V4L2_IDENT_CS53l32A = 53132,
	V4L2_IDENT_UPD61161 = 54000,
	V4L2_IDENT_UPD61162 = 54001,
	V4L2_IDENT_UPD64031A = 64031,
	V4L2_IDENT_UPD64083 = 64083,
};

struct std_descr {
	v4l2_std_id std;
	const char *descr;
	int: 32;
};

struct v4l2_ioctl_info {
	unsigned int ioctl;
	u32 flags;
	const char * const name;
	int (*func)(const struct v4l2_ioctl_ops *, struct file *, void *, void *);
	void (*debug)(const void *, bool);
};

struct v4l2_subscribed_event;

struct v4l2_kevent {
	struct list_head list;
	struct v4l2_subscribed_event *sev;
	int: 32;
	struct v4l2_event event;
	u64 ts;
};

struct v4l2_subscribed_event_ops;

struct v4l2_subscribed_event {
	struct list_head list;
	u32 type;
	u32 id;
	u32 flags;
	struct v4l2_fh *fh;
	struct list_head node;
	const struct v4l2_subscribed_event_ops *ops;
	unsigned int elems;
	unsigned int first;
	unsigned int in_use;
	struct v4l2_kevent events[0];
};

struct v4l2_subscribed_event_ops {
	int (*add)(struct v4l2_subscribed_event *, unsigned int);
	void (*del)(struct v4l2_subscribed_event *);
	void (*replace)(struct v4l2_event *, const struct v4l2_event *);
	void (*merge)(const struct v4l2_event *, struct v4l2_event *);
};

struct v4l2_subdev;

enum v4l2_subdev_format_whence {
	V4L2_SUBDEV_FORMAT_TRY = 0,
	V4L2_SUBDEV_FORMAT_ACTIVE = 1,
};

struct v4l2_subdev_crop {
	__u32 which;
	__u32 pad;
	struct v4l2_rect rect;
	__u32 reserved[8];
};

struct v4l2_subdev_capability {
	__u32 version;
	__u32 capabilities;
	__u32 reserved[14];
};

enum v4l2_pixel_encoding {
	V4L2_PIXEL_ENC_UNKNOWN = 0,
	V4L2_PIXEL_ENC_YUV = 1,
	V4L2_PIXEL_ENC_RGB = 2,
	V4L2_PIXEL_ENC_BAYER = 3,
};

struct v4l2_format_info {
	u32 format;
	u8 pixel_enc;
	u8 mem_planes;
	u8 comp_planes;
	u8 bpp[4];
	u8 hdiv;
	u8 vdiv;
	u8 block_w[4];
	u8 block_h[4];
};

struct v4l2_ctrl_config {
	const struct v4l2_ctrl_ops *ops;
	const struct v4l2_ctrl_type_ops *type_ops;
	u32 id;
	const char *name;
	enum v4l2_ctrl_type type;
	int: 32;
	s64 min;
	s64 max;
	u64 step;
	s64 def;
	union v4l2_ctrl_ptr p_def;
	u32 dims[4];
	u32 elem_size;
	u32 flags;
	int: 32;
	u64 menu_skip_mask;
	const char * const *qmenu;
	const s64 *qmenu_int;
	unsigned int is_private: 1;
	int: 31;
	int: 32;
};

struct v4l2_ctrl_helper {
	struct v4l2_ctrl_ref *mref;
	struct v4l2_ctrl_ref *ref;
	u32 next;
};

struct trace_event_raw_v4l2_event_class {
	struct trace_entry ent;
	int minor;
	u32 index;
	u32 type;
	u32 bytesused;
	u32 flags;
	u32 field;
	s64 timestamp;
	u32 timecode_type;
	u32 timecode_flags;
	u8 timecode_frames;
	u8 timecode_seconds;
	u8 timecode_minutes;
	u8 timecode_hours;
	u8 timecode_userbits0;
	u8 timecode_userbits1;
	u8 timecode_userbits2;
	u8 timecode_userbits3;
	u32 sequence;
	char __data[0];
	int: 32;
};

struct trace_event_raw_vb2_v4l2_event_class {
	struct trace_entry ent;
	int minor;
	u32 flags;
	u32 field;
	int: 32;
	u64 timestamp;
	u32 timecode_type;
	u32 timecode_flags;
	u8 timecode_frames;
	u8 timecode_seconds;
	u8 timecode_minutes;
	u8 timecode_hours;
	u8 timecode_userbits0;
	u8 timecode_userbits1;
	u8 timecode_userbits2;
	u8 timecode_userbits3;
	u32 sequence;
	char __data[0];
	int: 32;
};

struct trace_event_data_offsets_v4l2_event_class {};

struct trace_event_data_offsets_vb2_v4l2_event_class {};

typedef void (*btf_trace_v4l2_dqbuf)(void *, int, struct v4l2_buffer *);

typedef void (*btf_trace_v4l2_qbuf)(void *, int, struct v4l2_buffer *);

typedef void (*btf_trace_vb2_v4l2_buf_done)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_v4l2_buf_queue)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_v4l2_dqbuf)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_v4l2_qbuf)(void *, struct vb2_queue *, struct vb2_buffer *);

enum v4l2_i2c_tuner_type {
	ADDRS_RADIO = 0,
	ADDRS_DEMOD = 1,
	ADDRS_TV = 2,
	ADDRS_TV_WITH_DEMOD = 3,
};

enum dvb_device_type {
	DVB_DEVICE_SEC = 0,
	DVB_DEVICE_FRONTEND = 1,
	DVB_DEVICE_DEMUX = 2,
	DVB_DEVICE_DVR = 3,
	DVB_DEVICE_CA = 4,
	DVB_DEVICE_NET = 5,
	DVB_DEVICE_VIDEO = 6,
	DVB_DEVICE_AUDIO = 7,
	DVB_DEVICE_OSD = 8,
};

struct dvb_device;

struct dvb_adapter {
	int num;
	struct list_head list_head;
	struct list_head device_list;
	const char *name;
	u8 proposed_mac[6];
	void *priv;
	struct device *device;
	struct module *module;
	int mfe_shared;
	struct dvb_device *mfe_dvbdev;
	struct mutex mfe_lock;
};

struct dvb_device {
	struct list_head list_head;
	const struct file_operations *fops;
	struct dvb_adapter *adapter;
	enum dvb_device_type type;
	int minor;
	u32 id;
	int readers;
	int writers;
	int users;
	wait_queue_head_t wait_queue;
	int (*kernel_ioctl)(struct file *, unsigned int, void *);
	void *priv;
};

enum dmx_output {
	DMX_OUT_DECODER = 0,
	DMX_OUT_TAP = 1,
	DMX_OUT_TS_TAP = 2,
	DMX_OUT_TSDEMUX_TAP = 3,
};

enum dmx_input {
	DMX_IN_FRONTEND = 0,
	DMX_IN_DVR = 1,
};

enum dmx_ts_pes {
	DMX_PES_AUDIO0 = 0,
	DMX_PES_VIDEO0 = 1,
	DMX_PES_TELETEXT0 = 2,
	DMX_PES_SUBTITLE0 = 3,
	DMX_PES_PCR0 = 4,
	DMX_PES_AUDIO1 = 5,
	DMX_PES_VIDEO1 = 6,
	DMX_PES_TELETEXT1 = 7,
	DMX_PES_SUBTITLE1 = 8,
	DMX_PES_PCR1 = 9,
	DMX_PES_AUDIO2 = 10,
	DMX_PES_VIDEO2 = 11,
	DMX_PES_TELETEXT2 = 12,
	DMX_PES_SUBTITLE2 = 13,
	DMX_PES_PCR2 = 14,
	DMX_PES_AUDIO3 = 15,
	DMX_PES_VIDEO3 = 16,
	DMX_PES_TELETEXT3 = 17,
	DMX_PES_SUBTITLE3 = 18,
	DMX_PES_PCR3 = 19,
	DMX_PES_OTHER = 20,
};

struct dmx_filter {
	__u8 filter[16];
	__u8 mask[16];
	__u8 mode[16];
};

struct dmx_sct_filter_params {
	__u16 pid;
	struct dmx_filter filter;
	__u32 timeout;
	__u32 flags;
};

struct dmx_pes_filter_params {
	__u16 pid;
	enum dmx_input input;
	enum dmx_output output;
	enum dmx_ts_pes pes_type;
	__u32 flags;
};

struct dmx_stc {
	unsigned int num;
	unsigned int base;
	__u64 stc;
};

enum dmx_buffer_flags {
	DMX_BUFFER_FLAG_HAD_CRC32_DISCARD = 1,
	DMX_BUFFER_FLAG_TEI = 2,
	DMX_BUFFER_PKT_COUNTER_MISMATCH = 4,
	DMX_BUFFER_FLAG_DISCONTINUITY_DETECTED = 8,
	DMX_BUFFER_FLAG_DISCONTINUITY_INDICATOR = 16,
};

enum ts_filter_type {
	TS_PACKET = 1,
	TS_PAYLOAD_ONLY = 2,
	TS_DECODER = 4,
	TS_DEMUX = 8,
};

struct dmx_demux;

struct dmx_ts_feed {
	int is_filtering;
	struct dmx_demux *parent;
	void *priv;
	int (*set)(struct dmx_ts_feed *, u16, int, enum dmx_ts_pes, ktime_t);
	int (*start_filtering)(struct dmx_ts_feed *);
	int (*stop_filtering)(struct dmx_ts_feed *);
};

enum dmx_demux_caps {
	DMX_TS_FILTERING = 1,
	DMX_SECTION_FILTERING = 4,
	DMX_MEMORY_BASED_FILTERING = 8,
};

typedef int (*dmx_ts_cb)(const u8 *, size_t, const u8 *, size_t, struct dmx_ts_feed *, u32 *);

struct dmx_section_filter;

typedef int (*dmx_section_cb)(const u8 *, size_t, const u8 *, size_t, struct dmx_section_filter *, u32 *);

struct dmx_frontend;

struct dmx_section_feed;

struct dmx_demux {
	enum dmx_demux_caps capabilities;
	struct dmx_frontend *frontend;
	void *priv;
	int (*open)(struct dmx_demux *);
	int (*close)(struct dmx_demux *);
	int (*write)(struct dmx_demux *, const char *, size_t);
	int (*allocate_ts_feed)(struct dmx_demux *, struct dmx_ts_feed **, dmx_ts_cb);
	int (*release_ts_feed)(struct dmx_demux *, struct dmx_ts_feed *);
	int (*allocate_section_feed)(struct dmx_demux *, struct dmx_section_feed **, dmx_section_cb);
	int (*release_section_feed)(struct dmx_demux *, struct dmx_section_feed *);
	int (*add_frontend)(struct dmx_demux *, struct dmx_frontend *);
	int (*remove_frontend)(struct dmx_demux *, struct dmx_frontend *);
	struct list_head * (*get_frontends)(struct dmx_demux *);
	int (*connect_frontend)(struct dmx_demux *, struct dmx_frontend *);
	int (*disconnect_frontend)(struct dmx_demux *);
	int (*get_pes_pids)(struct dmx_demux *, u16 *);
	int (*get_stc)(struct dmx_demux *, unsigned int, u64 *, unsigned int *);
};

struct dmx_section_filter {
	u8 filter_value[18];
	u8 filter_mask[18];
	u8 filter_mode[18];
	struct dmx_section_feed *parent;
	void *priv;
};

struct dmx_section_feed {
	int is_filtering;
	struct dmx_demux *parent;
	void *priv;
	int check_crc;
	u32 crc_val;
	u8 *secbuf;
	u8 secbuf_base[4284];
	u16 secbufp;
	u16 seclen;
	u16 tsfeedp;
	int (*set)(struct dmx_section_feed *, u16, int);
	int (*allocate_filter)(struct dmx_section_feed *, struct dmx_section_filter **);
	int (*release_filter)(struct dmx_section_feed *, struct dmx_section_filter *);
	int (*start_filtering)(struct dmx_section_feed *);
	int (*stop_filtering)(struct dmx_section_feed *);
};

enum dmx_frontend_source {
	DMX_MEMORY_FE = 0,
	DMX_FRONTEND_0 = 1,
};

struct dmx_frontend {
	struct list_head connectivity_list;
	enum dmx_frontend_source source;
};

struct dvb_ringbuffer {
	u8 *data;
	ssize_t size;
	ssize_t pread;
	ssize_t pwrite;
	int error;
	wait_queue_head_t queue;
	spinlock_t lock;
};

struct dvb_buffer {
	struct vb2_buffer vb;
	struct list_head list;
};

struct dvb_vb2_ctx {
	struct vb2_queue vb_q;
	struct mutex mutex;
	spinlock_t slock;
	struct list_head dvb_q;
	struct dvb_buffer *buf;
	int offset;
	int remain;
	int state;
	int buf_siz;
	int buf_cnt;
	int nonblocking;
	enum dmx_buffer_flags flags;
	u32 count;
	char name[21];
};

enum dmxdev_type {
	DMXDEV_TYPE_NONE = 0,
	DMXDEV_TYPE_SEC = 1,
	DMXDEV_TYPE_PES = 2,
};

enum dmxdev_state {
	DMXDEV_STATE_FREE = 0,
	DMXDEV_STATE_ALLOCATED = 1,
	DMXDEV_STATE_SET = 2,
	DMXDEV_STATE_GO = 3,
	DMXDEV_STATE_DONE = 4,
	DMXDEV_STATE_TIMEDOUT = 5,
};

struct dmxdev_feed {
	u16 pid;
	struct dmx_ts_feed *ts;
	struct list_head next;
};

struct dmxdev;

struct dmxdev_filter {
	union {
		struct dmx_section_filter *sec;
	} filter;
	union {
		struct list_head ts;
		struct dmx_section_feed *sec;
	} feed;
	union {
		struct dmx_sct_filter_params sec;
		struct dmx_pes_filter_params pes;
	} params;
	enum dmxdev_type type;
	enum dmxdev_state state;
	struct dmxdev *dev;
	struct dvb_ringbuffer buffer;
	struct dvb_vb2_ctx vb2_ctx;
	struct mutex mutex;
	struct timer_list timer;
	int todo;
	u8 secheader[3];
};

struct dmxdev {
	struct dvb_device *dvbdev;
	struct dvb_device *dvr_dvbdev;
	struct dmxdev_filter *filter;
	struct dmx_demux *demux;
	int filternum;
	int capabilities;
	unsigned int may_do_mmap: 1;
	unsigned int exit: 1;
	struct dmx_frontend *dvr_orig_fe;
	struct dvb_ringbuffer dvr_buffer;
	struct dvb_vb2_ctx dvr_vb2_ctx;
	struct mutex mutex;
	spinlock_t lock;
};

enum dvb_dmx_filter_type {
	DMX_TYPE_TS = 0,
	DMX_TYPE_SEC = 1,
};

enum dvb_dmx_state {
	DMX_STATE_FREE = 0,
	DMX_STATE_ALLOCATED = 1,
	DMX_STATE_READY = 2,
	DMX_STATE_GO = 3,
};

struct dvb_demux_feed;

struct dvb_demux_filter {
	struct dmx_section_filter filter;
	u8 maskandmode[18];
	u8 maskandnotmode[18];
	bool doneq;
	struct dvb_demux_filter *next;
	struct dvb_demux_feed *feed;
	int index;
	enum dvb_dmx_state state;
	enum dvb_dmx_filter_type type;
	u16 hw_handle;
};

struct dvb_demux;

struct dvb_demux_feed {
	union {
		struct dmx_ts_feed ts;
		struct dmx_section_feed sec;
	} feed;
	union {
		dmx_ts_cb ts;
		dmx_section_cb sec;
	} cb;
	struct dvb_demux *demux;
	void *priv;
	enum dvb_dmx_filter_type type;
	enum dvb_dmx_state state;
	u16 pid;
	ktime_t timeout;
	struct dvb_demux_filter *filter;
	u32 buffer_flags;
	enum ts_filter_type ts_type;
	enum dmx_ts_pes pes_type;
	int cc;
	bool pusi_seen;
	u16 peslen;
	struct list_head list_head;
	unsigned int index;
	int: 32;
};

struct dvb_demux {
	struct dmx_demux dmx;
	void *priv;
	int filternum;
	int feednum;
	int (*start_feed)(struct dvb_demux_feed *);
	int (*stop_feed)(struct dvb_demux_feed *);
	int (*write_to_decoder)(struct dvb_demux_feed *, const u8 *, size_t);
	u32 (*check_crc32)(struct dvb_demux_feed *, const u8 *, size_t);
	void (*memcopy)(struct dvb_demux_feed *, u8 *, const u8 *, size_t);
	int users;
	struct dvb_demux_filter *filter;
	struct dvb_demux_feed *feed;
	struct list_head frontend_list;
	struct dvb_demux_feed *pesfilter[20];
	u16 pids[20];
	struct list_head feed_list;
	u8 tsbuf[204];
	int tsbufp;
	struct mutex mutex;
	spinlock_t lock;
	uint8_t *cnt_storage;
	int: 32;
	ktime_t speed_last_time;
	uint32_t speed_pkts_cnt;
	int playing;
	int recording;
	int: 32;
};

struct ca_slot_info {
	int num;
	int type;
	unsigned int flags;
};

struct ca_caps {
	unsigned int slot_num;
	unsigned int slot_type;
	unsigned int descr_num;
	unsigned int descr_type;
};

struct dvb_ca_en50221 {
	struct module *owner;
	int (*read_attribute_mem)(struct dvb_ca_en50221 *, int, int);
	int (*write_attribute_mem)(struct dvb_ca_en50221 *, int, int, u8);
	int (*read_cam_control)(struct dvb_ca_en50221 *, int, u8);
	int (*write_cam_control)(struct dvb_ca_en50221 *, int, u8, u8);
	int (*read_data)(struct dvb_ca_en50221 *, int, u8 *, int);
	int (*write_data)(struct dvb_ca_en50221 *, int, u8 *, int);
	int (*slot_reset)(struct dvb_ca_en50221 *, int);
	int (*slot_shutdown)(struct dvb_ca_en50221 *, int);
	int (*slot_ts_enable)(struct dvb_ca_en50221 *, int);
	int (*poll_slot_status)(struct dvb_ca_en50221 *, int, int);
	void *data;
	void *private;
};

struct dvb_ca_slot {
	int slot_state;
	struct mutex slot_lock;
	atomic_t camchange_count;
	int camchange_type;
	u32 config_base;
	u8 config_option;
	u8 da_irq_supported: 1;
	int link_buf_size;
	struct dvb_ringbuffer rx_buffer;
	long unsigned int timeout;
};

struct dvb_ca_private {
	struct kref refcount;
	struct dvb_ca_en50221 *pub;
	struct dvb_device *dvbdev;
	u32 flags;
	unsigned int slot_count;
	struct dvb_ca_slot *slot_info;
	wait_queue_head_t wait_queue;
	struct task_struct *thread;
	unsigned int open: 1;
	unsigned int wakeup: 1;
	long unsigned int delay;
	int next_read_slot;
	struct mutex ioctl_mutex;
};

enum fe_caps {
	FE_IS_STUPID = 0,
	FE_CAN_INVERSION_AUTO = 1,
	FE_CAN_FEC_1_2 = 2,
	FE_CAN_FEC_2_3 = 4,
	FE_CAN_FEC_3_4 = 8,
	FE_CAN_FEC_4_5 = 16,
	FE_CAN_FEC_5_6 = 32,
	FE_CAN_FEC_6_7 = 64,
	FE_CAN_FEC_7_8 = 128,
	FE_CAN_FEC_8_9 = 256,
	FE_CAN_FEC_AUTO = 512,
	FE_CAN_QPSK = 1024,
	FE_CAN_QAM_16 = 2048,
	FE_CAN_QAM_32 = 4096,
	FE_CAN_QAM_64 = 8192,
	FE_CAN_QAM_128 = 16384,
	FE_CAN_QAM_256 = 32768,
	FE_CAN_QAM_AUTO = 65536,
	FE_CAN_TRANSMISSION_MODE_AUTO = 131072,
	FE_CAN_BANDWIDTH_AUTO = 262144,
	FE_CAN_GUARD_INTERVAL_AUTO = 524288,
	FE_CAN_HIERARCHY_AUTO = 1048576,
	FE_CAN_8VSB = 2097152,
	FE_CAN_16VSB = 4194304,
	FE_HAS_EXTENDED_CAPS = 8388608,
	FE_CAN_MULTISTREAM = 67108864,
	FE_CAN_TURBO_FEC = 134217728,
	FE_CAN_2G_MODULATION = 268435456,
	FE_NEEDS_BENDING = 536870912,
	FE_CAN_RECOVER = 1073741824,
	FE_CAN_MUTE_TS = 2147483648,
};

enum fe_type {
	FE_QPSK = 0,
	FE_QAM = 1,
	FE_OFDM = 2,
	FE_ATSC = 3,
};

struct dvb_frontend_info {
	char name[128];
	enum fe_type type;
	__u32 frequency_min;
	__u32 frequency_max;
	__u32 frequency_stepsize;
	__u32 frequency_tolerance;
	__u32 symbol_rate_min;
	__u32 symbol_rate_max;
	__u32 symbol_rate_tolerance;
	__u32 notifier_delay;
	enum fe_caps caps;
};

struct dvb_diseqc_master_cmd {
	__u8 msg[6];
	__u8 msg_len;
};

struct dvb_diseqc_slave_reply {
	__u8 msg[4];
	__u8 msg_len;
	int timeout;
};

enum fe_sec_voltage {
	SEC_VOLTAGE_13 = 0,
	SEC_VOLTAGE_18 = 1,
	SEC_VOLTAGE_OFF = 2,
};

enum fe_sec_tone_mode {
	SEC_TONE_ON = 0,
	SEC_TONE_OFF = 1,
};

enum fe_sec_mini_cmd {
	SEC_MINI_A = 0,
	SEC_MINI_B = 1,
};

enum fe_status {
	FE_NONE = 0,
	FE_HAS_SIGNAL = 1,
	FE_HAS_CARRIER = 2,
	FE_HAS_VITERBI = 4,
	FE_HAS_SYNC = 8,
	FE_HAS_LOCK = 16,
	FE_TIMEDOUT = 32,
	FE_REINIT = 64,
};

enum fe_spectral_inversion {
	INVERSION_OFF = 0,
	INVERSION_ON = 1,
	INVERSION_AUTO = 2,
};

enum fe_code_rate {
	FEC_NONE = 0,
	FEC_1_2 = 1,
	FEC_2_3 = 2,
	FEC_3_4 = 3,
	FEC_4_5 = 4,
	FEC_5_6 = 5,
	FEC_6_7 = 6,
	FEC_7_8 = 7,
	FEC_8_9 = 8,
	FEC_AUTO = 9,
	FEC_3_5 = 10,
	FEC_9_10 = 11,
	FEC_2_5 = 12,
};

enum fe_modulation {
	QPSK = 0,
	QAM_16 = 1,
	QAM_32 = 2,
	QAM_64 = 3,
	QAM_128 = 4,
	QAM_256 = 5,
	QAM_AUTO = 6,
	VSB_8 = 7,
	VSB_16 = 8,
	PSK_8 = 9,
	APSK_16 = 10,
	APSK_32 = 11,
	DQPSK = 12,
	QAM_4_NR = 13,
};

enum fe_transmit_mode {
	TRANSMISSION_MODE_2K = 0,
	TRANSMISSION_MODE_8K = 1,
	TRANSMISSION_MODE_AUTO = 2,
	TRANSMISSION_MODE_4K = 3,
	TRANSMISSION_MODE_1K = 4,
	TRANSMISSION_MODE_16K = 5,
	TRANSMISSION_MODE_32K = 6,
	TRANSMISSION_MODE_C1 = 7,
	TRANSMISSION_MODE_C3780 = 8,
};

enum fe_guard_interval {
	GUARD_INTERVAL_1_32 = 0,
	GUARD_INTERVAL_1_16 = 1,
	GUARD_INTERVAL_1_8 = 2,
	GUARD_INTERVAL_1_4 = 3,
	GUARD_INTERVAL_AUTO = 4,
	GUARD_INTERVAL_1_128 = 5,
	GUARD_INTERVAL_19_128 = 6,
	GUARD_INTERVAL_19_256 = 7,
	GUARD_INTERVAL_PN420 = 8,
	GUARD_INTERVAL_PN595 = 9,
	GUARD_INTERVAL_PN945 = 10,
};

enum fe_hierarchy {
	HIERARCHY_NONE = 0,
	HIERARCHY_1 = 1,
	HIERARCHY_2 = 2,
	HIERARCHY_4 = 3,
	HIERARCHY_AUTO = 4,
};

enum fe_interleaving {
	INTERLEAVING_NONE = 0,
	INTERLEAVING_AUTO = 1,
	INTERLEAVING_240 = 2,
	INTERLEAVING_720 = 3,
};

enum fe_pilot {
	PILOT_ON = 0,
	PILOT_OFF = 1,
	PILOT_AUTO = 2,
};

enum fe_rolloff {
	ROLLOFF_35 = 0,
	ROLLOFF_20 = 1,
	ROLLOFF_25 = 2,
	ROLLOFF_AUTO = 3,
};

enum fe_delivery_system {
	SYS_UNDEFINED = 0,
	SYS_DVBC_ANNEX_A = 1,
	SYS_DVBC_ANNEX_B = 2,
	SYS_DVBT = 3,
	SYS_DSS = 4,
	SYS_DVBS = 5,
	SYS_DVBS2 = 6,
	SYS_DVBH = 7,
	SYS_ISDBT = 8,
	SYS_ISDBS = 9,
	SYS_ISDBC = 10,
	SYS_ATSC = 11,
	SYS_ATSCMH = 12,
	SYS_DTMB = 13,
	SYS_CMMB = 14,
	SYS_DAB = 15,
	SYS_DVBT2 = 16,
	SYS_TURBO = 17,
	SYS_DVBC_ANNEX_C = 18,
};

struct dtv_stats {
	__u8 scale;
	union {
		__u64 uvalue;
		__s64 svalue;
	};
} __attribute__((packed));

struct dtv_fe_stats {
	__u8 len;
	struct dtv_stats stat[4];
} __attribute__((packed));

struct dtv_property {
	__u32 cmd;
	__u32 reserved[3];
	union {
		__u32 data;
		struct dtv_fe_stats st;
		struct {
			__u8 data[32];
			__u32 len;
			__u32 reserved1[3];
			void *reserved2;
		} buffer;
	} u;
	int result;
};

struct dtv_properties {
	__u32 num;
	struct dtv_property *props;
};

enum fe_bandwidth {
	BANDWIDTH_8_MHZ = 0,
	BANDWIDTH_7_MHZ = 1,
	BANDWIDTH_6_MHZ = 2,
	BANDWIDTH_AUTO = 3,
	BANDWIDTH_5_MHZ = 4,
	BANDWIDTH_10_MHZ = 5,
	BANDWIDTH_1_712_MHZ = 6,
};

typedef enum fe_status fe_status_t;

typedef enum fe_spectral_inversion fe_spectral_inversion_t;

typedef enum fe_code_rate fe_code_rate_t;

typedef enum fe_modulation fe_modulation_t;

typedef enum fe_transmit_mode fe_transmit_mode_t;

typedef enum fe_bandwidth fe_bandwidth_t;

typedef enum fe_guard_interval fe_guard_interval_t;

typedef enum fe_hierarchy fe_hierarchy_t;

struct dvb_qpsk_parameters {
	__u32 symbol_rate;
	fe_code_rate_t fec_inner;
};

struct dvb_qam_parameters {
	__u32 symbol_rate;
	fe_code_rate_t fec_inner;
	fe_modulation_t modulation;
};

struct dvb_vsb_parameters {
	fe_modulation_t modulation;
};

struct dvb_ofdm_parameters {
	fe_bandwidth_t bandwidth;
	fe_code_rate_t code_rate_HP;
	fe_code_rate_t code_rate_LP;
	fe_modulation_t constellation;
	fe_transmit_mode_t transmission_mode;
	fe_guard_interval_t guard_interval;
	fe_hierarchy_t hierarchy_information;
};

struct dvb_frontend_parameters {
	__u32 frequency;
	fe_spectral_inversion_t inversion;
	union {
		struct dvb_qpsk_parameters qpsk;
		struct dvb_qam_parameters qam;
		struct dvb_ofdm_parameters ofdm;
		struct dvb_vsb_parameters vsb;
	} u;
};

struct dvb_frontend_event {
	fe_status_t status;
	struct dvb_frontend_parameters parameters;
};

struct dvb_frontend_tune_settings {
	int min_delay_ms;
	int step_size;
	int max_drift;
};

struct dvb_tuner_info {
	char name[128];
	u32 frequency_min_hz;
	u32 frequency_max_hz;
	u32 frequency_step_hz;
	u32 bandwidth_min;
	u32 bandwidth_max;
	u32 bandwidth_step;
};

struct analog_parameters {
	unsigned int frequency;
	unsigned int mode;
	unsigned int audmode;
	int: 32;
	u64 std;
};

enum dvbfe_algo {
	DVBFE_ALGO_HW = 1,
	DVBFE_ALGO_SW = 2,
	DVBFE_ALGO_CUSTOM = 4,
	DVBFE_ALGO_RECOVERY = 2147483648,
};

enum dvbfe_search {
	DVBFE_ALGO_SEARCH_SUCCESS = 1,
	DVBFE_ALGO_SEARCH_ASLEEP = 2,
	DVBFE_ALGO_SEARCH_FAILED = 4,
	DVBFE_ALGO_SEARCH_INVALID = 8,
	DVBFE_ALGO_SEARCH_AGAIN = 16,
	DVBFE_ALGO_SEARCH_ERROR = 2147483648,
};

struct dvb_frontend;

struct dvb_tuner_ops {
	struct dvb_tuner_info info;
	void (*release)(struct dvb_frontend *);
	int (*init)(struct dvb_frontend *);
	int (*sleep)(struct dvb_frontend *);
	int (*suspend)(struct dvb_frontend *);
	int (*resume)(struct dvb_frontend *);
	int (*set_params)(struct dvb_frontend *);
	int (*set_analog_params)(struct dvb_frontend *, struct analog_parameters *);
	int (*set_config)(struct dvb_frontend *, void *);
	int (*get_frequency)(struct dvb_frontend *, u32 *);
	int (*get_bandwidth)(struct dvb_frontend *, u32 *);
	int (*get_if_frequency)(struct dvb_frontend *, u32 *);
	int (*get_status)(struct dvb_frontend *, u32 *);
	int (*get_rf_strength)(struct dvb_frontend *, u16 *);
	int (*get_afc)(struct dvb_frontend *, s32 *);
	int (*calc_regs)(struct dvb_frontend *, u8 *, int);
	int (*set_frequency)(struct dvb_frontend *, u32);
	int (*set_bandwidth)(struct dvb_frontend *, u32);
};

struct dvb_frontend_internal_info {
	char name[128];
	u32 frequency_min_hz;
	u32 frequency_max_hz;
	u32 frequency_stepsize_hz;
	u32 frequency_tolerance_hz;
	u32 symbol_rate_min;
	u32 symbol_rate_max;
	u32 symbol_rate_tolerance;
	enum fe_caps caps;
};

struct analog_demod_info {
	char *name;
};

struct analog_demod_ops {
	struct analog_demod_info info;
	void (*set_params)(struct dvb_frontend *, struct analog_parameters *);
	int (*has_signal)(struct dvb_frontend *, u16 *);
	int (*get_afc)(struct dvb_frontend *, s32 *);
	void (*tuner_status)(struct dvb_frontend *);
	void (*standby)(struct dvb_frontend *);
	void (*release)(struct dvb_frontend *);
	int (*i2c_gate_ctrl)(struct dvb_frontend *, int);
	int (*set_config)(struct dvb_frontend *, void *);
};

struct dtv_frontend_properties;

struct dvb_frontend_ops {
	struct dvb_frontend_internal_info info;
	u8 delsys[8];
	void (*detach)(struct dvb_frontend *);
	void (*release)(struct dvb_frontend *);
	void (*release_sec)(struct dvb_frontend *);
	int (*init)(struct dvb_frontend *);
	int (*sleep)(struct dvb_frontend *);
	int (*suspend)(struct dvb_frontend *);
	int (*resume)(struct dvb_frontend *);
	int (*write)(struct dvb_frontend *, const u8 *, int);
	int (*tune)(struct dvb_frontend *, bool, unsigned int, unsigned int *, enum fe_status *);
	enum dvbfe_algo (*get_frontend_algo)(struct dvb_frontend *);
	int (*set_frontend)(struct dvb_frontend *);
	int (*get_tune_settings)(struct dvb_frontend *, struct dvb_frontend_tune_settings *);
	int (*get_frontend)(struct dvb_frontend *, struct dtv_frontend_properties *);
	int (*read_status)(struct dvb_frontend *, enum fe_status *);
	int (*read_ber)(struct dvb_frontend *, u32 *);
	int (*read_signal_strength)(struct dvb_frontend *, u16 *);
	int (*read_snr)(struct dvb_frontend *, u16 *);
	int (*read_ucblocks)(struct dvb_frontend *, u32 *);
	int (*diseqc_reset_overload)(struct dvb_frontend *);
	int (*diseqc_send_master_cmd)(struct dvb_frontend *, struct dvb_diseqc_master_cmd *);
	int (*diseqc_recv_slave_reply)(struct dvb_frontend *, struct dvb_diseqc_slave_reply *);
	int (*diseqc_send_burst)(struct dvb_frontend *, enum fe_sec_mini_cmd);
	int (*set_tone)(struct dvb_frontend *, enum fe_sec_tone_mode);
	int (*set_voltage)(struct dvb_frontend *, enum fe_sec_voltage);
	int (*enable_high_lnb_voltage)(struct dvb_frontend *, long int);
	int (*dishnetwork_send_legacy_command)(struct dvb_frontend *, long unsigned int);
	int (*i2c_gate_ctrl)(struct dvb_frontend *, int);
	int (*ts_bus_ctrl)(struct dvb_frontend *, int);
	int (*set_lna)(struct dvb_frontend *);
	enum dvbfe_search (*search)(struct dvb_frontend *);
	struct dvb_tuner_ops tuner_ops;
	struct analog_demod_ops analog_ops;
};

struct dtv_frontend_properties {
	u32 frequency;
	enum fe_modulation modulation;
	enum fe_sec_voltage voltage;
	enum fe_sec_tone_mode sectone;
	enum fe_spectral_inversion inversion;
	enum fe_code_rate fec_inner;
	enum fe_transmit_mode transmission_mode;
	u32 bandwidth_hz;
	enum fe_guard_interval guard_interval;
	enum fe_hierarchy hierarchy;
	u32 symbol_rate;
	enum fe_code_rate code_rate_HP;
	enum fe_code_rate code_rate_LP;
	enum fe_pilot pilot;
	enum fe_rolloff rolloff;
	enum fe_delivery_system delivery_system;
	enum fe_interleaving interleaving;
	u8 isdbt_partial_reception;
	u8 isdbt_sb_mode;
	u8 isdbt_sb_subchannel;
	char: 8;
	u32 isdbt_sb_segment_idx;
	u32 isdbt_sb_segment_count;
	u8 isdbt_layer_enabled;
	int: 24;
	struct {
		u8 segment_count;
		enum fe_code_rate fec;
		enum fe_modulation modulation;
		u8 interleaving;
	} layer[3];
	u32 stream_id;
	u32 scrambling_sequence_index;
	u8 atscmh_fic_ver;
	u8 atscmh_parade_id;
	u8 atscmh_nog;
	u8 atscmh_tnog;
	u8 atscmh_sgn;
	u8 atscmh_prc;
	u8 atscmh_rs_frame_mode;
	u8 atscmh_rs_frame_ensemble;
	u8 atscmh_rs_code_mode_pri;
	u8 atscmh_rs_code_mode_sec;
	u8 atscmh_sccc_block_mode;
	u8 atscmh_sccc_code_mode_a;
	u8 atscmh_sccc_code_mode_b;
	u8 atscmh_sccc_code_mode_c;
	u8 atscmh_sccc_code_mode_d;
	char: 8;
	u32 lna;
	struct dtv_fe_stats strength;
	struct dtv_fe_stats cnr;
	struct dtv_fe_stats pre_bit_error;
	struct dtv_fe_stats pre_bit_count;
	struct dtv_fe_stats post_bit_error;
	struct dtv_fe_stats post_bit_count;
	struct dtv_fe_stats block_error;
	struct dtv_fe_stats block_count;
} __attribute__((packed));

struct dvb_frontend {
	struct kref refcount;
	struct dvb_frontend_ops ops;
	struct dvb_adapter *dvb;
	void *demodulator_priv;
	void *tuner_priv;
	void *frontend_priv;
	void *sec_priv;
	void *analog_demod_priv;
	struct dtv_frontend_properties dtv_property_cache;
	int (*callback)(void *, int, int, int);
	int id;
	unsigned int exit;
};

struct dvb_fe_events {
	struct dvb_frontend_event events[8];
	int eventw;
	int eventr;
	int overflow;
	wait_queue_head_t wait_queue;
	struct mutex mtx;
};

struct dvb_frontend_private {
	struct dvb_device *dvbdev;
	struct dvb_frontend_parameters parameters_out;
	struct dvb_fe_events events;
	struct semaphore sem;
	struct list_head list_head;
	wait_queue_head_t wait_queue;
	struct task_struct *thread;
	long unsigned int release_jiffies;
	unsigned int wakeup;
	enum fe_status status;
	long unsigned int tune_mode_flags;
	unsigned int delay;
	unsigned int reinitialise;
	int tone;
	int voltage;
	unsigned int state;
	unsigned int bending;
	int lnb_drift;
	unsigned int inversion;
	unsigned int auto_step;
	unsigned int auto_sub_step;
	unsigned int started_auto_step;
	unsigned int min_delay;
	unsigned int max_drift;
	unsigned int step_size;
	int quality;
	unsigned int check_wrapped;
	enum dvbfe_search algo_status;
};

enum dvbv3_emulation_type {
	DVBV3_UNKNOWN = 0,
	DVBV3_QPSK = 1,
	DVBV3_QAM = 2,
	DVBV3_OFDM = 3,
	DVBV3_ATSC = 4,
};

struct dvb_net_if {
	__u16 pid;
	__u16 if_num;
	__u8 feedtype;
};

struct __dvb_net_if_old {
	__u16 pid;
	__u16 if_num;
};

struct dvb_net {
	struct dvb_device *dvbdev;
	struct net_device *device[10];
	int state[10];
	unsigned int exit: 1;
	struct dmx_demux *demux;
	struct mutex ioctl_mutex;
};

struct dvb_net_priv {
	int in_use;
	u16 pid;
	struct net_device *net;
	struct dvb_net *host;
	struct dmx_demux *demux;
	struct dmx_section_feed *secfeed;
	struct dmx_section_filter *secfilter;
	struct dmx_ts_feed *tsfeed;
	int multi_num;
	struct dmx_section_filter *multi_secfilter[10];
	unsigned char multi_macs[60];
	int rx_mode;
	struct work_struct set_multicast_list_wq;
	struct work_struct restart_net_feed_wq;
	unsigned char feedtype;
	int need_pusi;
	unsigned char tscc;
	struct sk_buff *ule_skb;
	unsigned char *ule_next_hdr;
	short unsigned int ule_sndu_len;
	short unsigned int ule_sndu_type;
	unsigned char ule_sndu_type_1;
	unsigned char ule_dbit;
	unsigned char ule_bridged;
	int ule_sndu_remain;
	long unsigned int ts_count;
	struct mutex mutex;
};

struct dvb_net_ule_handle {
	struct net_device *dev;
	struct dvb_net_priv *priv;
	struct ethhdr *ethh;
	const u8 *buf;
	size_t buf_len;
	long unsigned int skipped;
	const u8 *ts;
	const u8 *ts_end;
	const u8 *from_where;
	u8 ts_remain;
	u8 how_much;
	u8 new_ts;
	bool error;
};

struct rc_map_list {
	struct list_head list;
	struct rc_map map;
};

struct lirc_scancode {
	__u64 timestamp;
	__u16 flags;
	__u16 rc_proto;
	__u32 keycode;
	__u64 scancode;
};

enum rc_filter_type {
	RC_FILTER_NORMAL = 0,
	RC_FILTER_WAKEUP = 1,
	RC_FILTER_MAX = 2,
};

struct ir_raw_event {
	union {
		u32 duration;
		u32 carrier;
	};
	u8 duty_cycle;
	unsigned int pulse: 1;
	unsigned int overflow: 1;
	unsigned int timeout: 1;
	unsigned int carrier_report: 1;
};

struct ir_raw_event_ctrl {
	struct list_head list;
	struct task_struct *thread;
	struct {
		union {
			struct __kfifo kfifo;
			struct ir_raw_event *type;
			const struct ir_raw_event *const_type;
			char (*rectype)[0];
			struct ir_raw_event *ptr;
			const struct ir_raw_event *ptr_const;
		};
		struct ir_raw_event buf[512];
	} kfifo;
	ktime_t last_event;
	struct rc_dev *dev;
	spinlock_t edge_spinlock;
	struct timer_list edge_handle;
	struct ir_raw_event prev_ev;
	struct ir_raw_event this_ev;
	int: 32;
};

struct rc_filter_attribute {
	struct device_attribute attr;
	enum rc_filter_type type;
	bool mask;
};

struct ir_raw_handler {
	struct list_head list;
	u64 protocols;
	int (*decode)(struct rc_dev *, struct ir_raw_event);
	int (*encode)(enum rc_proto, u32, struct ir_raw_event *, unsigned int);
	u32 carrier;
	u32 min_timeout;
	int (*raw_register)(struct rc_dev *);
	int (*raw_unregister)(struct rc_dev *);
};

struct ir_raw_timings_manchester {
	unsigned int leader_pulse;
	unsigned int leader_space;
	unsigned int clock;
	unsigned int invert: 1;
	unsigned int trailer_space;
};

struct ir_raw_timings_pd {
	unsigned int header_pulse;
	unsigned int header_space;
	unsigned int bit_pulse;
	unsigned int bit_space[2];
	unsigned int trailer_pulse;
	unsigned int trailer_space;
	unsigned int msb_first: 1;
};

struct ir_raw_timings_pl {
	unsigned int header_pulse;
	unsigned int bit_space;
	unsigned int bit_pulse[2];
	unsigned int trailer_space;
	unsigned int msb_first: 1;
};

struct gpio_rc_dev {
	struct rc_dev *rcdev;
	struct gpio_desc *gpiod;
	int irq;
	struct device *pmdev;
	struct pm_qos_request qos;
};

enum vb2_memory {
	VB2_MEMORY_UNKNOWN = 0,
	VB2_MEMORY_MMAP = 1,
	VB2_MEMORY_USERPTR = 2,
	VB2_MEMORY_DMABUF = 4,
};

struct vb2_fileio_buf {
	void *vaddr;
	unsigned int size;
	unsigned int pos;
	unsigned int queued: 1;
};

struct vb2_fileio_data {
	unsigned int count;
	unsigned int type;
	unsigned int memory;
	struct vb2_fileio_buf bufs[32];
	unsigned int cur_index;
	unsigned int initial_index;
	unsigned int q_count;
	unsigned int dq_count;
	unsigned int read_once: 1;
	unsigned int write_immediately: 1;
};

typedef int (*vb2_thread_fnc)(struct vb2_buffer *, void *);

struct vb2_threadio_data {
	struct task_struct *thread;
	vb2_thread_fnc fnc;
	void *priv;
	bool stop;
};

struct frame_vector {
	unsigned int nr_allocated;
	unsigned int nr_frames;
	bool got_ref;
	bool is_pfns;
	void *ptrs[0];
};

struct trace_event_raw_vb2_event_class {
	struct trace_entry ent;
	void *owner;
	u32 queued_count;
	int owned_by_drv_count;
	u32 index;
	u32 type;
	u32 bytesused;
	u64 timestamp;
	char __data[0];
};

struct trace_event_data_offsets_vb2_event_class {};

typedef void (*btf_trace_vb2_buf_done)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_buf_queue)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_dqbuf)(void *, struct vb2_queue *, struct vb2_buffer *);

typedef void (*btf_trace_vb2_qbuf)(void *, struct vb2_queue *, struct vb2_buffer *);

struct vb2_vmarea_handler {
	refcount_t *refcount;
	void (*put)(void *);
	void *arg;
};

struct vb2_dc_buf {
	struct device *dev;
	void *vaddr;
	long unsigned int size;
	void *cookie;
	dma_addr_t dma_addr;
	long unsigned int attrs;
	enum dma_data_direction dma_dir;
	struct sg_table *dma_sgt;
	struct frame_vector *vec;
	struct vb2_vmarea_handler handler;
	refcount_t refcount;
	struct sg_table *sgt_base;
	struct dma_buf_attachment *db_attach;
	struct vb2_buffer *vb;
	bool non_coherent_mem;
};

struct vb2_dc_attachment {
	struct sg_table sgt;
	enum dma_data_direction dma_dir;
};

struct vb2_dma_sg_buf {
	struct device *dev;
	void *vaddr;
	struct page **pages;
	struct frame_vector *vec;
	int offset;
	enum dma_data_direction dma_dir;
	struct sg_table sg_table;
	struct sg_table *dma_sgt;
	size_t size;
	unsigned int num_pages;
	refcount_t refcount;
	struct vb2_vmarea_handler handler;
	struct dma_buf_attachment *db_attach;
	struct vb2_buffer *vb;
};

struct vb2_dma_sg_attachment {
	struct sg_table sgt;
	enum dma_data_direction dma_dir;
};

struct vb2_vmalloc_buf {
	void *vaddr;
	struct frame_vector *vec;
	enum dma_data_direction dma_dir;
	long unsigned int size;
	refcount_t refcount;
	struct vb2_vmarea_handler handler;
	struct dma_buf *dbuf;
};

struct vb2_vmalloc_attachment {
	struct sg_table sgt;
	enum dma_data_direction dma_dir;
};

struct pxp_fmt {
	u32 fourcc;
	int depth;
	u32 types;
};

struct pxp_q_data {
	unsigned int width;
	unsigned int height;
	unsigned int bytesperline;
	unsigned int sizeimage;
	unsigned int sequence;
	struct pxp_fmt *fmt;
	enum v4l2_ycbcr_encoding ycbcr_enc;
	enum v4l2_quantization quant;
};

enum {
	V4L2_M2M_SRC = 0,
	V4L2_M2M_DST = 1,
};

struct pxp_dev {
	struct v4l2_device v4l2_dev;
	struct video_device vfd;
	struct clk *clk;
	void *mmio;
	atomic_t num_inst;
	struct mutex dev_mutex;
	spinlock_t irqlock;
	struct v4l2_m2m_dev *m2m_dev;
};

struct pxp_ctx {
	struct v4l2_fh fh;
	struct pxp_dev *dev;
	struct v4l2_ctrl_handler hdl;
	int aborting;
	int mode;
	u8 alpha_component;
	u8 rotation;
	enum v4l2_colorspace colorspace;
	enum v4l2_xfer_func xfer_func;
	struct pxp_q_data q_data[2];
};

struct of_endpoint {
	unsigned int port;
	unsigned int id;
	const struct device_node *local_node;
};

struct mux_control;

struct video_mux {
	struct v4l2_subdev subdev;
	struct v4l2_async_notifier notifier;
	struct media_pad *pads;
	struct v4l2_mbus_framefmt *format_mbus;
	struct mux_control *mux;
	struct mutex lock;
	int active;
};

struct ipu_pos {
	u32 x;
	u32 y;
};

struct ipu_crop {
	struct ipu_pos pos;
	u32 w;
	u32 h;
};

struct ipu_deinterlace {
	bool enable;
	u8 motion;
	u8 field_fmt;
};

struct ipu_input {
	u32 width;
	u32 height;
	u32 format;
	struct ipu_crop crop;
	dma_addr_t paddr;
	struct ipu_deinterlace deinterlace;
	dma_addr_t paddr_n;
};

struct ipu_alpha {
	u8 mode;
	u8 gvalue;
	dma_addr_t loc_alp_paddr;
};

struct ipu_colorkey {
	bool enable;
	u32 value;
};

struct ipu_overlay {
	u32 width;
	u32 height;
	u32 format;
	struct ipu_crop crop;
	struct ipu_alpha alpha;
	struct ipu_colorkey colorkey;
	dma_addr_t paddr;
};

struct ipu_output {
	u32 width;
	u32 height;
	u32 format;
	u8 rotate;
	struct ipu_crop crop;
	dma_addr_t paddr;
};

struct ipu_task {
	struct ipu_input input;
	struct ipu_output output;
	bool overlay_en;
	struct ipu_overlay overlay;
	u8 priority;
	u8 task_id;
	int timeout;
};

enum {
	IPU_CHECK_OK = 0,
	IPU_CHECK_WARN_INPUT_OFFS_NOT8ALIGN = 1,
	IPU_CHECK_WARN_OUTPUT_OFFS_NOT8ALIGN = 2,
	IPU_CHECK_WARN_OVERLAY_OFFS_NOT8ALIGN = 4,
	IPU_CHECK_ERR_MIN = 5,
	IPU_CHECK_ERR_INPUT_CROP = 6,
	IPU_CHECK_ERR_OUTPUT_CROP = 7,
	IPU_CHECK_ERR_OVERLAY_CROP = 8,
	IPU_CHECK_ERR_INPUT_OVER_LIMIT = 9,
	IPU_CHECK_ERR_OV_OUT_NO_FIT = 10,
	IPU_CHECK_ERR_OVERLAY_WITH_VDI = 11,
	IPU_CHECK_ERR_PROC_NO_NEED = 12,
	IPU_CHECK_ERR_SPLIT_INPUTW_OVER = 13,
	IPU_CHECK_ERR_SPLIT_INPUTH_OVER = 14,
	IPU_CHECK_ERR_SPLIT_OUTPUTW_OVER = 15,
	IPU_CHECK_ERR_SPLIT_OUTPUTH_OVER = 16,
	IPU_CHECK_ERR_SPLIT_WITH_ROT = 17,
	IPU_CHECK_ERR_NOT_SUPPORT = 18,
	IPU_CHECK_ERR_NOT16ALIGN = 19,
	IPU_CHECK_ERR_W_DOWNSIZE_OVER = 20,
	IPU_CHECK_ERR_H_DOWNSIZE_OVER = 21,
};

struct mxc_vout_fb {
	char *name;
	int ipu_id;
	struct v4l2_rect crop_bounds;
	unsigned int disp_fmt;
	bool disp_support_csc;
	bool disp_support_windows;
};

struct dma_mem {
	void *vaddr;
	dma_addr_t paddr;
	size_t size;
};

struct mxc_vout_output {
	int open_cnt;
	struct fb_info *fbi;
	long unsigned int fb_smem_start;
	long unsigned int fb_smem_len;
	struct video_device *vfd;
	struct mutex mutex;
	struct mutex task_lock;
	struct mutex accs_lock;
	enum v4l2_buf_type type;
	struct videobuf_queue vbq;
	spinlock_t vbq_lock;
	struct list_head queue_list;
	struct list_head active_list;
	struct v4l2_rect crop_bounds;
	unsigned int disp_fmt;
	struct mxcfb_pos win_pos;
	bool disp_support_windows;
	bool disp_support_csc;
	bool fmt_init;
	bool release;
	bool linear_bypass_pp;
	bool vdoa_1080p;
	bool tiled_bypass_pp;
	struct v4l2_rect in_rect;
	struct ipu_task task;
	struct ipu_task vdoa_task;
	struct dma_mem vdoa_work;
	struct dma_mem vdoa_output[2];
	bool timer_stop;
	int: 24;
	int: 32;
	struct hrtimer timer;
	struct workqueue_struct *v4l_wq;
	struct work_struct disp_work;
	long unsigned int frame_count;
	long unsigned int vdi_frame_cnt;
	int: 32;
	ktime_t start_ktime;
	int ctrl_rotate;
	int ctrl_vflip;
	int ctrl_hflip;
	dma_addr_t disp_bufs[3];
	struct videobuf_buffer *pre1_vb;
	struct videobuf_buffer *pre2_vb;
	bool input_crop;
	int: 24;
	int: 32;
};

struct mxc_vout_dev {
	struct device *dev;
	struct v4l2_device v4l2_dev;
	struct mxc_vout_output *out[6];
	int out_num;
};

struct pxp_buffer {
	struct videobuf_buffer vb;
	struct dma_async_tx_descriptor *txd;
	struct scatterlist sg[3];
	int: 32;
};

struct pxp_data_format;

struct pxps___3 {
	struct platform_device *pdev;
	spinlock_t lock;
	struct mutex mutex;
	int users;
	struct video_device *vdev;
	struct videobuf_queue s0_vbq;
	struct pxp_buffer *active;
	struct list_head outq;
	struct pxp_channel *pxp_channel[1];
	struct pxp_config_data pxp_conf;
	struct dma_mem outbuf;
	int output;
	struct pxp_data_format *s0_fmt;
	struct fb_info *fbi;
	struct v4l2_framebuffer fb;
	int overlay_state;
	int global_alpha_state;
	u8 global_alpha;
	int s1_chromakey_state;
	u32 s1_chromakey;
	int fb_blank;
	int: 32;
};

struct pxp_data_format {
	char *name;
	unsigned int bpp;
	u32 fourcc;
	enum v4l2_colorspace colorspace;
};

enum v4l2_power_line_frequency {
	V4L2_CID_POWER_LINE_FREQUENCY_DISABLED = 0,
	V4L2_CID_POWER_LINE_FREQUENCY_50HZ = 1,
	V4L2_CID_POWER_LINE_FREQUENCY_60HZ = 2,
	V4L2_CID_POWER_LINE_FREQUENCY_AUTO = 3,
};

enum v4l2_deemphasis {
	V4L2_DEEMPHASIS_DISABLED = 0,
	V4L2_DEEMPHASIS_50_uS = 1,
	V4L2_DEEMPHASIS_75_uS = 2,
};

enum si476x_ctrl_id {
	V4L2_CID_SI476X_RSSI_THRESHOLD = 9967937,
	V4L2_CID_SI476X_SNR_THRESHOLD = 9967938,
	V4L2_CID_SI476X_MAX_TUNE_ERROR = 9967939,
	V4L2_CID_SI476X_HARMONICS_COUNT = 9967940,
	V4L2_CID_SI476X_DIVERSITY_MODE = 9967941,
	V4L2_CID_SI476X_INTERCHIP_LINK = 9967942,
};

enum si476x_rdsint_sources {
	SI476X_RDSTPPTY = 16,
	SI476X_RDSPI = 8,
	SI476X_RDSSYNC = 2,
	SI476X_RDSRECV = 1,
};

enum si476x_am_receiver_properties {
	SI476X_PROP_AUDIO_PWR_LINE_FILTER = 771,
};

enum si476x_fm_receiver_properties {
	SI476X_PROP_AUDIO_DEEMPHASIS = 770,
	SI476X_PROP_FM_RDS_INTERRUPT_SOURCE = 16384,
	SI476X_PROP_FM_RDS_INTERRUPT_FIFO_COUNT = 16385,
	SI476X_PROP_FM_RDS_CONFIG = 16386,
};

enum si476x_prop_audio_pwr_line_filter_bits {
	SI476X_PROP_PWR_HARMONICS_MASK = 31,
	SI476X_PROP_PWR_GRID_MASK = 256,
	SI476X_PROP_PWR_ENABLE_MASK = 512,
	SI476X_PROP_PWR_GRID_50HZ = 0,
	SI476X_PROP_PWR_GRID_60HZ = 256,
};

enum si476x_prop_fm_rds_config_bits {
	SI476X_PROP_RDSEN_MASK = 1,
	SI476X_PROP_RDSEN = 1,
};

enum si476x_freq_bands {
	SI476X_BAND_FM = 0,
	SI476X_BAND_AM = 1,
};

enum phase_diversity_modes_idx {
	SI476X_IDX_PHDIV_DISABLED = 0,
	SI476X_IDX_PHDIV_PRIMARY_COMBINING = 1,
	SI476X_IDX_PHDIV_PRIMARY_ANTENNA = 2,
	SI476X_IDX_PHDIV_SECONDARY_ANTENNA = 3,
	SI476X_IDX_PHDIV_SECONDARY_COMBINING = 4,
};

enum si476x_ctrl_idx {
	SI476X_IDX_RSSI_THRESHOLD = 0,
	SI476X_IDX_SNR_THRESHOLD = 1,
	SI476X_IDX_MAX_TUNE_ERROR = 2,
	SI476X_IDX_HARMONICS_COUNT = 3,
	SI476X_IDX_DIVERSITY_MODE = 4,
	SI476X_IDX_INTERCHIP_LINK = 5,
};

struct si476x_radio_ops {
	int (*tune_freq)(struct si476x_core *, struct si476x_tune_freq_args *);
	int (*seek_start)(struct si476x_core *, bool, bool);
	int (*rsq_status)(struct si476x_core *, struct si476x_rsq_status_args *, struct si476x_rsq_status_report *);
	int (*rds_blckcnt)(struct si476x_core *, bool, struct si476x_rds_blockcount_report *);
	int (*phase_diversity)(struct si476x_core *, enum si476x_phase_diversity_mode);
	int (*phase_div_status)(struct si476x_core *);
	int (*acf_status)(struct si476x_core *, struct si476x_acf_status_report *);
	int (*agc_status)(struct si476x_core *, struct si476x_agc_status_report *);
};

struct si476x_radio {
	struct v4l2_device v4l2dev;
	struct video_device videodev;
	struct v4l2_ctrl_handler ctrl_handler;
	struct si476x_core *core;
	const struct si476x_radio_ops *ops;
	struct dentry *debugfs;
	u32 audmode;
};

struct pps_ktime {
	__s64 sec;
	__s32 nsec;
	__u32 flags;
};

struct pps_kinfo {
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	int: 32;
};

struct pps_kparams {
	int api_version;
	int mode;
	struct pps_ktime assert_off_tu;
	struct pps_ktime clear_off_tu;
};

struct pps_fdata {
	struct pps_kinfo info;
	struct pps_ktime timeout;
};

struct pps_bind_args {
	int tsformat;
	int edge;
	int consumer;
};

struct pps_device;

struct pps_source_info {
	char name[32];
	char path[32];
	int mode;
	void (*echo)(struct pps_device *, int, void *);
	struct module *owner;
	struct device *dev;
};

struct pps_device {
	struct pps_source_info info;
	struct pps_kparams params;
	__u32 assert_sequence;
	__u32 clear_sequence;
	struct pps_ktime assert_tu;
	struct pps_ktime clear_tu;
	int current_mode;
	unsigned int last_ev;
	wait_queue_head_t queue;
	unsigned int id;
	const void *lookup_cookie;
	struct cdev cdev;
	struct device *dev;
	struct fasync_struct *async_queue;
	spinlock_t lock;
	int: 32;
};

struct ptp_extts_event {
	struct ptp_clock_time t;
	unsigned int index;
	unsigned int flags;
	unsigned int rsv[2];
};

struct timestamp_event_queue {
	struct ptp_extts_event buf[128];
	int head;
	int tail;
	spinlock_t lock;
	int: 32;
};

struct ptp_clock {
	struct posix_clock clock;
	int: 32;
	struct device dev;
	struct ptp_clock_info *info;
	dev_t devid;
	int index;
	struct pps_device *pps_source;
	long int dialed_frequency;
	int: 32;
	struct timestamp_event_queue tsevq;
	struct mutex tsevq_mux;
	struct mutex pincfg_mux;
	wait_queue_head_t tsev_wq;
	int defunct;
	struct device_attribute *pin_dev_attr;
	struct attribute **pin_attr;
	struct attribute_group pin_attr_group;
	const struct attribute_group *pin_attr_groups[2];
	struct kthread_worker *kworker;
	struct kthread_delayed_work aux_work;
	unsigned int max_vclocks;
	unsigned int n_vclocks;
	int *vclock_index;
	struct mutex n_vclocks_mux;
	bool is_virtual_clock;
	bool has_cycles;
	int: 16;
	int: 32;
};

struct ptp_vclock {
	struct ptp_clock *pclock;
	struct ptp_clock_info info;
	struct ptp_clock *clock;
	struct hlist_node vclock_hash_node;
	struct cyclecounter cc;
	struct timecounter tc;
	spinlock_t lock;
	int: 32;
};

struct ptp_clock_caps {
	int max_adj;
	int n_alarm;
	int n_ext_ts;
	int n_per_out;
	int pps;
	int n_pins;
	int cross_timestamping;
	int adjust_phase;
	int rsv[12];
};

struct ptp_sys_offset {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[51];
};

struct ptp_sys_offset_extended {
	unsigned int n_samples;
	unsigned int rsv[3];
	struct ptp_clock_time ts[75];
};

struct ptp_sys_offset_precise {
	struct ptp_clock_time device;
	struct ptp_clock_time sys_realtime;
	struct ptp_clock_time sys_monoraw;
	unsigned int rsv[4];
};

struct kvm_ptp_clock {
	struct ptp_clock *ptp_clock;
	struct ptp_clock_info caps;
};

struct syscon_reboot_context {
	struct regmap *map;
	u32 offset;
	u32 value;
	u32 mask;
	struct notifier_block restart_handler;
};

enum {
	POWER_SUPPLY_TECHNOLOGY_UNKNOWN = 0,
	POWER_SUPPLY_TECHNOLOGY_NiMH = 1,
	POWER_SUPPLY_TECHNOLOGY_LION = 2,
	POWER_SUPPLY_TECHNOLOGY_LIPO = 3,
	POWER_SUPPLY_TECHNOLOGY_LiFe = 4,
	POWER_SUPPLY_TECHNOLOGY_NiCd = 5,
	POWER_SUPPLY_TECHNOLOGY_LiMn = 6,
};

enum power_supply_property {
	POWER_SUPPLY_PROP_STATUS = 0,
	POWER_SUPPLY_PROP_CHARGE_TYPE = 1,
	POWER_SUPPLY_PROP_HEALTH = 2,
	POWER_SUPPLY_PROP_PRESENT = 3,
	POWER_SUPPLY_PROP_ONLINE = 4,
	POWER_SUPPLY_PROP_AUTHENTIC = 5,
	POWER_SUPPLY_PROP_TECHNOLOGY = 6,
	POWER_SUPPLY_PROP_CYCLE_COUNT = 7,
	POWER_SUPPLY_PROP_VOLTAGE_MAX = 8,
	POWER_SUPPLY_PROP_VOLTAGE_MIN = 9,
	POWER_SUPPLY_PROP_VOLTAGE_MAX_DESIGN = 10,
	POWER_SUPPLY_PROP_VOLTAGE_MIN_DESIGN = 11,
	POWER_SUPPLY_PROP_VOLTAGE_NOW = 12,
	POWER_SUPPLY_PROP_VOLTAGE_AVG = 13,
	POWER_SUPPLY_PROP_VOLTAGE_OCV = 14,
	POWER_SUPPLY_PROP_VOLTAGE_BOOT = 15,
	POWER_SUPPLY_PROP_CURRENT_MAX = 16,
	POWER_SUPPLY_PROP_CURRENT_NOW = 17,
	POWER_SUPPLY_PROP_CURRENT_AVG = 18,
	POWER_SUPPLY_PROP_CURRENT_BOOT = 19,
	POWER_SUPPLY_PROP_POWER_NOW = 20,
	POWER_SUPPLY_PROP_POWER_AVG = 21,
	POWER_SUPPLY_PROP_CHARGE_FULL_DESIGN = 22,
	POWER_SUPPLY_PROP_CHARGE_EMPTY_DESIGN = 23,
	POWER_SUPPLY_PROP_CHARGE_FULL = 24,
	POWER_SUPPLY_PROP_CHARGE_EMPTY = 25,
	POWER_SUPPLY_PROP_CHARGE_NOW = 26,
	POWER_SUPPLY_PROP_CHARGE_AVG = 27,
	POWER_SUPPLY_PROP_CHARGE_COUNTER = 28,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT = 29,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_CURRENT_MAX = 30,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE = 31,
	POWER_SUPPLY_PROP_CONSTANT_CHARGE_VOLTAGE_MAX = 32,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT = 33,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_LIMIT_MAX = 34,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_START_THRESHOLD = 35,
	POWER_SUPPLY_PROP_CHARGE_CONTROL_END_THRESHOLD = 36,
	POWER_SUPPLY_PROP_CHARGE_BEHAVIOUR = 37,
	POWER_SUPPLY_PROP_INPUT_CURRENT_LIMIT = 38,
	POWER_SUPPLY_PROP_INPUT_VOLTAGE_LIMIT = 39,
	POWER_SUPPLY_PROP_INPUT_POWER_LIMIT = 40,
	POWER_SUPPLY_PROP_ENERGY_FULL_DESIGN = 41,
	POWER_SUPPLY_PROP_ENERGY_EMPTY_DESIGN = 42,
	POWER_SUPPLY_PROP_ENERGY_FULL = 43,
	POWER_SUPPLY_PROP_ENERGY_EMPTY = 44,
	POWER_SUPPLY_PROP_ENERGY_NOW = 45,
	POWER_SUPPLY_PROP_ENERGY_AVG = 46,
	POWER_SUPPLY_PROP_CAPACITY = 47,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MIN = 48,
	POWER_SUPPLY_PROP_CAPACITY_ALERT_MAX = 49,
	POWER_SUPPLY_PROP_CAPACITY_ERROR_MARGIN = 50,
	POWER_SUPPLY_PROP_CAPACITY_LEVEL = 51,
	POWER_SUPPLY_PROP_TEMP = 52,
	POWER_SUPPLY_PROP_TEMP_MAX = 53,
	POWER_SUPPLY_PROP_TEMP_MIN = 54,
	POWER_SUPPLY_PROP_TEMP_ALERT_MIN = 55,
	POWER_SUPPLY_PROP_TEMP_ALERT_MAX = 56,
	POWER_SUPPLY_PROP_TEMP_AMBIENT = 57,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MIN = 58,
	POWER_SUPPLY_PROP_TEMP_AMBIENT_ALERT_MAX = 59,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_NOW = 60,
	POWER_SUPPLY_PROP_TIME_TO_EMPTY_AVG = 61,
	POWER_SUPPLY_PROP_TIME_TO_FULL_NOW = 62,
	POWER_SUPPLY_PROP_TIME_TO_FULL_AVG = 63,
	POWER_SUPPLY_PROP_TYPE = 64,
	POWER_SUPPLY_PROP_USB_TYPE = 65,
	POWER_SUPPLY_PROP_SCOPE = 66,
	POWER_SUPPLY_PROP_PRECHARGE_CURRENT = 67,
	POWER_SUPPLY_PROP_CHARGE_TERM_CURRENT = 68,
	POWER_SUPPLY_PROP_CALIBRATE = 69,
	POWER_SUPPLY_PROP_MANUFACTURE_YEAR = 70,
	POWER_SUPPLY_PROP_MANUFACTURE_MONTH = 71,
	POWER_SUPPLY_PROP_MANUFACTURE_DAY = 72,
	POWER_SUPPLY_PROP_MODEL_NAME = 73,
	POWER_SUPPLY_PROP_MANUFACTURER = 74,
	POWER_SUPPLY_PROP_SERIAL_NUMBER = 75,
};

enum power_supply_type {
	POWER_SUPPLY_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_TYPE_BATTERY = 1,
	POWER_SUPPLY_TYPE_UPS = 2,
	POWER_SUPPLY_TYPE_MAINS = 3,
	POWER_SUPPLY_TYPE_USB = 4,
	POWER_SUPPLY_TYPE_USB_DCP = 5,
	POWER_SUPPLY_TYPE_USB_CDP = 6,
	POWER_SUPPLY_TYPE_USB_ACA = 7,
	POWER_SUPPLY_TYPE_USB_TYPE_C = 8,
	POWER_SUPPLY_TYPE_USB_PD = 9,
	POWER_SUPPLY_TYPE_USB_PD_DRP = 10,
	POWER_SUPPLY_TYPE_APPLE_BRICK_ID = 11,
	POWER_SUPPLY_TYPE_WIRELESS = 12,
};

enum power_supply_usb_type {
	POWER_SUPPLY_USB_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_USB_TYPE_SDP = 1,
	POWER_SUPPLY_USB_TYPE_DCP = 2,
	POWER_SUPPLY_USB_TYPE_CDP = 3,
	POWER_SUPPLY_USB_TYPE_ACA = 4,
	POWER_SUPPLY_USB_TYPE_C = 5,
	POWER_SUPPLY_USB_TYPE_PD = 6,
	POWER_SUPPLY_USB_TYPE_PD_DRP = 7,
	POWER_SUPPLY_USB_TYPE_PD_PPS = 8,
	POWER_SUPPLY_USB_TYPE_APPLE_BRICK_ID = 9,
};

enum power_supply_notifier_events {
	PSY_EVENT_PROP_CHANGED = 0,
};

union power_supply_propval {
	int intval;
	const char *strval;
};

struct power_supply_config {
	struct device_node *of_node;
	struct fwnode_handle *fwnode;
	void *drv_data;
	const struct attribute_group **attr_grp;
	char **supplied_to;
	size_t num_supplicants;
};

struct power_supply;

struct power_supply_desc {
	const char *name;
	enum power_supply_type type;
	const enum power_supply_usb_type *usb_types;
	size_t num_usb_types;
	const enum power_supply_property *properties;
	size_t num_properties;
	int (*get_property)(struct power_supply *, enum power_supply_property, union power_supply_propval *);
	int (*set_property)(struct power_supply *, enum power_supply_property, const union power_supply_propval *);
	int (*property_is_writeable)(struct power_supply *, enum power_supply_property);
	void (*external_power_changed)(struct power_supply *);
	void (*set_charged)(struct power_supply *);
	bool no_thermal;
	int use_for_apm;
};

struct power_supply {
	const struct power_supply_desc *desc;
	char **supplied_to;
	size_t num_supplicants;
	char **supplied_from;
	size_t num_supplies;
	struct device_node *of_node;
	void *drv_data;
	int: 32;
	struct device dev;
	struct work_struct changed_work;
	struct delayed_work deferred_register_work;
	spinlock_t changed_lock;
	bool changed;
	bool initialized;
	bool removing;
	atomic_t use_cnt;
	struct thermal_zone_device *tzd;
	struct thermal_cooling_device *tcd;
	struct led_trigger *charging_full_trig;
	char *charging_full_trig_name;
	struct led_trigger *charging_trig;
	char *charging_trig_name;
	struct led_trigger *full_trig;
	char *full_trig_name;
	struct led_trigger *online_trig;
	char *online_trig_name;
	struct led_trigger *charging_blink_full_solid_trig;
	char *charging_blink_full_solid_trig_name;
};

struct power_supply_battery_ocv_table {
	int ocv;
	int capacity;
};

struct power_supply_resistance_temp_table {
	int temp;
	int resistance;
};

struct power_supply_vbat_ri_table {
	int vbat_uv;
	int ri_uohm;
};

struct power_supply_maintenance_charge_table {
	int charge_current_max_ua;
	int charge_voltage_max_uv;
	int charge_safety_timer_minutes;
};

struct power_supply_battery_info {
	unsigned int technology;
	int energy_full_design_uwh;
	int charge_full_design_uah;
	int voltage_min_design_uv;
	int voltage_max_design_uv;
	int tricklecharge_current_ua;
	int precharge_current_ua;
	int precharge_voltage_max_uv;
	int charge_term_current_ua;
	int charge_restart_voltage_uv;
	int overvoltage_limit_uv;
	int constant_charge_current_max_ua;
	int constant_charge_voltage_max_uv;
	struct power_supply_maintenance_charge_table *maintenance_charge;
	int maintenance_charge_size;
	int alert_low_temp_charge_current_ua;
	int alert_low_temp_charge_voltage_uv;
	int alert_high_temp_charge_current_ua;
	int alert_high_temp_charge_voltage_uv;
	int factory_internal_resistance_uohm;
	int factory_internal_resistance_charging_uohm;
	int ocv_temp[20];
	int temp_ambient_alert_min;
	int temp_ambient_alert_max;
	int temp_alert_min;
	int temp_alert_max;
	int temp_min;
	int temp_max;
	struct power_supply_battery_ocv_table *ocv_table[20];
	int ocv_table_size[20];
	struct power_supply_resistance_temp_table *resist_table;
	int resist_table_size;
	struct power_supply_vbat_ri_table *vbat2ri_discharging;
	int vbat2ri_discharging_size;
	struct power_supply_vbat_ri_table *vbat2ri_charging;
	int vbat2ri_charging_size;
	int bti_resistance_ohm;
	int bti_resistance_tolerance;
};

struct psy_am_i_supplied_data {
	struct power_supply *psy;
	unsigned int count;
};

struct psy_get_supplier_prop_data {
	struct power_supply *psy;
	enum power_supply_property psp;
	union power_supply_propval *val;
};

enum {
	POWER_SUPPLY_STATUS_UNKNOWN = 0,
	POWER_SUPPLY_STATUS_CHARGING = 1,
	POWER_SUPPLY_STATUS_DISCHARGING = 2,
	POWER_SUPPLY_STATUS_NOT_CHARGING = 3,
	POWER_SUPPLY_STATUS_FULL = 4,
};

enum {
	POWER_SUPPLY_CHARGE_TYPE_UNKNOWN = 0,
	POWER_SUPPLY_CHARGE_TYPE_NONE = 1,
	POWER_SUPPLY_CHARGE_TYPE_TRICKLE = 2,
	POWER_SUPPLY_CHARGE_TYPE_FAST = 3,
	POWER_SUPPLY_CHARGE_TYPE_STANDARD = 4,
	POWER_SUPPLY_CHARGE_TYPE_ADAPTIVE = 5,
	POWER_SUPPLY_CHARGE_TYPE_CUSTOM = 6,
	POWER_SUPPLY_CHARGE_TYPE_LONGLIFE = 7,
	POWER_SUPPLY_CHARGE_TYPE_BYPASS = 8,
};

enum {
	POWER_SUPPLY_HEALTH_UNKNOWN = 0,
	POWER_SUPPLY_HEALTH_GOOD = 1,
	POWER_SUPPLY_HEALTH_OVERHEAT = 2,
	POWER_SUPPLY_HEALTH_DEAD = 3,
	POWER_SUPPLY_HEALTH_OVERVOLTAGE = 4,
	POWER_SUPPLY_HEALTH_UNSPEC_FAILURE = 5,
	POWER_SUPPLY_HEALTH_COLD = 6,
	POWER_SUPPLY_HEALTH_WATCHDOG_TIMER_EXPIRE = 7,
	POWER_SUPPLY_HEALTH_SAFETY_TIMER_EXPIRE = 8,
	POWER_SUPPLY_HEALTH_OVERCURRENT = 9,
	POWER_SUPPLY_HEALTH_CALIBRATION_REQUIRED = 10,
	POWER_SUPPLY_HEALTH_WARM = 11,
	POWER_SUPPLY_HEALTH_COOL = 12,
	POWER_SUPPLY_HEALTH_HOT = 13,
	POWER_SUPPLY_HEALTH_NO_BATTERY = 14,
};

enum {
	POWER_SUPPLY_CAPACITY_LEVEL_UNKNOWN = 0,
	POWER_SUPPLY_CAPACITY_LEVEL_CRITICAL = 1,
	POWER_SUPPLY_CAPACITY_LEVEL_LOW = 2,
	POWER_SUPPLY_CAPACITY_LEVEL_NORMAL = 3,
	POWER_SUPPLY_CAPACITY_LEVEL_HIGH = 4,
	POWER_SUPPLY_CAPACITY_LEVEL_FULL = 5,
};

enum {
	POWER_SUPPLY_SCOPE_UNKNOWN = 0,
	POWER_SUPPLY_SCOPE_SYSTEM = 1,
	POWER_SUPPLY_SCOPE_DEVICE = 2,
};

enum power_supply_charge_behaviour {
	POWER_SUPPLY_CHARGE_BEHAVIOUR_AUTO = 0,
	POWER_SUPPLY_CHARGE_BEHAVIOUR_INHIBIT_CHARGE = 1,
	POWER_SUPPLY_CHARGE_BEHAVIOUR_FORCE_DISCHARGE = 2,
};

struct power_supply_attr {
	const char *prop_name;
	char attr_name[31];
	struct device_attribute dev_attr;
	const char * const *text_values;
	int text_values_len;
};

enum hwmon_sensor_types {
	hwmon_chip = 0,
	hwmon_temp = 1,
	hwmon_in = 2,
	hwmon_curr = 3,
	hwmon_power = 4,
	hwmon_energy = 5,
	hwmon_humidity = 6,
	hwmon_fan = 7,
	hwmon_pwm = 8,
	hwmon_intrusion = 9,
	hwmon_max = 10,
};

enum hwmon_temp_attributes {
	hwmon_temp_enable = 0,
	hwmon_temp_input = 1,
	hwmon_temp_type = 2,
	hwmon_temp_lcrit = 3,
	hwmon_temp_lcrit_hyst = 4,
	hwmon_temp_min = 5,
	hwmon_temp_min_hyst = 6,
	hwmon_temp_max = 7,
	hwmon_temp_max_hyst = 8,
	hwmon_temp_crit = 9,
	hwmon_temp_crit_hyst = 10,
	hwmon_temp_emergency = 11,
	hwmon_temp_emergency_hyst = 12,
	hwmon_temp_alarm = 13,
	hwmon_temp_lcrit_alarm = 14,
	hwmon_temp_min_alarm = 15,
	hwmon_temp_max_alarm = 16,
	hwmon_temp_crit_alarm = 17,
	hwmon_temp_emergency_alarm = 18,
	hwmon_temp_fault = 19,
	hwmon_temp_offset = 20,
	hwmon_temp_label = 21,
	hwmon_temp_lowest = 22,
	hwmon_temp_highest = 23,
	hwmon_temp_reset_history = 24,
	hwmon_temp_rated_min = 25,
	hwmon_temp_rated_max = 26,
};

enum hwmon_in_attributes {
	hwmon_in_enable = 0,
	hwmon_in_input = 1,
	hwmon_in_min = 2,
	hwmon_in_max = 3,
	hwmon_in_lcrit = 4,
	hwmon_in_crit = 5,
	hwmon_in_average = 6,
	hwmon_in_lowest = 7,
	hwmon_in_highest = 8,
	hwmon_in_reset_history = 9,
	hwmon_in_label = 10,
	hwmon_in_alarm = 11,
	hwmon_in_min_alarm = 12,
	hwmon_in_max_alarm = 13,
	hwmon_in_lcrit_alarm = 14,
	hwmon_in_crit_alarm = 15,
	hwmon_in_rated_min = 16,
	hwmon_in_rated_max = 17,
};

enum hwmon_curr_attributes {
	hwmon_curr_enable = 0,
	hwmon_curr_input = 1,
	hwmon_curr_min = 2,
	hwmon_curr_max = 3,
	hwmon_curr_lcrit = 4,
	hwmon_curr_crit = 5,
	hwmon_curr_average = 6,
	hwmon_curr_lowest = 7,
	hwmon_curr_highest = 8,
	hwmon_curr_reset_history = 9,
	hwmon_curr_label = 10,
	hwmon_curr_alarm = 11,
	hwmon_curr_min_alarm = 12,
	hwmon_curr_max_alarm = 13,
	hwmon_curr_lcrit_alarm = 14,
	hwmon_curr_crit_alarm = 15,
	hwmon_curr_rated_min = 16,
	hwmon_curr_rated_max = 17,
};

struct hwmon_ops {
	umode_t (*is_visible)(const void *, enum hwmon_sensor_types, u32, int);
	int (*read)(struct device *, enum hwmon_sensor_types, u32, int, long int *);
	int (*read_string)(struct device *, enum hwmon_sensor_types, u32, int, const char **);
	int (*write)(struct device *, enum hwmon_sensor_types, u32, int, long int);
};

struct hwmon_channel_info {
	enum hwmon_sensor_types type;
	const u32 *config;
};

struct hwmon_chip_info {
	const struct hwmon_ops *ops;
	const struct hwmon_channel_info **info;
};

struct power_supply_hwmon {
	struct power_supply *psy;
	long unsigned int *props;
};

struct hwmon_type_attr_list {
	const u32 *attrs;
	size_t n_attrs;
};

struct max8903_pdata {
	int cen;
	int dok;
	int uok;
	int chg;
	int flt;
	int dcm;
	int usus;
	int feature_flag;
	bool dcm_always_high;
	bool dc_valid;
	bool usb_valid;
};

struct max8903_data {
	struct max8903_pdata *pdata;
	struct device *dev;
	struct power_supply *psy;
	struct power_supply *usb;
	struct power_supply *bat;
	struct power_supply *detect_usb;
	bool fault;
	bool usb_in;
	bool ta_in;
	bool chg_state;
	struct delayed_work work;
	unsigned int interval;
	short unsigned int thermal_raw;
	int voltage_uV;
	int current_uA;
	int battery_status;
	int charger_online;
	int charger_voltage_uV;
	int real_capacity;
	int percent;
	int old_percent;
	int usb_charger_online;
	int first_delay_count;
};

typedef struct {
	u32 voltage;
	u32 percent;
} battery_capacity;

typedef struct {
	u32 voltage;
	u32 percent;
} *pbattery_capacity;

enum hwmon_chip_attributes {
	hwmon_chip_temp_reset_history = 0,
	hwmon_chip_in_reset_history = 1,
	hwmon_chip_curr_reset_history = 2,
	hwmon_chip_power_reset_history = 3,
	hwmon_chip_register_tz = 4,
	hwmon_chip_update_interval = 5,
	hwmon_chip_alarms = 6,
	hwmon_chip_samples = 7,
	hwmon_chip_curr_samples = 8,
	hwmon_chip_in_samples = 9,
	hwmon_chip_power_samples = 10,
	hwmon_chip_temp_samples = 11,
};

enum hwmon_power_attributes {
	hwmon_power_enable = 0,
	hwmon_power_average = 1,
	hwmon_power_average_interval = 2,
	hwmon_power_average_interval_max = 3,
	hwmon_power_average_interval_min = 4,
	hwmon_power_average_highest = 5,
	hwmon_power_average_lowest = 6,
	hwmon_power_average_max = 7,
	hwmon_power_average_min = 8,
	hwmon_power_input = 9,
	hwmon_power_input_highest = 10,
	hwmon_power_input_lowest = 11,
	hwmon_power_reset_history = 12,
	hwmon_power_accuracy = 13,
	hwmon_power_cap = 14,
	hwmon_power_cap_hyst = 15,
	hwmon_power_cap_max = 16,
	hwmon_power_cap_min = 17,
	hwmon_power_min = 18,
	hwmon_power_max = 19,
	hwmon_power_crit = 20,
	hwmon_power_lcrit = 21,
	hwmon_power_label = 22,
	hwmon_power_alarm = 23,
	hwmon_power_cap_alarm = 24,
	hwmon_power_min_alarm = 25,
	hwmon_power_max_alarm = 26,
	hwmon_power_lcrit_alarm = 27,
	hwmon_power_crit_alarm = 28,
	hwmon_power_rated_min = 29,
	hwmon_power_rated_max = 30,
};

enum hwmon_energy_attributes {
	hwmon_energy_enable = 0,
	hwmon_energy_input = 1,
	hwmon_energy_label = 2,
};

enum hwmon_humidity_attributes {
	hwmon_humidity_enable = 0,
	hwmon_humidity_input = 1,
	hwmon_humidity_label = 2,
	hwmon_humidity_min = 3,
	hwmon_humidity_min_hyst = 4,
	hwmon_humidity_max = 5,
	hwmon_humidity_max_hyst = 6,
	hwmon_humidity_alarm = 7,
	hwmon_humidity_fault = 8,
	hwmon_humidity_rated_min = 9,
	hwmon_humidity_rated_max = 10,
};

enum hwmon_fan_attributes {
	hwmon_fan_enable = 0,
	hwmon_fan_input = 1,
	hwmon_fan_label = 2,
	hwmon_fan_min = 3,
	hwmon_fan_max = 4,
	hwmon_fan_div = 5,
	hwmon_fan_pulses = 6,
	hwmon_fan_target = 7,
	hwmon_fan_alarm = 8,
	hwmon_fan_min_alarm = 9,
	hwmon_fan_max_alarm = 10,
	hwmon_fan_fault = 11,
};

enum hwmon_pwm_attributes {
	hwmon_pwm_input = 0,
	hwmon_pwm_enable = 1,
	hwmon_pwm_mode = 2,
	hwmon_pwm_freq = 3,
	hwmon_pwm_auto_channels_temp = 4,
};

enum hwmon_intrusion_attributes {
	hwmon_intrusion_alarm = 0,
	hwmon_intrusion_beep = 1,
};

struct trace_event_raw_hwmon_attr_class {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	long int val;
	char __data[0];
};

struct trace_event_raw_hwmon_attr_show_string {
	struct trace_entry ent;
	int index;
	u32 __data_loc_attr_name;
	u32 __data_loc_label;
	char __data[0];
};

struct trace_event_data_offsets_hwmon_attr_class {
	u32 attr_name;
};

struct trace_event_data_offsets_hwmon_attr_show_string {
	u32 attr_name;
	u32 label;
};

typedef void (*btf_trace_hwmon_attr_show)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_store)(void *, int, const char *, long int);

typedef void (*btf_trace_hwmon_attr_show_string)(void *, int, const char *, const char *);

struct hwmon_device {
	const char *name;
	const char *label;
	struct device dev;
	const struct hwmon_chip_info *chip;
	struct list_head tzdata;
	struct attribute_group group;
	const struct attribute_group **groups;
	int: 32;
};

struct hwmon_device_attribute {
	struct device_attribute dev_attr;
	const struct hwmon_ops *ops;
	enum hwmon_sensor_types type;
	u32 attr;
	int index;
	char name[32];
};

struct hwmon_thermal_data {
	struct list_head node;
	struct device *dev;
	int index;
	struct thermal_zone_device *tzd;
};

struct gpio_fan_speed {
	int rpm;
	int ctrl_val;
};

struct gpio_fan_data {
	struct device *dev;
	struct device *hwmon_dev;
	struct thermal_cooling_device *cdev;
	struct mutex lock;
	int num_gpios;
	struct gpio_desc **gpios;
	int num_speed;
	struct gpio_fan_speed *speed;
	int speed_index;
	int resume_speed;
	bool pwm_enable;
	struct gpio_desc *alarm_gpio;
	struct work_struct alarm_work;
};

struct iio_hwmon_state {
	struct iio_channel *channels;
	int num_channels;
	struct attribute_group attr_group;
	const struct attribute_group *groups[2];
	struct attribute **attrs;
};

struct max17135_data___2 {
	struct device *hwmon_dev;
};

struct mc13783_adc_priv {
	struct mc13xxx *mc13xxx;
	struct device *hwmon_dev;
	char name[20];
};

struct thermal_attr {
	struct device_attribute attr;
	char name[20];
};

struct trace_event_raw_thermal_temperature {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int temp_prev;
	int temp;
	char __data[0];
};

struct trace_event_raw_cdev_update {
	struct trace_entry ent;
	u32 __data_loc_type;
	long unsigned int target;
	char __data[0];
};

struct trace_event_raw_thermal_zone_trip {
	struct trace_entry ent;
	u32 __data_loc_thermal_zone;
	int id;
	int trip;
	enum thermal_trip_type trip_type;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_get_power_simple {
	struct trace_entry ent;
	int cpu;
	u32 power;
	char __data[0];
};

struct trace_event_raw_thermal_power_cpu_limit {
	struct trace_entry ent;
	u32 __data_loc_cpumask;
	unsigned int freq;
	long unsigned int cdev_state;
	u32 power;
	char __data[0];
};

struct trace_event_data_offsets_thermal_temperature {
	u32 thermal_zone;
};

struct trace_event_data_offsets_cdev_update {
	u32 type;
};

struct trace_event_data_offsets_thermal_zone_trip {
	u32 thermal_zone;
};

struct trace_event_data_offsets_thermal_power_cpu_get_power_simple {};

struct trace_event_data_offsets_thermal_power_cpu_limit {
	u32 cpumask;
};

typedef void (*btf_trace_thermal_temperature)(void *, struct thermal_zone_device *);

typedef void (*btf_trace_cdev_update)(void *, struct thermal_cooling_device *, long unsigned int);

typedef void (*btf_trace_thermal_zone_trip)(void *, struct thermal_zone_device *, int, enum thermal_trip_type);

typedef void (*btf_trace_thermal_power_cpu_get_power_simple)(void *, int, u32);

typedef void (*btf_trace_thermal_power_cpu_limit)(void *, const struct cpumask *, unsigned int, long unsigned int, u32);

struct thermal_instance {
	int id;
	char name[20];
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev;
	int trip;
	bool initialized;
	long unsigned int upper;
	long unsigned int lower;
	long unsigned int target;
	char attr_name[20];
	struct device_attribute attr;
	char weight_attr_name[20];
	struct device_attribute weight_attr;
	struct list_head tz_node;
	struct list_head cdev_node;
	unsigned int weight;
};

struct cooling_dev_stats {
	spinlock_t lock;
	unsigned int total_trans;
	long unsigned int state;
	long unsigned int max_states;
	ktime_t last_time;
	ktime_t *time_in_state;
	unsigned int *trans_table;
};

struct thermal_hwmon_device {
	char type[20];
	struct device *device;
	int count;
	struct list_head tz_list;
	struct list_head node;
};

struct thermal_hwmon_attr {
	struct device_attribute attr;
	char name[16];
};

struct thermal_hwmon_temp {
	struct list_head hwmon_node;
	struct thermal_zone_device *tz;
	struct thermal_hwmon_attr temp_input;
	struct thermal_hwmon_attr temp_crit;
};

struct cpufreq_cooling_device {
	u32 last_load;
	unsigned int cpufreq_state;
	unsigned int max_level;
	struct em_perf_domain *em;
	struct cpufreq_policy *policy;
	struct thermal_cooling_device_ops cooling_ops;
	struct freq_qos_request qos_req;
};

enum imx_thermal_trip {
	IMX_TRIP_PASSIVE = 0,
	IMX_TRIP_CRITICAL = 1,
	IMX_TRIP_NUM = 2,
};

struct thermal_soc_data {
	u32 version;
	u32 sensor_ctrl;
	u32 power_down_mask;
	u32 measure_temp_mask;
	u32 measure_freq_ctrl;
	u32 measure_freq_mask;
	u32 measure_freq_shift;
	u32 temp_data;
	u32 temp_value_mask;
	u32 temp_value_shift;
	u32 temp_valid_mask;
	u32 panic_alarm_ctrl;
	u32 panic_alarm_mask;
	u32 panic_alarm_shift;
	u32 high_alarm_ctrl;
	u32 high_alarm_mask;
	u32 high_alarm_shift;
	u32 low_alarm_ctrl;
	u32 low_alarm_mask;
	u32 low_alarm_shift;
};

struct imx_thermal_data {
	struct device *dev;
	struct cpufreq_policy *policy;
	struct thermal_zone_device *tz;
	struct thermal_cooling_device *cdev[2];
	struct regmap *tempmon;
	u32 c1;
	u32 c2;
	int temp_passive;
	int temp_critical;
	int temp_max;
	int alarm_temp;
	int last_temp;
	bool irq_enabled;
	int irq;
	struct clk *thermal_clk;
	const struct thermal_soc_data *socdata;
	const char *temp_grade;
};

struct devfreq_cooling_device {
	int id;
	struct thermal_cooling_device *cool_dev;
	unsigned int devfreq_state;
};

struct watchdog_core_data {
	struct device dev;
	struct cdev cdev;
	struct watchdog_device *wdd;
	struct mutex lock;
	int: 32;
	ktime_t last_keepalive;
	ktime_t last_hw_keepalive;
	ktime_t open_deadline;
	struct hrtimer timer;
	struct kthread_work work;
	long unsigned int status;
};

struct trace_event_raw_watchdog_template {
	struct trace_entry ent;
	int id;
	int err;
	char __data[0];
};

struct trace_event_raw_watchdog_set_timeout {
	struct trace_entry ent;
	int id;
	unsigned int timeout;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_watchdog_template {};

struct trace_event_data_offsets_watchdog_set_timeout {};

typedef void (*btf_trace_watchdog_start)(void *, struct watchdog_device *, int);

typedef void (*btf_trace_watchdog_ping)(void *, struct watchdog_device *, int);

typedef void (*btf_trace_watchdog_stop)(void *, struct watchdog_device *, int);

typedef void (*btf_trace_watchdog_set_timeout)(void *, struct watchdog_device *, unsigned int, int);

struct rn5t618_wdt {
	struct watchdog_device wdt_dev;
	struct rn5t618 *rn5t618;
};

struct imx2_wdt_device {
	struct clk *clk;
	struct regmap *regmap;
	struct watchdog_device wdog;
	bool ext_reset;
	bool clk_is_on;
	bool no_ping;
};

struct imx_wdt_hw_feature {
	bool prescaler_enable;
	u32 wdog_clock_rate;
};

struct imx7ulp_wdt_device {
	struct watchdog_device wdd;
	void *base;
	struct clk *clk;
	bool post_rcs_wait;
	const struct imx_wdt_hw_feature *hw;
};

struct da9062_watchdog {
	struct da9062 *hw;
	struct watchdog_device wdtdev;
	bool use_sw_pm;
};

enum blk_crypto_mode_num {
	BLK_ENCRYPTION_MODE_INVALID = 0,
	BLK_ENCRYPTION_MODE_AES_256_XTS = 1,
	BLK_ENCRYPTION_MODE_AES_128_CBC_ESSIV = 2,
	BLK_ENCRYPTION_MODE_ADIANTUM = 3,
	BLK_ENCRYPTION_MODE_MAX = 4,
};

struct dm_kobject_holder {
	struct kobject kobj;
	struct completion completion;
};

struct bt_codec {
	__u8 id;
	__u16 cid;
	__u16 vid;
	__u8 data_path;
	__u8 num_caps;
} __attribute__((packed));

typedef struct {
	__u8 b[6];
} bdaddr_t;

struct l2cap_chan;

struct l2cap_ctrl {
	u8 sframe: 1;
	u8 poll: 1;
	u8 final: 1;
	u8 fcs: 1;
	u8 sar: 2;
	u8 super: 2;
	u16 reqseq;
	u16 txseq;
	u8 retries;
	__le16 psm;
	bdaddr_t bdaddr;
	struct l2cap_chan *chan;
};

struct sco_ctrl {
	u8 pkt_status;
};

struct hci_dev;

typedef void (*hci_req_complete_t)(struct hci_dev *, u8, u16);

struct amp_assoc {
	__u16 len;
	__u16 offset;
	__u16 rem_len;
	__u16 len_so_far;
	__u8 data[672];
};

struct discovery_state {
	int type;
	enum {
		DISCOVERY_STOPPED = 0,
		DISCOVERY_STARTING = 1,
		DISCOVERY_FINDING = 2,
		DISCOVERY_RESOLVING = 3,
		DISCOVERY_STOPPING = 4,
	} state;
	struct list_head all;
	struct list_head unknown;
	struct list_head resolve;
	__u32 timestamp;
	bdaddr_t last_adv_addr;
	u8 last_adv_addr_type;
	s8 last_adv_rssi;
	u32 last_adv_flags;
	u8 last_adv_data[31];
	u8 last_adv_data_len;
	bool report_invalid_rssi;
	bool result_filtering;
	bool limited;
	s8 rssi;
	u16 uuid_count;
	u8 (*uuids)[16];
	long unsigned int scan_start;
	long unsigned int scan_duration;
	long unsigned int name_resolve_timeout;
};

enum suspended_state {
	BT_RUNNING = 0,
	BT_SUSPEND_DISCONNECT = 1,
	BT_SUSPEND_CONFIGURE_WAKE = 2,
};

struct hci_conn_hash {
	struct list_head list;
	unsigned int acl_num;
	unsigned int amp_num;
	unsigned int sco_num;
	unsigned int iso_num;
	unsigned int le_num;
	unsigned int le_num_peripheral;
};

struct hci_dev_stats {
	__u32 err_rx;
	__u32 err_tx;
	__u32 cmd_tx;
	__u32 evt_rx;
	__u32 acl_tx;
	__u32 acl_rx;
	__u32 sco_tx;
	__u32 sco_rx;
	__u32 byte_rx;
	__u32 byte_tx;
};

struct rfkill;

typedef u8 hci_conn_flags_t;

struct hci_dev {
	struct list_head list;
	struct mutex lock;
	char name[8];
	long unsigned int flags;
	__u16 id;
	__u8 bus;
	__u8 dev_type;
	bdaddr_t bdaddr;
	bdaddr_t setup_addr;
	bdaddr_t public_addr;
	bdaddr_t random_addr;
	bdaddr_t static_addr;
	__u8 adv_addr_type;
	__u8 dev_name[248];
	__u8 short_name[10];
	__u8 eir[240];
	__u16 appearance;
	__u8 dev_class[3];
	__u8 major_class;
	__u8 minor_class;
	__u8 max_page;
	__u8 features[24];
	__u8 le_features[8];
	__u8 le_accept_list_size;
	__u8 le_resolv_list_size;
	__u8 le_num_of_adv_sets;
	__u8 le_states[8];
	__u8 mesh_ad_types[16];
	__u8 mesh_send_ref;
	__u8 commands[64];
	__u8 hci_ver;
	__u16 hci_rev;
	__u8 lmp_ver;
	__u16 manufacturer;
	__u16 lmp_subver;
	__u16 voice_setting;
	__u8 num_iac;
	__u16 stored_max_keys;
	__u16 stored_num_keys;
	__u8 io_capability;
	__s8 inq_tx_power;
	__u8 err_data_reporting;
	__u16 page_scan_interval;
	__u16 page_scan_window;
	__u8 page_scan_type;
	__u8 le_adv_channel_map;
	__u16 le_adv_min_interval;
	__u16 le_adv_max_interval;
	__u8 le_scan_type;
	__u16 le_scan_interval;
	__u16 le_scan_window;
	__u16 le_scan_int_suspend;
	__u16 le_scan_window_suspend;
	__u16 le_scan_int_discovery;
	__u16 le_scan_window_discovery;
	__u16 le_scan_int_adv_monitor;
	__u16 le_scan_window_adv_monitor;
	__u16 le_scan_int_connect;
	__u16 le_scan_window_connect;
	__u16 le_conn_min_interval;
	__u16 le_conn_max_interval;
	__u16 le_conn_latency;
	__u16 le_supv_timeout;
	__u16 le_def_tx_len;
	__u16 le_def_tx_time;
	__u16 le_max_tx_len;
	__u16 le_max_tx_time;
	__u16 le_max_rx_len;
	__u16 le_max_rx_time;
	__u8 le_max_key_size;
	__u8 le_min_key_size;
	__u16 discov_interleaved_timeout;
	__u16 conn_info_min_age;
	__u16 conn_info_max_age;
	__u16 auth_payload_timeout;
	__u8 min_enc_key_size;
	__u8 max_enc_key_size;
	__u8 pairing_opts;
	__u8 ssp_debug_mode;
	__u8 hw_error_code;
	__u32 clock;
	__u16 advmon_allowlist_duration;
	__u16 advmon_no_filter_duration;
	__u8 enable_advmon_interleave_scan;
	__u16 devid_source;
	__u16 devid_vendor;
	__u16 devid_product;
	__u16 devid_version;
	__u8 def_page_scan_type;
	__u16 def_page_scan_int;
	__u16 def_page_scan_window;
	__u8 def_inq_scan_type;
	__u16 def_inq_scan_int;
	__u16 def_inq_scan_window;
	__u16 def_br_lsto;
	__u16 def_page_timeout;
	__u16 def_multi_adv_rotation_duration;
	__u16 def_le_autoconnect_timeout;
	__s8 min_le_tx_power;
	__s8 max_le_tx_power;
	__u16 pkt_type;
	__u16 esco_type;
	__u16 link_policy;
	__u16 link_mode;
	__u32 idle_timeout;
	__u16 sniff_min_interval;
	__u16 sniff_max_interval;
	__u8 amp_status;
	__u32 amp_total_bw;
	__u32 amp_max_bw;
	__u32 amp_min_latency;
	__u32 amp_max_pdu;
	__u8 amp_type;
	__u16 amp_pal_cap;
	__u16 amp_assoc_size;
	__u32 amp_max_flush_to;
	__u32 amp_be_flush_to;
	struct amp_assoc loc_assoc;
	__u8 flow_ctl_mode;
	unsigned int auto_accept_delay;
	long unsigned int quirks;
	atomic_t cmd_cnt;
	unsigned int acl_cnt;
	unsigned int sco_cnt;
	unsigned int le_cnt;
	unsigned int iso_cnt;
	unsigned int acl_mtu;
	unsigned int sco_mtu;
	unsigned int le_mtu;
	unsigned int iso_mtu;
	unsigned int acl_pkts;
	unsigned int sco_pkts;
	unsigned int le_pkts;
	unsigned int iso_pkts;
	__u16 block_len;
	__u16 block_mtu;
	__u16 num_blocks;
	__u16 block_cnt;
	long unsigned int acl_last_tx;
	long unsigned int sco_last_tx;
	long unsigned int le_last_tx;
	__u8 le_tx_def_phys;
	__u8 le_rx_def_phys;
	struct workqueue_struct *workqueue;
	struct workqueue_struct *req_workqueue;
	struct work_struct power_on;
	struct delayed_work power_off;
	struct work_struct error_reset;
	struct work_struct cmd_sync_work;
	struct list_head cmd_sync_work_list;
	struct mutex cmd_sync_work_lock;
	struct work_struct cmd_sync_cancel_work;
	struct work_struct reenable_adv_work;
	__u16 discov_timeout;
	struct delayed_work discov_off;
	struct delayed_work service_cache;
	struct delayed_work cmd_timer;
	struct delayed_work ncmd_timer;
	struct work_struct rx_work;
	struct work_struct cmd_work;
	struct work_struct tx_work;
	struct delayed_work le_scan_disable;
	struct delayed_work le_scan_restart;
	struct sk_buff_head rx_q;
	struct sk_buff_head raw_q;
	struct sk_buff_head cmd_q;
	struct sk_buff *sent_cmd;
	struct sk_buff *recv_event;
	struct mutex req_lock;
	wait_queue_head_t req_wait_q;
	__u32 req_status;
	__u32 req_result;
	struct sk_buff *req_skb;
	void *smp_data;
	void *smp_bredr_data;
	struct discovery_state discovery;
	int discovery_old_state;
	bool discovery_paused;
	int advertising_old_state;
	bool advertising_paused;
	struct notifier_block suspend_notifier;
	enum suspended_state suspend_state_next;
	enum suspended_state suspend_state;
	bool scanning_paused;
	bool suspended;
	u8 wake_reason;
	bdaddr_t wake_addr;
	u8 wake_addr_type;
	struct hci_conn_hash conn_hash;
	struct list_head mesh_pending;
	struct list_head mgmt_pending;
	struct list_head reject_list;
	struct list_head accept_list;
	struct list_head uuids;
	struct list_head link_keys;
	struct list_head long_term_keys;
	struct list_head identity_resolving_keys;
	struct list_head remote_oob_data;
	struct list_head le_accept_list;
	struct list_head le_resolv_list;
	struct list_head le_conn_params;
	struct list_head pend_le_conns;
	struct list_head pend_le_reports;
	struct list_head blocked_keys;
	struct list_head local_codecs;
	struct hci_dev_stats stat;
	atomic_t promisc;
	const char *hw_info;
	const char *fw_info;
	struct dentry *debugfs;
	struct device dev;
	struct rfkill *rfkill;
	long unsigned int dev_flags[2];
	hci_conn_flags_t conn_flags;
	__s8 adv_tx_power;
	__u8 adv_data[251];
	__u8 adv_data_len;
	__u8 scan_rsp_data[251];
	__u8 scan_rsp_data_len;
	__u8 per_adv_data[252];
	__u8 per_adv_data_len;
	struct list_head adv_instances;
	unsigned int adv_instance_cnt;
	__u8 cur_adv_instance;
	__u16 adv_instance_timeout;
	struct delayed_work adv_instance_expire;
	struct idr adv_monitors_idr;
	unsigned int adv_monitors_cnt;
	__u8 irk[16];
	__u32 rpa_timeout;
	struct delayed_work rpa_expired;
	bdaddr_t rpa;
	struct delayed_work mesh_send_done;
	enum {
		INTERLEAVE_SCAN_NONE = 0,
		INTERLEAVE_SCAN_NO_FILTER = 1,
		INTERLEAVE_SCAN_ALLOWLIST = 2,
	} interleave_scan_state;
	struct delayed_work interleave_scan;
	struct list_head monitored_devices;
	bool advmon_pend_notify;
	int (*open)(struct hci_dev *);
	int (*close)(struct hci_dev *);
	int (*flush)(struct hci_dev *);
	int (*setup)(struct hci_dev *);
	int (*shutdown)(struct hci_dev *);
	int (*send)(struct hci_dev *, struct sk_buff *);
	void (*notify)(struct hci_dev *, unsigned int);
	void (*hw_error)(struct hci_dev *, u8);
	int (*post_init)(struct hci_dev *);
	int (*set_diag)(struct hci_dev *, bool);
	int (*set_bdaddr)(struct hci_dev *, const bdaddr_t *);
	void (*cmd_timeout)(struct hci_dev *);
	bool (*wakeup)(struct hci_dev *);
	int (*set_quality_report)(struct hci_dev *, bool);
	int (*get_data_path_id)(struct hci_dev *, __u8 *);
	int (*get_codec_config_data)(struct hci_dev *, __u8, struct bt_codec *, __u8 *, __u8 **);
};

typedef void (*hci_req_complete_skb_t)(struct hci_dev *, u8, u16, struct sk_buff *);

struct hci_ctrl {
	struct sock *sk;
	u16 opcode;
	u8 req_flags;
	u8 req_event;
	union {
		hci_req_complete_t req_complete;
		hci_req_complete_skb_t req_complete_skb;
	};
};

struct mgmt_ctrl {
	struct hci_dev *hdev;
	u16 opcode;
};

struct bt_skb_cb {
	u8 pkt_type;
	u8 force_active;
	u16 expect;
	u8 incoming: 1;
	union {
		struct l2cap_ctrl l2cap;
		struct sco_ctrl sco;
		struct hci_ctrl hci;
		struct mgmt_ctrl mgmt;
	};
};

enum {
	HCI_QUIRK_RESET_ON_CLOSE = 0,
	HCI_QUIRK_RAW_DEVICE = 1,
	HCI_QUIRK_FIXUP_BUFFER_SIZE = 2,
	HCI_QUIRK_FIXUP_INQUIRY_MODE = 3,
	HCI_QUIRK_BROKEN_LOCAL_COMMANDS = 4,
	HCI_QUIRK_BROKEN_STORED_LINK_KEY = 5,
	HCI_QUIRK_EXTERNAL_CONFIG = 6,
	HCI_QUIRK_INVALID_BDADDR = 7,
	HCI_QUIRK_USE_BDADDR_PROPERTY = 8,
	HCI_QUIRK_STRICT_DUPLICATE_FILTER = 9,
	HCI_QUIRK_SIMULTANEOUS_DISCOVERY = 10,
	HCI_QUIRK_NON_PERSISTENT_DIAG = 11,
	HCI_QUIRK_NON_PERSISTENT_SETUP = 12,
	HCI_QUIRK_WIDEBAND_SPEECH_SUPPORTED = 13,
	HCI_QUIRK_VALID_LE_STATES = 14,
	HCI_QUIRK_BROKEN_ERR_DATA_REPORTING = 15,
	HCI_QUIRK_NO_SUSPEND_NOTIFIER = 16,
	HCI_QUIRK_BROKEN_READ_TRANSMIT_POWER = 17,
	HCI_QUIRK_BROKEN_FILTER_CLEAR_ALL = 18,
	HCI_QUIRK_BROKEN_ENHANCED_SETUP_SYNC_CONN = 19,
};

enum {
	HCI_SETUP = 0,
	HCI_CONFIG = 1,
	HCI_AUTO_OFF = 2,
	HCI_RFKILLED = 3,
	HCI_MGMT = 4,
	HCI_BONDABLE = 5,
	HCI_SERVICE_CACHE = 6,
	HCI_KEEP_DEBUG_KEYS = 7,
	HCI_USE_DEBUG_KEYS = 8,
	HCI_UNREGISTER = 9,
	HCI_UNCONFIGURED = 10,
	HCI_USER_CHANNEL = 11,
	HCI_EXT_CONFIGURED = 12,
	HCI_LE_ADV = 13,
	HCI_LE_PER_ADV = 14,
	HCI_LE_SCAN = 15,
	HCI_SSP_ENABLED = 16,
	HCI_SC_ENABLED = 17,
	HCI_SC_ONLY = 18,
	HCI_PRIVACY = 19,
	HCI_LIMITED_PRIVACY = 20,
	HCI_RPA_EXPIRED = 21,
	HCI_RPA_RESOLVING = 22,
	HCI_HS_ENABLED = 23,
	HCI_LE_ENABLED = 24,
	HCI_ADVERTISING = 25,
	HCI_ADVERTISING_CONNECTABLE = 26,
	HCI_CONNECTABLE = 27,
	HCI_DISCOVERABLE = 28,
	HCI_LIMITED_DISCOVERABLE = 29,
	HCI_LINK_SECURITY = 30,
	HCI_PERIODIC_INQ = 31,
	HCI_FAST_CONNECTABLE = 32,
	HCI_BREDR_ENABLED = 33,
	HCI_LE_SCAN_INTERRUPTED = 34,
	HCI_WIDEBAND_SPEECH_ENABLED = 35,
	HCI_EVENT_FILTER_CONFIGURED = 36,
	HCI_PA_SYNC = 37,
	HCI_DUT_MODE = 38,
	HCI_VENDOR_DIAG = 39,
	HCI_FORCE_BREDR_SMP = 40,
	HCI_FORCE_STATIC_ADDR = 41,
	HCI_LL_RPA_RESOLUTION = 42,
	HCI_ENABLE_LL_PRIVACY = 43,
	HCI_CMD_PENDING = 44,
	HCI_FORCE_NO_MITM = 45,
	HCI_QUALITY_REPORT = 46,
	HCI_OFFLOAD_CODECS_ENABLED = 47,
	HCI_LE_SIMULTANEOUS_ROLES = 48,
	HCI_CMD_DRAIN_WORKQUEUE = 49,
	HCI_MESH_EXPERIMENTAL = 50,
	HCI_MESH = 51,
	HCI_MESH_SENDING = 52,
	__HCI_NUM_FLAGS = 53,
};

struct vhci_data {
	struct hci_dev *hdev;
	wait_queue_head_t read_wait;
	struct sk_buff_head readq;
	struct mutex open_mutex;
	struct delayed_work open_timeout;
	struct work_struct suspend_work;
	bool suspended;
	bool wakeup;
	__u16 msft_opcode;
	bool aosp_capable;
};

struct hci_rp_read_local_version {
	__u8 status;
	__u8 hci_ver;
	__le16 hci_rev;
	__u8 lmp_ver;
	__le16 manufacturer;
	__le16 lmp_subver;
} __attribute__((packed));

enum {
	INTEL_BOOTLOADER = 0,
	INTEL_DOWNLOADING = 1,
	INTEL_FIRMWARE_LOADED = 2,
	INTEL_FIRMWARE_FAILED = 3,
	INTEL_BOOTING = 4,
	INTEL_BROKEN_INITIAL_NCMD = 5,
	INTEL_BROKEN_SHUTDOWN_LED = 6,
	INTEL_ROM_LEGACY = 7,
	INTEL_ROM_LEGACY_NO_WBS_SUPPORT = 8,
	__INTEL_NUM_FLAGS = 9,
};

struct hci_uart;

struct hci_uart_proto {
	unsigned int id;
	const char *name;
	unsigned int manufacturer;
	unsigned int init_speed;
	unsigned int oper_speed;
	int (*open)(struct hci_uart *);
	int (*close)(struct hci_uart *);
	int (*flush)(struct hci_uart *);
	int (*setup)(struct hci_uart *);
	int (*set_baudrate)(struct hci_uart *, unsigned int);
	int (*recv)(struct hci_uart *, const void *, int);
	int (*enqueue)(struct hci_uart *, struct sk_buff *);
	struct sk_buff * (*dequeue)(struct hci_uart *);
};

struct hci_uart {
	struct tty_struct *tty;
	struct serdev_device *serdev;
	struct hci_dev *hdev;
	long unsigned int flags;
	long unsigned int hdev_flags;
	struct work_struct init_ready;
	struct work_struct write_work;
	const struct hci_uart_proto *proto;
	struct percpu_rw_semaphore proto_lock;
	void *priv;
	struct sk_buff *tx_skb;
	long unsigned int tx_state;
	unsigned int init_speed;
	unsigned int oper_speed;
	u8 alignment;
	u8 padding;
};

struct h4_recv_pkt {
	u8 type;
	u8 hlen;
	u8 loff;
	u8 lsize;
	u16 maxlen;
	int (*recv)(struct hci_dev *, struct sk_buff *);
};

struct h4_struct {
	struct sk_buff *rx_skb;
	struct sk_buff_head txq;
};

struct hci_command_hdr {
	__le16 opcode;
	__u8 plen;
} __attribute__((packed));

struct hci_event_hdr {
	__u8 evt;
	__u8 plen;
};

struct bcsp_struct {
	struct sk_buff_head unack;
	struct sk_buff_head rel;
	struct sk_buff_head unrel;
	long unsigned int rx_count;
	struct sk_buff *rx_skb;
	u8 rxseq_txack;
	u8 rxack;
	struct timer_list tbcsp;
	struct hci_uart *hu;
	enum {
		BCSP_W4_PKT_DELIMITER = 0,
		BCSP_W4_PKT_START = 1,
		BCSP_W4_BCSP_HDR = 2,
		BCSP_W4_DATA = 3,
		BCSP_W4_CRC = 4,
	} rx_state;
	enum {
		BCSP_ESCSTATE_NOESC = 0,
		BCSP_ESCSTATE_ESC = 1,
	} rx_esc_state;
	u8 use_crc;
	u16 message_crc;
	u8 txack_req;
	u8 msgq_txseq;
};

struct bts_action {
	u16 type;
	u16 size;
	u8 data[0];
};

struct bts_action_delay {
	u32 msec;
};

struct hci_command {
	u8 prefix;
	u16 opcode;
	u8 plen;
	u32 speed;
} __attribute__((packed));

enum hcill_states_e {
	HCILL_ASLEEP = 0,
	HCILL_ASLEEP_TO_AWAKE = 1,
	HCILL_AWAKE = 2,
	HCILL_AWAKE_TO_ASLEEP = 3,
};

struct ll_device {
	struct hci_uart hu;
	struct serdev_device *serdev;
	struct gpio_desc *enable_gpio;
	struct clk *ext_clk;
	bdaddr_t bdaddr;
};

struct ll_struct {
	struct sk_buff *rx_skb;
	struct sk_buff_head txq;
	spinlock_t hcill_lock;
	long unsigned int hcill_state;
	struct sk_buff_head tx_wait_q;
};

struct nvmem_cell;

struct acpi_gpio_params {
	unsigned int crs_entry_index;
	unsigned int line_index;
	bool active_low;
};

struct acpi_gpio_mapping {
	const char *name;
	const struct acpi_gpio_params *data;
	unsigned int size;
	unsigned int quirks;
};

enum {
	H5_RX_ESC = 0,
	H5_TX_ACK_REQ = 1,
	H5_WAKEUP_DISABLE = 2,
	H5_HW_FLOW_CONTROL = 3,
};

struct h5_vnd;

struct h5 {
	struct hci_uart serdev_hu;
	struct sk_buff_head unack;
	struct sk_buff_head rel;
	struct sk_buff_head unrel;
	long unsigned int flags;
	struct sk_buff *rx_skb;
	size_t rx_pending;
	u8 rx_ack;
	int (*rx_func)(struct hci_uart *, u8);
	struct timer_list timer;
	struct hci_uart *hu;
	u8 tx_seq;
	u8 tx_ack;
	u8 tx_win;
	enum {
		H5_UNINITIALIZED = 0,
		H5_INITIALIZED = 1,
		H5_ACTIVE = 2,
	} state;
	enum {
		H5_AWAKE = 0,
		H5_SLEEPING = 1,
		H5_WAKING_UP = 2,
	} sleep;
	const struct h5_vnd *vnd;
	const char *id;
	struct gpio_desc *enable_gpio;
	struct gpio_desc *device_wake_gpio;
};

struct h5_vnd {
	int (*setup)(struct h5 *);
	void (*open)(struct h5 *);
	void (*close)(struct h5 *);
	int (*suspend)(struct h5 *);
	int (*resume)(struct h5 *);
	const struct acpi_gpio_mapping *acpi_gpio_map;
};

enum h5_driver_info {
	H5_INFO_WAKEUP_DISABLE = 1,
};

struct h5_device_data {
	uint32_t driver_info;
	struct h5_vnd *vnd;
};

enum {
	STATE_CHIP_VER_PENDING = 0,
	STATE_FW_REQ_PENDING = 1,
};

struct mrvl_data {
	struct sk_buff *rx_skb;
	struct sk_buff_head txq;
	struct sk_buff_head rawq;
	long unsigned int flags;
	unsigned int tx_len;
	u8 id;
	u8 rev;
};

struct mrvl_serdev {
	struct hci_uart hu;
};

struct hci_mrvl_pkt {
	__le16 lhs;
	__le16 rhs;
};

struct bt_iso_io_qos {
	__u32 interval;
	__u16 latency;
	__u16 sdu;
	__u8 phy;
	__u8 rtn;
};

struct bt_iso_qos {
	union {
		__u8 cig;
		__u8 big;
	};
	union {
		__u8 cis;
		__u8 bis;
	};
	union {
		__u8 sca;
		__u8 sync_interval;
	};
	__u8 packing;
	__u8 framing;
	struct bt_iso_io_qos in;
	struct bt_iso_io_qos out;
};

enum {
	HCI_UP = 0,
	HCI_INIT = 1,
	HCI_RUNNING = 2,
	HCI_PSCAN = 3,
	HCI_ISCAN = 4,
	HCI_AUTH = 5,
	HCI_ENCRYPT = 6,
	HCI_INQUIRY = 7,
	HCI_RAW = 8,
	HCI_RESET = 9,
};

struct hci_ev_cmd_complete {
	__u8 ncmd;
	__le16 opcode;
} __attribute__((packed));

struct hci_acl_hdr {
	__le16 handle;
	__le16 dlen;
};

struct hci_sco_hdr {
	__le16 handle;
	__u8 dlen;
} __attribute__((packed));

enum conn_reasons {
	CONN_REASON_PAIR_DEVICE = 0,
	CONN_REASON_L2CAP_CHAN = 1,
	CONN_REASON_SCO_CONNECT = 2,
	CONN_REASON_ISO_CONNECT = 3,
};

struct amp_mgr;

struct hci_conn {
	struct list_head list;
	atomic_t refcnt;
	bdaddr_t dst;
	__u8 dst_type;
	bdaddr_t src;
	__u8 src_type;
	bdaddr_t init_addr;
	__u8 init_addr_type;
	bdaddr_t resp_addr;
	__u8 resp_addr_type;
	__u8 adv_instance;
	__u16 handle;
	__u16 sync_handle;
	__u16 state;
	__u8 mode;
	__u8 type;
	__u8 role;
	bool out;
	__u8 attempt;
	__u8 dev_class[3];
	__u8 features[24];
	__u16 pkt_type;
	__u16 link_policy;
	__u8 key_type;
	__u8 auth_type;
	__u8 sec_level;
	__u8 pending_sec_level;
	__u8 pin_length;
	__u8 enc_key_size;
	__u8 io_capability;
	__u32 passkey_notify;
	__u8 passkey_entered;
	__u16 disc_timeout;
	__u16 conn_timeout;
	__u16 setting;
	__u16 auth_payload_timeout;
	__u16 le_conn_min_interval;
	__u16 le_conn_max_interval;
	__u16 le_conn_interval;
	__u16 le_conn_latency;
	__u16 le_supv_timeout;
	__u8 le_adv_data[31];
	__u8 le_adv_data_len;
	__u8 le_per_adv_data[252];
	__u8 le_per_adv_data_len;
	__u8 le_tx_phy;
	__u8 le_rx_phy;
	__s8 rssi;
	__s8 tx_power;
	__s8 max_tx_power;
	struct bt_iso_qos iso_qos;
	long unsigned int flags;
	enum conn_reasons conn_reason;
	__u32 clock;
	__u16 clock_accuracy;
	long unsigned int conn_info_timestamp;
	__u8 remote_cap;
	__u8 remote_auth;
	__u8 remote_id;
	unsigned int sent;
	struct sk_buff_head data_q;
	struct list_head chan_list;
	struct delayed_work disc_work;
	struct delayed_work auto_accept_work;
	struct delayed_work idle_work;
	struct delayed_work le_conn_timeout;
	struct work_struct le_scan_cleanup;
	int: 32;
	struct device dev;
	struct dentry *debugfs;
	struct hci_dev *hdev;
	void *l2cap_data;
	void *sco_data;
	void *iso_data;
	struct amp_mgr *amp_mgr;
	struct hci_conn *link;
	struct bt_codec codec;
	void (*connect_cfm_cb)(struct hci_conn *, u8);
	void (*security_cfm_cb)(struct hci_conn *, u8);
	void (*disconn_cfm_cb)(struct hci_conn *, u8);
	void (*cleanup)(struct hci_conn *);
	int: 32;
};

struct btintel_data {
	long unsigned int flags[1];
};

struct btusb_data {
	struct hci_dev *hdev;
	struct usb_device *udev;
	struct usb_interface *intf;
	struct usb_interface *isoc;
	struct usb_interface *diag;
	unsigned int isoc_ifnum;
	long unsigned int flags;
	bool poll_sync;
	int intr_interval;
	struct work_struct work;
	struct work_struct waker;
	struct delayed_work rx_work;
	struct sk_buff_head acl_q;
	struct usb_anchor deferred;
	struct usb_anchor tx_anchor;
	int tx_in_flight;
	spinlock_t txlock;
	struct usb_anchor intr_anchor;
	struct usb_anchor bulk_anchor;
	struct usb_anchor isoc_anchor;
	struct usb_anchor diag_anchor;
	struct usb_anchor ctrl_anchor;
	spinlock_t rxlock;
	struct sk_buff *evt_skb;
	struct sk_buff *acl_skb;
	struct sk_buff *sco_skb;
	struct usb_endpoint_descriptor *intr_ep;
	struct usb_endpoint_descriptor *bulk_tx_ep;
	struct usb_endpoint_descriptor *bulk_rx_ep;
	struct usb_endpoint_descriptor *isoc_tx_ep;
	struct usb_endpoint_descriptor *isoc_rx_ep;
	struct usb_endpoint_descriptor *diag_tx_ep;
	struct usb_endpoint_descriptor *diag_rx_ep;
	struct gpio_desc *reset_gpio;
	__u8 cmdreq_type;
	__u8 cmdreq;
	unsigned int sco_num;
	unsigned int air_mode;
	bool usb_alt6_packet_flow;
	int isoc_altsetting;
	int suspend_count;
	int (*recv_event)(struct hci_dev *, struct sk_buff *);
	int (*recv_acl)(struct hci_dev *, struct sk_buff *);
	int (*recv_bulk)(struct btusb_data *, void *, int);
	int (*setup_on_usb)(struct hci_dev *);
	int oob_wake_irq;
	unsigned int cmd_timeout_cnt;
};

struct qca_version {
	__le32 rom_version;
	__le32 patch_version;
	__le32 ram_version;
	__u8 chip_id;
	__u8 platform_id;
	__le16 flag;
	__u8 reserved[4];
};

struct qca_rampatch_version {
	__le16 rom_version_high;
	__le16 rom_version_low;
	__le16 patch_version;
};

struct qca_device_info {
	u32 rom_version;
	u8 rampatch_hdr;
	u8 nvm_hdr;
	u8 ver_offset;
};

struct hci_rp_read_bd_addr {
	__u8 status;
	bdaddr_t bdaddr;
};

enum {
	INTEL_TLV_CNVI_TOP = 16,
	INTEL_TLV_CNVR_TOP = 17,
	INTEL_TLV_CNVI_BT = 18,
	INTEL_TLV_CNVR_BT = 19,
	INTEL_TLV_CNVI_OTP = 20,
	INTEL_TLV_CNVR_OTP = 21,
	INTEL_TLV_DEV_REV_ID = 22,
	INTEL_TLV_USB_VENDOR_ID = 23,
	INTEL_TLV_USB_PRODUCT_ID = 24,
	INTEL_TLV_PCIE_VENDOR_ID = 25,
	INTEL_TLV_PCIE_DEVICE_ID = 26,
	INTEL_TLV_PCIE_SUBSYSTEM_ID = 27,
	INTEL_TLV_IMAGE_TYPE = 28,
	INTEL_TLV_TIME_STAMP = 29,
	INTEL_TLV_BUILD_TYPE = 30,
	INTEL_TLV_BUILD_NUM = 31,
	INTEL_TLV_FW_BUILD_PRODUCT = 32,
	INTEL_TLV_FW_BUILD_HW = 33,
	INTEL_TLV_FW_STEP = 34,
	INTEL_TLV_BT_SPEC = 35,
	INTEL_TLV_MFG_NAME = 36,
	INTEL_TLV_HCI_REV = 37,
	INTEL_TLV_LMP_SUBVER = 38,
	INTEL_TLV_OTP_PATCH_VER = 39,
	INTEL_TLV_SECURE_BOOT = 40,
	INTEL_TLV_KEY_FROM_HDR = 41,
	INTEL_TLV_OTP_LOCK = 42,
	INTEL_TLV_API_LOCK = 43,
	INTEL_TLV_DEBUG_LOCK = 44,
	INTEL_TLV_MIN_FW = 45,
	INTEL_TLV_LIMITED_CCE = 46,
	INTEL_TLV_SBE_TYPE = 47,
	INTEL_TLV_OTP_BDADDR = 48,
	INTEL_TLV_UNLOCKED_STATE = 49,
};

struct intel_tlv {
	u8 type;
	u8 len;
	u8 val[0];
};

struct intel_version_tlv {
	u32 cnvi_top;
	u32 cnvr_top;
	u32 cnvi_bt;
	u32 cnvr_bt;
	u16 dev_rev_id;
	u8 img_type;
	u16 timestamp;
	u8 build_type;
	u32 build_num;
	u8 secure_boot;
	u8 otp_lock;
	u8 api_lock;
	u8 debug_lock;
	u8 min_fw_build_nn;
	u8 min_fw_build_cw;
	u8 min_fw_build_yy;
	u8 limited_cce;
	u8 sbe_type;
	bdaddr_t otp_bd_addr;
};

struct intel_version {
	u8 status;
	u8 hw_platform;
	u8 hw_variant;
	u8 hw_revision;
	u8 fw_variant;
	u8 fw_revision;
	u8 fw_build_num;
	u8 fw_build_ww;
	u8 fw_build_yy;
	u8 fw_patch_num;
};

struct intel_boot_params {
	__u8 status;
	__u8 otp_format;
	__u8 otp_content;
	__u8 otp_patch;
	__le16 dev_revid;
	__u8 secure_boot;
	__u8 key_from_hdr;
	__u8 key_type;
	__u8 otp_lock;
	__u8 api_lock;
	__u8 debug_lock;
	bdaddr_t otp_bdaddr;
	__u8 min_fw_build_nn;
	__u8 min_fw_build_cw;
	__u8 min_fw_build_yy;
	__u8 limited_cce;
	__u8 unlocked_state;
} __attribute__((packed));

struct intel_bootup {
	__u8 zero;
	__u8 num_cmds;
	__u8 source;
	__u8 reset_type;
	__u8 reset_reason;
	__u8 ddc_status;
};

struct intel_secure_send_result {
	__u8 result;
	__le16 opcode;
	__u8 status;
} __attribute__((packed));

struct intel_reset {
	__u8 reset_type;
	__u8 patch_enable;
	__u8 ddc_reload;
	__u8 boot_option;
	__le32 boot_param;
};

struct intel_debug_features {
	__u8 page1[16];
};

struct intel_offload_use_cases {
	__u8 status;
	__u8 preset[8];
};

struct cmd_write_boot_params {
	u32 boot_addr;
	u8 fw_build_num;
	u8 fw_build_ww;
	u8 fw_build_yy;
} __attribute__((packed));

struct regmap_ibt_context {
	struct hci_dev *hdev;
	__u16 op_write;
	__u16 op_read;
};

struct ibt_cp_reg_access {
	__le32 addr;
	__u8 mode;
	__u8 len;
	__u8 data[0];
} __attribute__((packed));

struct ibt_rp_reg_access {
	__u8 status;
	__le32 addr;
	__u8 data[0];
} __attribute__((packed));

struct sdio_func;

typedef void sdio_irq_handler_t(struct sdio_func *);

struct mmc_card;

struct sdio_func_tuple;

struct sdio_func {
	struct mmc_card *card;
	int: 32;
	struct device dev;
	sdio_irq_handler_t *irq_handler;
	unsigned int num;
	unsigned char class;
	short unsigned int vendor;
	short unsigned int device;
	unsigned int max_blksize;
	unsigned int cur_blksize;
	unsigned int enable_timeout;
	unsigned int state;
	u8 *tmpbuf;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
	int: 32;
};

struct sdio_func_tuple {
	struct sdio_func_tuple *next;
	unsigned char code;
	unsigned char size;
	unsigned char data[0];
};

struct btmrvl_thread {
	struct task_struct *task;
	wait_queue_head_t wait_q;
	void *priv;
};

struct btmrvl_device {
	void *card;
	struct hci_dev *hcidev;
	u8 dev_type;
	u8 tx_dnld_rdy;
	u8 psmode;
	u8 pscmd;
	u8 hsmode;
	u8 hscmd;
	u16 gpio_gap;
	u8 hscfgcmd;
	u8 sendcmdflag;
};

struct btmrvl_adapter {
	void *hw_regs_buf;
	u8 *hw_regs;
	u32 int_count;
	struct sk_buff_head tx_queue;
	u8 psmode;
	u8 ps_state;
	u8 hs_state;
	u8 wakeup_tries;
	wait_queue_head_t cmd_wait_q;
	wait_queue_head_t event_hs_wait_q;
	u8 cmd_complete;
	bool is_suspended;
	bool is_suspending;
};

struct btmrvl_private {
	struct btmrvl_device btmrvl_dev;
	struct btmrvl_adapter *adapter;
	struct btmrvl_thread main_thread;
	int (*hw_host_to_card)(struct btmrvl_private *, u8 *, u16);
	int (*hw_wakeup_firmware)(struct btmrvl_private *);
	int (*hw_process_int_status)(struct btmrvl_private *);
	spinlock_t driver_lock;
	void *debugfs_data;
	bool surprise_removed;
};

struct btmrvl_event {
	u8 ec;
	u8 length;
	u8 data[4];
};

struct btmrvl_plt_wake_cfg {
	int irq_bt;
	bool wake_by_bt;
};

struct btmrvl_sdio_card_reg {
	u8 cfg;
	u8 host_int_mask;
	u8 host_intstatus;
	u8 card_status;
	u8 sq_read_base_addr_a0;
	u8 sq_read_base_addr_a1;
	u8 card_revision;
	u8 card_fw_status0;
	u8 card_fw_status1;
	u8 card_rx_len;
	u8 card_rx_unit;
	u8 io_port_0;
	u8 io_port_1;
	u8 io_port_2;
	bool int_read_to_clear;
	u8 host_int_rsr;
	u8 card_misc_cfg;
	u8 fw_dump_ctrl;
	u8 fw_dump_start;
	u8 fw_dump_end;
};

struct btmrvl_sdio_card {
	struct sdio_func *func;
	u32 ioport;
	const char *helper;
	const char *firmware;
	const struct btmrvl_sdio_card_reg *reg;
	bool support_pscan_win_report;
	bool supports_fw_dump;
	u16 sd_blksz_fw_dl;
	u8 rx_unit;
	struct btmrvl_private *priv;
	struct device_node *plt_of_node;
	struct btmrvl_plt_wake_cfg *plt_wake_cfg;
};

struct btmrvl_debugfs_data {
	struct dentry *config_dir;
	struct dentry *status_dir;
};

struct sdio_device_id {
	__u8 class;
	__u16 vendor;
	__u16 device;
	kernel_ulong_t driver_data;
};

typedef unsigned int mmc_pm_flag_t;

struct sdio_driver {
	char *name;
	const struct sdio_device_id *id_table;
	int (*probe)(struct sdio_func *, const struct sdio_device_id *);
	void (*remove)(struct sdio_func *);
	struct device_driver drv;
};

enum rdwr_status {
	RDWR_STATUS_SUCCESS = 0,
	RDWR_STATUS_FAILURE = 1,
	RDWR_STATUS_DONE = 2,
};

struct memory_type_mapping {
	u8 mem_name[8];
	u8 *mem_ptr;
	u32 mem_size;
	u8 done_flag;
};

struct btmrvl_sdio_device {
	const char *helper;
	const char *firmware;
	const struct btmrvl_sdio_card_reg *reg;
	const bool support_pscan_win_report;
	u16 sd_blksz_fw_dl;
	bool supports_fw_dump;
};

struct bcm_set_pcm_int_params {
	__u8 routing;
	__u8 rate;
	__u8 frame_sync;
	__u8 sync_mode;
	__u8 clock_mode;
};

typedef char bcm_fw_name[64];

struct bcm_subver_table {
	u16 subver;
	const char *name;
};

struct rtl_download_cmd {
	__u8 index;
	__u8 data[252];
};

struct rtl_rom_version_evt {
	__u8 status;
	__u8 version;
};

struct rtl_epatch_header {
	__u8 signature[8];
	__le32 fw_version;
	__le16 num_patches;
} __attribute__((packed));

struct rtl_vendor_config_entry {
	__le16 offset;
	__u8 len;
	__u8 data[0];
} __attribute__((packed));

struct rtl_vendor_config {
	__le32 signature;
	__le16 total_len;
	struct rtl_vendor_config_entry entry[0];
} __attribute__((packed));

enum btrtl_chip_id {
	CHIP_ID_8723A = 0,
	CHIP_ID_8723B = 1,
	CHIP_ID_8821A = 2,
	CHIP_ID_8761A = 3,
	CHIP_ID_8822B = 8,
	CHIP_ID_8723D = 9,
	CHIP_ID_8821C = 10,
	CHIP_ID_8822C = 13,
	CHIP_ID_8761B = 14,
	CHIP_ID_8852A = 18,
	CHIP_ID_8852B = 20,
	CHIP_ID_8852C = 25,
};

struct id_table {
	__u16 match_flags;
	__u16 lmp_subver;
	__u16 hci_rev;
	__u8 hci_ver;
	__u8 hci_bus;
	bool config_needed;
	bool has_rom_version;
	bool has_msft_ext;
	char *fw_name;
	char *cfg_name;
};

struct btrtl_device_info {
	const struct id_table *ic_info;
	u8 rom_version;
	u8 *fw_data;
	int fw_len;
	u8 *cfg_data;
	int cfg_len;
	bool drop_fw;
	int project_id;
};

enum opp_table_access {
	OPP_TABLE_ACCESS_UNKNOWN = 0,
	OPP_TABLE_ACCESS_EXCLUSIVE = 1,
	OPP_TABLE_ACCESS_SHARED = 2,
};

typedef int (*config_clks_t)(struct device *, struct opp_table *, struct dev_pm_opp *, void *, bool);

typedef int (*config_regulators_t)(struct device *, struct dev_pm_opp *, struct dev_pm_opp *, struct regulator **, unsigned int);

struct icc_path;

struct opp_table {
	struct list_head node;
	struct list_head lazy;
	struct blocking_notifier_head head;
	struct list_head dev_list;
	struct list_head opp_list;
	struct kref kref;
	struct mutex lock;
	struct device_node *np;
	long unsigned int clock_latency_ns_max;
	unsigned int voltage_tolerance_v1;
	unsigned int parsed_static_opps;
	enum opp_table_access shared_opp;
	long unsigned int rate_clk_single;
	struct dev_pm_opp *current_opp;
	struct dev_pm_opp *suspend_opp;
	struct mutex genpd_virt_dev_lock;
	struct device **genpd_virt_devs;
	struct opp_table **required_opp_tables;
	unsigned int required_opp_count;
	unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char *prop_name;
	config_clks_t config_clks;
	struct clk **clks;
	struct clk *clk;
	int clk_count;
	config_regulators_t config_regulators;
	struct regulator **regulators;
	int regulator_count;
	struct icc_path **paths;
	unsigned int path_count;
	bool enabled;
	bool genpd_performance_state;
	bool is_genpd;
	struct dentry *dentry;
	char dentry_name[255];
};

struct dev_pm_opp_supply;

struct dev_pm_opp_icc_bw;

struct dev_pm_opp {
	struct list_head node;
	struct kref kref;
	bool available;
	bool dynamic;
	bool turbo;
	bool suspend;
	bool removed;
	unsigned int pstate;
	long unsigned int *rates;
	unsigned int level;
	struct dev_pm_opp_supply *supplies;
	struct dev_pm_opp_icc_bw *bandwidth;
	long unsigned int clock_latency_ns;
	struct dev_pm_opp **required_opps;
	struct opp_table *opp_table;
	struct device_node *np;
	struct dentry *dentry;
	const char *of_name;
};

enum dev_pm_opp_event {
	OPP_EVENT_ADD = 0,
	OPP_EVENT_REMOVE = 1,
	OPP_EVENT_ENABLE = 2,
	OPP_EVENT_DISABLE = 3,
	OPP_EVENT_ADJUST_VOLTAGE = 4,
};

struct dev_pm_opp_supply {
	long unsigned int u_volt;
	long unsigned int u_volt_min;
	long unsigned int u_volt_max;
	long unsigned int u_amp;
	long unsigned int u_watt;
};

struct dev_pm_opp_icc_bw {
	u32 avg;
	u32 peak;
};

struct dev_pm_opp_config {
	const char * const *clk_names;
	config_clks_t config_clks;
	const char *prop_name;
	config_regulators_t config_regulators;
	const unsigned int *supported_hw;
	unsigned int supported_hw_count;
	const char * const *regulator_names;
	const char * const *genpd_names;
	struct device ***virt_devs;
};

struct opp_config_data {
	struct opp_table *opp_table;
	unsigned int flags;
};

struct opp_device {
	struct list_head node;
	const struct device *dev;
	struct dentry *dentry;
};

struct em_data_callback {};

struct cpufreq_policy_data {
	struct cpufreq_cpuinfo cpuinfo;
	struct cpufreq_frequency_table *freq_table;
	unsigned int cpu;
	unsigned int min;
	unsigned int max;
};

struct freq_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpufreq_policy *, char *);
	ssize_t (*store)(struct cpufreq_policy *, const char *, size_t);
};

struct cpufreq_driver {
	char name[16];
	u16 flags;
	void *driver_data;
	int (*init)(struct cpufreq_policy *);
	int (*verify)(struct cpufreq_policy_data *);
	int (*setpolicy)(struct cpufreq_policy *);
	int (*target)(struct cpufreq_policy *, unsigned int, unsigned int);
	int (*target_index)(struct cpufreq_policy *, unsigned int);
	unsigned int (*fast_switch)(struct cpufreq_policy *, unsigned int);
	void (*adjust_perf)(unsigned int, long unsigned int, long unsigned int, long unsigned int);
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	unsigned int (*get)(unsigned int);
	void (*update_limits)(unsigned int);
	int (*bios_limit)(int, unsigned int *);
	int (*online)(struct cpufreq_policy *);
	int (*offline)(struct cpufreq_policy *);
	int (*exit)(struct cpufreq_policy *);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
	void (*ready)(struct cpufreq_policy *);
	struct freq_attr **attr;
	bool boost_enabled;
	int (*set_boost)(struct cpufreq_policy *, int);
	void (*register_em)(struct cpufreq_policy *);
};

struct cpufreq_stats {
	unsigned int total_trans;
	int: 32;
	long long unsigned int last_time;
	unsigned int max_state;
	unsigned int state_num;
	unsigned int last_index;
	u64 *time_in_state;
	unsigned int *freq_table;
	unsigned int *trans_table;
	unsigned int reset_pending;
	int: 32;
	long long unsigned int reset_time;
};

struct gov_attr_set {
	struct kobject kobj;
	struct list_head policy_list;
	struct mutex update_lock;
	int usage_count;
};

struct governor_attr {
	struct attribute attr;
	ssize_t (*show)(struct gov_attr_set *, char *);
	ssize_t (*store)(struct gov_attr_set *, const char *, size_t);
};

enum {
	OD_NORMAL_SAMPLE = 0,
	OD_SUB_SAMPLE = 1,
};

struct dbs_governor;

struct dbs_data {
	struct gov_attr_set attr_set;
	struct dbs_governor *gov;
	void *tuners;
	unsigned int ignore_nice_load;
	unsigned int sampling_rate;
	unsigned int sampling_down_factor;
	unsigned int up_threshold;
	unsigned int io_is_busy;
};

struct policy_dbs_info;

struct dbs_governor {
	struct cpufreq_governor gov;
	struct kobj_type kobj_type;
	struct dbs_data *gdbs_data;
	unsigned int (*gov_dbs_update)(struct cpufreq_policy *);
	struct policy_dbs_info * (*alloc)();
	void (*free)(struct policy_dbs_info *);
	int (*init)(struct dbs_data *);
	void (*exit)(struct dbs_data *);
	void (*start)(struct cpufreq_policy *);
};

struct policy_dbs_info {
	struct cpufreq_policy *policy;
	struct mutex update_mutex;
	u64 last_sample_time;
	s64 sample_delay_ns;
	atomic_t work_count;
	struct irq_work irq_work;
	struct work_struct work;
	struct dbs_data *dbs_data;
	struct list_head list;
	unsigned int rate_mult;
	unsigned int idle_periods;
	bool is_shared;
	bool work_in_progress;
	int: 16;
	int: 32;
};

struct od_ops {
	unsigned int (*powersave_bias_target)(struct cpufreq_policy *, unsigned int, unsigned int);
};

struct od_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int freq_lo;
	unsigned int freq_lo_delay_us;
	unsigned int freq_hi_delay_us;
	unsigned int sample_type: 1;
};

struct od_dbs_tuners {
	unsigned int powersave_bias;
};

struct cs_policy_dbs_info {
	struct policy_dbs_info policy_dbs;
	unsigned int down_skip;
	unsigned int requested_freq;
};

struct cs_dbs_tuners {
	unsigned int down_threshold;
	unsigned int freq_step;
};

struct cpu_dbs_info {
	u64 prev_cpu_idle;
	u64 prev_update_time;
	u64 prev_cpu_nice;
	unsigned int prev_load;
	struct update_util_data update_util;
	struct policy_dbs_info *policy_dbs;
	int: 32;
};

struct cpufreq_dt_platform_data {
	bool have_governor_per_policy;
	unsigned int (*get_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*target_intermediate)(struct cpufreq_policy *, unsigned int);
	int (*suspend)(struct cpufreq_policy *);
	int (*resume)(struct cpufreq_policy *);
};

struct private_data {
	struct list_head node;
	cpumask_var_t cpus;
	struct device *cpu_dev;
	struct cpufreq_frequency_table *freq_table;
	bool have_static_opps;
	int opp_token;
};

enum IMX6_CPUFREQ_CLKS {
	ARM = 0,
	PLL1_SYS = 1,
	STEP = 2,
	PLL1_SW = 3,
	PLL2_PFD2_396M = 4,
	PLL1 = 5,
	PLL1_BYPASS = 6,
	PLL1_BYPASS_SRC = 7,
	PLL2_BUS = 8,
	SECONDARY_SEL = 9,
};

enum IMX7ULP_CPUFREQ_CLKS {
	ARM___2 = 0,
	CORE = 1,
	SCS_SEL = 2,
	HSRUN_CORE = 3,
	HSRUN_SCS_SEL = 4,
	FIRC = 5,
};

struct cpuidle_governor {
	char name[16];
	struct list_head governor_list;
	unsigned int rating;
	int (*enable)(struct cpuidle_driver *, struct cpuidle_device *);
	void (*disable)(struct cpuidle_driver *, struct cpuidle_device *);
	int (*select)(struct cpuidle_driver *, struct cpuidle_device *, bool *);
	void (*reflect)(struct cpuidle_device *, int);
};

struct cpuidle_state_kobj {
	struct cpuidle_state *state;
	struct cpuidle_state_usage *state_usage;
	struct completion kobj_unregister;
	struct kobject kobj;
	struct cpuidle_device *device;
};

struct cpuidle_driver_kobj {
	struct cpuidle_driver *drv;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_device_kobj {
	struct cpuidle_device *dev;
	struct completion kobj_unregister;
	struct kobject kobj;
};

struct cpuidle_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_device *, char *);
	ssize_t (*store)(struct cpuidle_device *, const char *, size_t);
};

struct cpuidle_state_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_state *, struct cpuidle_state_usage *, char *);
	ssize_t (*store)(struct cpuidle_state *, struct cpuidle_state_usage *, const char *, size_t);
};

struct cpuidle_driver_attr {
	struct attribute attr;
	ssize_t (*show)(struct cpuidle_driver *, char *);
	ssize_t (*store)(struct cpuidle_driver *, const char *, size_t);
};

struct menu_device {
	int needs_update;
	int tick_wakeup;
	u64 next_timer_ns;
	unsigned int bucket;
	unsigned int correction_factor[12];
	unsigned int intervals[8];
	int interval_ptr;
};

struct psci_cpuidle_data {
	u32 *psci_states;
	struct device *dev;
};

struct psci_pd_provider {
	struct list_head link;
	struct device_node *node;
};

struct mmc_cid {
	unsigned int manfid;
	char prod_name[8];
	unsigned char prv;
	unsigned int serial;
	short unsigned int oemid;
	short unsigned int year;
	unsigned char hwrev;
	unsigned char fwrev;
	unsigned char month;
};

struct mmc_csd {
	unsigned char structure;
	unsigned char mmca_vsn;
	short unsigned int cmdclass;
	short unsigned int taac_clks;
	unsigned int taac_ns;
	unsigned int c_size;
	unsigned int r2w_factor;
	unsigned int max_dtr;
	unsigned int erase_size;
	unsigned int read_blkbits;
	unsigned int write_blkbits;
	unsigned int capacity;
	unsigned int read_partial: 1;
	unsigned int read_misalign: 1;
	unsigned int write_partial: 1;
	unsigned int write_misalign: 1;
	unsigned int dsr_imp: 1;
};

struct mmc_ext_csd {
	u8 rev;
	u8 erase_group_def;
	u8 sec_feature_support;
	u8 rel_sectors;
	u8 rel_param;
	bool enhanced_rpmb_supported;
	u8 part_config;
	u8 cache_ctrl;
	u8 rst_n_function;
	u8 max_packed_writes;
	u8 max_packed_reads;
	u8 packed_event_en;
	unsigned int part_time;
	unsigned int sa_timeout;
	unsigned int generic_cmd6_time;
	unsigned int power_off_longtime;
	u8 power_off_notification;
	unsigned int hs_max_dtr;
	unsigned int hs200_max_dtr;
	unsigned int sectors;
	unsigned int hc_erase_size;
	unsigned int hc_erase_timeout;
	unsigned int sec_trim_mult;
	unsigned int sec_erase_mult;
	unsigned int trim_timeout;
	bool partition_setting_completed;
	int: 24;
	int: 32;
	long long unsigned int enhanced_area_offset;
	unsigned int enhanced_area_size;
	unsigned int cache_size;
	bool hpi_en;
	bool hpi;
	unsigned int hpi_cmd;
	bool bkops;
	bool man_bkops_en;
	bool auto_bkops_en;
	unsigned int data_sector_size;
	unsigned int data_tag_unit_size;
	unsigned int boot_ro_lock;
	bool boot_ro_lockable;
	bool ffu_capable;
	bool cmdq_en;
	bool cmdq_support;
	unsigned int cmdq_depth;
	u8 fwrev[8];
	u8 raw_exception_status;
	u8 raw_partition_support;
	u8 raw_rpmb_size_mult;
	u8 raw_erased_mem_count;
	u8 strobe_support;
	u8 raw_ext_csd_structure;
	u8 raw_card_type;
	u8 raw_driver_strength;
	u8 out_of_int_time;
	u8 raw_pwr_cl_52_195;
	u8 raw_pwr_cl_26_195;
	u8 raw_pwr_cl_52_360;
	u8 raw_pwr_cl_26_360;
	u8 raw_s_a_timeout;
	u8 raw_hc_erase_gap_size;
	u8 raw_erase_timeout_mult;
	u8 raw_hc_erase_grp_size;
	u8 raw_boot_mult;
	u8 raw_sec_trim_mult;
	u8 raw_sec_erase_mult;
	u8 raw_sec_feature_support;
	u8 raw_trim_mult;
	u8 raw_pwr_cl_200_195;
	u8 raw_pwr_cl_200_360;
	u8 raw_pwr_cl_ddr_52_195;
	u8 raw_pwr_cl_ddr_52_360;
	u8 raw_pwr_cl_ddr_200_360;
	u8 raw_bkops_status;
	u8 raw_sectors[4];
	u8 pre_eol_info;
	u8 device_life_time_est_typ_a;
	u8 device_life_time_est_typ_b;
	unsigned int feature_support;
};

struct sd_scr {
	unsigned char sda_vsn;
	unsigned char sda_spec3;
	unsigned char sda_spec4;
	unsigned char sda_specx;
	unsigned char bus_widths;
	unsigned char cmds;
};

struct sd_ssr {
	unsigned int au;
	unsigned int erase_timeout;
	unsigned int erase_offset;
};

struct sd_switch_caps {
	unsigned int hs_max_dtr;
	unsigned int uhs_max_dtr;
	unsigned int sd3_bus_mode;
	unsigned int sd3_drv_type;
	unsigned int sd3_curr_limit;
};

struct sd_ext_reg {
	u8 fno;
	u8 page;
	u16 offset;
	u8 rev;
	u8 feature_enabled;
	u8 feature_support;
};

struct sdio_cccr {
	unsigned int sdio_vsn;
	unsigned int sd_vsn;
	unsigned int multi_block: 1;
	unsigned int low_speed: 1;
	unsigned int wide_bus: 1;
	unsigned int high_power: 1;
	unsigned int high_speed: 1;
	unsigned int disable_cd: 1;
	unsigned int enable_async_irq: 1;
};

struct sdio_cis {
	short unsigned int vendor;
	short unsigned int device;
	short unsigned int blksize;
	unsigned int max_dtr;
};

struct mmc_part {
	u64 size;
	unsigned int part_cfg;
	char name[20];
	bool force_ro;
	unsigned int area_type;
};

struct mmc_host;

struct mmc_card {
	struct mmc_host *host;
	int: 32;
	struct device dev;
	u32 ocr;
	unsigned int rca;
	unsigned int type;
	unsigned int state;
	unsigned int quirks;
	unsigned int quirk_max_rate;
	bool reenable_cmdq;
	unsigned int erase_size;
	unsigned int erase_shift;
	unsigned int pref_erase;
	unsigned int eg_boundary;
	unsigned int erase_arg;
	u8 erased_byte;
	u32 raw_cid[4];
	u32 raw_csd[4];
	u32 raw_scr[2];
	u32 raw_ssr[16];
	struct mmc_cid cid;
	struct mmc_csd csd;
	int: 32;
	struct mmc_ext_csd ext_csd;
	struct sd_scr scr;
	struct sd_ssr ssr;
	struct sd_switch_caps sw_caps;
	struct sd_ext_reg ext_power;
	struct sd_ext_reg ext_perf;
	unsigned int sdio_funcs;
	atomic_t sdio_funcs_probed;
	struct sdio_cccr cccr;
	struct sdio_cis cis;
	struct sdio_func *sdio_func[7];
	struct sdio_func *sdio_single_irq;
	u8 major_rev;
	u8 minor_rev;
	unsigned int num_info;
	const char **info;
	struct sdio_func_tuple *tuples;
	unsigned int sd_bus_speed;
	unsigned int mmc_avail_type;
	unsigned int drive_strength;
	struct dentry *debugfs_root;
	struct mmc_part part[7];
	unsigned int nr_parts;
	struct workqueue_struct *complete_wq;
};

struct mmc_ios {
	unsigned int clock;
	short unsigned int vdd;
	unsigned int power_delay_ms;
	unsigned char bus_mode;
	unsigned char chip_select;
	unsigned char power_mode;
	unsigned char bus_width;
	unsigned char timing;
	unsigned char signal_voltage;
	unsigned char drv_type;
	bool enhanced_strobe;
};

struct mmc_ctx {
	struct task_struct *task;
};

struct mmc_slot {
	int cd_irq;
	bool cd_wake_enabled;
	void *handler_priv;
};

struct mmc_supply {
	struct regulator *vmmc;
	struct regulator *vqmmc;
};

struct mmc_host_ops;

struct mmc_pwrseq;

struct mmc_bus_ops;

struct mmc_request;

struct mmc_cqe_ops;

struct mmc_host {
	struct device *parent;
	int: 32;
	struct device class_dev;
	int index;
	const struct mmc_host_ops *ops;
	struct mmc_pwrseq *pwrseq;
	unsigned int f_min;
	unsigned int f_max;
	unsigned int f_init;
	u32 ocr_avail;
	u32 ocr_avail_sdio;
	u32 ocr_avail_sd;
	u32 ocr_avail_mmc;
	struct wakeup_source *ws;
	u32 max_current_330;
	u32 max_current_300;
	u32 max_current_180;
	u32 caps;
	u32 caps2;
	int fixed_drv_type;
	mmc_pm_flag_t pm_caps;
	unsigned int max_seg_size;
	short unsigned int max_segs;
	short unsigned int unused;
	unsigned int max_req_size;
	unsigned int max_blk_size;
	unsigned int max_blk_count;
	unsigned int max_busy_timeout;
	spinlock_t lock;
	struct mmc_ios ios;
	unsigned int use_spi_crc: 1;
	unsigned int claimed: 1;
	unsigned int doing_init_tune: 1;
	unsigned int can_retune: 1;
	unsigned int doing_retune: 1;
	unsigned int retune_now: 1;
	unsigned int retune_paused: 1;
	unsigned int retune_crc_disable: 1;
	unsigned int can_dma_map_merge: 1;
	int rescan_disable;
	int rescan_entered;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct timer_list retune_timer;
	bool trigger_card_event;
	struct mmc_card *card;
	wait_queue_head_t wq;
	struct mmc_ctx *claimer;
	int claim_cnt;
	struct mmc_ctx default_ctx;
	struct delayed_work detect;
	int detect_change;
	struct mmc_slot slot;
	const struct mmc_bus_ops *bus_ops;
	unsigned int sdio_irqs;
	struct task_struct *sdio_irq_thread;
	struct delayed_work sdio_irq_work;
	bool sdio_irq_pending;
	atomic_t sdio_irq_thread_abort;
	mmc_pm_flag_t pm_flags;
	struct led_trigger *led;
	bool regulator_enabled;
	struct mmc_supply supply;
	struct dentry *debugfs_root;
	struct mmc_request *ongoing_mrq;
	unsigned int actual_clock;
	unsigned int slotno;
	int dsr_req;
	u32 dsr;
	const struct mmc_cqe_ops *cqe_ops;
	void *cqe_private;
	int cqe_qdepth;
	bool cqe_enabled;
	bool cqe_on;
	bool hsq_enabled;
	u32 err_stats[15];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int private[0];
};

struct mmc_data;

struct mmc_command {
	u32 opcode;
	u32 arg;
	u32 resp[4];
	unsigned int flags;
	unsigned int retries;
	int error;
	unsigned int busy_timeout;
	struct mmc_data *data;
	struct mmc_request *mrq;
};

struct mmc_data {
	unsigned int timeout_ns;
	unsigned int timeout_clks;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int blk_addr;
	int error;
	unsigned int flags;
	unsigned int bytes_xfered;
	struct mmc_command *stop;
	struct mmc_request *mrq;
	unsigned int sg_len;
	int sg_count;
	struct scatterlist *sg;
	s32 host_cookie;
};

struct mmc_request {
	struct mmc_command *sbc;
	struct mmc_command *cmd;
	struct mmc_data *data;
	struct mmc_command *stop;
	struct completion completion;
	struct completion cmd_completion;
	void (*done)(struct mmc_request *);
	void (*recovery_notifier)(struct mmc_request *);
	struct mmc_host *host;
	bool cap_cmd_during_tfr;
	int tag;
};

enum mmc_err_stat {
	MMC_ERR_CMD_TIMEOUT = 0,
	MMC_ERR_CMD_CRC = 1,
	MMC_ERR_DAT_TIMEOUT = 2,
	MMC_ERR_DAT_CRC = 3,
	MMC_ERR_AUTO_CMD = 4,
	MMC_ERR_ADMA = 5,
	MMC_ERR_TUNING = 6,
	MMC_ERR_CMDQ_RED = 7,
	MMC_ERR_CMDQ_GCE = 8,
	MMC_ERR_CMDQ_ICCE = 9,
	MMC_ERR_REQ_TIMEOUT = 10,
	MMC_ERR_CMDQ_REQ_TIMEOUT = 11,
	MMC_ERR_ICE_CFG = 12,
	MMC_ERR_CTRL_TIMEOUT = 13,
	MMC_ERR_UNEXPECTED_IRQ = 14,
	MMC_ERR_MAX = 15,
};

struct mmc_host_ops {
	void (*post_req)(struct mmc_host *, struct mmc_request *, int);
	void (*pre_req)(struct mmc_host *, struct mmc_request *);
	void (*request)(struct mmc_host *, struct mmc_request *);
	int (*request_atomic)(struct mmc_host *, struct mmc_request *);
	void (*set_ios)(struct mmc_host *, struct mmc_ios *);
	int (*get_ro)(struct mmc_host *);
	int (*get_cd)(struct mmc_host *);
	void (*enable_sdio_irq)(struct mmc_host *, int);
	void (*ack_sdio_irq)(struct mmc_host *);
	void (*init_card)(struct mmc_host *, struct mmc_card *);
	int (*start_signal_voltage_switch)(struct mmc_host *, struct mmc_ios *);
	int (*card_busy)(struct mmc_host *);
	int (*execute_tuning)(struct mmc_host *, u32);
	int (*prepare_hs400_tuning)(struct mmc_host *, struct mmc_ios *);
	int (*execute_hs400_tuning)(struct mmc_host *, struct mmc_card *);
	int (*hs400_prepare_ddr)(struct mmc_host *);
	void (*hs400_downgrade)(struct mmc_host *);
	void (*hs400_complete)(struct mmc_host *);
	void (*hs400_enhanced_strobe)(struct mmc_host *, struct mmc_ios *);
	int (*select_drive_strength)(struct mmc_card *, unsigned int, int, int, int *);
	void (*card_hw_reset)(struct mmc_host *);
	void (*card_event)(struct mmc_host *);
	int (*multi_io_quirk)(struct mmc_card *, unsigned int, int);
	int (*init_sd_express)(struct mmc_host *, struct mmc_ios *);
};

struct mmc_cqe_ops {
	int (*cqe_enable)(struct mmc_host *, struct mmc_card *);
	void (*cqe_disable)(struct mmc_host *);
	int (*cqe_request)(struct mmc_host *, struct mmc_request *);
	void (*cqe_post_req)(struct mmc_host *, struct mmc_request *);
	void (*cqe_off)(struct mmc_host *);
	int (*cqe_wait_for_idle)(struct mmc_host *);
	bool (*cqe_timeout)(struct mmc_host *, struct mmc_request *, bool *);
	void (*cqe_recovery_start)(struct mmc_host *);
	void (*cqe_recovery_finish)(struct mmc_host *);
};

struct mmc_pwrseq_ops;

struct mmc_pwrseq {
	const struct mmc_pwrseq_ops *ops;
	struct device *dev;
	struct list_head pwrseq_node;
	struct module *owner;
};

struct mmc_bus_ops {
	void (*remove)(struct mmc_host *);
	void (*detect)(struct mmc_host *);
	int (*pre_suspend)(struct mmc_host *);
	int (*suspend)(struct mmc_host *);
	int (*resume)(struct mmc_host *);
	int (*runtime_suspend)(struct mmc_host *);
	int (*runtime_resume)(struct mmc_host *);
	int (*alive)(struct mmc_host *);
	int (*shutdown)(struct mmc_host *);
	int (*hw_reset)(struct mmc_host *);
	int (*sw_reset)(struct mmc_host *);
	bool (*cache_enabled)(struct mmc_host *);
	int (*flush_cache)(struct mmc_host *);
};

struct trace_event_raw_mmc_request_start {
	struct trace_entry ent;
	u32 cmd_opcode;
	u32 cmd_arg;
	unsigned int cmd_flags;
	unsigned int cmd_retries;
	u32 stop_opcode;
	u32 stop_arg;
	unsigned int stop_flags;
	unsigned int stop_retries;
	u32 sbc_opcode;
	u32 sbc_arg;
	unsigned int sbc_flags;
	unsigned int sbc_retries;
	unsigned int blocks;
	unsigned int blk_addr;
	unsigned int blksz;
	unsigned int data_flags;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_mmc_request_done {
	struct trace_entry ent;
	u32 cmd_opcode;
	int cmd_err;
	u32 cmd_resp[4];
	unsigned int cmd_retries;
	u32 stop_opcode;
	int stop_err;
	u32 stop_resp[4];
	unsigned int stop_retries;
	u32 sbc_opcode;
	int sbc_err;
	u32 sbc_resp[4];
	unsigned int sbc_retries;
	unsigned int bytes_xfered;
	int data_err;
	int tag;
	unsigned int can_retune;
	unsigned int doing_retune;
	unsigned int retune_now;
	int need_retune;
	int hold_retune;
	unsigned int retune_period;
	struct mmc_request *mrq;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_data_offsets_mmc_request_start {
	u32 name;
};

struct trace_event_data_offsets_mmc_request_done {
	u32 name;
};

typedef void (*btf_trace_mmc_request_start)(void *, struct mmc_host *, struct mmc_request *);

typedef void (*btf_trace_mmc_request_done)(void *, struct mmc_host *, struct mmc_request *);

struct mmc_pwrseq_ops {
	void (*pre_power_on)(struct mmc_host *);
	void (*post_power_on)(struct mmc_host *);
	void (*power_off)(struct mmc_host *);
	void (*reset)(struct mmc_host *);
};

enum mmc_busy_cmd {
	MMC_BUSY_CMD6 = 0,
	MMC_BUSY_ERASE = 1,
	MMC_BUSY_HPI = 2,
	MMC_BUSY_EXTR_SINGLE = 3,
	MMC_BUSY_IO = 4,
};

struct mmc_driver {
	struct device_driver drv;
	int (*probe)(struct mmc_card *);
	void (*remove)(struct mmc_card *);
	void (*shutdown)(struct mmc_card *);
};

struct mmc_clk_phase {
	bool valid;
	u16 in_deg;
	u16 out_deg;
};

struct mmc_clk_phase_map {
	struct mmc_clk_phase phase[11];
};

struct mmc_fixup {
	const char *name;
	int: 32;
	u64 rev_start;
	u64 rev_end;
	unsigned int manfid;
	short unsigned int oemid;
	u16 cis_vendor;
	u16 cis_device;
	unsigned int ext_csd_rev;
	const char *of_compatible;
	void (*vendor_fixup)(struct mmc_card *, int);
	int data;
	int: 32;
};

struct mmc_busy_data {
	struct mmc_card *card;
	bool retry_crc_err;
	enum mmc_busy_cmd busy_cmd;
};

struct mmc_op_cond_busy_data {
	struct mmc_host *host;
	u32 ocr;
	struct mmc_command *cmd;
};

struct sd_busy_data {
	struct mmc_card *card;
	u8 *reg_buf;
};

typedef int tpl_parse_t(struct mmc_card *, struct sdio_func *, const unsigned char *, unsigned int);

struct cis_tpl {
	unsigned char code;
	unsigned char min_size;
	tpl_parse_t *parse;
};

struct mmc_gpio {
	struct gpio_desc *ro_gpio;
	struct gpio_desc *cd_gpio;
	irqreturn_t (*cd_gpio_isr)(int, void *);
	char *ro_label;
	char *cd_label;
	u32 cd_debounce_delay_ms;
};

struct mmc_pwrseq_simple {
	struct mmc_pwrseq pwrseq;
	bool clk_enabled;
	u32 post_power_on_delay_ms;
	u32 power_off_delay_us;
	struct clk *ext_clk;
	struct gpio_descs *reset_gpios;
};

struct mmc_pwrseq_emmc {
	struct mmc_pwrseq pwrseq;
	struct notifier_block reset_nb;
	struct gpio_desc *reset_gpio;
};

struct mmc_ioc_cmd {
	int write_flag;
	int is_acmd;
	__u32 opcode;
	__u32 arg;
	__u32 response[4];
	unsigned int flags;
	unsigned int blksz;
	unsigned int blocks;
	unsigned int postsleep_min_us;
	unsigned int postsleep_max_us;
	unsigned int data_timeout_ns;
	unsigned int cmd_timeout_ms;
	__u32 __pad;
	__u64 data_ptr;
};

struct mmc_ioc_multi_cmd {
	__u64 num_of_cmds;
	struct mmc_ioc_cmd cmds[0];
};

enum mmc_issued {
	MMC_REQ_STARTED = 0,
	MMC_REQ_BUSY = 1,
	MMC_REQ_FAILED_TO_START = 2,
	MMC_REQ_FINISHED = 3,
};

enum mmc_issue_type {
	MMC_ISSUE_SYNC = 0,
	MMC_ISSUE_DCMD = 1,
	MMC_ISSUE_ASYNC = 2,
	MMC_ISSUE_MAX = 3,
};

struct mmc_blk_request {
	struct mmc_request mrq;
	struct mmc_command sbc;
	struct mmc_command cmd;
	struct mmc_command stop;
	struct mmc_data data;
};

enum mmc_drv_op {
	MMC_DRV_OP_IOCTL = 0,
	MMC_DRV_OP_IOCTL_RPMB = 1,
	MMC_DRV_OP_BOOT_WP = 2,
	MMC_DRV_OP_GET_CARD_STATUS = 3,
	MMC_DRV_OP_GET_EXT_CSD = 4,
};

struct mmc_queue_req {
	struct mmc_blk_request brq;
	struct scatterlist *sg;
	enum mmc_drv_op drv_op;
	int drv_op_result;
	void *drv_op_data;
	unsigned int ioc_count;
	int retries;
};

struct mmc_blk_data;

struct mmc_queue {
	struct mmc_card *card;
	struct mmc_ctx ctx;
	struct blk_mq_tag_set tag_set;
	struct mmc_blk_data *blkdata;
	struct request_queue *queue;
	spinlock_t lock;
	int in_flight[3];
	unsigned int cqe_busy;
	bool busy;
	bool recovery_needed;
	bool in_recovery;
	bool rw_wait;
	bool waiting;
	struct work_struct recovery_work;
	wait_queue_head_t wait;
	struct request *recovery_req;
	struct request *complete_req;
	struct mutex complete_lock;
	struct work_struct complete_work;
};

struct mmc_blk_data {
	struct device *parent;
	struct gendisk *disk;
	struct mmc_queue queue;
	struct list_head part;
	struct list_head rpmbs;
	unsigned int flags;
	struct kref kref;
	unsigned int read_only;
	unsigned int part_type;
	unsigned int reset_done;
	unsigned int part_curr;
	int area_type;
	struct dentry *status_dentry;
	struct dentry *ext_csd_dentry;
};

struct mmc_blk_busy_data {
	struct mmc_card *card;
	u32 status;
};

struct mmc_rpmb_data {
	struct device dev;
	struct cdev chrdev;
	int id;
	unsigned int part_index;
	struct mmc_blk_data *md;
	struct list_head node;
};

struct mmc_blk_ioc_data {
	struct mmc_ioc_cmd ic;
	unsigned char *buf;
	int: 32;
	u64 buf_bytes;
	struct mmc_rpmb_data *rpmb;
	int: 32;
};

struct sdhci_adma2_64_desc {
	__le16 cmd;
	__le16 len;
	__le32 addr_lo;
	__le32 addr_hi;
};

enum sdhci_cookie {
	COOKIE_UNMAPPED = 0,
	COOKIE_PRE_MAPPED = 1,
	COOKIE_MAPPED = 2,
};

struct sdhci_ops;

struct sdhci_host {
	const char *hw_name;
	unsigned int quirks;
	unsigned int quirks2;
	int irq;
	void *ioaddr;
	phys_addr_t mapbase;
	char *bounce_buffer;
	dma_addr_t bounce_addr;
	unsigned int bounce_buffer_size;
	const struct sdhci_ops *ops;
	struct mmc_host *mmc;
	struct mmc_host_ops mmc_host_ops;
	int: 32;
	u64 dma_mask;
	struct led_classdev led;
	char led_name[32];
	spinlock_t lock;
	int flags;
	unsigned int version;
	unsigned int max_clk;
	unsigned int timeout_clk;
	u8 max_timeout_count;
	unsigned int clk_mul;
	unsigned int clock;
	u8 pwr;
	u8 drv_type;
	bool reinit_uhs;
	bool runtime_suspended;
	bool bus_on;
	bool preset_enabled;
	bool pending_reset;
	bool irq_wake_enabled;
	bool v4_mode;
	bool use_external_dma;
	bool always_defer_done;
	struct mmc_request *mrqs_done[2];
	struct mmc_command *cmd;
	struct mmc_command *data_cmd;
	struct mmc_command *deferred_cmd;
	struct mmc_data *data;
	unsigned int data_early: 1;
	struct sg_mapping_iter sg_miter;
	unsigned int blocks;
	int sg_count;
	int max_adma;
	void *adma_table;
	void *align_buffer;
	size_t adma_table_sz;
	size_t align_buffer_sz;
	dma_addr_t adma_addr;
	dma_addr_t align_addr;
	unsigned int desc_sz;
	unsigned int alloc_desc_sz;
	struct workqueue_struct *complete_wq;
	struct work_struct complete_work;
	struct timer_list timer;
	struct timer_list data_timer;
	u32 caps;
	u32 caps1;
	bool read_caps;
	bool sdhci_core_to_disable_vqmmc;
	unsigned int ocr_avail_sdio;
	unsigned int ocr_avail_sd;
	unsigned int ocr_avail_mmc;
	u32 ocr_mask;
	unsigned int timing;
	u32 thread_isr;
	u32 ier;
	bool cqe_on;
	u32 cqe_ier;
	u32 cqe_err_ier;
	wait_queue_head_t buf_ready_int;
	unsigned int tuning_done;
	unsigned int tuning_count;
	unsigned int tuning_mode;
	unsigned int tuning_err;
	int tuning_delay;
	int tuning_loop_count;
	u32 sdma_boundary;
	u32 adma_table_cnt;
	int: 32;
	u64 data_timeout;
	long unsigned int private[0];
};

struct sdhci_ops {
	u32 (*read_l)(struct sdhci_host *, int);
	u16 (*read_w)(struct sdhci_host *, int);
	u8 (*read_b)(struct sdhci_host *, int);
	void (*write_l)(struct sdhci_host *, u32, int);
	void (*write_w)(struct sdhci_host *, u16, int);
	void (*write_b)(struct sdhci_host *, u8, int);
	void (*set_clock)(struct sdhci_host *, unsigned int);
	void (*set_power)(struct sdhci_host *, unsigned char, short unsigned int);
	u32 (*irq)(struct sdhci_host *, u32);
	int (*set_dma_mask)(struct sdhci_host *);
	int (*enable_dma)(struct sdhci_host *);
	unsigned int (*get_max_clock)(struct sdhci_host *);
	unsigned int (*get_min_clock)(struct sdhci_host *);
	unsigned int (*get_timeout_clock)(struct sdhci_host *);
	unsigned int (*get_max_timeout_count)(struct sdhci_host *);
	void (*set_timeout)(struct sdhci_host *, struct mmc_command *);
	void (*set_bus_width)(struct sdhci_host *, int);
	void (*platform_send_init_74_clocks)(struct sdhci_host *, u8);
	unsigned int (*get_ro)(struct sdhci_host *);
	void (*reset)(struct sdhci_host *, u8);
	int (*platform_execute_tuning)(struct sdhci_host *, u32);
	void (*set_uhs_signaling)(struct sdhci_host *, unsigned int);
	void (*hw_reset)(struct sdhci_host *);
	void (*adma_workaround)(struct sdhci_host *, u32);
	void (*card_event)(struct sdhci_host *);
	void (*voltage_switch)(struct sdhci_host *);
	void (*adma_write_desc)(struct sdhci_host *, void **, dma_addr_t, int, unsigned int);
	void (*copy_to_bounce_buffer)(struct sdhci_host *, struct mmc_data *, unsigned int);
	void (*request_done)(struct sdhci_host *, struct mmc_request *);
	void (*dump_vendor_regs)(struct sdhci_host *);
};

enum sdhci_reset_reason {
	SDHCI_RESET_FOR_INIT = 0,
	SDHCI_RESET_FOR_REQUEST_ERROR = 1,
	SDHCI_RESET_FOR_REQUEST_ERROR_DATA_ONLY = 2,
	SDHCI_RESET_FOR_TUNING_ABORT = 3,
	SDHCI_RESET_FOR_CARD_REMOVED = 4,
	SDHCI_RESET_FOR_CQE_RECOVERY = 5,
};

struct sdhci_pltfm_data {
	const struct sdhci_ops *ops;
	unsigned int quirks;
	unsigned int quirks2;
};

struct sdhci_pltfm_host {
	struct clk *clk;
	unsigned int clock;
	u16 xfer_mode_shadow;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int private[0];
};

struct cqhci_host_ops;

struct cqhci_slot;

struct cqhci_host {
	const struct cqhci_host_ops *ops;
	void *mmio;
	struct mmc_host *mmc;
	spinlock_t lock;
	unsigned int rca;
	bool dma64;
	int num_slots;
	int qcnt;
	u32 dcmd_slot;
	u32 caps;
	u32 quirks;
	bool enabled;
	bool halted;
	bool init_done;
	bool activated;
	bool waiting_for_idle;
	bool recovery_halt;
	size_t desc_size;
	size_t data_size;
	u8 *desc_base;
	u8 slot_sz;
	u8 task_desc_len;
	u8 link_desc_len;
	u8 *trans_desc_base;
	u8 trans_desc_len;
	dma_addr_t desc_dma_base;
	dma_addr_t trans_desc_dma_base;
	struct completion halt_comp;
	wait_queue_head_t wait_queue;
	struct cqhci_slot *slot;
};

struct cqhci_host_ops {
	void (*dumpregs)(struct mmc_host *);
	void (*write_l)(struct cqhci_host *, u32, int);
	u32 (*read_l)(struct cqhci_host *, int);
	void (*enable)(struct mmc_host *);
	void (*disable)(struct mmc_host *, bool);
	void (*update_dcmd_desc)(struct mmc_host *, struct mmc_request *, u64 *);
	void (*pre_enable)(struct mmc_host *);
	void (*post_disable)(struct mmc_host *);
};

enum wp_types {
	ESDHC_WP_NONE = 0,
	ESDHC_WP_CONTROLLER = 1,
	ESDHC_WP_GPIO = 2,
};

enum cd_types {
	ESDHC_CD_NONE = 0,
	ESDHC_CD_CONTROLLER = 1,
	ESDHC_CD_GPIO = 2,
	ESDHC_CD_PERMANENT = 3,
};

struct esdhc_platform_data {
	enum wp_types wp_type;
	enum cd_types cd_type;
	int max_bus_width;
	unsigned int delay_line;
	unsigned int tuning_step;
	unsigned int tuning_start_tap;
	unsigned int strobe_dll_delay_target;
	bool sdio_async_interrupt_enabled;
};

struct esdhc_soc_data {
	u32 flags;
};

struct pltfm_imx_data {
	u32 scratchpad;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_100mhz;
	struct pinctrl_state *pins_200mhz;
	const struct esdhc_soc_data *socdata;
	struct esdhc_platform_data boarddata;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	struct clk *clk_per;
	unsigned int actual_clock;
	enum {
		NO_CMD_PENDING = 0,
		MULTIBLK_IN_PROCESS = 1,
		WAIT_FOR_INT = 2,
	} multiblock_status;
	u32 is_ddr;
	struct pm_qos_request pm_qos_req;
};

struct cqhci_slot {
	struct mmc_request *mrq;
	unsigned int flags;
};

enum led_default_state {
	LEDS_DEFSTATE_OFF = 0,
	LEDS_DEFSTATE_ON = 1,
	LEDS_DEFSTATE_KEEP = 2,
};

struct led_init_data {
	struct fwnode_handle *fwnode;
	const char *default_label;
	const char *devicename;
	bool devname_mandatory;
};

struct led_properties {
	u32 color;
	bool color_present;
	const char *function;
	u32 func_enum;
	bool func_enum_present;
	const char *label;
};

typedef int (*gpio_blink_set_t)(struct gpio_desc *, int, long unsigned int *, long unsigned int *);

struct gpio_led {
	const char *name;
	const char *default_trigger;
	unsigned int gpio;
	unsigned int active_low: 1;
	unsigned int retain_state_suspended: 1;
	unsigned int panic_indicator: 1;
	unsigned int default_state: 2;
	unsigned int retain_state_shutdown: 1;
	struct gpio_desc *gpiod;
};

struct gpio_led_platform_data {
	int num_leds;
	const struct gpio_led *leds;
	gpio_blink_set_t gpio_blink_set;
};

struct gpio_led_data {
	struct led_classdev cdev;
	struct gpio_desc *gpiod;
	u8 can_sleep;
	u8 blinking;
	gpio_blink_set_t platform_gpio_blink_set;
};

struct gpio_leds_priv {
	int num_leds;
	struct gpio_led_data leds[0];
};

struct led_pwm {
	const char *name;
	u8 active_low;
	u8 default_state;
	unsigned int max_brightness;
};

struct led_pwm_data {
	struct led_classdev cdev;
	struct pwm_device *pwm;
	int: 32;
	struct pwm_state pwmstate;
	unsigned int active_low;
	int: 32;
};

struct led_pwm_priv {
	int num_leds;
	int: 32;
	struct led_pwm_data leds[0];
};

struct oneshot_trig_data {
	unsigned int invert;
};

struct heartbeat_trig_data {
	struct led_classdev *led_cdev;
	unsigned int phase;
	unsigned int period;
	struct timer_list timer;
	unsigned int invert;
};

struct bl_trig_notifier {
	struct led_classdev *led;
	int brightness;
	int old_status;
	struct notifier_block notifier;
	unsigned int invert;
};

struct gpio_trig_data {
	struct led_classdev *led;
	unsigned int desired_brightness;
	unsigned int inverted;
	unsigned int gpio;
};

struct psci_0_1_function_ids {
	u32 cpu_suspend;
	u32 cpu_on;
	u32 cpu_off;
	u32 migrate;
};

struct arm_cpuidle_irq_context {};

typedef long unsigned int psci_fn(long unsigned int, long unsigned int, long unsigned int, long unsigned int);

typedef int (*psci_initcall_t)(const struct device_node *);

struct fdt_property {
	fdt32_t tag;
	fdt32_t len;
	fdt32_t nameoff;
	char data[0];
};

struct dcp_key_payload {
	unsigned int key_len;
	unsigned int blob_len;
	unsigned char *key;
	unsigned char *blob;
};

struct dcp_dma_desc {
	uint32_t next_cmd_addr;
	uint32_t control0;
	uint32_t control1;
	uint32_t source;
	uint32_t destination;
	uint32_t size;
	uint32_t payload;
	uint32_t status;
};

struct dcp_coherent_block {
	uint8_t aes_in_buf[4096];
	uint8_t aes_out_buf[4096];
	uint8_t sha_in_buf[4096];
	uint8_t sha_out_buf[64];
	uint8_t aes_key[32];
	struct dcp_dma_desc desc[4];
};

struct dcp {
	struct device *dev;
	void *base;
	uint32_t caps;
	struct dcp_coherent_block *coh;
	struct completion completion[4];
	spinlock_t lock[4];
	struct task_struct *thread[4];
	struct crypto_queue queue[4];
	struct clk *dcp_clk;
};

enum dcp_chan {
	DCP_CHAN_HASH_SHA = 0,
	DCP_CHAN_CRYPTO = 2,
};

struct dcp_async_ctx {
	enum dcp_chan chan;
	uint32_t fill;
	struct mutex mutex;
	uint32_t alg;
	unsigned int hot: 1;
	struct crypto_skcipher *fallback;
	unsigned int key_len;
	uint8_t key[16];
};

struct dcp_aes_req_ctx {
	unsigned int enc: 1;
	unsigned int ecb: 1;
	int: 30;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct skcipher_request fallback_req;
};

struct dcp_sha_req_ctx {
	unsigned int init: 1;
	unsigned int fini: 1;
};

struct dcp_export_state {
	struct dcp_sha_req_ctx req_ctx;
	struct dcp_async_ctx async_ctx;
};

struct sahara_hw_desc {
	u32 hdr;
	u32 len1;
	u32 p1;
	u32 len2;
	u32 p2;
	u32 next;
};

struct sahara_hw_link {
	u32 len;
	u32 p;
	u32 next;
};

struct sahara_ctx {
	long unsigned int flags;
	int keylen;
	u8 key[16];
	struct crypto_skcipher *fallback;
};

struct sahara_aes_reqctx {
	long unsigned int mode;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct skcipher_request fallback_req;
};

struct sahara_sha_reqctx {
	u8 buf[64];
	u8 rembuf[64];
	u8 context[36];
	unsigned int mode;
	unsigned int digest_size;
	unsigned int context_size;
	unsigned int buf_cnt;
	unsigned int sg_in_idx;
	struct scatterlist *in_sg;
	struct scatterlist in_sg_chain[2];
	size_t total;
	unsigned int last;
	unsigned int first;
	unsigned int active;
};

struct sahara_dev {
	struct device *device;
	unsigned int version;
	void *regs_base;
	struct clk *clk_ipg;
	struct clk *clk_ahb;
	spinlock_t queue_spinlock;
	struct task_struct *kthread;
	struct completion dma_completion;
	struct sahara_ctx *ctx;
	struct crypto_queue queue;
	long unsigned int flags;
	struct sahara_hw_desc *hw_desc[2];
	dma_addr_t hw_phys_desc[2];
	u8 *key_base;
	dma_addr_t key_phys_base;
	u8 *iv_base;
	dma_addr_t iv_phys_base;
	u8 *context_base;
	dma_addr_t context_phys_base;
	struct sahara_hw_link *hw_link[20];
	dma_addr_t hw_phys_link[20];
	size_t total;
	struct scatterlist *in_sg;
	int nb_in_sg;
	struct scatterlist *out_sg;
	int nb_out_sg;
	u32 error;
};

struct of_timer_irq {
	int irq;
	int index;
	int percpu;
	const char *name;
	long unsigned int flags;
	irq_handler_t handler;
};

struct of_timer_base {
	void *base;
	const char *name;
	int index;
};

struct of_timer_clk {
	struct clk *clk;
	const char *name;
	int index;
	long unsigned int rate;
	long unsigned int period;
};

struct timer_of {
	unsigned int flags;
	struct device_node *np;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device clkevt;
	struct of_timer_base of_base;
	struct of_timer_irq of_irq;
	struct of_timer_clk of_clk;
	void *private_data;
	int: 32;
};

struct clocksource_mmio {
	void *reg;
	int: 32;
	struct clocksource clksrc;
};

enum arch_timer_reg {
	ARCH_TIMER_REG_CTRL = 0,
	ARCH_TIMER_REG_CVAL = 1,
};

enum arch_timer_ppi_nr {
	ARCH_TIMER_PHYS_SECURE_PPI = 0,
	ARCH_TIMER_PHYS_NONSECURE_PPI = 1,
	ARCH_TIMER_VIRT_PPI = 2,
	ARCH_TIMER_HYP_PPI = 3,
	ARCH_TIMER_HYP_VIRT_PPI = 4,
	ARCH_TIMER_MAX_TIMER_PPI = 5,
};

enum arch_timer_spi_nr {
	ARCH_TIMER_PHYS_SPI = 0,
	ARCH_TIMER_VIRT_SPI = 1,
	ARCH_TIMER_MAX_TIMER_SPI = 2,
};

struct arch_timer_kvm_info {
	struct timecounter timecounter;
	int virtual_irq;
	int physical_irq;
};

struct arch_timer_mem_frame {
	bool valid;
	phys_addr_t cntbase;
	size_t size;
	int phys_irq;
	int virt_irq;
};

struct arch_timer_mem {
	phys_addr_t cntctlbase;
	size_t size;
	struct arch_timer_mem_frame frame[8];
};

struct arch_timer {
	void *base;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device evt;
};

enum imx_gpt_type {
	GPT_TYPE_IMX1 = 0,
	GPT_TYPE_IMX21 = 1,
	GPT_TYPE_IMX31 = 2,
	GPT_TYPE_IMX6DL = 3,
};

struct imx_gpt_data;

struct imx_timer {
	enum imx_gpt_type type;
	void *base;
	int irq;
	struct clk *clk_per;
	struct clk *clk_ipg;
	const struct imx_gpt_data *gpt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct clock_event_device ced;
};

struct imx_gpt_data {
	int reg_tstat;
	int reg_tcn;
	int reg_tcmp;
	void (*gpt_setup_tctl)(struct imx_timer *);
	void (*gpt_irq_enable)(struct imx_timer *);
	void (*gpt_irq_disable)(struct imx_timer *);
	void (*gpt_irq_acknowledge)(struct imx_timer *);
	int (*set_next_event)(long unsigned int, struct clock_event_device *);
};

struct hid_device_id {
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	kernel_ulong_t driver_data;
};

struct hid_item {
	unsigned int format;
	__u8 size;
	__u8 type;
	__u8 tag;
	union {
		__u8 u8;
		__s8 s8;
		__u16 u16;
		__s16 s16;
		__u32 u32;
		__s32 s32;
		__u8 *longdata;
	} data;
};

struct hid_global {
	unsigned int usage_page;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	unsigned int report_id;
	unsigned int report_size;
	unsigned int report_count;
};

struct hid_local {
	unsigned int usage[12288];
	u8 usage_size[12288];
	unsigned int collection_index[12288];
	unsigned int usage_index;
	unsigned int usage_minimum;
	unsigned int delimiter_depth;
	unsigned int delimiter_branch;
};

struct hid_collection {
	int parent_idx;
	unsigned int type;
	unsigned int usage;
	unsigned int level;
};

struct hid_usage {
	unsigned int hid;
	unsigned int collection_index;
	unsigned int usage_index;
	__s8 resolution_multiplier;
	__s8 wheel_factor;
	__u16 code;
	__u8 type;
	__s8 hat_min;
	__s8 hat_max;
	__s8 hat_dir;
	__s16 wheel_accumulated;
};

struct hid_report;

struct hid_input;

struct hid_field {
	unsigned int physical;
	unsigned int logical;
	unsigned int application;
	struct hid_usage *usage;
	unsigned int maxusage;
	unsigned int flags;
	unsigned int report_offset;
	unsigned int report_size;
	unsigned int report_count;
	unsigned int report_type;
	__s32 *value;
	__s32 *new_value;
	__s32 *usages_priorities;
	__s32 logical_minimum;
	__s32 logical_maximum;
	__s32 physical_minimum;
	__s32 physical_maximum;
	__s32 unit_exponent;
	unsigned int unit;
	bool ignored;
	struct hid_report *report;
	unsigned int index;
	struct hid_input *hidinput;
	__u16 dpad;
	unsigned int slot_idx;
};

struct hid_field_entry;

struct hid_device;

struct hid_report {
	struct list_head list;
	struct list_head hidinput_list;
	struct list_head field_entry_list;
	unsigned int id;
	enum hid_report_type type;
	unsigned int application;
	struct hid_field *field[256];
	struct hid_field_entry *field_entries;
	unsigned int maxfield;
	unsigned int size;
	struct hid_device *device;
	bool tool_active;
	unsigned int tool;
};

struct hid_input {
	struct list_head list;
	struct hid_report *report;
	struct input_dev *input;
	const char *name;
	bool registered;
	struct list_head reports;
	unsigned int application;
};

struct hid_field_entry {
	struct list_head list;
	struct hid_field *field;
	unsigned int index;
	__s32 priority;
};

enum hid_type {
	HID_TYPE_OTHER = 0,
	HID_TYPE_USBMOUSE = 1,
	HID_TYPE_USBNONE = 2,
};

struct hid_report_enum {
	unsigned int numbered;
	struct list_head report_list;
	struct hid_report *report_id_hash[256];
};

struct hid_driver;

struct hid_ll_driver;

struct hid_device {
	__u8 *dev_rdesc;
	unsigned int dev_rsize;
	__u8 *rdesc;
	unsigned int rsize;
	struct hid_collection *collection;
	unsigned int collection_size;
	unsigned int maxcollection;
	unsigned int maxapplication;
	__u16 bus;
	__u16 group;
	__u32 vendor;
	__u32 product;
	__u32 version;
	enum hid_type type;
	unsigned int country;
	struct hid_report_enum report_enum[3];
	struct work_struct led_work;
	struct semaphore driver_input_lock;
	int: 32;
	struct device dev;
	struct hid_driver *driver;
	struct hid_ll_driver *ll_driver;
	struct mutex ll_open_lock;
	unsigned int ll_open_count;
	long unsigned int status;
	unsigned int claimed;
	unsigned int quirks;
	bool io_started;
	struct list_head inputs;
	void *hiddev;
	void *hidraw;
	char name[128];
	char phys[64];
	char uniq[64];
	void *driver_data;
	int (*ff_init)(struct hid_device *);
	int (*hiddev_connect)(struct hid_device *, unsigned int);
	void (*hiddev_disconnect)(struct hid_device *);
	void (*hiddev_hid_event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*hiddev_report_event)(struct hid_device *, struct hid_report *);
	short unsigned int debug;
	struct dentry *debug_dir;
	struct dentry *debug_rdesc;
	struct dentry *debug_events;
	struct list_head debug_list;
	spinlock_t debug_list_lock;
	wait_queue_head_t debug_wait;
	unsigned int id;
	int: 32;
};

struct hid_report_id;

struct hid_usage_id;

struct hid_driver {
	char *name;
	const struct hid_device_id *id_table;
	struct list_head dyn_list;
	spinlock_t dyn_lock;
	bool (*match)(struct hid_device *, bool);
	int (*probe)(struct hid_device *, const struct hid_device_id *);
	void (*remove)(struct hid_device *);
	const struct hid_report_id *report_table;
	int (*raw_event)(struct hid_device *, struct hid_report *, u8 *, int);
	const struct hid_usage_id *usage_table;
	int (*event)(struct hid_device *, struct hid_field *, struct hid_usage *, __s32);
	void (*report)(struct hid_device *, struct hid_report *);
	__u8 * (*report_fixup)(struct hid_device *, __u8 *, unsigned int *);
	int (*input_mapping)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_mapped)(struct hid_device *, struct hid_input *, struct hid_field *, struct hid_usage *, long unsigned int **, int *);
	int (*input_configured)(struct hid_device *, struct hid_input *);
	void (*feature_mapping)(struct hid_device *, struct hid_field *, struct hid_usage *);
	int (*suspend)(struct hid_device *, pm_message_t);
	int (*resume)(struct hid_device *);
	int (*reset_resume)(struct hid_device *);
	struct device_driver driver;
};

struct hid_ll_driver {
	int (*start)(struct hid_device *);
	void (*stop)(struct hid_device *);
	int (*open)(struct hid_device *);
	void (*close)(struct hid_device *);
	int (*power)(struct hid_device *, int);
	int (*parse)(struct hid_device *);
	void (*request)(struct hid_device *, struct hid_report *, int);
	int (*wait)(struct hid_device *);
	int (*raw_request)(struct hid_device *, unsigned char, __u8 *, size_t, unsigned char, int);
	int (*output_report)(struct hid_device *, __u8 *, size_t);
	int (*idle)(struct hid_device *, int, int, int);
	bool (*may_wakeup)(struct hid_device *);
};

struct hid_parser {
	struct hid_global global;
	struct hid_global global_stack[4];
	unsigned int global_stack_ptr;
	struct hid_local local;
	unsigned int *collection_stack;
	unsigned int collection_stack_ptr;
	unsigned int collection_stack_size;
	struct hid_device *device;
	unsigned int scan_flags;
};

struct hid_report_id {
	__u32 report_type;
};

struct hid_usage_id {
	__u32 usage_hid;
	__u32 usage_type;
	__u32 usage_code;
};

struct hiddev {
	int minor;
	int exist;
	int open;
	struct mutex existancelock;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct list_head list;
	spinlock_t list_lock;
	bool initialized;
};

struct hidraw {
	unsigned int minor;
	int exist;
	int open;
	wait_queue_head_t wait;
	struct hid_device *hid;
	struct device *dev;
	spinlock_t list_lock;
	struct list_head list;
};

struct hid_dynid {
	struct list_head list;
	struct hid_device_id id;
};

struct usage_priority {
	__u32 usage;
	bool global;
	unsigned int slot_overwrite;
};

typedef bool (*hid_usage_cmp_t)(struct hid_usage *, unsigned int, unsigned int);

struct quirks_list_struct {
	struct hid_device_id hid_bl_item;
	struct list_head node;
};

struct hid_debug_list {
	struct {
		union {
			struct __kfifo kfifo;
			char *type;
			const char *const_type;
			char (*rectype)[0];
			char *ptr;
			const char *ptr_const;
		};
		char buf[0];
	} hid_debug_fifo;
	struct fasync_struct *fasync;
	struct hid_device *hdev;
	struct list_head node;
	struct mutex read_mutex;
};

struct hid_usage_entry {
	unsigned int page;
	unsigned int usage;
	const char *description;
};

enum latency_mode {
	HID_LATENCY_NORMAL = 0,
	HID_LATENCY_HIGH = 1,
};

struct mt_usages {
	struct list_head list;
	__s32 *x;
	__s32 *y;
	__s32 *cx;
	__s32 *cy;
	__s32 *p;
	__s32 *w;
	__s32 *h;
	__s32 *a;
	__s32 *contactid;
	bool *tip_state;
	bool *inrange_state;
	bool *confidence_state;
};

struct mt_application {
	struct list_head list;
	unsigned int application;
	unsigned int report_id;
	struct list_head mt_usages;
	__s32 quirks;
	__s32 *scantime;
	__s32 scantime_logical_max;
	__s32 *raw_cc;
	int left_button_state;
	unsigned int mt_flags;
	long unsigned int *pending_palm_slots;
	__u8 num_received;
	__u8 num_expected;
	__u8 buttons_count;
	__u8 touches_by_report;
	__s32 dev_time;
	long unsigned int jiffies;
	int timestamp;
	int prev_scantime;
	bool have_contact_count;
};

struct mt_class {
	__s32 name;
	__s32 quirks;
	__s32 sn_move;
	__s32 sn_width;
	__s32 sn_height;
	__s32 sn_pressure;
	__u8 maxcontacts;
	bool is_indirect;
	bool export_all_inputs;
};

struct mt_report_data {
	struct list_head list;
	struct hid_report *report;
	struct mt_application *application;
	bool is_mt_collection;
};

struct mt_device {
	struct mt_class mtclass;
	struct timer_list release_timer;
	struct hid_device *hdev;
	long unsigned int mt_io_flags;
	__u8 inputmode_value;
	__u8 maxcontacts;
	bool is_buttonpad;
	bool serial_maybe;
	struct list_head applications;
	struct list_head reports;
};

struct hid_control_fifo {
	unsigned char dir;
	struct hid_report *report;
	char *raw_report;
};

struct hid_output_fifo {
	struct hid_report *report;
	char *raw_report;
};

struct usbhid_device {
	struct hid_device *hid;
	struct usb_interface *intf;
	int ifnum;
	unsigned int bufsize;
	struct urb *urbin;
	char *inbuf;
	dma_addr_t inbuf_dma;
	struct urb *urbctrl;
	struct usb_ctrlrequest *cr;
	struct hid_control_fifo ctrl[256];
	unsigned char ctrlhead;
	unsigned char ctrltail;
	char *ctrlbuf;
	dma_addr_t ctrlbuf_dma;
	long unsigned int last_ctrl;
	struct urb *urbout;
	struct hid_output_fifo out[256];
	unsigned char outhead;
	unsigned char outtail;
	char *outbuf;
	dma_addr_t outbuf_dma;
	long unsigned int last_out;
	struct mutex mutex;
	spinlock_t lock;
	long unsigned int iofl;
	struct timer_list io_retry;
	long unsigned int stop_retry;
	unsigned int retry_delay;
	struct work_struct reset_work;
	wait_queue_head_t wait;
};

struct alias_prop {
	struct list_head link;
	const char *alias;
	struct device_node *np;
	int id;
	char stem[0];
};

struct amba_cs_uci_id {
	unsigned int devarch;
	unsigned int devarch_mask;
	unsigned int devtype;
	void *data;
};

struct amba_device {
	struct device dev;
	struct resource res;
	struct clk *pclk;
	struct device_dma_parameters dma_parms;
	unsigned int periphid;
	struct mutex periphid_lock;
	unsigned int cid;
	struct amba_cs_uci_id uci;
	unsigned int irq[9];
	const char *driver_override;
	int: 32;
};

struct supplier_bindings {
	struct device_node * (*parse_prop)(struct device_node *, const char *, int);
	bool optional;
	bool node_not_dev;
};

struct of_changeset_entry {
	struct list_head node;
	long unsigned int action;
	struct device_node *np;
	struct property *prop;
	struct property *old_prop;
};

struct of_changeset {
	struct list_head entries;
};

struct of_bus___2 {
	void (*count_cells)(const void *, int, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
};

struct of_bus {
	const char *name;
	const char *addresses;
	int (*match)(struct device_node *);
	void (*count_cells)(struct device_node *, int *, int *);
	u64 (*map)(__be32 *, const __be32 *, int, int, int);
	int (*translate)(__be32 *, u64, int);
	bool has_flags;
	unsigned int (*get_flags)(const __be32 *);
};

struct of_intc_desc {
	struct list_head list;
	of_irq_init_cb_t irq_init_cb;
	struct device_node *dev;
	struct device_node *interrupt_parent;
};

struct rmem_assigned_device {
	struct device *dev;
	struct reserved_mem *rmem;
	struct list_head list;
};

enum of_overlay_notify_action {
	OF_OVERLAY_INIT = 0,
	OF_OVERLAY_PRE_APPLY = 1,
	OF_OVERLAY_POST_APPLY = 2,
	OF_OVERLAY_PRE_REMOVE = 3,
	OF_OVERLAY_POST_REMOVE = 4,
};

struct of_overlay_notify_data {
	struct device_node *overlay;
	struct device_node *target;
};

struct target {
	struct device_node *np;
	bool in_livetree;
};

struct fragment {
	struct device_node *overlay;
	struct device_node *target;
};

struct overlay_changeset {
	int id;
	struct list_head ovcs_list;
	const void *new_fdt;
	const void *overlay_mem;
	struct device_node *overlay_root;
	enum of_overlay_notify_action notify_state;
	int count;
	struct fragment *fragments;
	bool symbols_fragment;
	struct of_changeset cset;
};

struct mbox_client {
	struct device *dev;
	bool tx_block;
	long unsigned int tx_tout;
	bool knows_txdone;
	void (*rx_callback)(struct mbox_client *, void *);
	void (*tx_prepare)(struct mbox_client *, void *);
	void (*tx_done)(struct mbox_client *, void *, int);
};

struct mbox_chan;

struct mbox_chan_ops {
	int (*send_data)(struct mbox_chan *, void *);
	int (*flush)(struct mbox_chan *, long unsigned int);
	int (*startup)(struct mbox_chan *);
	void (*shutdown)(struct mbox_chan *);
	bool (*last_tx_done)(struct mbox_chan *);
	bool (*peek_data)(struct mbox_chan *);
};

struct mbox_controller;

struct mbox_chan {
	struct mbox_controller *mbox;
	unsigned int txdone_method;
	struct mbox_client *cl;
	struct completion tx_complete;
	void *active_req;
	unsigned int msg_count;
	unsigned int msg_free;
	void *msg_data[20];
	spinlock_t lock;
	void *con_priv;
};

struct mbox_controller {
	struct device *dev;
	const struct mbox_chan_ops *ops;
	struct mbox_chan *chans;
	int num_chans;
	bool txdone_irq;
	bool txdone_poll;
	unsigned int txpoll_period;
	struct mbox_chan * (*of_xlate)(struct mbox_controller *, const struct of_phandle_args *);
	int: 32;
	struct hrtimer poll_hrt;
	spinlock_t poll_hrt_lock;
	struct list_head node;
	int: 32;
};

struct imx_sc_rpc_msg {
	uint8_t ver;
	uint8_t size;
	uint8_t svc;
	uint8_t func;
};

struct imx_s4_rpc_msg {
	uint8_t ver;
	uint8_t size;
	uint8_t cmd;
	uint8_t tag;
};

enum imx_mu_chan_type {
	IMX_MU_TYPE_TX = 0,
	IMX_MU_TYPE_RX = 1,
	IMX_MU_TYPE_TXDB = 2,
	IMX_MU_TYPE_RXDB = 3,
	IMX_MU_TYPE_RST = 4,
};

enum imx_mu_xcr {
	IMX_MU_CR = 0,
	IMX_MU_GIER = 1,
	IMX_MU_GCR = 2,
	IMX_MU_TCR = 3,
	IMX_MU_RCR = 4,
	IMX_MU_xCR_MAX = 5,
};

enum imx_mu_xsr {
	IMX_MU_SR = 0,
	IMX_MU_GSR = 1,
	IMX_MU_TSR = 2,
	IMX_MU_RSR = 3,
	IMX_MU_xSR_MAX = 4,
};

struct imx_sc_rpc_msg_max {
	struct imx_sc_rpc_msg hdr;
	u32 data[30];
};

struct imx_s4_rpc_msg_max {
	struct imx_s4_rpc_msg hdr;
	u32 data[254];
};

struct imx_mu_con_priv {
	unsigned int idx;
	char irq_desc[20];
	enum imx_mu_chan_type type;
	struct mbox_chan *chan;
	struct tasklet_struct txdb_tasklet;
};

struct imx_mu_dcfg;

struct imx_mu_priv {
	struct device *dev;
	void *base;
	void *msg;
	spinlock_t xcr_lock;
	struct mbox_controller mbox;
	struct mbox_chan mbox_chans[17];
	struct imx_mu_con_priv con_priv[17];
	const struct imx_mu_dcfg *dcfg;
	struct clk *clk;
	int irq[17];
	bool suspend;
	u32 xcr[5];
	bool side_b;
};

enum imx_mu_type {
	IMX_MU_V1 = 0,
	IMX_MU_V2 = 2,
	IMX_MU_V2_S4 = 32768,
	IMX_MU_V2_IRQ = 65536,
};

struct imx_mu_dcfg {
	int (*tx)(struct imx_mu_priv *, struct imx_mu_con_priv *, void *);
	int (*rx)(struct imx_mu_priv *, struct imx_mu_con_priv *);
	int (*rxdb)(struct imx_mu_priv *, struct imx_mu_con_priv *);
	void (*init)(struct imx_mu_priv *);
	enum imx_mu_type type;
	u32 xTR;
	u32 xRR;
	u32 xSR[4];
	u32 xCR[5];
	u32 xBUF;
};

struct resource_table {
	u32 ver;
	u32 num;
	u32 reserved[2];
	u32 offset[0];
};

struct fw_rsc_hdr {
	u32 type;
	u8 data[0];
};

enum fw_resource_type {
	RSC_CARVEOUT = 0,
	RSC_DEVMEM = 1,
	RSC_TRACE = 2,
	RSC_VDEV = 3,
	RSC_LAST = 4,
	RSC_VENDOR_START = 128,
	RSC_VENDOR_END = 512,
};

struct fw_rsc_carveout {
	u32 da;
	u32 pa;
	u32 len;
	u32 flags;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_devmem {
	u32 da;
	u32 pa;
	u32 len;
	u32 flags;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_trace {
	u32 da;
	u32 len;
	u32 reserved;
	u8 name[32];
};

struct fw_rsc_vdev_vring {
	u32 da;
	u32 align;
	u32 num;
	u32 notifyid;
	u32 pa;
};

struct fw_rsc_vdev {
	u32 id;
	u32 notifyid;
	u32 dfeatures;
	u32 gfeatures;
	u32 config_len;
	u8 status;
	u8 num_of_vrings;
	u8 reserved[2];
	struct fw_rsc_vdev_vring vring[0];
};

struct rproc;

struct rproc_mem_entry {
	void *va;
	bool is_iomem;
	dma_addr_t dma;
	size_t len;
	u32 da;
	void *priv;
	char name[32];
	struct list_head node;
	u32 rsc_offset;
	u32 flags;
	u32 of_resm_idx;
	int (*alloc)(struct rproc *, struct rproc_mem_entry *);
	int (*release)(struct rproc *, struct rproc_mem_entry *);
};

enum rproc_dump_mechanism {
	RPROC_COREDUMP_DISABLED = 0,
	RPROC_COREDUMP_ENABLED = 1,
	RPROC_COREDUMP_INLINE = 2,
};

struct iommu_domain;

struct rproc_ops;

struct rproc {
	struct list_head node;
	struct iommu_domain *domain;
	const char *name;
	const char *firmware;
	void *priv;
	struct rproc_ops *ops;
	int: 32;
	struct device dev;
	atomic_t power;
	unsigned int state;
	enum rproc_dump_mechanism dump_conf;
	struct mutex lock;
	struct dentry *dbg_dir;
	struct list_head traces;
	int num_traces;
	struct list_head carveouts;
	struct list_head mappings;
	u64 bootaddr;
	struct list_head rvdevs;
	struct list_head subdevs;
	struct idr notifyids;
	int index;
	struct work_struct crash_handler;
	unsigned int crash_cnt;
	bool recovery_disabled;
	int max_notifyid;
	struct resource_table *table_ptr;
	struct resource_table *clean_table;
	struct resource_table *cached_table;
	size_t table_sz;
	bool has_iommu;
	bool auto_boot;
	bool sysfs_read_only;
	struct list_head dump_segments;
	int nb_vdev;
	u8 elf_class;
	u16 elf_machine;
	struct cdev cdev;
	bool cdev_put_on_release;
	long unsigned int features[1];
	int: 32;
};

enum rsc_handling_status {
	RSC_HANDLED = 0,
	RSC_IGNORED = 1,
};

struct rproc_ops {
	int (*prepare)(struct rproc *);
	int (*unprepare)(struct rproc *);
	int (*start)(struct rproc *);
	int (*stop)(struct rproc *);
	int (*attach)(struct rproc *);
	int (*detach)(struct rproc *);
	void (*kick)(struct rproc *, int);
	void * (*da_to_va)(struct rproc *, u64, size_t, bool *);
	int (*parse_fw)(struct rproc *, const struct firmware *);
	int (*handle_rsc)(struct rproc *, u32, void *, int, int);
	struct resource_table * (*find_loaded_rsc_table)(struct rproc *, const struct firmware *);
	struct resource_table * (*get_loaded_rsc_table)(struct rproc *, size_t *);
	int (*load)(struct rproc *, const struct firmware *);
	int (*sanity_check)(struct rproc *, const struct firmware *);
	u64 (*get_boot_addr)(struct rproc *, const struct firmware *);
	long unsigned int (*panic)(struct rproc *);
	void (*coredump)(struct rproc *);
};

enum rproc_state {
	RPROC_OFFLINE = 0,
	RPROC_SUSPENDED = 1,
	RPROC_RUNNING = 2,
	RPROC_CRASHED = 3,
	RPROC_DELETED = 4,
	RPROC_ATTACHED = 5,
	RPROC_DETACHED = 6,
	RPROC_LAST = 7,
};

enum rproc_crash_type {
	RPROC_MMUFAULT = 0,
	RPROC_WATCHDOG = 1,
	RPROC_FATAL_ERROR = 2,
};

enum rproc_features {
	RPROC_FEAT_ATTACH_ON_RECOVERY = 0,
	RPROC_MAX_FEATURES = 1,
};

struct iommu_domain_ops;

typedef int (*iommu_fault_handler_t)(struct iommu_domain *, struct device *, long unsigned int, int, void *);

struct iommu_domain_geometry {
	dma_addr_t aperture_start;
	dma_addr_t aperture_end;
	bool force_aperture;
};

struct iommu_dma_cookie;

struct iommu_domain {
	unsigned int type;
	const struct iommu_domain_ops *ops;
	long unsigned int pgsize_bitmap;
	iommu_fault_handler_t handler;
	void *handler_token;
	struct iommu_domain_geometry geometry;
	struct iommu_dma_cookie *iova_cookie;
};

struct rproc_subdev {
	struct list_head node;
	int (*prepare)(struct rproc_subdev *);
	int (*start)(struct rproc_subdev *);
	void (*stop)(struct rproc_subdev *, bool);
	void (*unprepare)(struct rproc_subdev *);
};

struct rproc_vdev;

struct rproc_vring {
	void *va;
	int num;
	u32 da;
	u32 align;
	int notifyid;
	struct rproc_vdev *rvdev;
	struct virtqueue *vq;
};

struct rproc_vdev {
	struct rproc_subdev subdev;
	struct platform_device *pdev;
	unsigned int id;
	struct list_head node;
	struct rproc *rproc;
	struct rproc_vring vring[2];
	u32 rsc_offset;
	u32 index;
};

struct rproc_debug_trace {
	struct rproc *rproc;
	struct dentry *tfile;
	struct list_head node;
	struct rproc_mem_entry trace_mem;
};

struct rproc_vdev_data {
	u32 rsc_offset;
	unsigned int id;
	u32 index;
	struct fw_rsc_vdev *rsc;
};

typedef int (*rproc_handle_resource_t)(struct rproc *, void *, int, int);

typedef __u64 Elf64_Addr;

typedef __u16 Elf64_Half;

typedef __u64 Elf64_Off;

typedef __u32 Elf64_Word;

typedef __u64 Elf64_Xword;

struct elf64_hdr {
	unsigned char e_ident[16];
	Elf64_Half e_type;
	Elf64_Half e_machine;
	Elf64_Word e_version;
	Elf64_Addr e_entry;
	Elf64_Off e_phoff;
	Elf64_Off e_shoff;
	Elf64_Word e_flags;
	Elf64_Half e_ehsize;
	Elf64_Half e_phentsize;
	Elf64_Half e_phnum;
	Elf64_Half e_shentsize;
	Elf64_Half e_shnum;
	Elf64_Half e_shstrndx;
};

struct elf64_phdr {
	Elf64_Word p_type;
	Elf64_Word p_flags;
	Elf64_Off p_offset;
	Elf64_Addr p_vaddr;
	Elf64_Addr p_paddr;
	Elf64_Xword p_filesz;
	Elf64_Xword p_memsz;
	Elf64_Xword p_align;
};

struct elf64_shdr {
	Elf64_Word sh_name;
	Elf64_Word sh_type;
	Elf64_Xword sh_flags;
	Elf64_Addr sh_addr;
	Elf64_Off sh_offset;
	Elf64_Xword sh_size;
	Elf64_Word sh_link;
	Elf64_Word sh_info;
	Elf64_Xword sh_addralign;
	Elf64_Xword sh_entsize;
};

struct rproc_dump_segment {
	struct list_head node;
	dma_addr_t da;
	size_t size;
	void *priv;
	void (*dump)(struct rproc *, struct rproc_dump_segment *, void *, size_t, size_t);
	loff_t offset;
};

struct rproc_coredump_state {
	struct rproc *rproc;
	void *header;
	struct completion dump_done;
};

struct imx_rproc_att {
	u32 da;
	u32 sa;
	u32 size;
	int flags;
};

enum imx_rproc_method {
	IMX_RPROC_NONE = 0,
	IMX_RPROC_MMIO = 1,
	IMX_RPROC_SMC = 2,
	IMX_RPROC_SCU_API = 3,
};

struct imx_rproc_dcfg {
	u32 src_reg;
	u32 src_mask;
	u32 src_start;
	u32 src_stop;
	const struct imx_rproc_att *att;
	size_t att_size;
	enum imx_rproc_method method;
};

struct imx_rproc_mem {
	void *cpu_addr;
	phys_addr_t sys_addr;
	size_t size;
};

struct mbox_chan;

struct imx_rproc {
	struct device *dev;
	struct regmap *regmap;
	struct rproc *rproc;
	const struct imx_rproc_dcfg *dcfg;
	struct imx_rproc_mem mem[32];
	struct clk *clk;
	struct clk *clk_audio;
	struct mbox_client cl;
	struct mbox_chan *tx_ch;
	struct mbox_chan *rx_ch;
	struct work_struct rproc_work;
	struct workqueue_struct *workqueue;
	void *rsc_table;
	struct imx_sc_ipc *ipc_handle;
	struct notifier_block rproc_nb;
	u32 rproc_pt;
	u32 rsrc_id;
	u32 entry;
	int num_pd;
	u32 core_index;
	struct device **pd_dev;
	struct device_link **pd_dev_link;
	u32 startup_delay;
	struct sys_off_data data;
};

struct rpmsg_channel_info {
	char name[32];
	u32 src;
	u32 dst;
};

typedef __u32 __rpmsg32;

struct rpmsg_ns_msg {
	char name[32];
	__rpmsg32 addr;
	__rpmsg32 flags;
};

enum rpmsg_ns_flags {
	RPMSG_NS_CREATE = 0,
	RPMSG_NS_DESTROY = 1,
};

typedef __u16 __rpmsg16;

struct virtproc_info {
	struct virtio_device *vdev;
	struct virtqueue *rvq;
	struct virtqueue *svq;
	void *rbufs;
	void *sbufs;
	unsigned int num_bufs;
	unsigned int buf_size;
	int last_sbuf;
	dma_addr_t bufs_dma;
	struct mutex tx_lock;
	struct idr endpoints;
	struct mutex endpoints_lock;
	wait_queue_head_t sendq;
	atomic_t sleepers;
};

struct rpmsg_hdr {
	__rpmsg32 src;
	__rpmsg32 dst;
	__rpmsg32 reserved;
	__rpmsg16 len;
	__rpmsg16 flags;
	u8 data[0];
};

struct virtio_rpmsg_channel {
	struct rpmsg_device rpdev;
	struct virtproc_info *vrp;
	int: 32;
};

enum imx_rpmsg_variants {
	IMX8QM___2 = 0,
	IMX8QXP___2 = 1,
	IMX8MQ___2 = 2,
	IMX8MM___2 = 3,
	IMX7ULP = 4,
	IMX7D___2 = 5,
	IMX6SX___2 = 6,
};

struct imx_rpmsg_vproc;

struct imx_virdev {
	struct virtio_device vdev;
	unsigned int vring[2];
	struct virtqueue *vq[2];
	int base_vq_id;
	int num_of_vqs;
	struct imx_rpmsg_vproc *rpdev;
	int: 32;
};

struct imx_rpmsg_vproc {
	struct mbox_client cl;
	struct mbox_client cl_rxdb;
	struct mbox_chan *tx_ch;
	struct mbox_chan *rx_ch;
	struct mbox_chan *rxdb_ch;
	enum imx_rpmsg_variants variant;
	int vdev_nums;
	int first_notify;
	u32 flags;
	struct imx_virdev *ivdev[8];
	struct delayed_work rpmsg_work;
	struct circ_buf rx_buffer;
	spinlock_t mu_lock;
	u32 mub_partition;
	struct notifier_block proc_nb;
	struct platform_device *pdev;
};

struct imx_rpmsg_vq_info {
	__u16 num;
	__u16 vq_id;
	__u32 mmsg;
	void *addr;
	struct imx_rpmsg_vproc *rpdev;
};

union extcon_property_value {
	int intval;
};

struct extcon_cable;

struct extcon_dev {
	const char *name;
	const unsigned int *supported_cable;
	const u32 *mutually_exclusive;
	int: 32;
	struct device dev;
	struct raw_notifier_head nh_all;
	struct raw_notifier_head *nh;
	struct list_head entry;
	int max_supported;
	spinlock_t lock;
	u32 state;
	struct device_type extcon_dev_type;
	struct extcon_cable *cables;
	struct attribute_group attr_g_muex;
	struct attribute **attrs_muex;
	struct device_attribute *d_attrs_muex;
	int: 32;
};

struct extcon_cable {
	struct extcon_dev *edev;
	int cable_index;
	struct attribute_group attr_g;
	struct device_attribute attr_name;
	struct device_attribute attr_state;
	struct attribute *attrs[3];
	union extcon_property_value usb_propval[3];
	union extcon_property_value chg_propval[1];
	union extcon_property_value jack_propval[1];
	union extcon_property_value disp_propval[2];
	long unsigned int usb_bits[1];
	long unsigned int chg_bits[1];
	long unsigned int jack_bits[1];
	long unsigned int disp_bits[1];
};

struct __extcon_info {
	unsigned int type;
	unsigned int id;
	const char *name;
};

struct extcon_dev_notifier_devres {
	struct extcon_dev *edev;
	unsigned int id;
	struct notifier_block *nb;
};

struct usb_extcon_info {
	struct device *dev;
	struct extcon_dev *edev;
	struct gpio_desc *id_gpiod;
	struct gpio_desc *vbus_gpiod;
	int id_irq;
	int vbus_irq;
	long unsigned int debounce_jiffies;
	struct delayed_work wq_detcable;
};

enum iio_modifier {
	IIO_NO_MOD = 0,
	IIO_MOD_X = 1,
	IIO_MOD_Y = 2,
	IIO_MOD_Z = 3,
	IIO_MOD_X_AND_Y = 4,
	IIO_MOD_X_AND_Z = 5,
	IIO_MOD_Y_AND_Z = 6,
	IIO_MOD_X_AND_Y_AND_Z = 7,
	IIO_MOD_X_OR_Y = 8,
	IIO_MOD_X_OR_Z = 9,
	IIO_MOD_Y_OR_Z = 10,
	IIO_MOD_X_OR_Y_OR_Z = 11,
	IIO_MOD_LIGHT_BOTH = 12,
	IIO_MOD_LIGHT_IR = 13,
	IIO_MOD_ROOT_SUM_SQUARED_X_Y = 14,
	IIO_MOD_SUM_SQUARED_X_Y_Z = 15,
	IIO_MOD_LIGHT_CLEAR = 16,
	IIO_MOD_LIGHT_RED = 17,
	IIO_MOD_LIGHT_GREEN = 18,
	IIO_MOD_LIGHT_BLUE = 19,
	IIO_MOD_QUATERNION = 20,
	IIO_MOD_TEMP_AMBIENT = 21,
	IIO_MOD_TEMP_OBJECT = 22,
	IIO_MOD_NORTH_MAGN = 23,
	IIO_MOD_NORTH_TRUE = 24,
	IIO_MOD_NORTH_MAGN_TILT_COMP = 25,
	IIO_MOD_NORTH_TRUE_TILT_COMP = 26,
	IIO_MOD_RUNNING = 27,
	IIO_MOD_JOGGING = 28,
	IIO_MOD_WALKING = 29,
	IIO_MOD_STILL = 30,
	IIO_MOD_ROOT_SUM_SQUARED_X_Y_Z = 31,
	IIO_MOD_I = 32,
	IIO_MOD_Q = 33,
	IIO_MOD_CO2 = 34,
	IIO_MOD_VOC = 35,
	IIO_MOD_LIGHT_UV = 36,
	IIO_MOD_LIGHT_DUV = 37,
	IIO_MOD_PM1 = 38,
	IIO_MOD_PM2P5 = 39,
	IIO_MOD_PM4 = 40,
	IIO_MOD_PM10 = 41,
	IIO_MOD_ETHANOL = 42,
	IIO_MOD_H2 = 43,
	IIO_MOD_O2 = 44,
	IIO_MOD_LINEAR_X = 45,
	IIO_MOD_LINEAR_Y = 46,
	IIO_MOD_LINEAR_Z = 47,
	IIO_MOD_PITCH = 48,
	IIO_MOD_YAW = 49,
	IIO_MOD_ROLL = 50,
};

enum iio_event_type {
	IIO_EV_TYPE_THRESH = 0,
	IIO_EV_TYPE_MAG = 1,
	IIO_EV_TYPE_ROC = 2,
	IIO_EV_TYPE_THRESH_ADAPTIVE = 3,
	IIO_EV_TYPE_MAG_ADAPTIVE = 4,
	IIO_EV_TYPE_CHANGE = 5,
	IIO_EV_TYPE_MAG_REFERENCED = 6,
	IIO_EV_TYPE_GESTURE = 7,
};

enum iio_event_direction {
	IIO_EV_DIR_EITHER = 0,
	IIO_EV_DIR_RISING = 1,
	IIO_EV_DIR_FALLING = 2,
	IIO_EV_DIR_NONE = 3,
	IIO_EV_DIR_SINGLETAP = 4,
	IIO_EV_DIR_DOUBLETAP = 5,
};

enum iio_event_info {
	IIO_EV_INFO_ENABLE = 0,
	IIO_EV_INFO_VALUE = 1,
	IIO_EV_INFO_HYSTERESIS = 2,
	IIO_EV_INFO_PERIOD = 3,
	IIO_EV_INFO_HIGH_PASS_FILTER_3DB = 4,
	IIO_EV_INFO_LOW_PASS_FILTER_3DB = 5,
	IIO_EV_INFO_TIMEOUT = 6,
	IIO_EV_INFO_RESET_TIMEOUT = 7,
	IIO_EV_INFO_TAP2_MIN_DELAY = 8,
};

enum iio_available_type {
	IIO_AVAIL_LIST = 0,
	IIO_AVAIL_RANGE = 1,
};

enum iio_chan_info_enum {
	IIO_CHAN_INFO_RAW = 0,
	IIO_CHAN_INFO_PROCESSED = 1,
	IIO_CHAN_INFO_SCALE = 2,
	IIO_CHAN_INFO_OFFSET = 3,
	IIO_CHAN_INFO_CALIBSCALE = 4,
	IIO_CHAN_INFO_CALIBBIAS = 5,
	IIO_CHAN_INFO_PEAK = 6,
	IIO_CHAN_INFO_PEAK_SCALE = 7,
	IIO_CHAN_INFO_QUADRATURE_CORRECTION_RAW = 8,
	IIO_CHAN_INFO_AVERAGE_RAW = 9,
	IIO_CHAN_INFO_LOW_PASS_FILTER_3DB_FREQUENCY = 10,
	IIO_CHAN_INFO_HIGH_PASS_FILTER_3DB_FREQUENCY = 11,
	IIO_CHAN_INFO_SAMP_FREQ = 12,
	IIO_CHAN_INFO_FREQUENCY = 13,
	IIO_CHAN_INFO_PHASE = 14,
	IIO_CHAN_INFO_HARDWAREGAIN = 15,
	IIO_CHAN_INFO_HYSTERESIS = 16,
	IIO_CHAN_INFO_HYSTERESIS_RELATIVE = 17,
	IIO_CHAN_INFO_INT_TIME = 18,
	IIO_CHAN_INFO_ENABLE = 19,
	IIO_CHAN_INFO_CALIBHEIGHT = 20,
	IIO_CHAN_INFO_CALIBWEIGHT = 21,
	IIO_CHAN_INFO_DEBOUNCE_COUNT = 22,
	IIO_CHAN_INFO_DEBOUNCE_TIME = 23,
	IIO_CHAN_INFO_CALIBEMISSIVITY = 24,
	IIO_CHAN_INFO_OVERSAMPLING_RATIO = 25,
	IIO_CHAN_INFO_THERMOCOUPLE_TYPE = 26,
	IIO_CHAN_INFO_CALIBAMBIENT = 27,
	IIO_CHAN_INFO_ZEROPOINT = 28,
};

enum iio_shared_by {
	IIO_SEPARATE = 0,
	IIO_SHARED_BY_TYPE = 1,
	IIO_SHARED_BY_DIR = 2,
	IIO_SHARED_BY_ALL = 3,
};

struct iio_chan_spec_ext_info {
	const char *name;
	enum iio_shared_by shared;
	ssize_t (*read)(struct iio_dev *, uintptr_t, const struct iio_chan_spec *, char *);
	ssize_t (*write)(struct iio_dev *, uintptr_t, const struct iio_chan_spec *, const char *, size_t);
	uintptr_t private;
};

struct iio_buffer;

struct iio_trigger;

struct iio_poll_func;

struct iio_info;

struct iio_buffer_setup_ops;

struct iio_dev {
	int modes;
	int: 32;
	struct device dev;
	struct iio_buffer *buffer;
	int scan_bytes;
	struct mutex mlock;
	const long unsigned int *available_scan_masks;
	unsigned int masklength;
	const long unsigned int *active_scan_mask;
	bool scan_timestamp;
	struct iio_trigger *trig;
	struct iio_poll_func *pollfunc;
	struct iio_poll_func *pollfunc_event;
	const struct iio_chan_spec *channels;
	int num_channels;
	const char *name;
	const char *label;
	const struct iio_info *info;
	const struct iio_buffer_setup_ops *setup_ops;
	void *priv;
	int: 32;
};

struct iio_enum {
	const char * const *items;
	unsigned int num_items;
	int (*set)(struct iio_dev *, const struct iio_chan_spec *, unsigned int);
	int (*get)(struct iio_dev *, const struct iio_chan_spec *);
};

struct iio_mount_matrix {
	const char *rotation[9];
};

typedef const struct iio_mount_matrix *iio_get_mount_matrix_t(const struct iio_dev *, const struct iio_chan_spec *);

struct iio_event_spec {
	enum iio_event_type type;
	enum iio_event_direction dir;
	long unsigned int mask_separate;
	long unsigned int mask_shared_by_type;
	long unsigned int mask_shared_by_dir;
	long unsigned int mask_shared_by_all;
};

struct iio_info {
	const struct attribute_group *event_attrs;
	const struct attribute_group *attrs;
	int (*read_raw)(struct iio_dev *, const struct iio_chan_spec *, int *, int *, long int);
	int (*read_raw_multi)(struct iio_dev *, const struct iio_chan_spec *, int, int *, int *, long int);
	int (*read_avail)(struct iio_dev *, const struct iio_chan_spec *, const int **, int *, int *, long int);
	int (*write_raw)(struct iio_dev *, const struct iio_chan_spec *, int, int, long int);
	int (*read_label)(struct iio_dev *, const struct iio_chan_spec *, char *);
	int (*write_raw_get_fmt)(struct iio_dev *, const struct iio_chan_spec *, long int);
	int (*read_event_config)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction);
	int (*write_event_config)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, int);
	int (*read_event_value)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, enum iio_event_info, int *, int *);
	int (*write_event_value)(struct iio_dev *, const struct iio_chan_spec *, enum iio_event_type, enum iio_event_direction, enum iio_event_info, int, int);
	int (*validate_trigger)(struct iio_dev *, struct iio_trigger *);
	int (*update_scan_mode)(struct iio_dev *, const long unsigned int *);
	int (*debugfs_reg_access)(struct iio_dev *, unsigned int, unsigned int, unsigned int *);
	int (*fwnode_xlate)(struct iio_dev *, const struct fwnode_reference_args *);
	int (*hwfifo_set_watermark)(struct iio_dev *, unsigned int);
	int (*hwfifo_flush_to_buffer)(struct iio_dev *, unsigned int);
};

struct iio_buffer_setup_ops {
	int (*preenable)(struct iio_dev *);
	int (*postenable)(struct iio_dev *);
	int (*predisable)(struct iio_dev *);
	int (*postdisable)(struct iio_dev *);
	bool (*validate_scan_mask)(struct iio_dev *, const long unsigned int *);
};

enum iio_buffer_direction {
	IIO_BUFFER_DIRECTION_IN = 0,
	IIO_BUFFER_DIRECTION_OUT = 1,
};

struct iio_buffer_access_funcs;

struct iio_buffer {
	unsigned int length;
	long unsigned int flags;
	size_t bytes_per_datum;
	enum iio_buffer_direction direction;
	const struct iio_buffer_access_funcs *access;
	long int *scan_mask;
	struct list_head demux_list;
	wait_queue_head_t pollq;
	unsigned int watermark;
	bool scan_timestamp;
	struct list_head buffer_attr_list;
	struct attribute_group buffer_group;
	const struct attribute **attrs;
	void *demux_bounce;
	struct list_head attached_entry;
	struct list_head buffer_list;
	struct kref ref;
};

struct iio_event_interface;

struct iio_ioctl_handler;

struct iio_dev_opaque {
	struct iio_dev indio_dev;
	int currentmode;
	int id;
	struct module *driver_module;
	struct lock_class_key mlock_key;
	struct mutex info_exist_lock;
	bool trig_readonly;
	struct iio_event_interface *event_interface;
	struct iio_buffer **attached_buffers;
	unsigned int attached_buffers_cnt;
	struct iio_ioctl_handler *buffer_ioctl_handler;
	struct list_head buffer_list;
	struct list_head channel_attr_list;
	struct attribute_group chan_attr_group;
	struct list_head ioctl_handlers;
	const struct attribute_group **groups;
	int groupcounter;
	struct attribute_group legacy_scan_el_group;
	struct attribute_group legacy_buffer_group;
	void *bounce_buffer;
	size_t bounce_buffer_size;
	unsigned int scan_index_timestamp;
	clockid_t clock_id;
	struct cdev chrdev;
	long unsigned int flags;
	struct dentry *debugfs_dentry;
	unsigned int cached_reg_addr;
	char read_buf[20];
	unsigned int read_buf_len;
};

struct iio_event_data {
	__u64 id;
	__s64 timestamp;
};

struct iio_ioctl_handler {
	struct list_head entry;
	long int (*ioctl)(struct iio_dev *, struct file *, unsigned int, long unsigned int);
};

struct iio_event_interface {
	wait_queue_head_t wait;
	int: 32;
	struct {
		union {
			struct __kfifo kfifo;
			struct iio_event_data *type;
			const struct iio_event_data *const_type;
			char (*rectype)[0];
			struct iio_event_data *ptr;
			const struct iio_event_data *ptr_const;
		};
		int: 32;
		struct iio_event_data buf[16];
	} det_events;
	struct list_head dev_attr_list;
	long unsigned int flags;
	struct attribute_group group;
	struct mutex read_lock;
	struct iio_ioctl_handler ioctl_handler;
};

struct iio_dev_buffer_pair {
	struct iio_dev *indio_dev;
	struct iio_buffer *buffer;
};

struct iio_dev_attr {
	struct device_attribute dev_attr;
	u64 address;
	struct list_head l;
	const struct iio_chan_spec *c;
	struct iio_buffer *buffer;
};

struct iio_const_attr {
	const char *string;
	struct device_attribute dev_attr;
};

struct iio_buffer_access_funcs {
	int (*store_to)(struct iio_buffer *, const void *);
	int (*read)(struct iio_buffer *, size_t, char *);
	size_t (*data_available)(struct iio_buffer *);
	int (*remove_from)(struct iio_buffer *, void *);
	int (*write)(struct iio_buffer *, size_t, const char *);
	size_t (*space_available)(struct iio_buffer *);
	int (*request_update)(struct iio_buffer *);
	int (*set_bytes_per_datum)(struct iio_buffer *, size_t);
	int (*set_length)(struct iio_buffer *, unsigned int);
	int (*enable)(struct iio_buffer *, struct iio_dev *);
	int (*disable)(struct iio_buffer *, struct iio_dev *);
	void (*release)(struct iio_buffer *);
	unsigned int modes;
	unsigned int flags;
};

struct iio_map {
	const char *adc_channel_label;
	const char *consumer_dev_name;
	const char *consumer_channel;
	void *consumer_data;
};

struct iio_map_internal {
	struct iio_dev *indio_dev;
	struct iio_map *map;
	struct list_head l;
};

struct iio_device_config {
	unsigned int mode;
	unsigned int watermark;
	const long unsigned int *scan_mask;
	unsigned int scan_bytes;
	bool scan_timestamp;
};

struct iio_demux_table {
	unsigned int from;
	unsigned int to;
	unsigned int length;
	struct list_head l;
};

struct iio_subirq {
	bool enabled;
};

struct iio_trigger_ops;

struct iio_trigger {
	const struct iio_trigger_ops *ops;
	struct module *owner;
	int id;
	const char *name;
	struct device dev;
	struct list_head list;
	struct list_head alloc_list;
	atomic_t use_count;
	struct irq_chip subirq_chip;
	int subirq_base;
	struct iio_subirq subirqs[2];
	long unsigned int pool[1];
	struct mutex pool_lock;
	bool attached_own_device;
	struct work_struct reenable_work;
	int: 32;
};

struct iio_poll_func {
	struct iio_dev *indio_dev;
	irqreturn_t (*h)(int, void *);
	irqreturn_t (*thread)(int, void *);
	int type;
	char *name;
	int irq;
	s64 timestamp;
};

struct iio_trigger_ops {
	int (*set_trigger_state)(struct iio_trigger *, bool);
	void (*reenable)(struct iio_trigger *);
	int (*validate_device)(struct iio_trigger *, struct iio_dev *);
};

struct mma_chip_info;

struct mma8452_data {
	struct i2c_client *client;
	struct mutex lock;
	struct iio_mount_matrix orientation;
	u8 ctrl_reg1;
	u8 data_cfg;
	const struct mma_chip_info *chip_info;
	int sleep_val;
	struct regulator *vdd_reg;
	struct regulator *vddio_reg;
	struct {
		__be16 channels[3];
		s64 ts;
	} buffer;
};

struct mma_chip_info {
	const char *name;
	u8 chip_id;
	const struct iio_chan_spec *channels;
	int num_channels;
	const int mma_scales[6];
	int all_events;
	int enabled_events;
};

struct mma8452_event_regs {
	u8 ev_cfg;
	u8 ev_cfg_ele;
	u8 ev_cfg_chan_shift;
	u8 ev_src;
	u8 ev_ths;
	u8 ev_ths_mask;
	u8 ev_count;
};

enum {
	idx_x = 0,
	idx_y = 1,
	idx_z = 2,
	idx_ts = 3,
};

enum {
	mma8451 = 0,
	mma8452 = 1,
	mma8453 = 2,
	mma8652 = 3,
	mma8653 = 4,
	fxls8471 = 5,
};

enum imx7d_adc_clk_pre_div {
	IMX7D_ADC_ANALOG_CLK_PRE_DIV_4 = 0,
	IMX7D_ADC_ANALOG_CLK_PRE_DIV_8 = 1,
	IMX7D_ADC_ANALOG_CLK_PRE_DIV_16 = 2,
	IMX7D_ADC_ANALOG_CLK_PRE_DIV_32 = 3,
	IMX7D_ADC_ANALOG_CLK_PRE_DIV_64 = 4,
	IMX7D_ADC_ANALOG_CLK_PRE_DIV_128 = 5,
};

enum imx7d_adc_average_num {
	IMX7D_ADC_AVERAGE_NUM_4 = 0,
	IMX7D_ADC_AVERAGE_NUM_8 = 1,
	IMX7D_ADC_AVERAGE_NUM_16 = 2,
	IMX7D_ADC_AVERAGE_NUM_32 = 3,
};

struct imx7d_adc_feature {
	enum imx7d_adc_clk_pre_div clk_pre_div;
	enum imx7d_adc_average_num avg_num;
	u32 core_time_unit;
};

struct imx7d_adc {
	struct device *dev;
	void *regs;
	struct clk *clk;
	u32 vref_uv;
	u32 value;
	u32 channel;
	u32 pre_div_num;
	struct regulator *vref;
	struct imx7d_adc_feature adc_feature;
	struct completion completion;
};

struct imx7d_adc_analogue_core_clk {
	u32 pre_div;
	u32 reg_config;
};

struct u16_fract {
	__u16 numerator;
	__u16 denominator;
};

struct rn5t618_adc_data {
	struct device *dev;
	struct rn5t618 *rn5t618;
	struct completion conv_completion;
	int irq;
};

enum rn5t618_channels {
	LIMMON = 0,
	VBAT = 1,
	VADP = 2,
	VUSB = 3,
	VSYS = 4,
	VTHM = 5,
	AIN1 = 6,
	AIN0 = 7,
};

enum clk_sel {
	VF610_ADCIOC_BUSCLK_SET = 0,
	VF610_ADCIOC_ALTCLK_SET = 1,
	VF610_ADCIOC_ADACK_SET = 2,
};

enum vol_ref {
	VF610_ADCIOC_VR_VREF_SET = 0,
	VF610_ADCIOC_VR_VALT_SET = 1,
	VF610_ADCIOC_VR_VBG_SET = 2,
};

enum average_sel {
	VF610_ADC_SAMPLE_1 = 0,
	VF610_ADC_SAMPLE_4 = 1,
	VF610_ADC_SAMPLE_8 = 2,
	VF610_ADC_SAMPLE_16 = 3,
	VF610_ADC_SAMPLE_32 = 4,
};

enum conversion_mode_sel {
	VF610_ADC_CONV_NORMAL = 0,
	VF610_ADC_CONV_HIGH_SPEED = 1,
	VF610_ADC_CONV_LOW_POWER = 2,
};

enum lst_adder_sel {
	VF610_ADCK_CYCLES_3 = 0,
	VF610_ADCK_CYCLES_5 = 1,
	VF610_ADCK_CYCLES_7 = 2,
	VF610_ADCK_CYCLES_9 = 3,
	VF610_ADCK_CYCLES_13 = 4,
	VF610_ADCK_CYCLES_17 = 5,
	VF610_ADCK_CYCLES_21 = 6,
	VF610_ADCK_CYCLES_25 = 7,
};

struct vf610_adc_feature {
	enum clk_sel clk_sel;
	enum vol_ref vol_ref;
	enum conversion_mode_sel conv_mode;
	int clk_div;
	int sample_rate;
	int res_mode;
	u32 lst_adder_index;
	u32 default_sample_time;
	bool calibration;
	bool ovwren;
};

struct vf610_adc {
	struct device *dev;
	void *regs;
	struct clk *clk;
	u32 vref_uv;
	u32 value;
	struct regulator *vref;
	u32 max_adck_rate[3];
	struct vf610_adc_feature adc_feature;
	u32 sample_freq_avail[5];
	struct completion completion;
	int: 32;
	struct {
		u16 chan;
		int: 16;
		int: 32;
		s64 timestamp;
	} scan;
};

struct iio_kfifo {
	struct iio_buffer buffer;
	struct kfifo kf;
	struct mutex user_lock;
	int update_needed;
};

enum fxas21002c_fields {
	F_DR_STATUS = 0,
	F_OUT_X_MSB = 1,
	F_OUT_X_LSB = 2,
	F_OUT_Y_MSB = 3,
	F_OUT_Y_LSB = 4,
	F_OUT_Z_MSB = 5,
	F_OUT_Z_LSB = 6,
	F_ZYX_OW = 7,
	F_Z_OW = 8,
	F_Y_OW = 9,
	F_X_OW = 10,
	F_ZYX_DR = 11,
	F_Z_DR = 12,
	F_Y_DR = 13,
	F_X_DR = 14,
	F_OVF = 15,
	F_WMKF = 16,
	F_CNT = 17,
	F_MODE = 18,
	F_WMRK = 19,
	F_EVENT = 20,
	FE_TIME = 21,
	F_BOOTEND = 22,
	F_SRC_FIFO = 23,
	F_SRC_RT = 24,
	F_SRC_DRDY = 25,
	F_WHO_AM_I = 26,
	F_BW = 27,
	F_SPIW = 28,
	F_SEL = 29,
	F_HPF_EN = 30,
	F_FS = 31,
	F_ELE = 32,
	F_ZTEFE = 33,
	F_YTEFE = 34,
	F_XTEFE = 35,
	F_EA = 36,
	F_ZRT = 37,
	F_ZRT_POL = 38,
	F_YRT = 39,
	F_YRT_POL = 40,
	F_XRT = 41,
	F_XRT_POL = 42,
	F_DBCNTM = 43,
	F_THS = 44,
	F_RT_COUNT = 45,
	F_TEMP = 46,
	F_RST = 47,
	F_ST = 48,
	F_DR = 49,
	F_ACTIVE = 50,
	F_READY = 51,
	F_INT_CFG_FIFO = 52,
	F_INT_EN_FIFO = 53,
	F_INT_CFG_RT = 54,
	F_INT_EN_RT = 55,
	F_INT_CFG_DRDY = 56,
	F_INT_EN_DRDY = 57,
	F_IPOL = 58,
	F_PP_OD = 59,
	F_WRAPTOONE = 60,
	F_EXTCTRLEN = 61,
	F_FS_DOUBLE = 62,
	F_MAX_FIELDS = 63,
};

enum fxas21002c_mode_state {
	FXAS21002C_MODE_STANDBY = 0,
	FXAS21002C_MODE_READY = 1,
	FXAS21002C_MODE_ACTIVE = 2,
};

struct fxas21002c_data {
	u8 chip_id;
	enum fxas21002c_mode_state mode;
	enum fxas21002c_mode_state prev_mode;
	struct mutex lock;
	struct regmap *regmap;
	struct regmap_field *regmap_fields[63];
	struct iio_trigger *dready_trig;
	int: 32;
	s64 timestamp;
	int irq;
	struct regulator *vdd;
	struct regulator *vddio;
	int: 32;
	s16 buffer[8];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum fxas21002c_channel_index {
	CHANNEL_SCAN_INDEX_X = 0,
	CHANNEL_SCAN_INDEX_Y = 1,
	CHANNEL_SCAN_INDEX_Z = 2,
	CHANNEL_SCAN_MAX = 3,
};

struct fxos8700_data {
	struct regmap *regmap;
	struct iio_trigger *trig;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	__be16 buf;
	int: 16;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum fxos8700_accel_scale_bits {
	MODE_2G = 0,
	MODE_4G = 1,
	MODE_8G = 2,
};

enum fxos8700_scan_axis {
	FXOS8700_SCAN_ACCEL_X = 0,
	FXOS8700_SCAN_ACCEL_Y = 1,
	FXOS8700_SCAN_ACCEL_Z = 2,
	FXOS8700_SCAN_MAGN_X = 3,
	FXOS8700_SCAN_MAGN_Y = 4,
	FXOS8700_SCAN_MAGN_Z = 5,
	FXOS8700_SCAN_RHALL = 6,
	FXOS8700_SCAN_TIMESTAMP = 7,
};

enum fxos8700_sensor {
	FXOS8700_ACCEL = 0,
	FXOS8700_MAGN = 1,
	FXOS8700_NUM_SENSORS = 2,
};

struct fxos8700_scale {
	u8 bits;
	int uscale;
};

struct fxos8700_odr {
	u8 bits;
	int odr;
	int uodr;
};

enum isl29018_int_time {
	ISL29018_INT_TIME_16 = 0,
	ISL29018_INT_TIME_12 = 1,
	ISL29018_INT_TIME_8 = 2,
	ISL29018_INT_TIME_4 = 3,
};

struct isl29018_scale {
	unsigned int scale;
	unsigned int uscale;
};

struct isl29018_chip {
	struct regmap *regmap;
	struct mutex lock;
	int type;
	unsigned int calibscale;
	unsigned int ucalibscale;
	unsigned int int_time;
	struct isl29018_scale scale;
	int prox_scheme;
	bool suspended;
	struct regulator *vcc_reg;
};

enum {
	isl29018 = 0,
	isl29023 = 1,
	isl29035 = 2,
};

struct isl29018_chip_info {
	const struct iio_chan_spec *channels;
	int num_channels;
	const struct iio_info *indio_info;
	const struct regmap_config *regmap_cfg;
};

struct mag3110_data {
	struct i2c_client *client;
	struct mutex lock;
	u8 ctrl_reg1;
	int sleep_val;
	struct regulator *vdd_reg;
	struct regulator *vddio_reg;
	struct {
		__be16 channels[3];
		u8 temperature;
		s64 ts;
	} scan;
};

struct mpl3115_data {
	struct i2c_client *client;
	struct mutex lock;
	u8 ctrl_reg1;
};

struct pmu_irq_ops {
	void (*enable_pmuirq)(unsigned int);
	void (*disable_pmuirq)(unsigned int);
	void (*free_pmuirq)(unsigned int, int, void *);
};

struct nvmem_cell_lookup {
	const char *nvmem_name;
	const char *cell_name;
	const char *dev_id;
	const char *con_id;
	struct list_head node;
};

enum {
	NVMEM_ADD = 1,
	NVMEM_REMOVE = 2,
	NVMEM_CELL_ADD = 3,
	NVMEM_CELL_REMOVE = 4,
};

struct nvmem_cell_table {
	const char *nvmem_name;
	const struct nvmem_cell_info *cells;
	size_t ncells;
	struct list_head node;
};

struct nvmem_device {
	struct module *owner;
	int: 32;
	struct device dev;
	int stride;
	int word_size;
	int id;
	struct kref refcnt;
	size_t size;
	bool read_only;
	bool root_only;
	int flags;
	enum nvmem_type type;
	struct bin_attribute eeprom;
	struct device *base_dev;
	struct list_head cells;
	const struct nvmem_keepout *keepout;
	unsigned int nkeepout;
	nvmem_reg_read_t reg_read;
	nvmem_reg_write_t reg_write;
	nvmem_cell_post_process_t cell_post_process;
	struct gpio_desc *wp_gpio;
	void *priv;
};

struct nvmem_cell_entry {
	const char *name;
	int offset;
	int bytes;
	int bit_offset;
	int nbits;
	struct device_node *np;
	struct nvmem_device *nvmem;
	struct list_head node;
};

struct nvmem_cell {
	struct nvmem_cell_entry *entry;
	const char *id;
};

struct ocotp_params;

struct ocotp_priv {
	struct device *dev;
	struct clk *clk;
	void *base;
	const struct ocotp_params *params;
	struct nvmem_config *config;
};

struct ocotp_ctrl_reg {
	u32 bm_addr;
	u32 bm_busy;
	u32 bm_error;
	u32 bm_rel_shadows;
};

struct ocotp_params {
	unsigned int nregs;
	unsigned int bank_address_words;
	void (*set_timing)(struct ocotp_priv *);
	struct ocotp_ctrl_reg ctrl;
	bool reverse_mac_address;
};

struct snvs_lpgpr_cfg {
	int offset;
	int offset_hplr;
	int offset_lplr;
	int size;
};

struct device_d;

struct snvs_lpgpr_priv {
	struct device_d *dev;
	struct regmap *regmap;
	struct nvmem_config cfg;
	const struct snvs_lpgpr_cfg *dcfg;
};

struct tee_ioctl_shm_alloc_data {
	__u64 size;
	__u32 flags;
	__s32 id;
};

struct tee_ioctl_buf_data {
	__u64 buf_ptr;
	__u64 buf_len;
};

struct tee_ioctl_cancel_arg {
	__u32 cancel_id;
	__u32 session;
};

struct tee_ioctl_close_session_arg {
	__u32 session;
};

struct tee_iocl_supp_recv_arg {
	__u32 func;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_iocl_supp_send_arg {
	__u32 ret;
	__u32 num_params;
	struct tee_ioctl_param params[0];
};

struct tee_ioctl_shm_register_data {
	__u64 addr;
	__u64 length;
	__u32 flags;
	__s32 id;
};

struct tee_desc;

struct tee_shm_pool;

struct tee_device {
	char name[32];
	const struct tee_desc *desc;
	int id;
	unsigned int flags;
	int: 32;
	struct device dev;
	struct cdev cdev;
	size_t num_users;
	struct completion c_no_users;
	struct mutex mutex;
	struct idr idr;
	struct tee_shm_pool *pool;
	int: 32;
};

struct tee_driver_ops {
	void (*get_version)(struct tee_device *, struct tee_ioctl_version_data *);
	int (*open)(struct tee_context *);
	void (*release)(struct tee_context *);
	int (*open_session)(struct tee_context *, struct tee_ioctl_open_session_arg *, struct tee_param *);
	int (*close_session)(struct tee_context *, u32);
	int (*invoke_func)(struct tee_context *, struct tee_ioctl_invoke_arg *, struct tee_param *);
	int (*cancel_req)(struct tee_context *, u32, u32);
	int (*supp_recv)(struct tee_context *, u32 *, u32 *, struct tee_param *);
	int (*supp_send)(struct tee_context *, u32, u32, struct tee_param *);
	int (*shm_register)(struct tee_context *, struct tee_shm *, struct page **, size_t, long unsigned int);
	int (*shm_unregister)(struct tee_context *, struct tee_shm *);
};

struct tee_desc {
	const char *name;
	const struct tee_driver_ops *ops;
	struct module *owner;
	u32 flags;
};

struct tee_shm_pool_ops;

struct tee_shm_pool {
	const struct tee_shm_pool_ops *ops;
	void *private_data;
};

struct tee_shm_pool_ops {
	int (*alloc)(struct tee_shm_pool *, struct tee_shm *, size_t, size_t);
	void (*free)(struct tee_shm_pool *, struct tee_shm *);
	void (*destroy_pool)(struct tee_shm_pool *);
};

struct match_dev_data {
	struct tee_ioctl_version_data *vers;
	const void *data;
	int (*match)(struct tee_ioctl_version_data *, const void *);
};

struct optee_msg_param_tmem {
	u64 buf_ptr;
	u64 size;
	u64 shm_ref;
};

struct optee_msg_param_rmem {
	u64 offs;
	u64 size;
	u64 shm_ref;
};

struct optee_msg_param_fmem {
	u32 offs_low;
	u16 offs_high;
	u16 internal_offs;
	u64 size;
	u64 global_id;
};

struct optee_msg_param_value {
	u64 a;
	u64 b;
	u64 c;
};

struct optee_msg_param {
	u64 attr;
	union {
		struct optee_msg_param_tmem tmem;
		struct optee_msg_param_rmem rmem;
		struct optee_msg_param_fmem fmem;
		struct optee_msg_param_value value;
		u8 octets[24];
	} u;
};

typedef void optee_invoke_fn(long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, long unsigned int, struct arm_smccc_res *);

struct optee_call_queue {
	struct mutex mutex;
	struct list_head waiters;
};

struct optee_notif {
	u_int max_key;
	spinlock_t lock;
	struct list_head db;
	u_long *bitmap;
};

struct optee_shm_arg_cache {
	u32 flags;
	struct mutex mutex;
	struct list_head shm_args;
};

struct optee_supp {
	struct mutex mutex;
	struct tee_context *ctx;
	int req_id;
	struct list_head reqs;
	struct idr idr;
	struct completion reqs_c;
};

struct optee_smc {
	optee_invoke_fn *invoke_fn;
	void *memremaped_shm;
	u32 sec_caps;
	unsigned int notif_irq;
};

struct ffa_device;

struct optee_ffa {
	struct ffa_device *ffa_dev;
	struct mutex mutex;
	struct rhashtable global_ids;
};

struct optee;

struct optee_ops {
	int (*do_call_with_arg)(struct tee_context *, struct tee_shm *, u_int);
	int (*to_msg_param)(struct optee *, struct optee_msg_param *, size_t, const struct tee_param *);
	int (*from_msg_param)(struct optee *, struct tee_param *, size_t, const struct optee_msg_param *);
};

struct optee {
	struct tee_device *supp_teedev;
	struct tee_device *teedev;
	const struct optee_ops *ops;
	struct tee_context *ctx;
	union {
		struct optee_smc smc;
		struct optee_ffa ffa;
	};
	struct optee_shm_arg_cache shm_arg_cache;
	struct optee_call_queue call_queue;
	struct optee_notif notif;
	struct optee_supp supp;
	struct tee_shm_pool *pool;
	unsigned int rpc_param_count;
	bool scan_bus_done;
	struct workqueue_struct *scan_bus_wq;
	struct work_struct scan_bus_work;
};

struct optee_session {
	struct list_head list_node;
	u32 session_id;
};

struct optee_context_data {
	struct mutex mutex;
	struct list_head sess_list;
};

struct optee_msg_arg {
	u32 cmd;
	u32 func;
	u32 session;
	u32 cancel_id;
	u32 pad;
	u32 ret;
	u32 ret_origin;
	u32 num_params;
	struct optee_msg_param params[0];
};

struct optee_call_waiter {
	struct list_head list_node;
	struct completion c;
};

struct optee_shm_arg_entry {
	struct list_head list_node;
	struct tee_shm *shm;
	long unsigned int map[1];
};

struct notif_entry {
	struct list_head link;
	struct completion c;
	u_int key;
};

struct optee_supp_req {
	struct list_head link;
	bool in_queue;
	u32 func;
	u32 ret;
	size_t num_params;
	struct tee_param *param;
	struct completion c;
};

struct optee_rpc_param {
	u32 a0;
	u32 a1;
	u32 a2;
	u32 a3;
	u32 a4;
	u32 a5;
	u32 a6;
	u32 a7;
};

struct optee_call_ctx {
	void *pages_list;
	size_t num_entries;
};

struct optee_smc_calls_revision_result {
	long unsigned int major;
	long unsigned int minor;
	long unsigned int reserved0;
	long unsigned int reserved1;
};

struct optee_smc_call_get_os_revision_result {
	long unsigned int major;
	long unsigned int minor;
	long unsigned int build_id;
	long unsigned int reserved1;
};

struct optee_smc_get_shm_config_result {
	long unsigned int status;
	long unsigned int start;
	long unsigned int size;
	long unsigned int settings;
};

struct optee_smc_exchange_capabilities_result {
	long unsigned int status;
	long unsigned int capabilities;
	long unsigned int max_notif_value;
	long unsigned int data;
};

struct optee_smc_disable_shm_cache_result {
	long unsigned int status;
	long unsigned int shm_upper32;
	long unsigned int shm_lower32;
	long unsigned int reserved0;
};

struct trace_event_raw_optee_invoke_fn_begin {
	struct trace_entry ent;
	void *param;
	u32 args[8];
	char __data[0];
};

struct trace_event_raw_optee_invoke_fn_end {
	struct trace_entry ent;
	void *param;
	long unsigned int rets[4];
	char __data[0];
};

struct trace_event_data_offsets_optee_invoke_fn_begin {};

struct trace_event_data_offsets_optee_invoke_fn_end {};

typedef void (*btf_trace_optee_invoke_fn_begin)(void *, struct optee_rpc_param *);

typedef void (*btf_trace_optee_invoke_fn_end)(void *, struct optee_rpc_param *, struct arm_smccc_res *);

struct optee_shm_arg_entry;

struct ffa_ops;

struct ffa_device {
	int vm_id;
	bool mode_32bit;
	uuid_t uuid;
	struct device dev;
	const struct ffa_ops *ops;
	int: 32;
};

struct ffa_info_ops;

struct ffa_msg_ops;

struct ffa_mem_ops;

struct ffa_ops {
	const struct ffa_info_ops *info_ops;
	const struct ffa_msg_ops *msg_ops;
	const struct ffa_mem_ops *mem_ops;
};

struct ffa_device_id {
	uuid_t uuid;
};

struct ffa_driver {
	const char *name;
	int (*probe)(struct ffa_device *);
	void (*remove)(struct ffa_device *);
	const struct ffa_device_id *id_table;
	struct device_driver driver;
};

struct ffa_partition_info {
	u16 id;
	u16 exec_ctxt;
	u32 properties;
	u32 uuid[4];
};

struct ffa_send_direct_data {
	long unsigned int data0;
	long unsigned int data1;
	long unsigned int data2;
	long unsigned int data3;
	long unsigned int data4;
};

struct ffa_mem_region_attributes {
	u16 receiver;
	u8 attrs;
	u8 flag;
	u32 composite_off;
	u64 reserved;
};

struct ffa_mem_ops_args {
	bool use_txbuf;
	u32 nattrs;
	u32 flags;
	int: 32;
	u64 tag;
	u64 g_handle;
	struct scatterlist *sg;
	struct ffa_mem_region_attributes *attrs;
};

struct ffa_info_ops {
	u32 (*api_version_get)();
	int (*partition_info_get)(const char *, struct ffa_partition_info *);
};

struct ffa_msg_ops {
	void (*mode_32bit_set)(struct ffa_device *);
	int (*sync_send_receive)(struct ffa_device *, struct ffa_send_direct_data *);
};

struct ffa_mem_ops {
	int (*memory_reclaim)(u64, u32);
	int (*memory_share)(struct ffa_mem_ops_args *);
	int (*memory_lend)(struct ffa_mem_ops_args *);
};

struct mux_control;

struct mux_control_ops {
	int (*set)(struct mux_control *, int);
};

struct mux_chip;

struct mux_control {
	struct semaphore lock;
	struct mux_chip *chip;
	int cached_state;
	unsigned int states;
	int idle_state;
	ktime_t last_change;
};

struct mux_chip {
	unsigned int controllers;
	struct mux_control *mux;
	struct device dev;
	int id;
	const struct mux_control_ops *ops;
};

struct mux_state {
	struct mux_control *mux;
	unsigned int state;
};

typedef struct {
	unsigned int size;
	unsigned char *atr_buffer;
	int errval;
} sim_atr_t;

typedef struct {
	unsigned int wwt;
	unsigned int cwt;
	unsigned int bwt;
	unsigned int bgt;
	unsigned int cgt;
} sim_timing_t;

typedef struct {
	unsigned char *xmt_buffer;
	int xmt_length;
	int timeout;
	int errval;
} sim_xmt_t;

typedef struct {
	unsigned char *rcv_buffer;
	int rcv_length;
	int timeout;
	int errval;
} sim_rcv_t;

typedef struct {
	unsigned char di;
	unsigned char fi;
} sim_baud_t;

struct mxc_sim_platform_data;

struct sim_t {
	s32 present;
	u8 open_cnt;
	int state;
	struct clk *clk;
	struct resource *res;
	void *ioaddr;
	int ipb_irq;
	int dat_irq;
	int errval;
	int protocol_type;
	sim_timing_t timing_data;
	sim_baud_t baud_rate;
	int timeout;
	u8 nack_threshold;
	u8 nack_enable;
	u32 expected_rcv_cnt;
	u8 is_fixed_len_rec;
	u32 xmt_remaining;
	u32 xmt_pos;
	u32 rcv_count;
	u8 rcv_buffer[400];
	u8 xmt_buffer[300];
	struct completion xfer_done;
	struct fasync_struct *fasync;
	struct mxc_sim_platform_data *plat_data;
	bool last_is_tx;
	u16 rcv_head;
	spinlock_t lock;
	bool sven_low_active;
	u32 port_index;
	u32 port_detect_reg;
	u32 port_ctrl_reg;
	u32 clk_rate;
	u32 quirks;
	u8 checking_ts_timing;
};

enum imx_sim_type {
	IMX7D_SIM = 0,
	IMX6UL_SIM = 1,
};

enum MLB_CTYPE {
	MLB_CTYPE_SYNC = 0,
	MLB_CTYPE_CTRL = 1,
	MLB_CTYPE_ASYNC = 2,
	MLB_CTYPE_ISOC = 3,
};

enum CLK_SPEED {
	CLK_256FS = 0,
	CLK_512FS = 1,
	CLK_1024FS = 2,
	CLK_2048FS = 3,
	CLK_3072FS = 4,
	CLK_4096FS = 5,
	CLK_6144FS = 6,
	CLK_8192FS = 7,
};

enum MLB_INDEX {
	IMX6Q_MLB = 0,
	IMX6SX_MLB = 1,
};

struct imx_mlb_hwdata {
	enum MLB_INDEX devtype;
	u32 quirk_flag;
};

struct mlb_ringbuf {
	s8 *virt_bufs[8];
	u32 phy_addrs[8];
	s32 head;
	s32 tail;
	s32 unit_size;
	s32 total_size;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	rwlock_t rb_lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct mlb_channel_info {
	u32 address;
	u32 cl;
	u32 dbr_buf_head;
};

struct mlb_dev_info {
	const char dev_name[20];
	const unsigned int channel_type;
	enum CLK_SPEED fps;
	struct mlb_channel_info channels[2];
	u8 *rbuf_base_virt;
	u32 rbuf_base_phy;
	int: 32;
	struct mlb_ringbuf rx_rbuf;
	struct mlb_ringbuf tx_rbuf;
	long unsigned int ex_event;
	long unsigned int tx_busy;
	atomic_t on;
	atomic_t opencnt;
	wait_queue_head_t rx_wq;
	wait_queue_head_t tx_wq;
	s32 tx_ok;
	spinlock_t event_lock;
	u32 isoc_blksz;
	u32 sync_quad;
	u32 cdt_buf_dep;
	u32 adt_buf_dep;
	u32 buf_size;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct mlb_data {
	struct device *dev;
	struct mlb_dev_info *devinfo;
	const struct imx_mlb_hwdata *hwdata;
	struct clk *mlb;
	struct cdev cdev;
	struct class *class;
	dev_t firstdev;
	struct regulator *nvcc;
	void *membase;
	struct gen_pool *iram_pool;
	u32 iram_size;
	int irq_ahb0;
	int irq_ahb1;
	int irq_mlb;
	bool use_iram;
};

typedef enum {
	IPU_ROTATE_NONE___2 = 0,
	IPU_ROTATE_VERT_FLIP___2 = 1,
	IPU_ROTATE_HORIZ_FLIP___2 = 2,
	IPU_ROTATE_180___2 = 3,
	IPU_ROTATE_90_RIGHT___2 = 4,
	IPU_ROTATE_90_RIGHT_VFLIP___2 = 5,
	IPU_ROTATE_90_RIGHT_HFLIP___2 = 6,
	IPU_ROTATE_90_LEFT___2 = 7,
} ipu_rotate_mode_t;

typedef enum {
	IPU_OUTPUT_BUFFER = 0,
	IPU_ALPHA_IN_BUFFER = 1,
	IPU_GRAPH_IN_BUFFER = 2,
	IPU_VIDEO_IN_BUFFER = 3,
	IPU_INPUT_BUFFER = 3,
	IPU_SEC_INPUT_BUFFER = 2,
} ipu_buffer_t;

enum ipuv3_type {
	IPUv3D = 0,
	IPUv3EX = 1,
	IPUv3M = 2,
	IPUv3H = 3,
};

struct ipu_irq_node {
	irqreturn_t (*handler)(int, void *);
	const char *name;
	void *dev_id;
	__u32 flags;
};

enum csc_type_t {
	RGB2YUV = 0,
	YUV2RGB = 1,
	RGB2RGB = 2,
	YUV2YUV = 3,
	CSC_NONE = 4,
	CSC_NUM = 5,
};

struct rot_mem {
	void *vaddr;
	dma_addr_t paddr;
	int size;
};

struct ipu_soc {
	unsigned int id;
	unsigned int devtype;
	bool online;
	struct clk *ipu_clk;
	struct clk *di_clk[2];
	struct clk *di_clk_sel[2];
	struct clk *pixel_clk[2];
	bool pixel_clk_en[2];
	struct clk *pixel_clk_sel[2];
	struct clk *csi_clk[2];
	struct clk *prg_clk;
	int irq_sync;
	int irq_err;
	struct ipu_irq_node irq_list[464];
	void *cm_reg;
	void *idmac_reg;
	void *dp_reg;
	void *ic_reg;
	void *dc_reg;
	void *dc_tmpl_reg;
	void *dmfc_reg;
	void *di_reg[2];
	void *smfc_reg;
	void *csi_reg[2];
	void *cpmem_base;
	void *tpmem_base;
	void *vdi_reg;
	struct device *dev;
	ipu_channel_t csi_channel[2];
	ipu_channel_t using_ic_dirct_ch;
	unsigned char dc_di_assignment[10];
	bool sec_chan_en[32];
	bool thrd_chan_en[32];
	bool chan_is_interlaced[52];
	uint32_t channel_init_mask;
	uint32_t channel_enable_mask;
	int dc_use_count;
	int dp_use_count;
	int dmfc_use_count;
	int smfc_use_count;
	int ic_use_count;
	int rot_use_count;
	int vdi_use_count;
	int di_use_count[2];
	int csi_use_count[2];
	struct mutex mutex_lock;
	spinlock_t int_reg_spin_lock;
	spinlock_t rdy_reg_spin_lock;
	int dmfc_size_28;
	int dmfc_size_29;
	int dmfc_size_24;
	int dmfc_size_27;
	int dmfc_size_23;
	enum csc_type_t fg_csc_type;
	enum csc_type_t bg_csc_type;
	bool color_key_4rgb;
	bool dc_swap;
	struct completion dc_comp;
	struct completion csi_comp;
	struct rot_mem rot_dma[2];
	int vdoa_en;
	struct task_struct *thread[2];
	bool bypass_reset;
	unsigned int ch0123_axi;
	unsigned int ch23_axi;
	unsigned int ch27_axi;
	unsigned int ch28_axi;
	unsigned int normal_axi;
	bool smfc_idmac_12bit_3planar_bs_fixup;
};

struct ipu_ch_param_word {
	uint32_t data[5];
	uint32_t res[3];
};

struct ipu_ch_param {
	struct ipu_ch_param_word word[2];
};

enum {
	IPU_CONF_CSI0_EN = 1,
	IPU_CONF_CSI1_EN = 2,
	IPU_CONF_IC_EN = 4,
	IPU_CONF_ROT_EN = 8,
	IPU_CONF_ISP_EN = 16,
	IPU_CONF_DP_EN = 32,
	IPU_CONF_DI0_EN = 64,
	IPU_CONF_DI1_EN = 128,
	IPU_CONF_DMFC_EN = 1024,
	IPU_CONF_SMFC_EN = 256,
	IPU_CONF_DC_EN = 512,
	IPU_CONF_VDI_EN = 4096,
	IPU_CONF_IDMAC_DIS = 4194304,
	IPU_CONF_IC_DMFC_SEL = 33554432,
	IPU_CONF_IC_DMFC_SYNC = 67108864,
	IPU_CONF_VDI_DMFC_SYNC = 134217728,
	IPU_CONF_CSI0_DATA_SOURCE = 268435456,
	IPU_CONF_CSI0_DATA_SOURCE_OFFSET = 28,
	IPU_CONF_CSI1_DATA_SOURCE = 536870912,
	IPU_CONF_IC_INPUT = 1073741824,
	IPU_CONF_CSI_SEL = 2147483648,
	DI0_COUNTER_RELEASE = 16777216,
	DI1_COUNTER_RELEASE = 33554432,
	FS_PRPVF_ROT_SRC_SEL_MASK = 3840,
	FS_PRPVF_ROT_SRC_SEL_OFFSET = 8,
	FS_PRPENC_ROT_SRC_SEL_MASK = 15,
	FS_PRPENC_ROT_SRC_SEL_OFFSET = 0,
	FS_PP_ROT_SRC_SEL_MASK = 983040,
	FS_PP_ROT_SRC_SEL_OFFSET = 16,
	FS_PP_SRC_SEL_MASK = 61440,
	FS_PP_SRC_SEL_VDOA = 32768,
	FS_PP_SRC_SEL_OFFSET = 12,
	FS_PRP_SRC_SEL_MASK = 251658240,
	FS_PRP_SRC_SEL_OFFSET = 24,
	FS_VF_IN_VALID = 2147483648,
	FS_ENC_IN_VALID = 1073741824,
	FS_VDI_SRC_SEL_MASK = 805306368,
	FS_VDI_SRC_SEL_VDOA = 536870912,
	FS_VDOA_DEST_SEL_MASK = 196608,
	FS_VDOA_DEST_SEL_VDI = 131072,
	FS_VDOA_DEST_SEL_IC = 65536,
	FS_VDI_SRC_SEL_OFFSET = 28,
	FS_PRPENC_DEST_SEL_MASK = 15,
	FS_PRPENC_DEST_SEL_OFFSET = 0,
	FS_PRPVF_DEST_SEL_MASK = 240,
	FS_PRPVF_DEST_SEL_OFFSET = 4,
	FS_PRPVF_ROT_DEST_SEL_MASK = 3840,
	FS_PRPVF_ROT_DEST_SEL_OFFSET = 8,
	FS_PP_DEST_SEL_MASK = 61440,
	FS_PP_DEST_SEL_OFFSET = 12,
	FS_PP_ROT_DEST_SEL_MASK = 983040,
	FS_PP_ROT_DEST_SEL_OFFSET = 16,
	FS_PRPENC_ROT_DEST_SEL_MASK = 15728640,
	FS_PRPENC_ROT_DEST_SEL_OFFSET = 20,
	FS_SMFC0_DEST_SEL_MASK = 15,
	FS_SMFC0_DEST_SEL_OFFSET = 0,
	FS_SMFC1_DEST_SEL_MASK = 112,
	FS_SMFC1_DEST_SEL_OFFSET = 4,
	FS_SMFC2_DEST_SEL_MASK = 1920,
	FS_SMFC2_DEST_SEL_OFFSET = 7,
	FS_SMFC3_DEST_SEL_MASK = 14336,
	FS_SMFC3_DEST_SEL_OFFSET = 11,
	FS_DC1_SRC_SEL_MASK = 15728640,
	FS_DC1_SRC_SEL_OFFSET = 20,
	FS_DC2_SRC_SEL_MASK = 983040,
	FS_DC2_SRC_SEL_OFFSET = 16,
	FS_DP_SYNC0_SRC_SEL_MASK = 15,
	FS_DP_SYNC0_SRC_SEL_OFFSET = 0,
	FS_DP_SYNC1_SRC_SEL_MASK = 240,
	FS_DP_SYNC1_SRC_SEL_OFFSET = 4,
	FS_DP_ASYNC0_SRC_SEL_MASK = 3840,
	FS_DP_ASYNC0_SRC_SEL_OFFSET = 8,
	FS_DP_ASYNC1_SRC_SEL_MASK = 61440,
	FS_DP_ASYNC1_SRC_SEL_OFFSET = 12,
	FS_AUTO_REF_PER_MASK = 0,
	FS_AUTO_REF_PER_OFFSET = 16,
	TSTAT_VF_MASK = 12,
	TSTAT_VF_OFFSET = 2,
	TSTAT_VF_ROT_MASK = 768,
	TSTAT_VF_ROT_OFFSET = 8,
	TSTAT_ENC_MASK = 3,
	TSTAT_ENC_OFFSET = 0,
	TSTAT_ENC_ROT_MASK = 192,
	TSTAT_ENC_ROT_OFFSET = 6,
	TSTAT_PP_MASK = 48,
	TSTAT_PP_OFFSET = 4,
	TSTAT_PP_ROT_MASK = 3072,
	TSTAT_PP_ROT_OFFSET = 10,
	TASK_STAT_IDLE = 0,
	TASK_STAT_ACTIVE = 1,
	TASK_STAT_WAIT4READY = 2,
	IDMAC_CONF_USED_BUFS_EN_R = 33554432,
	IDMAC_CONF_USED_BUFS_MAX_R_MASK = 31457280,
	IDMAC_CONF_USED_BUFS_MAX_R_OFFSET = 21,
	IDMAC_CONF_USED_BUFS_EN_W = 1048576,
	IDMAC_CONF_USED_BUFS_MAX_W_MASK = 917504,
	IDMAC_CONF_USED_BUFS_MAX_W_OFFSET = 17,
	IC_CONF_PRPENC_EN = 1,
	IC_CONF_PRPENC_CSC1 = 2,
	IC_CONF_PRPENC_ROT_EN = 4,
	IC_CONF_PRPVF_EN = 256,
	IC_CONF_PRPVF_CSC1 = 512,
	IC_CONF_PRPVF_CSC2 = 1024,
	IC_CONF_PRPVF_CMB = 2048,
	IC_CONF_PRPVF_ROT_EN = 4096,
	IC_CONF_PP_EN = 65536,
	IC_CONF_PP_CSC1 = 131072,
	IC_CONF_PP_CSC2 = 262144,
	IC_CONF_PP_CMB = 524288,
	IC_CONF_PP_ROT_EN = 1048576,
	IC_CONF_IC_GLB_LOC_A = 268435456,
	IC_CONF_KEY_COLOR_EN = 536870912,
	IC_CONF_RWS_EN = 1073741824,
	IC_CONF_CSI_MEM_WR_EN = 2147483648,
	IC_RSZ_MAX_RESIZE_RATIO = 16384,
	IC_IDMAC_1_CB0_BURST_16 = 1,
	IC_IDMAC_1_CB1_BURST_16 = 2,
	IC_IDMAC_1_CB2_BURST_16 = 4,
	IC_IDMAC_1_CB3_BURST_16 = 8,
	IC_IDMAC_1_CB4_BURST_16 = 16,
	IC_IDMAC_1_CB5_BURST_16 = 32,
	IC_IDMAC_1_CB6_BURST_16 = 64,
	IC_IDMAC_1_CB7_BURST_16 = 128,
	IC_IDMAC_1_PRPENC_ROT_MASK = 14336,
	IC_IDMAC_1_PRPENC_ROT_OFFSET = 11,
	IC_IDMAC_1_PRPVF_ROT_MASK = 114688,
	IC_IDMAC_1_PRPVF_ROT_OFFSET = 14,
	IC_IDMAC_1_PP_ROT_MASK = 917504,
	IC_IDMAC_1_PP_ROT_OFFSET = 17,
	IC_IDMAC_1_PP_FLIP_RS = 4194304,
	IC_IDMAC_1_PRPVF_FLIP_RS = 2097152,
	IC_IDMAC_1_PRPENC_FLIP_RS = 1048576,
	IC_IDMAC_2_PRPENC_HEIGHT_MASK = 1023,
	IC_IDMAC_2_PRPENC_HEIGHT_OFFSET = 0,
	IC_IDMAC_2_PRPVF_HEIGHT_MASK = 1047552,
	IC_IDMAC_2_PRPVF_HEIGHT_OFFSET = 10,
	IC_IDMAC_2_PP_HEIGHT_MASK = 1072693248,
	IC_IDMAC_2_PP_HEIGHT_OFFSET = 20,
	IC_IDMAC_3_PRPENC_WIDTH_MASK = 1023,
	IC_IDMAC_3_PRPENC_WIDTH_OFFSET = 0,
	IC_IDMAC_3_PRPVF_WIDTH_MASK = 1047552,
	IC_IDMAC_3_PRPVF_WIDTH_OFFSET = 10,
	IC_IDMAC_3_PP_WIDTH_MASK = 1072693248,
	IC_IDMAC_3_PP_WIDTH_OFFSET = 20,
	CSI_SENS_CONF_DATA_FMT_SHIFT = 8,
	CSI_SENS_CONF_DATA_FMT_MASK = 1792,
	CSI_SENS_CONF_DATA_FMT_RGB_YUV444 = 0,
	CSI_SENS_CONF_DATA_FMT_YUV422_YUYV = 1,
	CSI_SENS_CONF_DATA_FMT_YUV422_UYVY = 2,
	CSI_SENS_CONF_DATA_FMT_BAYER = 3,
	CSI_SENS_CONF_DATA_FMT_RGB565 = 4,
	CSI_SENS_CONF_DATA_FMT_RGB555 = 5,
	CSI_SENS_CONF_DATA_FMT_RGB444 = 6,
	CSI_SENS_CONF_DATA_FMT_JPEG = 7,
	CSI_SENS_CONF_VSYNC_POL_SHIFT = 0,
	CSI_SENS_CONF_HSYNC_POL_SHIFT = 1,
	CSI_SENS_CONF_DATA_POL_SHIFT = 2,
	CSI_SENS_CONF_PIX_CLK_POL_SHIFT = 3,
	CSI_SENS_CONF_SENS_PRTCL_MASK = 112,
	CSI_SENS_CONF_SENS_PRTCL_SHIFT = 4,
	CSI_SENS_CONF_PACK_TIGHT_SHIFT = 7,
	CSI_SENS_CONF_DATA_WIDTH_SHIFT = 11,
	CSI_SENS_CONF_EXT_VSYNC_SHIFT = 15,
	CSI_SENS_CONF_DIVRATIO_SHIFT = 16,
	CSI_SENS_CONF_DIVRATIO_MASK = 16711680,
	CSI_SENS_CONF_DATA_DEST_SHIFT = 24,
	CSI_SENS_CONF_DATA_DEST_MASK = 117440512,
	CSI_SENS_CONF_JPEG8_EN_SHIFT = 27,
	CSI_SENS_CONF_JPEG_EN_SHIFT = 28,
	CSI_SENS_CONF_FORCE_EOF_SHIFT = 29,
	CSI_SENS_CONF_DATA_EN_POL_SHIFT = 31,
	CSI_DATA_DEST_ISP = 1,
	CSI_DATA_DEST_IC = 2,
	CSI_DATA_DEST_IDMAC = 4,
	CSI_CCIR_ERR_DET_EN = 16777216,
	CSI_HORI_DOWNSIZE_EN = 2147483648,
	CSI_VERT_DOWNSIZE_EN = 1073741824,
	CSI_TEST_GEN_MODE_EN = 16777216,
	CSI_HSC_MASK = 536805376,
	CSI_HSC_SHIFT = 16,
	CSI_VSC_MASK = 4095,
	CSI_VSC_SHIFT = 0,
	CSI_TEST_GEN_R_MASK = 255,
	CSI_TEST_GEN_R_SHIFT = 0,
	CSI_TEST_GEN_G_MASK = 65280,
	CSI_TEST_GEN_G_SHIFT = 8,
	CSI_TEST_GEN_B_MASK = 16711680,
	CSI_TEST_GEN_B_SHIFT = 16,
	CSI_MIPI_DI0_MASK = 255,
	CSI_MIPI_DI0_SHIFT = 0,
	CSI_MIPI_DI1_MASK = 65280,
	CSI_MIPI_DI1_SHIFT = 8,
	CSI_MIPI_DI2_MASK = 16711680,
	CSI_MIPI_DI2_SHIFT = 16,
	CSI_MIPI_DI3_MASK = 4278190080,
	CSI_MIPI_DI3_SHIFT = 24,
	CSI_MAX_RATIO_SKIP_ISP_MASK = 458752,
	CSI_MAX_RATIO_SKIP_ISP_SHIFT = 16,
	CSI_SKIP_ISP_MASK = 16252928,
	CSI_SKIP_ISP_SHIFT = 19,
	CSI_MAX_RATIO_SKIP_SMFC_MASK = 7,
	CSI_MAX_RATIO_SKIP_SMFC_SHIFT = 0,
	CSI_SKIP_SMFC_MASK = 248,
	CSI_SKIP_SMFC_SHIFT = 3,
	CSI_ID_2_SKIP_MASK = 768,
	CSI_ID_2_SKIP_SHIFT = 8,
	CSI_COLOR_FIRST_ROW_MASK = 2,
	CSI_COLOR_FIRST_COMP_MASK = 1,
	SMFC_MAP_CH0_MASK = 7,
	SMFC_MAP_CH0_SHIFT = 0,
	SMFC_MAP_CH1_MASK = 56,
	SMFC_MAP_CH1_SHIFT = 3,
	SMFC_MAP_CH2_MASK = 448,
	SMFC_MAP_CH2_SHIFT = 6,
	SMFC_MAP_CH3_MASK = 3584,
	SMFC_MAP_CH3_SHIFT = 9,
	SMFC_WM0_SET_MASK = 7,
	SMFC_WM0_SET_SHIFT = 0,
	SMFC_WM1_SET_MASK = 448,
	SMFC_WM1_SET_SHIFT = 6,
	SMFC_WM2_SET_MASK = 458752,
	SMFC_WM2_SET_SHIFT = 16,
	SMFC_WM3_SET_MASK = 29360128,
	SMFC_WM3_SET_SHIFT = 22,
	SMFC_WM0_CLR_MASK = 56,
	SMFC_WM0_CLR_SHIFT = 3,
	SMFC_WM1_CLR_MASK = 3584,
	SMFC_WM1_CLR_SHIFT = 9,
	SMFC_WM2_CLR_MASK = 3670016,
	SMFC_WM2_CLR_SHIFT = 19,
	SMFC_WM3_CLR_MASK = 234881024,
	SMFC_WM3_CLR_SHIFT = 25,
	SMFC_BS0_MASK = 15,
	SMFC_BS0_SHIFT = 0,
	SMFC_BS1_MASK = 240,
	SMFC_BS1_SHIFT = 4,
	SMFC_BS2_MASK = 3840,
	SMFC_BS2_SHIFT = 8,
	SMFC_BS3_MASK = 61440,
	SMFC_BS3_SHIFT = 12,
	PF_CONF_TYPE_MASK = 7,
	PF_CONF_TYPE_SHIFT = 0,
	PF_CONF_PAUSE_EN = 16,
	PF_CONF_RESET = 32768,
	PF_CONF_PAUSE_ROW_MASK = 16711680,
	PF_CONF_PAUSE_ROW_SHIFT = 16,
	DI_DW_GEN_ACCESS_SIZE_OFFSET = 24,
	DI_DW_GEN_COMPONENT_SIZE_OFFSET = 16,
	DI_GEN_DI_CLK_EXT = 1048576,
	DI_GEN_POLARITY_DISP_CLK = 131072,
	DI_GEN_POLARITY_1 = 1,
	DI_GEN_POLARITY_2 = 2,
	DI_GEN_POLARITY_3 = 4,
	DI_GEN_POLARITY_4 = 8,
	DI_GEN_POLARITY_5 = 16,
	DI_GEN_POLARITY_6 = 32,
	DI_GEN_POLARITY_7 = 64,
	DI_GEN_POLARITY_8 = 128,
	DI_POL_DRDY_DATA_POLARITY = 128,
	DI_POL_DRDY_POLARITY_15 = 16,
	DI_VSYNC_SEL_OFFSET = 13,
	DC_WR_CH_CONF_FIELD_MODE = 512,
	DC_WR_CH_CONF_PROG_TYPE_OFFSET = 5,
	DC_WR_CH_CONF_PROG_TYPE_MASK = 224,
	DC_WR_CH_CONF_PROG_DI_ID = 4,
	DC_WR_CH_CONF_PROG_DISP_ID_OFFSET = 3,
	DC_WR_CH_CONF_PROG_DISP_ID_MASK = 24,
	DC_UGDE_0_ODD_EN = 33554432,
	DC_UGDE_0_ID_CODED_MASK = 7,
	DC_UGDE_0_ID_CODED_OFFSET = 0,
	DC_UGDE_0_EV_PRIORITY_MASK = 120,
	DC_UGDE_0_EV_PRIORITY_OFFSET = 3,
	DP_COM_CONF_FG_EN = 1,
	DP_COM_CONF_GWSEL = 2,
	DP_COM_CONF_GWAM = 4,
	DP_COM_CONF_GWCKE = 8,
	DP_COM_CONF_CSC_DEF_MASK = 768,
	DP_COM_CONF_CSC_DEF_OFFSET = 8,
	DP_COM_CONF_CSC_DEF_FG = 768,
	DP_COM_CONF_CSC_DEF_BG = 512,
	DP_COM_CONF_CSC_DEF_BOTH = 256,
	DP_COM_CONF_GAMMA_EN = 4096,
	DP_COM_CONF_GAMMA_YUV_EN = 8192,
	DI_SER_CONF_LLA_SER_ACCESS = 32,
	DI_SER_CONF_SERIAL_CLK_POL = 16,
	DI_SER_CONF_SERIAL_DATA_POL = 8,
	DI_SER_CONF_SERIAL_RS_POL = 4,
	DI_SER_CONF_SERIAL_CS_POL = 2,
	DI_SER_CONF_WAIT4SERIAL = 1,
	VDI_C_CH_420 = 0,
	VDI_C_CH_422 = 2,
	VDI_C_MOT_SEL_FULL = 8,
	VDI_C_MOT_SEL_LOW = 4,
	VDI_C_MOT_SEL_MED = 0,
	VDI_C_BURST_SIZE1_4 = 48,
	VDI_C_BURST_SIZE2_4 = 768,
	VDI_C_BURST_SIZE3_4 = 12288,
	VDI_C_BURST_SIZE_MASK = 15,
	VDI_C_BURST_SIZE1_OFFSET = 4,
	VDI_C_BURST_SIZE2_OFFSET = 8,
	VDI_C_BURST_SIZE3_OFFSET = 12,
	VDI_C_VWM1_SET_1 = 0,
	VDI_C_VWM1_SET_2 = 65536,
	VDI_C_VWM1_CLR_2 = 524288,
	VDI_C_VWM3_SET_1 = 0,
	VDI_C_VWM3_SET_2 = 4194304,
	VDI_C_VWM3_CLR_2 = 33554432,
	VDI_C_TOP_FIELD_MAN_1 = 1073741824,
	VDI_C_TOP_FIELD_AUTO_1 = 2147483648,
};

struct ipu_devtype {
	const char *name;
	long unsigned int cm_ofs;
	long unsigned int idmac_ofs;
	long unsigned int ic_ofs;
	long unsigned int csi0_ofs;
	long unsigned int csi1_ofs;
	long unsigned int di0_ofs;
	long unsigned int di1_ofs;
	long unsigned int smfc_ofs;
	long unsigned int dc_ofs;
	long unsigned int dmfc_ofs;
	long unsigned int vdi_ofs;
	long unsigned int cpmem_ofs;
	long unsigned int srm_ofs;
	long unsigned int tpm_ofs;
	long unsigned int dc_tmpl_ofs;
	enum ipuv3_type type;
	bool idmac_used_bufs_present;
};

struct ipu_platform_type {
	struct ipu_devtype devtype;
	unsigned int ch0123_axi;
	unsigned int ch23_axi;
	unsigned int ch27_axi;
	unsigned int ch28_axi;
	unsigned int normal_axi;
	bool smfc_idmac_12bit_3planar_bs_fixup;
	bool idmac_used_bufs_en_r;
	bool idmac_used_bufs_en_w;
	unsigned int idmac_used_bufs_max_r;
	unsigned int idmac_used_bufs_max_w;
};

enum {
	IC_TASK_VIEWFINDER = 0,
	IC_TASK_ENCODER = 1,
	IC_TASK_POST_PROCESSOR = 2,
};

typedef struct {
	unsigned int data_pol: 1;
	unsigned int clk_pol: 1;
	unsigned int cs_pol: 1;
	unsigned int rs_pol: 1;
	unsigned int addr_pol: 1;
	unsigned int read_pol: 1;
	unsigned int write_pol: 1;
	unsigned int Vsync_pol: 1;
	unsigned int burst_pol: 1;
	unsigned int burst_mode: 2;
	unsigned int ifc_mode: 3;
	unsigned int ifc_width: 5;
	unsigned int ser_preamble_len: 4;
	unsigned int ser_preamble: 8;
	char: 1;
	unsigned int ser_rw_mode: 2;
} ipu_adc_sig_cfg_t;

enum ipu_dmfc_type {
	DMFC_NORMAL = 0,
	DMFC_HIGH_RESOLUTION_DC = 1,
	DMFC_HIGH_RESOLUTION_DP = 2,
	DMFC_HIGH_RESOLUTION_ONLY_DP = 3,
};

enum di_pins {
	DI_PIN11 = 0,
	DI_PIN12 = 1,
	DI_PIN13 = 2,
	DI_PIN14 = 3,
	DI_PIN15 = 4,
	DI_PIN16 = 5,
	DI_PIN17 = 6,
	DI_PIN_CS = 7,
	DI_PIN_SER_CLK = 0,
	DI_PIN_SER_RS = 1,
};

enum di_sync_wave {
	DI_SYNC_NONE = 4294967295,
	DI_SYNC_CLK = 0,
	DI_SYNC_INT_HSYNC = 1,
	DI_SYNC_HSYNC = 2,
	DI_SYNC_VSYNC = 3,
	DI_SYNC_DE = 5,
};

struct dp_csc_param_t {
	int mode;
	void *coeff;
};

typedef struct {
	unsigned int data_width: 4;
	unsigned int clk_mode: 3;
	unsigned int ext_vsync: 1;
	unsigned int Vsync_pol: 1;
	unsigned int Hsync_pol: 1;
	unsigned int pixclk_pol: 1;
	unsigned int data_pol: 1;
	unsigned int sens_clksrc: 1;
	unsigned int pack_tight: 1;
	unsigned int force_eof: 1;
	unsigned int data_en_pol: 1;
	unsigned int data_fmt;
	unsigned int csi;
	unsigned int mclk;
} ipu_csi_signal_cfg_t;

enum {
	IPU_CSI_CLK_MODE_GATED_CLK = 0,
	IPU_CSI_CLK_MODE_NONGATED_CLK = 1,
	IPU_CSI_CLK_MODE_CCIR656_PROGRESSIVE = 2,
	IPU_CSI_CLK_MODE_CCIR656_INTERLACED = 3,
	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_DDR = 4,
	IPU_CSI_CLK_MODE_CCIR1120_PROGRESSIVE_SDR = 5,
	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_DDR = 6,
	IPU_CSI_CLK_MODE_CCIR1120_INTERLACED_SDR = 7,
};

enum {
	IPU_CSI_MIPI_DI0 = 0,
	IPU_CSI_MIPI_DI1 = 1,
	IPU_CSI_MIPI_DI2 = 2,
	IPU_CSI_MIPI_DI3 = 3,
};

typedef enum {
	RGB_CS = 0,
	YUV_CS = 1,
	NULL_CS = 2,
} cs_t;

struct stripe_param {
	unsigned int input_width;
	unsigned int output_width;
	unsigned int input_column;
	unsigned int output_column;
	unsigned int idr;
	unsigned int irr;
};

struct vfield_buf {
	u32 prev_veba;
	u32 cur_veba;
	u32 next_veba;
	u32 vubo;
};

struct vframe_buf {
	u32 veba;
	u32 vubo;
};

struct vdoa_params {
	u32 width;
	u32 height;
	int vpu_stride;
	int interlaced;
	int scan_order;
	int ipu_num;
	int band_lines;
	int band_mode;
	int pfs;
	u32 ieba0;
	u32 ieba1;
	u32 ieba2;
	struct vframe_buf vframe_buf;
	struct vfield_buf vfield_buf;
};

struct vdoa_ipu_buf {
	u32 ieba0;
	u32 ieba1;
	u32 iubo;
};

typedef void *vdoa_handle_t;

typedef enum {
	STATE_OK = 0,
	STATE_QUEUE = 1,
	STATE_IN_PROGRESS = 2,
	STATE_ERR = 3,
	STATE_TIMEOUT = 4,
	STATE_RES_TIMEOUT = 5,
	STATE_NO_IPU = 6,
	STATE_NO_IRQ = 7,
	STATE_IPU_BUSY = 8,
	STATE_IRQ_FAIL = 9,
	STATE_IRQ_TIMEOUT = 10,
	STATE_ENABLE_CHAN_FAIL = 11,
	STATE_DISABLE_CHAN_FAIL = 12,
	STATE_SEL_BUF_FAIL = 13,
	STATE_INIT_CHAN_FAIL = 14,
	STATE_LINK_CHAN_FAIL = 15,
	STATE_UNLINK_CHAN_FAIL = 16,
	STATE_INIT_CHAN_BUF_FAIL = 17,
	STATE_INIT_CHAN_BAND_FAIL = 18,
	STATE_SYS_NO_MEM = 19,
	STATE_VDOA_IRQ_TIMEOUT = 20,
	STATE_VDOA_IRQ_FAIL = 21,
	STATE_VDOA_TASK_FAIL = 22,
} ipu_state_t;

enum {
	INPUT_CHAN_VDI_P = 1,
	INPUT_CHAN = 2,
	INPUT_CHAN_VDI_N = 3,
};

struct ipu_state_msg {
	int state;
	char *msg;
};

struct stripe_setting {
	u32 iw;
	u32 ih;
	u32 ow;
	u32 oh;
	u32 outh_resize_ratio;
	u32 outv_resize_ratio;
	u32 i_left_pos;
	u32 i_right_pos;
	u32 i_top_pos;
	u32 i_bottom_pos;
	u32 o_left_pos;
	u32 o_right_pos;
	u32 o_top_pos;
	u32 o_bottom_pos;
	u32 rl_split_line;
	u32 ud_split_line;
};

struct task_set {
	u8 mode;
	u8 task;
	u8 split_mode;
	u8 band_lines;
	ipu_channel_t ic_chan;
	ipu_channel_t rot_chan;
	ipu_channel_t vdi_ic_p_chan;
	ipu_channel_t vdi_ic_n_chan;
	u32 i_off;
	u32 i_uoff;
	u32 i_voff;
	u32 istride;
	u32 ov_off;
	u32 ov_uoff;
	u32 ov_voff;
	u32 ovstride;
	u32 ov_alpha_off;
	u32 ov_alpha_stride;
	u32 o_off;
	u32 o_uoff;
	u32 o_voff;
	u32 ostride;
	u32 r_fmt;
	u32 r_width;
	u32 r_height;
	u32 r_stride;
	dma_addr_t r_paddr;
	struct stripe_setting sp_setting;
};

struct ipu_task_entry;

struct ipu_split_task {
	struct ipu_task task;
	struct ipu_task_entry *parent_task;
	struct ipu_task_entry *child_task;
	u32 task_no;
};

struct vdoa_output_mem {
	void *vaddr;
	dma_addr_t paddr;
	int size;
};

struct ipu_task_entry {
	struct ipu_input input;
	struct ipu_output output;
	bool overlay_en;
	struct ipu_overlay overlay;
	int timeout;
	int irq;
	u8 task_id;
	u8 ipu_id;
	u8 task_in_list;
	u8 split_done;
	struct mutex split_lock;
	struct mutex vdic_lock;
	wait_queue_head_t split_waitq;
	struct list_head node;
	struct list_head split_list;
	struct ipu_soc *ipu;
	struct device *dev;
	struct task_set set;
	wait_queue_head_t task_waitq;
	struct completion irq_comp;
	struct kref refcount;
	ipu_state_t state;
	u32 task_no;
	atomic_t done;
	atomic_t res_free;
	atomic_t res_get;
	struct ipu_task_entry *parent;
	char *vditmpbuf[2];
	u32 old_save_lines;
	u32 old_size;
	bool buf1filled;
	bool buf0filled;
	vdoa_handle_t vdoa_handle;
	struct vdoa_output_mem vdoa_dma;
};

struct ipu_channel_tabel {
	struct mutex lock;
	u8 used[4];
	u8 vdoa_used;
};

struct ipu_thread_data {
	struct ipu_soc *ipu;
	u32 id;
	u32 is_vdoa;
};

struct ipu_alloc_list {
	struct list_head list;
	dma_addr_t phy_addr;
	void *cpu_addr;
	u32 size;
	void *file_index;
};

enum {
	VDOA_INIT = 1,
	VDOA_GET = 2,
	VDOA_SETUP = 4,
	VDOA_GET_OBUF = 8,
	VDOA_START = 16,
	VDOA_INIRQ = 32,
	VDOA_STOP = 64,
	VDOA_PUT = 1,
};

enum {
	VDOA_NULL = 0,
	VDOA_FRAME = 1,
	VDOA_PREV_FIELD = 2,
	VDOA_CURR_FIELD = 3,
	VDOA_NEXT_FIELD = 4,
};

struct vdoa_info {
	int state;
	struct device *dev;
	struct clk *vdoa_clk;
	void *reg_base;
	struct gen_pool *iram_pool;
	long unsigned int iram_base;
	long unsigned int iram_paddr;
	int irq;
	int field;
	struct completion comp;
};

struct clk_di_mux {
	struct clk_hw hw;
	u8 ipu_id;
	u8 di_id;
	u8 flags;
	u8 index;
};

struct clk_di_div {
	struct clk_hw hw;
	u8 ipu_id;
	u8 di_id;
	u8 flags;
};

struct clk_di_gate {
	struct clk_hw hw;
	u8 ipu_id;
	u8 di_id;
	u8 flags;
};

struct prg_chan {
	unsigned int pre_num;
	struct mutex mutex;
	bool in_use;
};

struct ipu_prg_data {
	unsigned int id;
	void *base;
	long unsigned int memory;
	struct clk *axi_clk;
	struct clk *apb_clk;
	struct list_head list;
	struct device *dev;
	struct prg_chan chan[3];
	struct regmap *regmap;
	struct regmap_field *pre_prg_sel[2];
	spinlock_t lock;
};

struct ipu_soc;

struct ipu_pre_data {
	unsigned int id;
	struct device *dev;
	void *base;
	struct clk *clk;
	struct mutex mutex;
	spinlock_t lock;
	struct list_head list;
	struct gen_pool *iram_pool;
	long unsigned int double_buffer_size;
	long unsigned int double_buffer_base;
	long unsigned int double_buffer_paddr;
	bool in_use;
	bool enabled;
};

struct hdmi_cec_priv {
	int receive_error;
	int send_error;
	u8 Logical_address;
	bool cec_state;
	u8 last_msg[17];
	u8 msg_len;
	u8 latest_cec_stat;
	spinlock_t irq_lock;
	struct delayed_work hdmi_cec_work;
	struct mutex lock;
};

struct hdmi_cec_event {
	int event_type;
	int msg_len;
	u8 msg[17];
	struct list_head list;
};

struct vpu_mem_desc {
	u32 size;
	dma_addr_t phy_addr;
	u32 cpu_addr;
	u32 virt_uaddr;
};

struct vpu_priv {
	struct fasync_struct *async_queue;
	struct work_struct work;
	struct workqueue_struct *workqueue;
	struct mutex lock;
};

struct memalloc_record {
	struct list_head list;
	struct vpu_mem_desc mem;
};

struct iram_setting {
	u32 start;
	u32 end;
};

struct mipi_csi2_info {
	bool mipi_en;
	int ipu_id;
	unsigned int csi_id;
	unsigned int v_channel;
	unsigned int lanes;
	unsigned int datatype;
	struct clk *cfg_clk;
	struct clk *dphy_clk;
	struct clk *pixel_clk;
	void *mipi_csi2_base;
	struct platform_device *pdev;
	struct mutex mutex_lock;
};

struct snd_minor {
	int type;
	int card;
	int device;
	const struct file_operations *f_ops;
	void *private_data;
	struct device *dev;
	struct snd_card *card_ptr;
};

struct snd_monitor_file {
	struct file *file;
	const struct file_operations *disconnected_f_op;
	struct list_head shutdown_list;
	struct list_head list;
};

struct snd_ctl_card_info {
	int card;
	int pad;
	unsigned char id[16];
	unsigned char driver[16];
	unsigned char name[32];
	unsigned char longname[80];
	unsigned char reserved_[16];
	unsigned char mixername[80];
	unsigned char components[128];
};

struct snd_ctl_elem_list {
	unsigned int offset;
	unsigned int space;
	unsigned int used;
	unsigned int count;
	struct snd_ctl_elem_id *pids;
	unsigned char reserved[50];
};

struct snd_ctl_tlv {
	unsigned int numid;
	unsigned int length;
	unsigned int tlv[0];
};

enum sndrv_ctl_event_type {
	SNDRV_CTL_EVENT_ELEM = 0,
	SNDRV_CTL_EVENT_LAST = 0,
};

struct snd_ctl_event {
	int type;
	union {
		struct {
			unsigned int mask;
			struct snd_ctl_elem_id id;
		} elem;
		unsigned char data8[60];
	} data;
};

enum {
	SNDRV_CTL_TLV_OP_READ = 0,
	SNDRV_CTL_TLV_OP_WRITE = 1,
	SNDRV_CTL_TLV_OP_CMD = 4294967295,
};

struct snd_kctl_event {
	struct list_head list;
	struct snd_ctl_elem_id id;
	unsigned int mask;
};

struct snd_ctl_layer_ops {
	struct snd_ctl_layer_ops *next;
	const char *module_name;
	void (*lregister)(struct snd_card *);
	void (*ldisconnect)(struct snd_card *);
	void (*lnotify)(struct snd_card *, unsigned int, struct snd_kcontrol *, unsigned int);
};

typedef int (*snd_kctl_ioctl_func_t)(struct snd_card *, struct snd_ctl_file *, unsigned int, long unsigned int);

struct snd_kctl_ioctl {
	struct list_head list;
	snd_kctl_ioctl_func_t fioctl;
};

enum snd_ctl_add_mode {
	CTL_ADD_EXCLUSIVE = 0,
	CTL_REPLACE = 1,
	CTL_ADD_ON_REPLACE = 2,
};

struct user_element {
	struct snd_ctl_elem_info info;
	struct snd_card *card;
	char *elem_data;
	long unsigned int elem_data_size;
	void *tlv_data;
	long unsigned int tlv_data_size;
	void *priv_data;
};

struct snd_pci_quirk {
	short unsigned int subvendor;
	short unsigned int subdevice;
	short unsigned int subdevice_mask;
	int value;
};

struct snd_fasync {
	struct fasync_struct *fasync;
	int signal;
	int poll;
	int on;
	struct list_head list;
};

struct snd_info_private_data {
	struct snd_info_buffer *rbuffer;
	struct snd_info_buffer *wbuffer;
	struct snd_info_entry *entry;
	void *file_private_data;
};

struct link_ctl_info {
	snd_ctl_elem_type_t type;
	int count;
	int min_val;
	int max_val;
};

struct link_master {
	struct list_head followers;
	struct link_ctl_info info;
	int val;
	unsigned int tlv[4];
	void (*hook)(void *, int);
	void *hook_private_data;
};

struct link_follower {
	struct list_head list;
	struct link_master *master;
	struct link_ctl_info info;
	int vals[2];
	unsigned int flags;
	struct snd_kcontrol *kctl;
	struct snd_kcontrol follower;
};

enum snd_jack_types {
	SND_JACK_HEADPHONE = 1,
	SND_JACK_MICROPHONE = 2,
	SND_JACK_HEADSET = 3,
	SND_JACK_LINEOUT = 4,
	SND_JACK_MECHANICAL = 8,
	SND_JACK_VIDEOOUT = 16,
	SND_JACK_AVOUT = 20,
	SND_JACK_LINEIN = 32,
	SND_JACK_BTN_0 = 16384,
	SND_JACK_BTN_1 = 8192,
	SND_JACK_BTN_2 = 4096,
	SND_JACK_BTN_3 = 2048,
	SND_JACK_BTN_4 = 1024,
	SND_JACK_BTN_5 = 512,
};

struct snd_jack {
	struct list_head kctl_list;
	struct snd_card *card;
	const char *id;
	struct input_dev *input_dev;
	struct mutex input_dev_lock;
	int registered;
	int type;
	char name[100];
	unsigned int key[6];
	int hw_status_cache;
	void *private_data;
	void (*private_free)(struct snd_jack *);
};

struct snd_jack_kctl {
	struct snd_kcontrol *kctl;
	struct list_head list;
	unsigned int mask_bits;
	struct snd_jack *jack;
	bool sw_inject_enable;
};

enum {
	SNDRV_TIMER_CLASS_NONE = 4294967295,
	SNDRV_TIMER_CLASS_SLAVE = 0,
	SNDRV_TIMER_CLASS_GLOBAL = 1,
	SNDRV_TIMER_CLASS_CARD = 2,
	SNDRV_TIMER_CLASS_PCM = 3,
	SNDRV_TIMER_CLASS_LAST = 3,
};

enum {
	SNDRV_TIMER_SCLASS_NONE = 0,
	SNDRV_TIMER_SCLASS_APPLICATION = 1,
	SNDRV_TIMER_SCLASS_SEQUENCER = 2,
	SNDRV_TIMER_SCLASS_OSS_SEQUENCER = 3,
	SNDRV_TIMER_SCLASS_LAST = 3,
};

struct snd_timer_id {
	int dev_class;
	int dev_sclass;
	int card;
	int device;
	int subdevice;
};

struct snd_timer_ginfo {
	struct snd_timer_id tid;
	unsigned int flags;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	long unsigned int reserved0;
	long unsigned int resolution;
	long unsigned int resolution_min;
	long unsigned int resolution_max;
	unsigned int clients;
	unsigned char reserved[32];
};

struct snd_timer_gparams {
	struct snd_timer_id tid;
	long unsigned int period_num;
	long unsigned int period_den;
	unsigned char reserved[32];
};

struct snd_timer_gstatus {
	struct snd_timer_id tid;
	long unsigned int resolution;
	long unsigned int resolution_num;
	long unsigned int resolution_den;
	unsigned char reserved[32];
};

struct snd_timer_select {
	struct snd_timer_id id;
	unsigned char reserved[32];
};

struct snd_timer_info {
	unsigned int flags;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	long unsigned int reserved0;
	long unsigned int resolution;
	unsigned char reserved[64];
};

struct snd_timer_params {
	unsigned int flags;
	unsigned int ticks;
	unsigned int queue_size;
	unsigned int reserved0;
	unsigned int filter;
	unsigned char reserved[60];
};

struct snd_timer_read {
	unsigned int resolution;
	unsigned int ticks;
};

enum {
	SNDRV_TIMER_EVENT_RESOLUTION = 0,
	SNDRV_TIMER_EVENT_TICK = 1,
	SNDRV_TIMER_EVENT_START = 2,
	SNDRV_TIMER_EVENT_STOP = 3,
	SNDRV_TIMER_EVENT_CONTINUE = 4,
	SNDRV_TIMER_EVENT_PAUSE = 5,
	SNDRV_TIMER_EVENT_EARLY = 6,
	SNDRV_TIMER_EVENT_SUSPEND = 7,
	SNDRV_TIMER_EVENT_RESUME = 8,
	SNDRV_TIMER_EVENT_MSTART = 12,
	SNDRV_TIMER_EVENT_MSTOP = 13,
	SNDRV_TIMER_EVENT_MCONTINUE = 14,
	SNDRV_TIMER_EVENT_MPAUSE = 15,
	SNDRV_TIMER_EVENT_MSUSPEND = 17,
	SNDRV_TIMER_EVENT_MRESUME = 18,
};

struct snd_timer_hardware {
	unsigned int flags;
	long unsigned int resolution;
	long unsigned int resolution_min;
	long unsigned int resolution_max;
	long unsigned int ticks;
	int (*open)(struct snd_timer *);
	int (*close)(struct snd_timer *);
	long unsigned int (*c_resolution)(struct snd_timer *);
	int (*start)(struct snd_timer *);
	int (*stop)(struct snd_timer *);
	int (*set_period)(struct snd_timer *, long unsigned int, long unsigned int);
	int (*precise_resolution)(struct snd_timer *, long unsigned int *, long unsigned int *);
};

struct snd_timer {
	int tmr_class;
	struct snd_card *card;
	struct module *module;
	int tmr_device;
	int tmr_subdevice;
	char id[64];
	char name[80];
	unsigned int flags;
	int running;
	long unsigned int sticks;
	void *private_data;
	void (*private_free)(struct snd_timer *);
	struct snd_timer_hardware hw;
	spinlock_t lock;
	struct list_head device_list;
	struct list_head open_list_head;
	struct list_head active_list_head;
	struct list_head ack_list_head;
	struct list_head sack_list_head;
	struct work_struct task_work;
	int max_instances;
	int num_instances;
};

struct snd_timer_instance {
	struct snd_timer *timer;
	char *owner;
	unsigned int flags;
	void *private_data;
	void (*private_free)(struct snd_timer_instance *);
	void (*callback)(struct snd_timer_instance *, long unsigned int, long unsigned int);
	void (*ccallback)(struct snd_timer_instance *, int, struct timespec64 *, long unsigned int);
	void (*disconnect)(struct snd_timer_instance *);
	void *callback_data;
	long unsigned int ticks;
	long unsigned int cticks;
	long unsigned int pticks;
	long unsigned int resolution;
	long unsigned int lost;
	int slave_class;
	unsigned int slave_id;
	struct list_head open_list;
	struct list_head active_list;
	struct list_head ack_list;
	struct list_head slave_list_head;
	struct list_head slave_active_head;
	struct snd_timer_instance *master;
};

enum timer_tread_format {
	TREAD_FORMAT_NONE = 0,
	TREAD_FORMAT_TIME64 = 1,
	TREAD_FORMAT_TIME32 = 2,
};

struct snd_timer_tread32 {
	int event;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	unsigned int val;
};

struct snd_timer_tread64 {
	int event;
	u8 pad1[4];
	s64 tstamp_sec;
	s64 tstamp_nsec;
	unsigned int val;
	u8 pad2[4];
};

struct snd_timer_user {
	struct snd_timer_instance *timeri;
	int tread;
	long unsigned int ticks;
	long unsigned int overrun;
	int qhead;
	int qtail;
	int qused;
	int queue_size;
	bool disconnected;
	struct snd_timer_read *queue;
	struct snd_timer_tread64 *tqueue;
	spinlock_t qlock;
	long unsigned int last_resolution;
	unsigned int filter;
	struct timespec64 tstamp;
	wait_queue_head_t qchange_sleep;
	struct snd_fasync *fasync;
	struct mutex ioctl_lock;
	int: 32;
};

struct snd_timer_status32 {
	s32 tstamp_sec;
	s32 tstamp_nsec;
	unsigned int resolution;
	unsigned int lost;
	unsigned int overrun;
	unsigned int queue;
	unsigned char reserved[64];
};

struct snd_timer_status64 {
	s64 tstamp_sec;
	s64 tstamp_nsec;
	unsigned int resolution;
	unsigned int lost;
	unsigned int overrun;
	unsigned int queue;
	unsigned char reserved[64];
};

struct snd_timer_system_private {
	struct timer_list tlist;
	struct snd_timer *snd_timer;
	long unsigned int last_expires;
	long unsigned int last_jiffies;
	long unsigned int correction;
};

enum {
	SNDRV_TIMER_IOCTL_START_OLD = 21536,
	SNDRV_TIMER_IOCTL_STOP_OLD = 21537,
	SNDRV_TIMER_IOCTL_CONTINUE_OLD = 21538,
	SNDRV_TIMER_IOCTL_PAUSE_OLD = 21539,
};

enum {
	SNDRV_PCM_CLASS_GENERIC = 0,
	SNDRV_PCM_CLASS_MULTI = 1,
	SNDRV_PCM_CLASS_MODEM = 2,
	SNDRV_PCM_CLASS_DIGITIZER = 3,
	SNDRV_PCM_CLASS_LAST = 3,
};

struct snd_pcm_info {
	unsigned int device;
	unsigned int subdevice;
	int stream;
	int card;
	unsigned char id[64];
	unsigned char name[80];
	unsigned char subname[32];
	int dev_class;
	int dev_subclass;
	unsigned int subdevices_count;
	unsigned int subdevices_avail;
	union snd_pcm_sync_id sync;
	unsigned char reserved[64];
};

enum {
	SNDRV_PCM_TSTAMP_NONE = 0,
	SNDRV_PCM_TSTAMP_ENABLE = 1,
	SNDRV_PCM_TSTAMP_LAST = 1,
};

struct snd_pcm_status64 {
	snd_pcm_state_t state;
	u8 rsvd[4];
	s64 trigger_tstamp_sec;
	s64 trigger_tstamp_nsec;
	s64 tstamp_sec;
	s64 tstamp_nsec;
	snd_pcm_uframes_t appl_ptr;
	snd_pcm_uframes_t hw_ptr;
	snd_pcm_sframes_t delay;
	snd_pcm_uframes_t avail;
	snd_pcm_uframes_t avail_max;
	snd_pcm_uframes_t overrange;
	snd_pcm_state_t suspended_state;
	__u32 audio_tstamp_data;
	s64 audio_tstamp_sec;
	s64 audio_tstamp_nsec;
	s64 driver_tstamp_sec;
	s64 driver_tstamp_nsec;
	__u32 audio_tstamp_accuracy;
	unsigned char reserved[20];
};

enum {
	SNDRV_PCM_MMAP_OFFSET_DATA = 0,
	SNDRV_PCM_MMAP_OFFSET_STATUS_OLD = 2147483648,
	SNDRV_PCM_MMAP_OFFSET_CONTROL_OLD = 2164260864,
	SNDRV_PCM_MMAP_OFFSET_STATUS_NEW = 2181038080,
	SNDRV_PCM_MMAP_OFFSET_CONTROL_NEW = 2197815296,
	SNDRV_PCM_MMAP_OFFSET_STATUS = 2181038080,
	SNDRV_PCM_MMAP_OFFSET_CONTROL = 2197815296,
};

typedef int snd_pcm_hw_param_t;

struct snd_pcm_sw_params {
	int tstamp_mode;
	unsigned int period_step;
	unsigned int sleep_min;
	snd_pcm_uframes_t avail_min;
	snd_pcm_uframes_t xfer_align;
	snd_pcm_uframes_t start_threshold;
	snd_pcm_uframes_t stop_threshold;
	snd_pcm_uframes_t silence_threshold;
	snd_pcm_uframes_t silence_size;
	snd_pcm_uframes_t boundary;
	unsigned int proto;
	unsigned int tstamp_type;
	unsigned char reserved[56];
};

struct snd_pcm_channel_info {
	unsigned int channel;
	__kernel_off_t offset;
	unsigned int first;
	unsigned int step;
};

enum {
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_COMPAT = 0,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_DEFAULT = 1,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK = 2,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ABSOLUTE = 3,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_ESTIMATED = 4,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LINK_SYNCHRONIZED = 5,
	SNDRV_PCM_AUDIO_TSTAMP_TYPE_LAST = 5,
};

struct snd_pcm_sync_ptr {
	__u32 flags;
	__u32 pad1;
	union {
		struct snd_pcm_mmap_status status;
		unsigned char reserved[64];
	} s;
	union {
		struct snd_pcm_mmap_control control;
		unsigned char reserved[64];
	} c;
};

struct snd_xferi {
	snd_pcm_sframes_t result;
	void *buf;
	snd_pcm_uframes_t frames;
};

struct snd_xfern {
	snd_pcm_sframes_t result;
	void **bufs;
	snd_pcm_uframes_t frames;
};

enum {
	SNDRV_PCM_TSTAMP_TYPE_GETTIMEOFDAY = 0,
	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC = 1,
	SNDRV_PCM_TSTAMP_TYPE_MONOTONIC_RAW = 2,
	SNDRV_PCM_TSTAMP_TYPE_LAST = 2,
};

enum snd_dma_sync_mode {
	SNDRV_DMA_SYNC_CPU = 0,
	SNDRV_DMA_SYNC_DEVICE = 1,
};

struct snd_pcm_file {
	struct snd_pcm_substream *substream;
	int no_compat_mmap;
	unsigned int user_pversion;
};

struct snd_pcm_hw_constraint_list {
	const unsigned int *list;
	unsigned int count;
	unsigned int mask;
};

struct snd_pcm_status32 {
	snd_pcm_state_t state;
	s32 trigger_tstamp_sec;
	s32 trigger_tstamp_nsec;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	u32 appl_ptr;
	u32 hw_ptr;
	s32 delay;
	u32 avail;
	u32 avail_max;
	u32 overrange;
	snd_pcm_state_t suspended_state;
	u32 audio_tstamp_data;
	s32 audio_tstamp_sec;
	s32 audio_tstamp_nsec;
	s32 driver_tstamp_sec;
	s32 driver_tstamp_nsec;
	u32 audio_tstamp_accuracy;
	unsigned char reserved[36];
};

struct snd_pcm_hw_params_old {
	unsigned int flags;
	unsigned int masks[3];
	struct snd_interval intervals[12];
	unsigned int rmask;
	unsigned int cmask;
	unsigned int info;
	unsigned int msbits;
	unsigned int rate_num;
	unsigned int rate_den;
	snd_pcm_uframes_t fifo_size;
	unsigned char reserved[64];
};

struct action_ops {
	int (*pre_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	int (*do_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	void (*undo_action)(struct snd_pcm_substream *, snd_pcm_state_t);
	void (*post_action)(struct snd_pcm_substream *, snd_pcm_state_t);
};

struct snd_pcm_mmap_status32 {
	snd_pcm_state_t state;
	s32 pad1;
	u32 hw_ptr;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	snd_pcm_state_t suspended_state;
	s32 audio_tstamp_sec;
	s32 audio_tstamp_nsec;
};

struct snd_pcm_mmap_control32 {
	u32 appl_ptr;
	u32 avail_min;
};

struct snd_pcm_sync_ptr32 {
	u32 flags;
	union {
		struct snd_pcm_mmap_status32 status;
		unsigned char reserved[64];
	} s;
	union {
		struct snd_pcm_mmap_control32 control;
		unsigned char reserved[64];
	} c;
};

typedef u32 u_int32_t;

typedef u64 u_int64_t;

enum {
	SNDRV_CHMAP_UNKNOWN = 0,
	SNDRV_CHMAP_NA = 1,
	SNDRV_CHMAP_MONO = 2,
	SNDRV_CHMAP_FL = 3,
	SNDRV_CHMAP_FR = 4,
	SNDRV_CHMAP_RL = 5,
	SNDRV_CHMAP_RR = 6,
	SNDRV_CHMAP_FC = 7,
	SNDRV_CHMAP_LFE = 8,
	SNDRV_CHMAP_SL = 9,
	SNDRV_CHMAP_SR = 10,
	SNDRV_CHMAP_RC = 11,
	SNDRV_CHMAP_FLC = 12,
	SNDRV_CHMAP_FRC = 13,
	SNDRV_CHMAP_RLC = 14,
	SNDRV_CHMAP_RRC = 15,
	SNDRV_CHMAP_FLW = 16,
	SNDRV_CHMAP_FRW = 17,
	SNDRV_CHMAP_FLH = 18,
	SNDRV_CHMAP_FCH = 19,
	SNDRV_CHMAP_FRH = 20,
	SNDRV_CHMAP_TC = 21,
	SNDRV_CHMAP_TFL = 22,
	SNDRV_CHMAP_TFR = 23,
	SNDRV_CHMAP_TFC = 24,
	SNDRV_CHMAP_TRL = 25,
	SNDRV_CHMAP_TRR = 26,
	SNDRV_CHMAP_TRC = 27,
	SNDRV_CHMAP_TFLC = 28,
	SNDRV_CHMAP_TFRC = 29,
	SNDRV_CHMAP_TSL = 30,
	SNDRV_CHMAP_TSR = 31,
	SNDRV_CHMAP_LLFE = 32,
	SNDRV_CHMAP_RLFE = 33,
	SNDRV_CHMAP_BC = 34,
	SNDRV_CHMAP_BLC = 35,
	SNDRV_CHMAP_BRC = 36,
	SNDRV_CHMAP_LAST = 36,
};

struct snd_ratnum {
	unsigned int num;
	unsigned int den_min;
	unsigned int den_max;
	unsigned int den_step;
};

struct snd_ratden {
	unsigned int num_min;
	unsigned int num_max;
	unsigned int num_step;
	unsigned int den;
};

struct snd_pcm_hw_constraint_ratnums {
	int nrats;
	const struct snd_ratnum *rats;
};

struct snd_pcm_hw_constraint_ratdens {
	int nrats;
	const struct snd_ratden *rats;
};

struct snd_pcm_hw_constraint_ranges {
	unsigned int count;
	const struct snd_interval *ranges;
	unsigned int mask;
};

struct snd_pcm_chmap_elem {
	unsigned char channels;
	unsigned char map[15];
};

struct snd_pcm_chmap {
	struct snd_pcm *pcm;
	int stream;
	struct snd_kcontrol *kctl;
	const struct snd_pcm_chmap_elem *chmap;
	unsigned int max_channels;
	unsigned int channel_mask;
	void *private_data;
};

typedef int (*pcm_transfer_f)(struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);

typedef int (*pcm_copy_f)(struct snd_pcm_substream *, snd_pcm_uframes_t, void *, snd_pcm_uframes_t, snd_pcm_uframes_t, pcm_transfer_f);

struct pcm_format_data {
	unsigned char width;
	unsigned char phys;
	signed char le;
	signed char signd;
	unsigned char silence[8];
};

struct snd_malloc_ops {
	void * (*alloc)(struct snd_dma_buffer *, size_t);
	void (*free)(struct snd_dma_buffer *);
	dma_addr_t (*get_addr)(struct snd_dma_buffer *, size_t);
	struct page * (*get_page)(struct snd_dma_buffer *, size_t);
	unsigned int (*get_chunk_size)(struct snd_dma_buffer *, unsigned int, unsigned int);
	int (*mmap)(struct snd_dma_buffer *, struct vm_area_struct *);
	void (*sync)(struct snd_dma_buffer *, enum snd_dma_sync_mode);
};

struct snd_dmaengine_dai_dma_data {
	dma_addr_t addr;
	enum dma_slave_buswidth addr_width;
	u32 maxburst;
	void *filter_data;
	const char *chan_name;
	unsigned int fifo_size;
	unsigned int flags;
	void *peripheral_config;
	size_t peripheral_size;
};

struct dmaengine_pcm_runtime_data {
	struct dma_chan *dma_chan;
	dma_cookie_t cookie;
	unsigned int pos;
};

struct snd_rawmidi_info {
	unsigned int device;
	unsigned int subdevice;
	int stream;
	int card;
	unsigned int flags;
	unsigned char id[64];
	unsigned char name[80];
	unsigned char subname[32];
	unsigned int subdevices_count;
	unsigned int subdevices_avail;
	unsigned char reserved[64];
};

struct snd_rawmidi_framing_tstamp {
	__u8 frame_type;
	__u8 length;
	__u8 reserved[2];
	__u32 tv_nsec;
	__u64 tv_sec;
	__u8 data[16];
};

struct snd_rawmidi_params {
	int stream;
	size_t buffer_size;
	size_t avail_min;
	unsigned int no_active_sensing: 1;
	unsigned int mode;
	unsigned char reserved[12];
};

struct snd_rawmidi_file {
	struct snd_rawmidi *rmidi;
	struct snd_rawmidi_substream *input;
	struct snd_rawmidi_substream *output;
	unsigned int user_pversion;
};

struct snd_rawmidi_status32 {
	s32 stream;
	s32 tstamp_sec;
	s32 tstamp_nsec;
	u32 avail;
	u32 xruns;
	unsigned char reserved[16];
};

struct snd_rawmidi_status64 {
	int stream;
	u8 rsvd[4];
	s64 tstamp_sec;
	s64 tstamp_nsec;
	size_t avail;
	size_t xruns;
	unsigned char reserved[16];
};

struct snd_ac97;

struct snd_ac97_build_ops {
	int (*build_3d)(struct snd_ac97 *);
	int (*build_specific)(struct snd_ac97 *);
	int (*build_spdif)(struct snd_ac97 *);
	int (*build_post_spdif)(struct snd_ac97 *);
	void (*suspend)(struct snd_ac97 *);
	void (*resume)(struct snd_ac97 *);
	void (*update_jacks)(struct snd_ac97 *);
};

struct snd_ac97_bus;

struct snd_ac97_res_table;

struct snd_ac97_gpio_priv;

struct snd_ac97 {
	const struct snd_ac97_build_ops *build_ops;
	void *private_data;
	void (*private_free)(struct snd_ac97 *);
	struct snd_ac97_bus *bus;
	struct pci_dev *pci;
	struct snd_info_entry *proc;
	struct snd_info_entry *proc_regs;
	short unsigned int subsystem_vendor;
	short unsigned int subsystem_device;
	struct mutex reg_mutex;
	struct mutex page_mutex;
	short unsigned int num;
	short unsigned int addr;
	unsigned int id;
	short unsigned int caps;
	short unsigned int ext_id;
	short unsigned int ext_mid;
	const struct snd_ac97_res_table *res_table;
	unsigned int scaps;
	unsigned int flags;
	unsigned int rates[6];
	unsigned int spdif_status;
	short unsigned int regs[128];
	long unsigned int reg_accessed[4];
	union {
		struct {
			short unsigned int unchained[3];
			short unsigned int chained[3];
			short unsigned int id[3];
			short unsigned int pcmreg[3];
			short unsigned int codec_cfg[3];
			unsigned char swap_mic_linein;
			unsigned char lo_as_master;
		} ad18xx;
		unsigned int dev_flags;
	} spec;
	unsigned char indep_surround;
	unsigned char channel_mode;
	int: 16;
	int: 32;
	struct device dev;
	struct snd_ac97_gpio_priv *gpio_priv;
	struct snd_pcm_chmap *chmaps[2];
	int: 32;
};

struct snd_ac97_bus_ops {
	void (*reset)(struct snd_ac97 *);
	void (*warm_reset)(struct snd_ac97 *);
	void (*write)(struct snd_ac97 *, short unsigned int, short unsigned int);
	short unsigned int (*read)(struct snd_ac97 *, short unsigned int);
	void (*wait)(struct snd_ac97 *);
	void (*init)(struct snd_ac97 *);
};

struct ac97_pcm;

struct snd_ac97_bus {
	const struct snd_ac97_bus_ops *ops;
	void *private_data;
	void (*private_free)(struct snd_ac97_bus *);
	struct snd_card *card;
	short unsigned int num;
	short unsigned int no_vra: 1;
	short unsigned int dra: 1;
	short unsigned int isdin: 1;
	unsigned int clock;
	spinlock_t bus_lock;
	short unsigned int used_slots[8];
	short unsigned int pcms_count;
	struct ac97_pcm *pcms;
	struct snd_ac97 *codec[4];
	struct snd_info_entry *proc;
};

struct ac97_pcm {
	struct snd_ac97_bus *bus;
	unsigned int stream: 1;
	unsigned int exclusive: 1;
	unsigned int copy_flag: 1;
	unsigned int spdif: 1;
	short unsigned int aslots;
	short unsigned int cur_dbl;
	unsigned int rates;
	struct {
		short unsigned int slots;
		short unsigned int rslots[4];
		unsigned char rate_table[4];
		struct snd_ac97 *codec[4];
	} r[2];
	long unsigned int private_value;
};

struct snd_ac97_res_table {
	short unsigned int reg;
	short unsigned int bits;
};

struct snd_ac97_template {
	void *private_data;
	void (*private_free)(struct snd_ac97 *);
	struct pci_dev *pci;
	short unsigned int num;
	short unsigned int addr;
	unsigned int scaps;
	const struct snd_ac97_res_table *res_table;
};

struct ac97_quirk {
	short unsigned int subvendor;
	short unsigned int subdevice;
	short unsigned int mask;
	unsigned int codec_id;
	const char *name;
	int type;
};

struct ac97_enum {
	unsigned char reg;
	unsigned char shift_l;
	unsigned char shift_r;
	short unsigned int mask;
	const char * const *texts;
};

struct vt1618_uaj_item {
	short unsigned int mask;
	short unsigned int shift;
	const char * const items[4];
};

struct ac97_codec_id {
	unsigned int id;
	unsigned int mask;
	const char *name;
	int (*patch)(struct snd_ac97 *);
	int (*mpatch)(struct snd_ac97 *);
	unsigned int flags;
};

enum {
	AC97_GENERAL_PCM_OUT = 0,
	AC97_GENERAL_STEREO_ENHANCEMENT = 1,
	AC97_GENERAL_3D = 2,
	AC97_GENERAL_LOUDNESS = 3,
	AC97_GENERAL_MONO = 4,
	AC97_GENERAL_MIC = 5,
	AC97_GENERAL_LOOPBACK = 6,
};

struct ac97_power_reg {
	short unsigned int reg;
	short unsigned int power_reg;
	short unsigned int mask;
};

enum {
	PWIDX_ADC = 0,
	PWIDX_FRONT = 1,
	PWIDX_CLFE = 2,
	PWIDX_SURR = 3,
	PWIDX_MIC = 4,
	PWIDX_SIZE = 5,
};

struct quirk_table {
	const char *name;
	int (*func)(struct snd_ac97 *);
};

enum ac97_pcm_cfg {
	AC97_PCM_CFG_FRONT = 2,
	AC97_PCM_CFG_REAR = 10,
	AC97_PCM_CFG_LFE = 11,
	AC97_PCM_CFG_40 = 4,
	AC97_PCM_CFG_51 = 6,
	AC97_PCM_CFG_SPDIF = 20,
};

struct snd_soc_dapm_path {
	const char *name;
	union {
		struct {
			struct snd_soc_dapm_widget *source;
			struct snd_soc_dapm_widget *sink;
		};
		struct snd_soc_dapm_widget *node[2];
	};
	u32 connect: 1;
	u32 walking: 1;
	u32 weak: 1;
	u32 is_supply: 1;
	int (*connected)(struct snd_soc_dapm_widget *, struct snd_soc_dapm_widget *);
	struct list_head list_node[2];
	struct list_head list_kcontrol;
	struct list_head list;
};

enum snd_soc_dapm_direction {
	SND_SOC_DAPM_DIR_IN = 0,
	SND_SOC_DAPM_DIR_OUT = 1,
};

struct trace_event_raw_snd_soc_card {
	struct trace_entry ent;
	u32 __data_loc_name;
	int val;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_basic {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_widget {
	struct trace_entry ent;
	u32 __data_loc_name;
	int val;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_walk_done {
	struct trace_entry ent;
	u32 __data_loc_name;
	int power_checks;
	int path_checks;
	int neighbour_checks;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_path {
	struct trace_entry ent;
	u32 __data_loc_wname;
	u32 __data_loc_pname;
	u32 __data_loc_pnname;
	int path_node;
	int path_connect;
	int path_dir;
	char __data[0];
};

struct trace_event_raw_snd_soc_dapm_connected {
	struct trace_entry ent;
	int paths;
	int stream;
	char __data[0];
};

struct trace_event_raw_snd_soc_jack_irq {
	struct trace_entry ent;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_snd_soc_jack_report {
	struct trace_entry ent;
	u32 __data_loc_name;
	int mask;
	int val;
	char __data[0];
};

struct trace_event_raw_snd_soc_jack_notify {
	struct trace_entry ent;
	u32 __data_loc_name;
	int val;
	char __data[0];
};

struct trace_event_data_offsets_snd_soc_card {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_basic {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_widget {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_walk_done {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_dapm_path {
	u32 wname;
	u32 pname;
	u32 pnname;
};

struct trace_event_data_offsets_snd_soc_dapm_connected {};

struct trace_event_data_offsets_snd_soc_jack_irq {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_jack_report {
	u32 name;
};

struct trace_event_data_offsets_snd_soc_jack_notify {
	u32 name;
};

typedef void (*btf_trace_snd_soc_bias_level_start)(void *, struct snd_soc_card *, int);

typedef void (*btf_trace_snd_soc_bias_level_done)(void *, struct snd_soc_card *, int);

typedef void (*btf_trace_snd_soc_dapm_start)(void *, struct snd_soc_card *);

typedef void (*btf_trace_snd_soc_dapm_done)(void *, struct snd_soc_card *);

typedef void (*btf_trace_snd_soc_dapm_widget_power)(void *, struct snd_soc_dapm_widget *, int);

typedef void (*btf_trace_snd_soc_dapm_widget_event_start)(void *, struct snd_soc_dapm_widget *, int);

typedef void (*btf_trace_snd_soc_dapm_widget_event_done)(void *, struct snd_soc_dapm_widget *, int);

typedef void (*btf_trace_snd_soc_dapm_walk_done)(void *, struct snd_soc_card *);

typedef void (*btf_trace_snd_soc_dapm_path)(void *, struct snd_soc_dapm_widget *, enum snd_soc_dapm_direction, struct snd_soc_dapm_path *);

typedef void (*btf_trace_snd_soc_dapm_connected)(void *, int, int);

typedef void (*btf_trace_snd_soc_jack_irq)(void *, const char *);

typedef void (*btf_trace_snd_soc_jack_report)(void *, struct snd_soc_jack *, int, int);

typedef void (*btf_trace_snd_soc_jack_notify)(void *, struct snd_soc_jack *, int);

struct snd_soc_dapm_widget_list {
	int num_widgets;
	struct snd_soc_dapm_widget *widgets[0];
};

struct snd_soc_dapm_pinctrl_priv {
	const char *active_state;
	const char *sleep_state;
};

struct soc_mixer_control {
	int min;
	int max;
	int platform_max;
	int reg;
	int rreg;
	unsigned int shift;
	unsigned int rshift;
	unsigned int sign_bit;
	unsigned int invert: 1;
	unsigned int autodisable: 1;
};

struct soc_enum {
	int reg;
	unsigned char shift_l;
	unsigned char shift_r;
	unsigned int items;
	unsigned int mask;
	const char * const *texts;
	const unsigned int *values;
	unsigned int autodisable: 1;
};

struct dapm_kcontrol_data {
	unsigned int value;
	struct snd_soc_dapm_widget *widget;
	struct list_head paths;
	struct snd_soc_dapm_widget_list *wlist;
};

struct snd_soc_jack_pin {
	struct list_head list;
	const char *pin;
	int mask;
	bool invert;
};

struct snd_soc_jack_zone {
	unsigned int min_mv;
	unsigned int max_mv;
	unsigned int jack_type;
	unsigned int debounce_time;
	struct list_head list;
};

struct snd_soc_jack_gpio {
	unsigned int gpio;
	unsigned int idx;
	struct device *gpiod_dev;
	const char *name;
	int report;
	int invert;
	int debounce_time;
	bool wake;
	struct snd_soc_jack *jack;
	struct delayed_work work;
	struct notifier_block pm_notifier;
	struct gpio_desc *desc;
	void *data;
	int (*jack_status_check)(void *);
};

struct jack_gpio_tbl {
	int count;
	struct snd_soc_jack *jack;
	struct snd_soc_jack_gpio *gpios;
};

enum snd_soc_dpcm_link_state {
	SND_SOC_DPCM_LINK_STATE_NEW = 0,
	SND_SOC_DPCM_LINK_STATE_FREE = 1,
};

struct snd_soc_dpcm {
	struct snd_soc_pcm_runtime *be;
	struct snd_soc_pcm_runtime *fe;
	enum snd_soc_dpcm_link_state state;
	struct list_head list_be;
	struct list_head list_fe;
	struct snd_pcm_hw_params hw_params;
	struct dentry *debugfs_state;
};

struct snd_dmaengine_pcm_config {
	int (*prepare_slave_config)(struct snd_pcm_substream *, struct snd_pcm_hw_params *, struct dma_slave_config *);
	struct dma_chan * (*compat_request_channel)(struct snd_soc_pcm_runtime *, struct snd_pcm_substream *);
	int (*process)(struct snd_pcm_substream *, int, long unsigned int, void *, long unsigned int);
	dma_filter_fn compat_filter_fn;
	struct device *dma_dev;
	const char *chan_names[2];
	const struct snd_pcm_hardware *pcm_hardware;
	unsigned int prealloc_buffer_size;
};

struct soc_bytes {
	int base;
	int num_regs;
	u32 mask;
};

struct soc_bytes_ext {
	int max;
	int (*get)(struct snd_kcontrol *, unsigned int *, unsigned int);
	int (*put)(struct snd_kcontrol *, const unsigned int *, unsigned int);
};

struct soc_mreg_control {
	long int min;
	long int max;
	unsigned int regbase;
	unsigned int regcount;
	unsigned int nbits;
	unsigned int invert;
};

struct dmaengine_pcm {
	struct dma_chan *chan[2];
	const struct snd_dmaengine_pcm_config *config;
	struct snd_soc_component component;
	unsigned int flags;
};

struct snd_ac97_gpio_priv {
	struct gpio_chip gpio_chip;
	unsigned int gpios_set;
	struct snd_soc_component *component;
};

struct snd_ac97_reset_cfg {
	struct pinctrl *pctl;
	struct pinctrl_state *pstate_reset;
	struct pinctrl_state *pstate_warm_reset;
	struct pinctrl_state *pstate_run;
	int gpio_sdata;
	int gpio_sync;
	int gpio_reset;
};

struct cs42xx8_driver_data {
	char name[32];
	int num_adcs;
};

struct cs42xx8_priv {
	struct regulator_bulk_data supplies[4];
	const struct cs42xx8_driver_data *drvdata;
	struct regmap *regmap;
	struct clk *clk;
	bool slave_mode[2];
	bool is_tdm;
	long unsigned int sysclk;
	u32 tx_channels;
	struct gpio_desc *gpiod_reset;
	u32 rate[2];
};

struct cs42xx8_ratios {
	unsigned int mfreq;
	unsigned int min_mclk;
	unsigned int max_mclk;
	unsigned int ratio[3];
};

enum sgtl5000_regulator_supplies {
	DVDD = 0,
	AVDD = 1,
	PVDD = 2,
	HPVDD = 3,
	ES8328_SUPPLY_NUM = 4,
};

struct es8328_priv {
	struct regmap *regmap;
	struct clk *clk;
	int playback_fs;
	bool deemph;
	int mclkdiv2;
	const struct snd_pcm_hw_constraint_list *sysclk_constraints;
	const int *mclk_ratios;
	bool provider;
	struct regulator_bulk_data supplies[4];
};

enum hdmi_codec_cea_spk_placement {
	FL = 1,
	FC = 2,
	FR = 4,
	FLC = 8,
	FRC = 16,
	RL = 32,
	RC = 64,
	RR = 128,
	RLC = 256,
	RRC = 512,
	LFE = 1024,
};

struct hdmi_codec_cea_spk_alloc {
	const int ca_id;
	unsigned int n_ch;
	long unsigned int mask;
};

struct hdmi_codec_priv {
	struct hdmi_codec_pdata hcd;
	uint8_t eld[128];
	struct snd_pcm_chmap *chmap_info;
	unsigned int chmap_idx;
	struct mutex lock;
	bool busy;
	struct snd_soc_jack *jack;
	unsigned int jack_status;
	u8 iec_status[24];
};

enum sgtl5000_regulator_supplies___2 {
	VDDA = 0,
	VDDIO = 1,
	VDDD = 2,
	SGTL5000_SUPPLY_NUM = 3,
};

enum sgtl5000_micbias_resistor {
	SGTL5000_MICBIAS_OFF = 0,
	SGTL5000_MICBIAS_2K = 2,
	SGTL5000_MICBIAS_4K = 4,
	SGTL5000_MICBIAS_8K = 8,
};

enum {
	I2S_LRCLK_STRENGTH_DISABLE = 0,
	I2S_LRCLK_STRENGTH_LOW = 1,
	I2S_LRCLK_STRENGTH_MEDIUM = 2,
	I2S_LRCLK_STRENGTH_HIGH = 3,
};

enum {
	I2S_SCLK_STRENGTH_DISABLE = 0,
	I2S_SCLK_STRENGTH_LOW = 1,
	I2S_SCLK_STRENGTH_MEDIUM = 2,
	I2S_SCLK_STRENGTH_HIGH = 3,
};

enum {
	HP_POWER_EVENT = 0,
	DAC_POWER_EVENT = 1,
	ADC_POWER_EVENT = 2,
	LAST_POWER_EVENT = 2,
};

struct sgtl5000_priv {
	int sysclk;
	int master;
	int fmt;
	struct regulator_bulk_data supplies[3];
	int num_supplies;
	struct regmap *regmap;
	struct clk *mclk;
	int revision;
	u8 micbias_resistor;
	u8 micbias_voltage;
	u8 lrclk_strength;
	u8 sclk_strength;
	u16 mute_state[3];
};

enum si476x_audio_registers {
	SI476X_DIGITAL_IO_OUTPUT_FORMAT = 515,
	SI476X_DIGITAL_IO_OUTPUT_SAMPLE_RATE = 514,
};

enum si476x_digital_io_output_format {
	SI476X_DIGITAL_IO_SLOT_SIZE_SHIFT = 11,
	SI476X_DIGITAL_IO_SAMPLE_SIZE_SHIFT = 8,
};

enum si476x_daudio_formats {
	SI476X_DAUDIO_MODE_I2S = 0,
	SI476X_DAUDIO_MODE_DSP_A = 12,
	SI476X_DAUDIO_MODE_DSP_B = 14,
	SI476X_DAUDIO_MODE_LEFT_J = 16,
	SI476X_DAUDIO_MODE_RIGHT_J = 18,
	SI476X_DAUDIO_MODE_IB = 32,
	SI476X_DAUDIO_MODE_IF = 64,
};

enum si476x_pcm_format {
	SI476X_PCM_FORMAT_S8 = 2,
	SI476X_PCM_FORMAT_S16_LE = 4,
	SI476X_PCM_FORMAT_S20_3LE = 5,
	SI476X_PCM_FORMAT_S24_LE = 6,
};

struct aic23 {
	struct regmap *regmap;
	int mclk;
	int requested_adc;
	int requested_dac;
};

enum aic31xx_type {
	AIC3100 = 0,
	AIC3110 = 2,
	AIC3120 = 4,
	AIC3111 = 6,
	DAC3100 = 8,
	DAC3101 = 10,
};

struct aic31xx_pdata {
	enum aic31xx_type codec_type;
	unsigned int gpio_reset;
	int micbias_vg;
};

struct aic31xx_priv;

struct aic31xx_disable_nb {
	struct notifier_block nb;
	struct aic31xx_priv *aic31xx;
};

struct aic31xx_priv {
	struct snd_soc_component *component;
	u8 i2c_regs_status;
	struct device *dev;
	struct regmap *regmap;
	enum aic31xx_type codec_type;
	struct gpio_desc *gpio_reset;
	int micbias_vg;
	struct aic31xx_pdata pdata;
	struct regulator_bulk_data supplies[6];
	struct aic31xx_disable_nb disable_nb[6];
	struct snd_soc_jack *jack;
	u32 sysclk_id;
	unsigned int sysclk;
	u8 p_div;
	int rate_div_line;
	bool master_dapm_route_applied;
	int irq;
	u8 ocmv;
};

struct aic31xx_rate_divs {
	u32 mclk_p;
	u32 rate;
	u8 pll_r;
	u8 pll_j;
	u16 pll_d;
	u16 dosr;
	u8 ndac;
	u8 mdac;
	u8 aosr;
	u8 nadc;
	u8 madc;
};

struct wm8960_data {
	bool capless;
	bool shared_lrclk;
	u32 hp_cfg[3];
	u32 gpio_cfg[2];
};

struct wm8960_priv {
	struct clk *mclk;
	struct regmap *regmap;
	int (*set_bias_level)(struct snd_soc_component *, enum snd_soc_bias_level);
	struct snd_soc_dapm_widget *lout1;
	struct snd_soc_dapm_widget *rout1;
	struct snd_soc_dapm_widget *out3;
	bool deemph;
	int lrclk;
	int bclk;
	int sysclk;
	int clk_id;
	int freq_in;
	bool is_stream_in_use[2];
	struct wm8960_data pdata;
	int: 32;
	ktime_t dsch_start;
};

struct _pll_div {
	u32 pre_div: 1;
	u32 n: 4;
	u32 k: 24;
};

struct wm8962_pdata {
	struct clk *mclk;
	int gpio_base;
	u32 gpio_init[6];
	u32 mic_cfg;
	bool irq_active_low;
	bool spk_mono;
	bool in4_dc_measure;
};

struct wm8962_priv {
	struct wm8962_pdata pdata;
	struct regmap *regmap;
	struct snd_soc_component *component;
	int sysclk;
	int sysclk_rate;
	int bclk;
	int lrclk;
	struct completion fll_lock;
	int fll_src;
	int fll_fref;
	int fll_fout;
	struct mutex dsp2_ena_lock;
	u16 dsp2_ena;
	struct delayed_work mic_work;
	struct snd_soc_jack *jack;
	struct regulator_bulk_data supplies[8];
	struct notifier_block disable_nb[8];
	struct input_dev *beep;
	struct work_struct beep_work;
	int beep_rate;
	struct gpio_chip gpio_chip;
	int irq;
};

struct _fll_div {
	u16 fll_fratio;
	u16 fll_outdiv;
	u16 fll_refclk_div;
	u16 n;
	u16 theta;
	u16 lambda;
};

struct wm_hubs_data {
	int dcs_codes_l;
	int dcs_codes_r;
	int dcs_readback_mode;
	int hp_startup_mode;
	int series_startup;
	int no_series_update;
	bool micd_scthr;
	bool no_cache_dac_hp_direct;
	struct list_head dcs_cache;
	bool (*check_class_w_digital)(struct snd_soc_component *);
	int micb1_delay;
	int micb2_delay;
	bool lineout1_se;
	bool lineout1n_ena;
	bool lineout1p_ena;
	bool lineout2_se;
	bool lineout2n_ena;
	bool lineout2p_ena;
	bool dcs_done_irq;
	struct completion dcs_done;
	struct snd_soc_component *component;
};

enum {
	WM8994_MCLK1 = 0,
	WM8994_MCLK2 = 1,
	WM8994_NUM_MCLK = 2,
};

enum wm8994_vmid_mode {
	WM8994_VMID_NORMAL = 0,
	WM8994_VMID_FORCE = 1,
};

typedef void (*wm1811_micdet_cb)(void *);

typedef void (*wm1811_mic_id_cb)(void *, u16);

struct wm8994_micdet {
	struct snd_soc_jack *jack;
	bool detecting;
};

struct wm8994_fll_config {
	int src;
	int in;
	int out;
};

struct wm8994_priv {
	struct wm_hubs_data hubs;
	struct wm8994 *wm8994;
	struct clk_bulk_data mclk[2];
	int sysclk[2];
	int sysclk_rate[2];
	int mclk_rate[2];
	int aifclk[2];
	int aifdiv[2];
	int channels[2];
	struct wm8994_fll_config fll[2];
	struct wm8994_fll_config fll_suspend[2];
	struct completion fll_locked[2];
	bool fll_locked_irq;
	bool fll_byp;
	bool clk_has_run;
	int vmid_refcount;
	int active_refcount;
	enum wm8994_vmid_mode vmid_mode;
	int dac_rates[2];
	int lrclk_shared[2];
	int mbc_ena[3];
	int hpf1_ena[3];
	int hpf2_ena[3];
	int vss_ena[3];
	int enh_eq_ena[3];
	const char **drc_texts;
	int drc_cfg[3];
	struct soc_enum drc_enum;
	int num_retune_mobile_texts;
	const char **retune_mobile_texts;
	int retune_mobile_cfg[3];
	struct soc_enum retune_mobile_enum;
	int mbc_cfg;
	const char **mbc_texts;
	struct soc_enum mbc_enum;
	int vss_cfg;
	const char **vss_texts;
	struct soc_enum vss_enum;
	int vss_hpf_cfg;
	const char **vss_hpf_texts;
	struct soc_enum vss_hpf_enum;
	int enh_eq_cfg;
	const char **enh_eq_texts;
	struct soc_enum enh_eq_enum;
	struct mutex accdet_lock;
	struct wm8994_micdet micdet[2];
	struct delayed_work mic_work;
	struct delayed_work open_circuit_work;
	struct delayed_work mic_complete_work;
	u16 mic_status;
	bool mic_detecting;
	bool jack_mic;
	int btn_mask;
	bool jackdet;
	int jackdet_mode;
	struct delayed_work jackdet_bootstrap;
	int micdet_irq;
	wm1811_micdet_cb micd_cb;
	void *micd_cb_data;
	wm1811_mic_id_cb mic_id_cb;
	void *mic_id_cb_data;
	unsigned int aif1clk_enable: 1;
	unsigned int aif2clk_enable: 1;
	unsigned int aif1clk_disable: 1;
	unsigned int aif2clk_disable: 1;
	struct mutex fw_lock;
	int dsp_active;
	const struct firmware *cur_fw;
	const struct firmware *mbc;
	const struct firmware *mbc_vss;
	const struct firmware *enh_eq;
};

struct wm8994_reg_mask {
	unsigned int reg;
	unsigned int mask;
};

struct fll_div {
	u16 outdiv;
	u16 n;
	u16 k;
	u16 lambda;
	u16 clk_ref_div;
	u16 fll_fratio;
};

struct wm_hubs_dcs_cache {
	struct list_head list;
	unsigned int left;
	unsigned int right;
	u16 dcs_cfg;
};

struct rpmsg_head {
	u8 cate;
	u8 major;
	u8 minor;
	u8 type;
	u8 cmd;
	u8 reserved[5];
};

struct param_s {
	unsigned char audioindex;
	unsigned char format;
	unsigned char channels;
	unsigned int rate;
	unsigned int buffer_addr;
	unsigned int buffer_size;
	unsigned int period_size;
	unsigned int buffer_tail;
} __attribute__((packed));

struct param_r {
	unsigned char audioindex;
	unsigned char resp;
	unsigned char reserved1[1];
	unsigned int buffer_offset;
	unsigned int reg_addr;
	unsigned int reg_data;
	unsigned char reserved2[4];
	unsigned int buffer_tail;
} __attribute__((packed));

struct rpmsg_s_msg {
	struct rpmsg_head header;
	struct param_s param;
} __attribute__((packed));

struct rpmsg_r_msg {
	struct rpmsg_head header;
	struct param_r param;
} __attribute__((packed));

struct rpmsg_msg {
	struct rpmsg_s_msg s_msg;
	struct rpmsg_r_msg r_msg;
} __attribute__((packed));

struct rpmsg_info;

struct work_of_rpmsg {
	struct rpmsg_info *info;
	struct rpmsg_msg msg;
	struct work_struct work;
};

typedef void (*dma_callback)(void *);

struct stream_timer {
	struct timer_list timer;
	struct rpmsg_info *info;
	struct snd_pcm_substream *substream;
};

struct rpmsg_info {
	struct rpmsg_device *rpdev;
	struct device *dev;
	struct completion cmd_complete;
	struct pm_qos_request pm_qos_req;
	struct rpmsg_r_msg r_msg;
	struct rpmsg_msg msg[26];
	struct rpmsg_msg notify[2];
	bool notify_updated[2];
	char: 8;
	struct workqueue_struct *rpmsg_wq;
	struct work_of_rpmsg work_list[48];
	int work_write_index;
	int work_read_index;
	int msg_drop_count[2];
	int num_period[2];
	void *callback_param[2];
	dma_callback callback[2];
	int (*send_message)(struct rpmsg_msg *, struct rpmsg_info *);
	spinlock_t lock[2];
	spinlock_t wq_lock;
	struct mutex msg_lock;
	struct stream_timer stream_timer[2];
} __attribute__((packed));

struct rpmsg_codec {
	int audioindex;
	bool capless;
	bool shared_lrclk;
};

struct rpmsg_wm8960_priv {
	struct clk *mclk;
	struct regmap *regmap;
	int (*set_bias_level)(struct snd_soc_component *, enum snd_soc_bias_level);
	struct snd_soc_dapm_widget *lout1;
	struct snd_soc_dapm_widget *rout1;
	struct snd_soc_dapm_widget *out3;
	bool deemph;
	int lrclk;
	int bclk;
	int sysclk;
	int clk_id;
	int freq_in;
	bool is_stream_in_use[2];
	struct wm8960_data pdata;
	struct rpmsg_info *info;
	int audioindex;
};

struct asoc_simple_tdm_width_map {
	u8 sample_bits;
	u8 slot_count;
	u16 slot_width;
};

struct asoc_simple_dai {
	const char *name;
	unsigned int sysclk;
	int clk_direction;
	int slots;
	int slot_width;
	unsigned int tx_slot_mask;
	unsigned int rx_slot_mask;
	struct clk *clk;
	bool clk_fixed;
	struct asoc_simple_tdm_width_map *tdm_width_map;
	int n_tdm_widths;
};

struct asoc_simple_data {
	u32 convert_rate;
	u32 convert_channels;
	const char *convert_sample_format;
};

struct asoc_simple_jack {
	struct snd_soc_jack jack;
	struct snd_soc_jack_pin pin;
	struct snd_soc_jack_gpio gpio;
};

struct prop_nums {
	int cpus;
	int codecs;
	int platforms;
};

struct simple_dai_props {
	struct asoc_simple_dai *cpu_dai;
	struct asoc_simple_dai *codec_dai;
	struct snd_soc_dai_link_component *cpus;
	struct snd_soc_dai_link_component *codecs;
	struct snd_soc_dai_link_component *platforms;
	struct asoc_simple_data adata;
	struct snd_soc_codec_conf *codec_conf;
	struct prop_nums num;
	unsigned int mclk_fs;
};

struct asoc_simple_priv {
	struct snd_soc_card snd_card;
	struct simple_dai_props *dai_props;
	struct asoc_simple_jack hp_jack;
	struct asoc_simple_jack mic_jack;
	struct snd_soc_dai_link *dai_link;
	struct asoc_simple_dai *dais;
	struct snd_soc_dai_link_component *dlcs;
	struct snd_soc_dai_link_component dummy;
	struct snd_soc_codec_conf *codec_conf;
	struct gpio_desc *pa_gpio;
	const struct snd_soc_ops *ops;
	unsigned int dpcm_selectable: 1;
	unsigned int force_dpcm: 1;
};

struct link_info {
	int link;
	int cpu;
	struct prop_nums num[512];
};

struct asoc_simple_card_info {
	const char *name;
	const char *card;
	const char *codec;
	const char *platform;
	unsigned int daifmt;
	struct asoc_simple_dai cpu_dai;
	struct asoc_simple_dai codec_dai;
};

struct fsl_esai_client;

struct fsl_esai_mix {
	struct dma_chan *chan;
	struct snd_pcm_substream *fe_substream[4];
	struct fsl_esai_client *client[4];
	struct snd_dma_buffer dma_buffer;
	struct workqueue_struct *mix_wq;
	struct work_struct work;
	struct snd_pcm_substream *substream;
	dma_cookie_t cookie;
	u32 buffer_read_offset;
	u32 buffer_write_offset;
	u32 buffer_bytes;
	u32 period_bytes;
	u32 period_num;
	u32 word_width;
	u32 channels;
	u32 client_cnt;
	u32 sdo_cnt;
	u32 sdi_cnt;
	atomic_t active;
};

struct fsl_esai_soc_data {
	bool reset_at_xrun;
};

struct fsl_esai {
	struct snd_dmaengine_dai_dma_data dma_params_rx;
	struct snd_dmaengine_dai_dma_data dma_params_tx;
	struct platform_device *pdev;
	struct regmap *regmap;
	struct clk *coreclk;
	struct clk *extalclk;
	struct clk *fsysclk;
	struct clk *spbaclk;
	struct work_struct work;
	const struct fsl_esai_soc_data *soc;
	struct fsl_esai_mix mix[2];
	spinlock_t lock;
	u32 fifo_depth;
	u32 slot_width;
	u32 slots;
	u32 tx_mask;
	u32 rx_mask;
	u32 channels[2];
	u32 hck_rate[2];
	u32 sck_rate[2];
	bool hck_dir[2];
	bool sck_div[2];
	bool consumer_mode[2];
	bool synchronous;
	bool sw_mix;
	char name[32];
};

enum fsl_asoc_card_type {
	CARD_CS42888 = 1,
	CARD_WM8960 = 2,
	CARD_WM8962 = 3,
	CARD_SGTL5000 = 4,
	CARD_AC97 = 5,
	CARD_CS427X = 6,
	CARD_TLV320AIC32X4 = 7,
	CARD_MQS = 8,
	CARD_WM8524 = 9,
	CARD_SI476X = 10,
	CARD_WM8958 = 11,
};

struct codec_priv {
	long unsigned int mclk_freq;
	long unsigned int free_freq;
	u32 mclk_id;
	u32 fll_id;
	u32 pll_id;
};

struct cpu_priv {
	long unsigned int sysclk_freq[2];
	u32 sysclk_dir[2];
	u32 sysclk_id[2];
	u32 slot_width;
};

struct fsl_asoc_card_priv {
	struct snd_soc_dai_link dai_link[3];
	struct asoc_simple_jack hp_jack;
	struct asoc_simple_jack mic_jack;
	struct platform_device *pdev;
	struct codec_priv codec_priv;
	struct cpu_priv cpu_priv;
	struct snd_soc_card card;
	u8 streams;
	u32 sample_rate;
	snd_pcm_format_t sample_format;
	u32 asrc_rate;
	snd_pcm_format_t asrc_format;
	u32 dai_fmt;
	u32 card_type;
	bool is_stream_tdm[2];
	bool is_codec_master;
	bool is_playback_only;
	bool is_capture_only;
	char name[32];
};

enum sdma_peripheral_type {
	IMX_DMATYPE_SSI = 0,
	IMX_DMATYPE_SSI_SP = 1,
	IMX_DMATYPE_MMC = 2,
	IMX_DMATYPE_SDHC = 3,
	IMX_DMATYPE_UART = 4,
	IMX_DMATYPE_UART_SP = 5,
	IMX_DMATYPE_FIRI = 6,
	IMX_DMATYPE_CSPI = 7,
	IMX_DMATYPE_CSPI_SP = 8,
	IMX_DMATYPE_SIM = 9,
	IMX_DMATYPE_ATA = 10,
	IMX_DMATYPE_CCM = 11,
	IMX_DMATYPE_EXT = 12,
	IMX_DMATYPE_MSHC = 13,
	IMX_DMATYPE_MSHC_SP = 14,
	IMX_DMATYPE_DSP = 15,
	IMX_DMATYPE_MEMORY = 16,
	IMX_DMATYPE_FIFO_MEMORY = 17,
	IMX_DMATYPE_SPDIF = 18,
	IMX_DMATYPE_IPU_MEMORY = 19,
	IMX_DMATYPE_ASRC = 20,
	IMX_DMATYPE_ESAI = 21,
	IMX_DMATYPE_SSI_DUAL = 22,
	IMX_DMATYPE_ASRC_SP = 23,
	IMX_DMATYPE_SAI = 24,
	IMX_DMATYPE_MULTI_SAI = 25,
	IMX_DMATYPE_HDMI = 26,
	IMX_DMATYPE_I2C = 27,
};

struct imx_dma_data {
	int dma_request;
	int dma_request2;
	enum sdma_peripheral_type peripheral_type;
	int priority;
};

enum asrc_pair_index {
	ASRC_INVALID_PAIR = 4294967295,
	ASRC_PAIR_A = 0,
	ASRC_PAIR_B = 1,
	ASRC_PAIR_C = 2,
	ASRC_PAIR_D = 3,
};

enum asrc_inclk {
	INCLK_NONE = 3,
	INCLK_ESAI_RX = 0,
	INCLK_SSI1_RX = 1,
	INCLK_SSI2_RX = 2,
	INCLK_SSI3_RX = 7,
	INCLK_SPDIF_RX = 4,
	INCLK_MLB_CLK = 5,
	INCLK_PAD = 6,
	INCLK_ESAI_TX = 8,
	INCLK_SSI1_TX = 9,
	INCLK_SSI2_TX = 10,
	INCLK_SSI3_TX = 11,
	INCLK_SPDIF_TX = 12,
	INCLK_ASRCK1_CLK = 15,
	INCLK_AUD_PLL_DIV_CLK0 = 16,
	INCLK_AUD_PLL_DIV_CLK1 = 17,
	INCLK_AUD_CLK0 = 18,
	INCLK_AUD_CLK1 = 19,
	INCLK_ESAI0_RX_CLK = 20,
	INCLK_ESAI0_TX_CLK = 21,
	INCLK_SPDIF0_RX = 22,
	INCLK_SPDIF1_RX = 23,
	INCLK_SAI0_RX_BCLK = 24,
	INCLK_SAI0_TX_BCLK = 25,
	INCLK_SAI1_RX_BCLK = 26,
	INCLK_SAI1_TX_BCLK = 27,
	INCLK_SAI2_RX_BCLK = 28,
	INCLK_SAI3_RX_BCLK = 29,
	INCLK_ASRC0_MUX_CLK = 30,
	INCLK_ESAI1_RX_CLK = 32,
	INCLK_ESAI1_TX_CLK = 33,
	INCLK_SAI6_TX_BCLK = 34,
	INCLK_HDMI_RX_SAI0_RX_BCLK = 36,
	INCLK_HDMI_TX_SAI0_TX_BCLK = 37,
};

enum asrc_outclk {
	OUTCLK_NONE = 3,
	OUTCLK_ESAI_TX = 0,
	OUTCLK_SSI1_TX = 1,
	OUTCLK_SSI2_TX = 2,
	OUTCLK_SSI3_TX = 7,
	OUTCLK_SPDIF_TX = 4,
	OUTCLK_MLB_CLK = 5,
	OUTCLK_PAD = 6,
	OUTCLK_ESAI_RX = 8,
	OUTCLK_SSI1_RX = 9,
	OUTCLK_SSI2_RX = 10,
	OUTCLK_SSI3_RX = 11,
	OUTCLK_SPDIF_RX = 12,
	OUTCLK_ASRCK1_CLK = 15,
	OUTCLK_AUD_PLL_DIV_CLK0 = 16,
	OUTCLK_AUD_PLL_DIV_CLK1 = 17,
	OUTCLK_AUD_CLK0 = 18,
	OUTCLK_AUD_CLK1 = 19,
	OUTCLK_ESAI0_RX_CLK = 20,
	OUTCLK_ESAI0_TX_CLK = 21,
	OUTCLK_SPDIF0_RX = 22,
	OUTCLK_SPDIF1_RX = 23,
	OUTCLK_SAI0_RX_BCLK = 24,
	OUTCLK_SAI0_TX_BCLK = 25,
	OUTCLK_SAI1_RX_BCLK = 26,
	OUTCLK_SAI1_TX_BCLK = 27,
	OUTCLK_SAI2_RX_BCLK = 28,
	OUTCLK_SAI3_RX_BCLK = 29,
	OUTCLK_ASRCO_MUX_CLK = 30,
	OUTCLK_ESAI1_RX_CLK = 32,
	OUTCLK_ESAI1_TX_CLK = 33,
	OUTCLK_SAI6_TX_BCLK = 34,
	OUTCLK_HDMI_RX_SAI0_RX_BCLK = 36,
	OUTCLK_HDMI_TX_SAI0_TX_BCLK = 37,
};

struct asrc_config {
	enum asrc_pair_index pair;
	unsigned int channel_num;
	unsigned int dma_buffer_size;
	unsigned int input_sample_rate;
	unsigned int output_sample_rate;
	snd_pcm_format_t input_format;
	snd_pcm_format_t output_format;
	enum asrc_inclk inclk;
	enum asrc_outclk outclk;
};

struct asrc_req {
	unsigned int chn_num;
	enum asrc_pair_index index;
	uint64_t supported_in_format;
	uint64_t supported_out_format;
};

struct asrc_convert_buffer {
	void *input_buffer_vaddr;
	void *output_buffer_vaddr;
	unsigned int input_buffer_length;
	unsigned int output_buffer_length;
};

struct asrc_status_flags {
	enum asrc_pair_index index;
	unsigned int overload_error;
};

enum asrc_error_status {
	ASRC_TASK_Q_OVERLOAD = 1,
	ASRC_OUTPUT_TASK_OVERLOAD = 2,
	ASRC_INPUT_TASK_OVERLOAD = 4,
	ASRC_OUTPUT_BUFFER_OVERFLOW = 8,
	ASRC_INPUT_BUFFER_UNDERRUN = 16,
};

struct fsl_asrc;

struct fsl_asrc_pair {
	struct fsl_asrc *asrc;
	unsigned int error;
	enum asrc_pair_index index;
	unsigned int channels;
	struct dma_async_tx_descriptor *desc[2];
	struct dma_chan *dma_chan[2];
	struct imx_dma_data dma_data;
	unsigned int pos;
	bool req_dma_chan;
	void *private;
	void *private_m2m;
};

struct fsl_asrc {
	struct snd_dmaengine_dai_dma_data dma_params_rx;
	struct snd_dmaengine_dai_dma_data dma_params_tx;
	struct platform_device *pdev;
	struct regmap *regmap;
	long unsigned int paddr;
	struct clk *mem_clk;
	struct clk *ipg_clk;
	struct clk *spba_clk;
	spinlock_t lock;
	struct miscdevice asrc_miscdev;
	struct fsl_asrc_pair *pair[4];
	unsigned int channel_avail;
	int asrc_rate;
	snd_pcm_format_t asrc_format;
	bool use_edma;
	struct dma_chan * (*get_dma_channel)(struct fsl_asrc_pair *, bool);
	int (*request_pair)(int, struct fsl_asrc_pair *);
	void (*release_pair)(struct fsl_asrc_pair *);
	int (*get_fifo_addr)(u8, enum asrc_pair_index);
	size_t pair_priv_size;
	void *private;
};

enum asrc_word_width {
	ASRC_WIDTH_24_BIT = 0,
	ASRC_WIDTH_16_BIT = 1,
	ASRC_WIDTH_8_BIT = 2,
};

struct dma_block {
	dma_addr_t dma_paddr;
	void *dma_vaddr;
	unsigned int length;
};

struct fsl_asrc_soc_data {
	bool use_edma;
	unsigned int channel_bits;
};

struct fsl_asrc_pair_priv {
	struct asrc_config *config;
};

struct fsl_asrc_priv {
	struct clk *asrck_clk[16];
	const struct fsl_asrc_soc_data *soc;
	unsigned char *clk_map[2];
	u32 regcache_cfg;
	char name[20];
};

struct fsl_asrc_m2m {
	struct fsl_asrc_pair *pair;
	struct completion complete[2];
	struct dma_block dma_block[2];
	unsigned int pair_hold;
	unsigned int asrc_active;
	unsigned int sg_nodes[2];
	struct scatterlist sg[8];
	snd_pcm_format_t word_format[2];
	unsigned int rate[2];
	unsigned int last_period_size;
	u32 watermark[2];
	spinlock_t lock;
};

struct sdma_peripheral_config {
	int n_fifos_src;
	int n_fifos_dst;
	int stride_fifos_src;
	int stride_fifos_dst;
	int words_per_fifo;
	bool sw_done;
	unsigned int sw_done_sel;
};

struct fsl_sai_soc_data {
	bool use_imx_pcm;
	bool use_edma;
	bool mclk0_is_mclk1;
	bool mclk_with_tere;
	unsigned int fifo_depth;
	unsigned int pins;
	unsigned int reg_offset;
	unsigned int flags;
	unsigned int max_register;
	unsigned int max_burst[2];
};

struct fsl_sai_verid {
	u32 version;
	u32 feature;
};

struct fsl_sai_param {
	u32 slot_num;
	u32 fifo_depth;
	u32 dataline;
};

struct fsl_sai_dl_cfg {
	unsigned int type;
	unsigned int pins[2];
	unsigned int mask[2];
	unsigned int start_off[2];
	unsigned int next_off[2];
};

struct fsl_sai {
	struct platform_device *pdev;
	struct regmap *regmap;
	struct regmap *regmap_gpr;
	struct clk *bus_clk;
	struct clk *mclk_clk[4];
	struct clk *pll8k_clk;
	struct clk *pll11k_clk;
	struct resource *res;
	bool is_consumer_mode[2];
	bool is_lsb_first;
	bool is_dsp_mode;
	bool is_pdm_mode;
	bool is_multi_fifo_dma;
	bool synchronous[2];
	struct fsl_sai_dl_cfg *dl_cfg;
	unsigned int dl_cfg_cnt;
	bool monitor_spdif;
	bool monitor_spdif_start;
	bool mclk_direction_output;
	int gpr_idx;
	unsigned int masterflag[2];
	unsigned int mclk_id[2];
	unsigned int mclk_streams;
	unsigned int slots;
	unsigned int slot_width;
	unsigned int bclk_ratio;
	const struct fsl_sai_soc_data *soc_data;
	struct snd_soc_dai_driver cpu_dai_drv;
	struct snd_dmaengine_dai_dma_data dma_params_rx;
	struct snd_dmaengine_dai_dma_data dma_params_tx;
	struct fsl_sai_verid verid;
	struct fsl_sai_param param;
	struct pm_qos_request pm_qos_req;
	struct pinctrl *pinctrl;
	struct pinctrl_state *pins_state;
	struct sdma_peripheral_config audio_config[2];
	struct snd_pcm_hw_constraint_list constraint_rates;
	unsigned int constraint_rates_list[20];
};

struct fsl_ssi_dbg {
	struct dentry *dbg_dir;
	struct {
		unsigned int rfrc;
		unsigned int tfrc;
		unsigned int cmdau;
		unsigned int cmddu;
		unsigned int rxt;
		unsigned int rdr1;
		unsigned int rdr0;
		unsigned int tde1;
		unsigned int tde0;
		unsigned int roe1;
		unsigned int roe0;
		unsigned int tue1;
		unsigned int tue0;
		unsigned int tfs;
		unsigned int rfs;
		unsigned int tls;
		unsigned int rls;
		unsigned int rff1;
		unsigned int rff0;
		unsigned int tfe1;
		unsigned int tfe0;
	} stats;
};

struct imx_pcm_fiq_params {
	int irq;
	void *base;
	struct snd_dmaengine_dai_dma_data *dma_params_rx;
	struct snd_dmaengine_dai_dma_data *dma_params_tx;
};

struct fsl_ssi_regvals {
	u32 sier;
	u32 srcr;
	u32 stcr;
	u32 scr;
};

struct fsl_ssi_soc_data {
	bool imx;
	bool imx21regs;
	bool offline_config;
	u32 sisr_write_mask;
};

struct fsl_ssi {
	struct regmap *regs;
	int irq;
	struct snd_soc_dai_driver cpu_dai_drv;
	unsigned int dai_fmt;
	u8 streams;
	u8 i2s_net;
	bool synchronous;
	bool use_dma;
	bool use_dual_fifo;
	bool use_dyna_fifo;
	bool has_ipg_clk_name;
	unsigned int fifo_depth;
	unsigned int slot_width;
	unsigned int slots;
	struct fsl_ssi_regvals regvals[2];
	struct clk *clk;
	struct clk *baudclk;
	unsigned int baudclk_streams;
	u32 regcache_sfcsr;
	u32 regcache_sacnt;
	struct snd_dmaengine_dai_dma_data dma_params_tx;
	struct snd_dmaengine_dai_dma_data dma_params_rx;
	dma_addr_t ssi_phys;
	struct imx_pcm_fiq_params fiq_params;
	struct platform_device *card_pdev;
	char card_name[32];
	u32 card_idx;
	struct fsl_ssi_dbg dbg_stats;
	const struct fsl_ssi_soc_data *soc;
	struct device *dev;
	u32 fifo_watermark;
	u32 dma_maxburst;
	struct mutex ac97_reg_lock;
	struct sdma_peripheral_config audio_config[2];
	int: 32;
};

enum spdif_gainsel {
	GAINSEL_MULTI_24 = 0,
	GAINSEL_MULTI_16 = 1,
	GAINSEL_MULTI_12 = 2,
	GAINSEL_MULTI_8 = 3,
	GAINSEL_MULTI_6 = 4,
	GAINSEL_MULTI_4 = 5,
	GAINSEL_MULTI_3 = 6,
};

enum spdif_txrate {
	SPDIF_TXRATE_32000 = 0,
	SPDIF_TXRATE_44100 = 1,
	SPDIF_TXRATE_48000 = 2,
	SPDIF_TXRATE_88200 = 3,
	SPDIF_TXRATE_96000 = 4,
	SPDIF_TXRATE_176400 = 5,
	SPDIF_TXRATE_192000 = 6,
};

struct fsl_spdif_soc_data {
	bool imx;
	bool shared_root_clock;
	bool raw_capture_mode;
	bool cchannel_192b;
	u32 interrupts;
	u32 tx_burst;
	u32 rx_burst;
	u64 tx_formats;
};

struct spdif_mixer_control {
	spinlock_t ctl_lock;
	unsigned char ch_status[4];
	unsigned char subcode[192];
	unsigned char qsub[24];
	u32 upos;
	u32 qpos;
	u32 ready_buf;
};

struct fsl_spdif_priv {
	const struct fsl_spdif_soc_data *soc;
	struct spdif_mixer_control fsl_spdif_control;
	struct snd_soc_dai_driver cpu_dai_drv;
	struct snd_card *snd_card;
	struct snd_kcontrol *rxrate_kcontrol;
	struct platform_device *pdev;
	struct regmap *regmap;
	bool dpll_locked;
	u32 txrate[7];
	u8 txclk_df[7];
	u16 sysclk_df[7];
	u8 txclk_src[7];
	u8 rxclk_src;
	struct clk *txclk[8];
	struct clk *rxclk;
	struct clk *coreclk;
	struct clk *sysclk;
	struct clk *spbaclk;
	struct snd_dmaengine_dai_dma_data dma_params_tx;
	struct snd_dmaengine_dai_dma_data dma_params_rx;
	u32 regcache_srpc;
	bool bypass;
	struct clk *pll8k_clk;
	struct clk *pll11k_clk;
};

struct fsl_esai_client_dma {
	struct snd_dma_buffer dma_buffer;
	int buffer_bytes;
	int period_bytes;
	int period_num;
	int buffer_offset;
	int channels;
	int word_width;
	bool active;
};

struct fsl_esai_client {
	struct snd_soc_dai_driver cpu_dai_drv;
	struct fsl_esai_client_dma dma[2];
	int id;
	int: 32;
};

struct fsl_mqs_soc_data {
	bool use_gpr;
	int ctrl_off;
	int en_mask;
	int en_shift;
	int rst_mask;
	int rst_shift;
	int osr_mask;
	int osr_shift;
	int div_mask;
	int div_shift;
};

struct fsl_mqs {
	struct regmap *regmap;
	struct clk *mclk;
	struct clk *ipg;
	const struct fsl_mqs_soc_data *soc;
	unsigned int reg_mqs_ctrl;
};

struct imx_hdmi {
	struct snd_soc_dai_driver cpu_dai_drv;
	struct platform_device *codec_dev;
	struct platform_device *dma_dev;
	struct platform_device *pdev;
	struct clk *isfr_clk;
	struct clk *iahb_clk;
	struct clk *mipi_core_clk;
};

union hdmi_audio_header_t {
	uint64_t U;
	struct {
		unsigned int consumer: 1;
		unsigned int linear_pcm: 1;
		unsigned int copyright: 1;
		unsigned int pre_emphasis: 3;
		unsigned int mode: 2;
		unsigned int category_code: 8;
		unsigned int source: 4;
		unsigned int channel: 4;
		unsigned int sample_freq: 4;
		unsigned int clock_acc: 2;
		unsigned int reserved0: 2;
		unsigned int word_length: 4;
		unsigned int org_sample_freq: 4;
		unsigned int cgms_a: 2;
		unsigned int reserved1: 6;
		unsigned int reserved2: 8;
		unsigned int reserved3: 8;
	} B;
	unsigned char status[8];
};

enum cea_speaker_placement {
	FL___2 = 1,
	FC___2 = 2,
	FR___2 = 4,
	FLC___2 = 8,
	FRC___2 = 16,
	RL___2 = 32,
	RC___2 = 64,
	RR___2 = 128,
	RLC___2 = 256,
	RRC___2 = 512,
	LFE___2 = 1024,
	FLW = 2048,
	FRW = 4096,
	FLH = 8192,
	FCH = 16384,
	FRH = 32768,
	TC = 65536,
};

struct cea_channel_speaker_allocation {
	int ca_index;
	int speakers[8];
	int channels;
	int spk_mask;
};

struct fsl_aud2htx {
	struct platform_device *pdev;
	struct regmap *regmap;
	struct clk *bus_clk;
	struct snd_dmaengine_dai_dma_data dma_params_rx;
	struct snd_dmaengine_dai_dma_data dma_params_tx;
};

struct fsl_rpmsg_soc_data {
	int rates;
	int: 32;
	u64 formats;
};

struct fsl_rpmsg {
	struct clk *ipg;
	struct clk *mclk;
	struct clk *dma;
	struct clk *pll8k;
	struct clk *pll11k;
	struct platform_device *card_pdev;
	const struct fsl_rpmsg_soc_data *soc_data;
	unsigned int mclk_streams;
	int force_lpa;
	int enable_lpa;
	int buffer_size[2];
};

enum imx_audmux_type {
	IMX21_AUDMUX = 0,
	IMX31_AUDMUX = 1,
};

struct imx_audio_rpmsg {
	struct platform_device *rpmsg_pdev;
};

struct imx_hdmi_sdma_params {
	dma_addr_t phyaddr;
	u32 buffer_num;
	int dma;
};

union hdmi_audio_dma_data_t {
	uint32_t U;
	struct {
		unsigned int data: 24;
		unsigned int v: 1;
		unsigned int u: 1;
		unsigned int c: 1;
		unsigned int p: 1;
		unsigned int b: 1;
		unsigned int reserved: 3;
	} B;
};

struct hdmi_sdma_script {
	int control_reg_addr;
	int status_reg_addr;
	int dma_start_addr;
	u32 buffer[20];
};

struct hdmi_dma_priv {
	struct snd_pcm_substream *substream;
	struct platform_device *pdev;
	struct snd_dma_buffer hw_buffer;
	long unsigned int buffer_bytes;
	long unsigned int appl_bytes;
	int periods;
	int period_time;
	int period_bytes;
	int dma_period_bytes;
	int buffer_ratio;
	long unsigned int offset;
	snd_pcm_format_t format;
	int sample_align;
	int sample_bits;
	int channels;
	int rate;
	int frame_idx;
	bool tx_active;
	spinlock_t irq_lock;
	dma_addr_t phy_hdmi_sdma_t;
	struct hdmi_sdma_script *hdmi_sdma_t;
	struct dma_chan *dma_channel;
	struct dma_async_tx_descriptor *desc;
	struct imx_hdmi_sdma_params sdma_params;
};

struct imx_es8328_data {
	struct device *dev;
	struct snd_soc_dai_link dai;
	struct snd_soc_card card;
	char codec_dai_name[32];
	char platform_name[32];
	int jack_gpio;
};

struct imx_sgtl5000_data {
	struct snd_soc_dai_link dai;
	struct snd_soc_card card;
	char codec_dai_name[32];
	char platform_name[32];
	struct clk *codec_clk;
	unsigned int clk_frequency;
};

struct imx_spdif_data {
	struct snd_soc_dai_link dai;
	struct snd_soc_card card;
	u32 support_rates[10];
	u32 support_rates_num;
};

struct cpu_priv___2 {
	u32 sysclk_id[2];
	u32 slot_width;
};

struct imx_hdmi_data {
	struct snd_soc_dai_link dai;
	struct snd_soc_card card;
	struct snd_soc_jack hdmi_jack;
	struct snd_soc_jack_pin hdmi_jack_pin;
	struct cpu_priv___2 cpu_priv;
	u32 dai_fmt;
};

struct imx_rpmsg {
	struct snd_soc_dai_link dai;
	struct snd_soc_card card;
	long unsigned int sysclk;
	struct asoc_simple_jack hp_jack;
	bool lpa;
};

struct net_device_devres {
	struct net_device *ndev;
};

struct __kernel_old_timespec {
	__kernel_old_time_t tv_sec;
	long int tv_nsec;
};

struct __kernel_sock_timeval {
	__s64 tv_sec;
	__s64 tv_usec;
};

struct mmsghdr {
	struct user_msghdr msg_hdr;
	unsigned int msg_len;
};

struct scm_timestamping_internal {
	struct timespec64 ts[3];
};

struct flowi_tunnel {
	__be64 tun_id;
};

struct flowi_common {
	int flowic_oif;
	int flowic_iif;
	int flowic_l3mdev;
	__u32 flowic_mark;
	__u8 flowic_tos;
	__u8 flowic_scope;
	__u8 flowic_proto;
	__u8 flowic_flags;
	__u32 flowic_secid;
	kuid_t flowic_uid;
	int: 32;
	struct flowi_tunnel flowic_tun_key;
	__u32 flowic_multipath_hash;
	int: 32;
};

union flowi_uli {
	struct {
		__be16 dport;
		__be16 sport;
	} ports;
	struct {
		__u8 type;
		__u8 code;
	} icmpt;
	__be32 gre_key;
	struct {
		__u8 type;
	} mht;
};

struct flowi4 {
	struct flowi_common __fl_common;
	__be32 saddr;
	__be32 daddr;
	union flowi_uli uli;
	int: 32;
};

struct flowi6 {
	struct flowi_common __fl_common;
	struct in6_addr daddr;
	struct in6_addr saddr;
	__be32 flowlabel;
	union flowi_uli uli;
	__u32 mp_hash;
	int: 32;
};

struct flowi {
	union {
		struct flowi_common __fl_common;
		struct flowi4 ip4;
		struct flowi6 ip6;
	} u;
};

struct nf_hook_state;

typedef unsigned int nf_hookfn(void *, struct sk_buff *, const struct nf_hook_state *);

struct nf_hook_entry {
	nf_hookfn *hook;
	void *priv;
};

struct nf_hook_entries {
	u16 num_hook_entries;
	struct nf_hook_entry hooks[0];
};

enum sock_shutdown_cmd {
	SHUT_RD = 0,
	SHUT_WR = 1,
	SHUT_RDWR = 2,
};

struct net_proto_family {
	int family;
	int (*create)(struct net *, struct socket *, int, int);
	struct module *owner;
};

enum {
	SOCK_WAKE_IO = 0,
	SOCK_WAKE_WAITD = 1,
	SOCK_WAKE_SPACE = 2,
	SOCK_WAKE_URG = 3,
};

struct scm_ts_pktinfo {
	__u32 if_index;
	__u32 pkt_length;
	__u32 reserved[2];
};

struct socket_alloc {
	struct socket socket;
	struct inode vfs_inode;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct sock_skb_cb {
	u32 dropcount;
};

typedef u32 compat_caddr_t;

struct compat_ifmap {
	compat_ulong_t mem_start;
	compat_ulong_t mem_end;
	short unsigned int base_addr;
	unsigned char irq;
	unsigned char dma;
	unsigned char port;
};

struct compat_if_settings {
	unsigned int type;
	unsigned int size;
	compat_uptr_t ifs_ifsu;
};

struct compat_ifreq {
	union {
		char ifrn_name[16];
	} ifr_ifrn;
	union {
		struct sockaddr ifru_addr;
		struct sockaddr ifru_dstaddr;
		struct sockaddr ifru_broadaddr;
		struct sockaddr ifru_netmask;
		struct sockaddr ifru_hwaddr;
		short int ifru_flags;
		compat_int_t ifru_ivalue;
		compat_int_t ifru_mtu;
		struct compat_ifmap ifru_map;
		char ifru_slave[16];
		char ifru_newname[16];
		compat_caddr_t ifru_data;
		struct compat_if_settings ifru_settings;
	} ifr_ifru;
};

struct compat_mmsghdr {
	struct compat_msghdr msg_hdr;
	compat_uint_t msg_len;
};

struct ip_options {
	__be32 faddr;
	__be32 nexthop;
	unsigned char optlen;
	unsigned char srr;
	unsigned char rr;
	unsigned char ts;
	unsigned char is_strictroute: 1;
	unsigned char srr_is_hit: 1;
	unsigned char is_changed: 1;
	unsigned char rr_needaddr: 1;
	unsigned char ts_needtime: 1;
	unsigned char ts_needaddr: 1;
	unsigned char router_alert;
	unsigned char cipso;
	unsigned char __pad2;
	unsigned char __data[0];
};

struct ip_options_rcu {
	struct callback_head rcu;
	struct ip_options opt;
};

struct ipv6_opt_hdr;

struct ipv6_rt_hdr;

struct ipv6_txoptions {
	refcount_t refcnt;
	int tot_len;
	__u16 opt_flen;
	__u16 opt_nflen;
	struct ipv6_opt_hdr *hopopt;
	struct ipv6_opt_hdr *dst0opt;
	struct ipv6_rt_hdr *srcrt;
	struct ipv6_opt_hdr *dst1opt;
	struct callback_head rcu;
};

struct inet_cork {
	unsigned int flags;
	__be32 addr;
	struct ip_options *opt;
	unsigned int fragsize;
	int length;
	struct dst_entry *dst;
	u8 tx_flags;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	u64 transmit_time;
	u32 mark;
	int: 32;
};

struct inet_cork_full {
	struct inet_cork base;
	struct flowi fl;
};

struct ipv6_pinfo;

struct ip_mc_socklist;

struct inet_sock {
	struct sock sk;
	struct ipv6_pinfo *pinet6;
	__be32 inet_saddr;
	__s16 uc_ttl;
	__u16 cmsg_flags;
	struct ip_options_rcu *inet_opt;
	__be16 inet_sport;
	__u16 inet_id;
	__u8 tos;
	__u8 min_ttl;
	__u8 mc_ttl;
	__u8 pmtudisc;
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 rcv_tos;
	__u8 convert_csum;
	int uc_index;
	int mc_index;
	__be32 mc_addr;
	struct ip_mc_socklist *mc_list;
	int: 32;
	struct inet_cork_full cork;
};

struct in6_pktinfo {
	struct in6_addr ipi6_addr;
	int ipi6_ifindex;
};

struct inet6_cork {
	struct ipv6_txoptions *opt;
	u8 hop_limit;
	u8 tclass;
};

struct ipv6_mc_socklist;

struct ipv6_ac_socklist;

struct ipv6_fl_socklist;

struct ipv6_pinfo {
	struct in6_addr saddr;
	struct in6_pktinfo sticky_pktinfo;
	const struct in6_addr *daddr_cache;
	__be32 flow_label;
	__u32 frag_size;
	__u16 __unused_1: 7;
	__s16 hop_limit: 9;
	__u16 mc_loop: 1;
	__u16 __unused_2: 6;
	__s16 mcast_hops: 9;
	int ucast_oif;
	int mcast_oif;
	union {
		struct {
			__u16 srcrt: 1;
			__u16 osrcrt: 1;
			__u16 rxinfo: 1;
			__u16 rxoinfo: 1;
			__u16 rxhlim: 1;
			__u16 rxohlim: 1;
			__u16 hopopts: 1;
			__u16 ohopopts: 1;
			__u16 dstopts: 1;
			__u16 odstopts: 1;
			__u16 rxflow: 1;
			__u16 rxtclass: 1;
			__u16 rxpmtu: 1;
			__u16 rxorigdstaddr: 1;
			__u16 recvfragsize: 1;
		} bits;
		__u16 all;
	} rxopt;
	__u16 recverr: 1;
	__u16 sndflow: 1;
	__u16 repflow: 1;
	__u16 pmtudisc: 3;
	__u16 padding: 1;
	__u16 srcprefs: 3;
	__u16 dontfrag: 1;
	__u16 autoflowlabel: 1;
	__u16 autoflowlabel_set: 1;
	__u16 mc_all: 1;
	__u16 recverr_rfc4884: 1;
	__u16 rtalert_isolate: 1;
	__u8 min_hopcount;
	__u8 tclass;
	__be32 rcv_flowinfo;
	__u32 dst_cookie;
	struct ipv6_mc_socklist *ipv6_mc_list;
	struct ipv6_ac_socklist *ipv6_ac_list;
	struct ipv6_fl_socklist *ipv6_fl_list;
	struct ipv6_txoptions *opt;
	struct sk_buff *pktoptions;
	struct sk_buff *rxpmtu;
	struct inet6_cork cork;
};

struct nf_hook_state {
	u8 hook;
	u8 pf;
	struct net_device *in;
	struct net_device *out;
	struct sock *sk;
	struct net *net;
	int (*okfn)(struct net *, struct sock *, struct sk_buff *);
};

struct ipv6_rt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
};

struct ipv6_opt_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
};

struct inet6_skb_parm {
	int iif;
	__be16 ra;
	__u16 dst0;
	__u16 srcrt;
	__u16 dst1;
	__u16 lastopt;
	__u16 nhoff;
	__u16 flags;
	__u16 frag_max_size;
	__u16 srhoff;
};

struct ip6_sf_socklist;

struct ipv6_mc_socklist {
	struct in6_addr addr;
	int ifindex;
	unsigned int sfmode;
	struct ipv6_mc_socklist *next;
	struct ip6_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ipv6_ac_socklist {
	struct in6_addr acl_addr;
	int acl_ifindex;
	struct ipv6_ac_socklist *acl_next;
};

struct ip6_flowlabel;

struct ipv6_fl_socklist {
	struct ipv6_fl_socklist *next;
	struct ip6_flowlabel *fl;
	struct callback_head rcu;
};

struct ip6_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	struct in6_addr sl_addr[0];
};

struct ip6_flowlabel {
	struct ip6_flowlabel *next;
	__be32 label;
	atomic_t users;
	struct in6_addr dst;
	struct ipv6_txoptions *opt;
	long unsigned int linger;
	struct callback_head rcu;
	u8 share;
	union {
		struct pid *pid;
		kuid_t uid;
	} owner;
	long unsigned int lastuse;
	long unsigned int expires;
	struct net *fl_net;
};

struct inet_skb_parm {
	int iif;
	struct ip_options opt;
	u16 flags;
	u16 frag_max_size;
};

struct sock_ee_data_rfc4884 {
	__u16 len;
	__u8 flags;
	__u8 reserved;
};

struct sock_extended_err {
	__u32 ee_errno;
	__u8 ee_origin;
	__u8 ee_type;
	__u8 ee_code;
	__u8 ee_pad;
	__u32 ee_info;
	union {
		__u32 ee_data;
		struct sock_ee_data_rfc4884 ee_rfc4884;
	};
};

struct sock_exterr_skb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	struct sock_extended_err ee;
	u16 addr_offset;
	__be16 port;
	u8 opt_stats: 1;
	u8 unused: 7;
};

struct net_bridge;

struct used_address {
	struct __kernel_sockaddr_storage name;
	unsigned int name_len;
};

struct linger {
	int l_onoff;
	int l_linger;
};

struct cmsghdr {
	__kernel_size_t cmsg_len;
	int cmsg_level;
	int cmsg_type;
};

struct ucred {
	__u32 pid;
	__u32 uid;
	__u32 gid;
};

struct netdev_name_node {
	struct hlist_node hlist;
	struct list_head list;
	struct net_device *dev;
	const char *name;
};

struct sd_flow_limit {
	u64 count;
	unsigned int num_buckets;
	unsigned int history_head;
	u16 history[128];
	u8 buckets[0];
};

struct so_timestamping {
	int flags;
	int bind_phc;
};

enum txtime_flags {
	SOF_TXTIME_DEADLINE_MODE = 1,
	SOF_TXTIME_REPORT_ERRORS = 2,
	SOF_TXTIME_FLAGS_LAST = 2,
	SOF_TXTIME_FLAGS_MASK = 3,
};

struct sock_txtime {
	__kernel_clockid_t clockid;
	__u32 flags;
};

enum sk_pacing {
	SK_PACING_NONE = 0,
	SK_PACING_NEEDED = 1,
	SK_PACING_FQ = 2,
};

struct sockcm_cookie {
	u64 transmit_time;
	u32 mark;
	u16 tsflags;
};

struct fastopen_queue {
	struct request_sock *rskq_rst_head;
	struct request_sock *rskq_rst_tail;
	spinlock_t lock;
	int qlen;
	int max_qlen;
	struct tcp_fastopen_context *ctx;
};

struct request_sock_queue {
	spinlock_t rskq_lock;
	u8 rskq_defer_accept;
	u32 synflood_warned;
	atomic_t qlen;
	atomic_t young;
	struct request_sock *rskq_accept_head;
	struct request_sock *rskq_accept_tail;
	struct fastopen_queue fastopenq;
};

struct minmax_sample {
	u32 t;
	u32 v;
};

struct minmax {
	struct minmax_sample s[3];
};

struct inet_connection_sock_af_ops {
	int (*queue_xmit)(struct sock *, struct sk_buff *, struct flowi *);
	void (*send_check)(struct sock *, struct sk_buff *);
	int (*rebuild_header)(struct sock *);
	void (*sk_rx_dst_set)(struct sock *, const struct sk_buff *);
	int (*conn_request)(struct sock *, struct sk_buff *);
	struct sock * (*syn_recv_sock)(const struct sock *, struct sk_buff *, struct request_sock *, struct dst_entry *, struct request_sock *, bool *);
	u16 net_header_len;
	u16 net_frag_header_len;
	u16 sockaddr_len;
	int (*setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*getsockopt)(struct sock *, int, int, char *, int *);
	void (*addr2sockaddr)(struct sock *, struct sockaddr *);
	void (*mtu_reduced)(struct sock *);
};

struct inet_bind_bucket;

struct inet_bind2_bucket;

struct tcp_ulp_ops;

struct inet_connection_sock {
	struct inet_sock icsk_inet;
	struct request_sock_queue icsk_accept_queue;
	struct inet_bind_bucket *icsk_bind_hash;
	struct inet_bind2_bucket *icsk_bind2_hash;
	long unsigned int icsk_timeout;
	struct timer_list icsk_retransmit_timer;
	struct timer_list icsk_delack_timer;
	__u32 icsk_rto;
	__u32 icsk_rto_min;
	__u32 icsk_delack_max;
	__u32 icsk_pmtu_cookie;
	const struct tcp_congestion_ops *icsk_ca_ops;
	const struct inet_connection_sock_af_ops *icsk_af_ops;
	const struct tcp_ulp_ops *icsk_ulp_ops;
	void *icsk_ulp_data;
	void (*icsk_clean_acked)(struct sock *, u32);
	unsigned int (*icsk_sync_mss)(struct sock *, u32);
	__u8 icsk_ca_state: 5;
	__u8 icsk_ca_initialized: 1;
	__u8 icsk_ca_setsockopt: 1;
	__u8 icsk_ca_dst_locked: 1;
	__u8 icsk_retransmits;
	__u8 icsk_pending;
	__u8 icsk_backoff;
	__u8 icsk_syn_retries;
	__u8 icsk_probes_out;
	__u16 icsk_ext_hdr_len;
	struct {
		__u8 pending;
		__u8 quick;
		__u8 pingpong;
		__u8 retry;
		__u32 ato;
		long unsigned int timeout;
		__u32 lrcvtime;
		__u16 last_seg_size;
		__u16 rcv_mss;
	} icsk_ack;
	struct {
		int search_high;
		int search_low;
		u32 probe_size: 31;
		u32 enabled: 1;
		u32 probe_timestamp;
	} icsk_mtup;
	u32 icsk_probes_tstamp;
	u32 icsk_user_timeout;
	int: 32;
	u64 icsk_ca_priv[13];
};

struct inet_bind_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	signed char fastreuse;
	signed char fastreuseport;
	kuid_t fastuid;
	struct in6_addr fast_v6_rcv_saddr;
	__be32 fast_rcv_saddr;
	short unsigned int fast_sk_family;
	bool fast_ipv6_only;
	struct hlist_node node;
	struct hlist_head owners;
};

struct inet_bind2_bucket {
	possible_net_t ib_net;
	int l3mdev;
	short unsigned int port;
	short unsigned int family;
	union {
		struct in6_addr v6_rcv_saddr;
		__be32 rcv_saddr;
	};
	struct hlist_node node;
	struct hlist_head owners;
};

struct tcp_ulp_ops {
	struct list_head list;
	int (*init)(struct sock *);
	void (*update)(struct sock *, struct proto *, void (*)(struct sock *));
	void (*release)(struct sock *);
	int (*get_info)(const struct sock *, struct sk_buff *);
	size_t (*get_info_size)(const struct sock *);
	void (*clone)(const struct request_sock *, struct sock *, const gfp_t);
	char name[16];
	struct module *owner;
};

struct tcp_fastopen_cookie {
	__le64 val[2];
	s8 len;
	bool exp;
	int: 16;
	int: 32;
};

struct tcp_sack_block {
	u32 start_seq;
	u32 end_seq;
};

struct tcp_options_received {
	int ts_recent_stamp;
	u32 ts_recent;
	u32 rcv_tsval;
	u32 rcv_tsecr;
	u16 saw_tstamp: 1;
	u16 tstamp_ok: 1;
	u16 dsack: 1;
	u16 wscale_ok: 1;
	u16 sack_ok: 3;
	u16 smc_ok: 1;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u8 saw_unknown: 1;
	u8 unused: 7;
	u8 num_sacks;
	u16 user_mss;
	u16 mss_clamp;
};

struct tcp_rack {
	u64 mstamp;
	u32 rtt_us;
	u32 end_seq;
	u32 last_delivered;
	u8 reo_wnd_steps;
	u8 reo_wnd_persist: 5;
	u8 dsack_seen: 1;
	u8 advanced: 1;
};

struct tcp_fastopen_request;

struct tcp_sock {
	struct inet_connection_sock inet_conn;
	u16 tcp_header_len;
	u16 gso_segs;
	__be32 pred_flags;
	u64 bytes_received;
	u32 segs_in;
	u32 data_segs_in;
	u32 rcv_nxt;
	u32 copied_seq;
	u32 rcv_wup;
	u32 snd_nxt;
	u32 segs_out;
	u32 data_segs_out;
	u64 bytes_sent;
	u64 bytes_acked;
	u32 dsack_dups;
	u32 snd_una;
	u32 snd_sml;
	u32 rcv_tstamp;
	u32 lsndtime;
	u32 last_oow_ack_time;
	u32 compressed_ack_rcv_nxt;
	u32 tsoffset;
	struct list_head tsq_node;
	struct list_head tsorted_sent_queue;
	u32 snd_wl1;
	u32 snd_wnd;
	u32 max_window;
	u32 mss_cache;
	u32 window_clamp;
	u32 rcv_ssthresh;
	struct tcp_rack rack;
	u16 advmss;
	u8 compressed_ack;
	u8 dup_ack_counter: 2;
	u8 tlp_retrans: 1;
	u8 unused: 5;
	u32 chrono_start;
	u32 chrono_stat[3];
	u8 chrono_type: 2;
	u8 rate_app_limited: 1;
	u8 fastopen_connect: 1;
	u8 fastopen_no_cookie: 1;
	u8 is_sack_reneg: 1;
	u8 fastopen_client_fail: 2;
	u8 nonagle: 4;
	u8 thin_lto: 1;
	u8 recvmsg_inq: 1;
	u8 repair: 1;
	u8 frto: 1;
	u8 repair_queue;
	u8 save_syn: 2;
	u8 syn_data: 1;
	u8 syn_fastopen: 1;
	u8 syn_fastopen_exp: 1;
	u8 syn_fastopen_ch: 1;
	u8 syn_data_acked: 1;
	u8 is_cwnd_limited: 1;
	u32 tlp_high_seq;
	u32 tcp_tx_delay;
	u64 tcp_wstamp_ns;
	u64 tcp_clock_cache;
	u64 tcp_mstamp;
	u32 srtt_us;
	u32 mdev_us;
	u32 mdev_max_us;
	u32 rttvar_us;
	u32 rtt_seq;
	struct minmax rtt_min;
	u32 packets_out;
	u32 retrans_out;
	u32 max_packets_out;
	u32 cwnd_usage_seq;
	u16 urg_data;
	u8 ecn_flags;
	u8 keepalive_probes;
	u32 reordering;
	u32 reord_seen;
	u32 snd_up;
	struct tcp_options_received rx_opt;
	u32 snd_ssthresh;
	u32 snd_cwnd;
	u32 snd_cwnd_cnt;
	u32 snd_cwnd_clamp;
	u32 snd_cwnd_used;
	u32 snd_cwnd_stamp;
	u32 prior_cwnd;
	u32 prr_delivered;
	u32 prr_out;
	u32 delivered;
	u32 delivered_ce;
	u32 lost;
	u32 app_limited;
	u64 first_tx_mstamp;
	u64 delivered_mstamp;
	u32 rate_delivered;
	u32 rate_interval_us;
	u32 rcv_wnd;
	u32 write_seq;
	u32 notsent_lowat;
	u32 pushed_seq;
	u32 lost_out;
	u32 sacked_out;
	struct hrtimer pacing_timer;
	struct hrtimer compressed_ack_timer;
	struct sk_buff *lost_skb_hint;
	struct sk_buff *retransmit_skb_hint;
	struct rb_root out_of_order_queue;
	struct sk_buff *ooo_last_skb;
	struct tcp_sack_block duplicate_sack[1];
	struct tcp_sack_block selective_acks[4];
	struct tcp_sack_block recv_sack_cache[4];
	struct sk_buff *highest_sack;
	int lost_cnt_hint;
	u32 prior_ssthresh;
	u32 high_seq;
	u32 retrans_stamp;
	u32 undo_marker;
	int undo_retrans;
	int: 32;
	u64 bytes_retrans;
	u32 total_retrans;
	u32 urg_seq;
	unsigned int keepalive_time;
	unsigned int keepalive_intvl;
	int linger2;
	u8 bpf_sock_ops_cb_flags;
	u8 bpf_chg_cc_inprogress: 1;
	u16 timeout_rehash;
	u32 rcv_ooopack;
	u32 rcv_rtt_last_tsecr;
	struct {
		u32 rtt_us;
		u32 seq;
		u64 time;
	} rcv_rtt_est;
	struct {
		u32 space;
		u32 seq;
		u64 time;
	} rcvq_space;
	struct {
		u32 probe_seq_start;
		u32 probe_seq_end;
	} mtu_probe;
	u32 mtu_info;
	struct tcp_fastopen_request *fastopen_req;
	struct request_sock *fastopen_rsk;
	struct saved_syn *saved_syn;
};

struct tcp_fastopen_request {
	struct tcp_fastopen_cookie cookie;
	struct msghdr *data;
	size_t size;
	int copied;
	struct ubuf_info *uarg;
};

struct net_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, u32);
	unsigned int no_policy: 1;
	unsigned int icmp_strict_tag_validation: 1;
};

struct cgroup_cls_state {
	struct cgroup_subsys_state css;
	u32 classid;
	int: 32;
};

enum {
	SK_MEMINFO_RMEM_ALLOC = 0,
	SK_MEMINFO_RCVBUF = 1,
	SK_MEMINFO_WMEM_ALLOC = 2,
	SK_MEMINFO_SNDBUF = 3,
	SK_MEMINFO_FWD_ALLOC = 4,
	SK_MEMINFO_WMEM_QUEUED = 5,
	SK_MEMINFO_OPTMEM = 6,
	SK_MEMINFO_BACKLOG = 7,
	SK_MEMINFO_DROPS = 8,
	SK_MEMINFO_VARS = 9,
};

enum sknetlink_groups {
	SKNLGRP_NONE = 0,
	SKNLGRP_INET_TCP_DESTROY = 1,
	SKNLGRP_INET_UDP_DESTROY = 2,
	SKNLGRP_INET6_TCP_DESTROY = 3,
	SKNLGRP_INET6_UDP_DESTROY = 4,
	__SKNLGRP_MAX = 5,
};

struct inet_request_sock {
	struct request_sock req;
	u16 snd_wscale: 4;
	u16 rcv_wscale: 4;
	u16 tstamp_ok: 1;
	u16 sack_ok: 1;
	u16 wscale_ok: 1;
	u16 ecn_ok: 1;
	u16 acked: 1;
	u16 no_srccheck: 1;
	u16 smc_ok: 1;
	u32 ir_mark;
	union {
		struct ip_options_rcu *ireq_opt;
		struct {
			struct ipv6_txoptions *ipv6_opt;
			struct sk_buff *pktopts;
		};
	};
};

struct tcp_request_sock_ops;

struct tcp_request_sock {
	struct inet_request_sock req;
	const struct tcp_request_sock_ops *af_specific;
	int: 32;
	u64 snt_synack;
	bool tfo_listener;
	bool is_mptcp;
	u32 txhash;
	u32 rcv_isn;
	u32 snt_isn;
	u32 ts_off;
	u32 last_oow_ack_time;
	u32 rcv_nxt;
	u8 syn_tos;
};

enum tcp_synack_type {
	TCP_SYNACK_NORMAL = 0,
	TCP_SYNACK_FASTOPEN = 1,
	TCP_SYNACK_COOKIE = 2,
};

struct tcp_request_sock_ops {
	u16 mss_clamp;
	__u32 (*cookie_init_seq)(const struct sk_buff *, __u16 *);
	struct dst_entry * (*route_req)(const struct sock *, struct sk_buff *, struct flowi *, struct request_sock *);
	u32 (*init_seq)(const struct sk_buff *);
	u32 (*init_ts_off)(const struct net *, const struct sk_buff *);
	int (*send_synack)(const struct sock *, struct dst_entry *, struct flowi *, struct request_sock *, struct tcp_fastopen_cookie *, enum tcp_synack_type, struct sk_buff *);
};

enum {
	XFRM_POLICY_TYPE_MAIN = 0,
	XFRM_POLICY_TYPE_SUB = 1,
	XFRM_POLICY_TYPE_MAX = 2,
	XFRM_POLICY_TYPE_ANY = 255,
};

enum {
	XFRM_MSG_BASE = 16,
	XFRM_MSG_NEWSA = 16,
	XFRM_MSG_DELSA = 17,
	XFRM_MSG_GETSA = 18,
	XFRM_MSG_NEWPOLICY = 19,
	XFRM_MSG_DELPOLICY = 20,
	XFRM_MSG_GETPOLICY = 21,
	XFRM_MSG_ALLOCSPI = 22,
	XFRM_MSG_ACQUIRE = 23,
	XFRM_MSG_EXPIRE = 24,
	XFRM_MSG_UPDPOLICY = 25,
	XFRM_MSG_UPDSA = 26,
	XFRM_MSG_POLEXPIRE = 27,
	XFRM_MSG_FLUSHSA = 28,
	XFRM_MSG_FLUSHPOLICY = 29,
	XFRM_MSG_NEWAE = 30,
	XFRM_MSG_GETAE = 31,
	XFRM_MSG_REPORT = 32,
	XFRM_MSG_MIGRATE = 33,
	XFRM_MSG_NEWSADINFO = 34,
	XFRM_MSG_GETSADINFO = 35,
	XFRM_MSG_NEWSPDINFO = 36,
	XFRM_MSG_GETSPDINFO = 37,
	XFRM_MSG_MAPPING = 38,
	XFRM_MSG_SETDEFAULT = 39,
	XFRM_MSG_GETDEFAULT = 40,
	__XFRM_MSG_MAX = 41,
};

enum xfrm_attr_type_t {
	XFRMA_UNSPEC = 0,
	XFRMA_ALG_AUTH = 1,
	XFRMA_ALG_CRYPT = 2,
	XFRMA_ALG_COMP = 3,
	XFRMA_ENCAP = 4,
	XFRMA_TMPL = 5,
	XFRMA_SA = 6,
	XFRMA_POLICY = 7,
	XFRMA_SEC_CTX = 8,
	XFRMA_LTIME_VAL = 9,
	XFRMA_REPLAY_VAL = 10,
	XFRMA_REPLAY_THRESH = 11,
	XFRMA_ETIMER_THRESH = 12,
	XFRMA_SRCADDR = 13,
	XFRMA_COADDR = 14,
	XFRMA_LASTUSED = 15,
	XFRMA_POLICY_TYPE = 16,
	XFRMA_MIGRATE = 17,
	XFRMA_ALG_AEAD = 18,
	XFRMA_KMADDRESS = 19,
	XFRMA_ALG_AUTH_TRUNC = 20,
	XFRMA_MARK = 21,
	XFRMA_TFCPAD = 22,
	XFRMA_REPLAY_ESN_VAL = 23,
	XFRMA_SA_EXTRA_FLAGS = 24,
	XFRMA_PROTO = 25,
	XFRMA_ADDRESS_FILTER = 26,
	XFRMA_PAD = 27,
	XFRMA_OFFLOAD_DEV = 28,
	XFRMA_SET_MARK = 29,
	XFRMA_SET_MARK_MASK = 30,
	XFRMA_IF_ID = 31,
	XFRMA_MTIMER_THRESH = 32,
	__XFRMA_MAX = 33,
};

struct mmpin {
	struct user_struct *user;
	unsigned int num_pg;
};

struct ubuf_info_msgzc {
	struct ubuf_info ubuf;
	union {
		struct {
			long unsigned int desc;
			void *ctx;
		};
		struct {
			u32 id;
			u16 len;
			u16 zerocopy: 1;
			u32 bytelen;
		};
	};
	struct mmpin mmp;
};

enum {
	SKB_FCLONE_UNAVAILABLE = 0,
	SKB_FCLONE_ORIG = 1,
	SKB_FCLONE_CLONE = 2,
};

struct sk_buff_fclones {
	struct sk_buff skb1;
	struct sk_buff skb2;
	refcount_t fclone_ref;
	int: 32;
};

struct skb_seq_state {
	__u32 lower_offset;
	__u32 upper_offset;
	__u32 frag_idx;
	__u32 stepped_offset;
	struct sk_buff *root_skb;
	struct sk_buff *cur_skb;
	__u8 *frag_data;
	__u32 frag_off;
};

struct skb_checksum_ops {
	__wsum (*update)(const void *, int, __wsum);
	__wsum (*combine)(__wsum, __wsum, int, int);
};

struct skb_gso_cb {
	union {
		int mac_offset;
		int data_offset;
	};
	int encap_level;
	__wsum csum;
	__u16 csum_start;
};

struct qdisc_walker {
	int stop;
	int skip;
	int count;
	int (*fn)(struct Qdisc *, long unsigned int, struct qdisc_walker *);
};

struct ip_auth_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__be16 reserved;
	__be32 spi;
	__be32 seq_no;
	__u8 auth_data[0];
};

struct frag_hdr {
	__u8 nexthdr;
	__u8 reserved;
	__be16 frag_off;
	__be32 identification;
};

enum {
	SCM_TSTAMP_SND = 0,
	SCM_TSTAMP_SCHED = 1,
	SCM_TSTAMP_ACK = 2,
};

struct mpls_shim_hdr {
	__be32 label_stack_entry;
};

struct page_frag_1k {
	void *va;
	u16 offset;
	bool pfmemalloc;
};

struct napi_alloc_cache {
	struct page_frag_cache page;
	struct page_frag_1k page_small;
	unsigned int skb_count;
	void *skb_cache[64];
};

typedef int (*sendmsg_func)(struct sock *, struct msghdr *, struct kvec *, size_t, size_t);

typedef int (*sendpage_func)(struct sock *, struct page *, int, size_t, int);

struct ahash_request;

struct scm_cookie {
	struct pid *pid;
	struct scm_fp_list *fp;
	struct scm_creds creds;
};

struct scm_timestamping {
	struct __kernel_old_timespec ts[3];
};

struct scm_timestamping64 {
	struct __kernel_timespec ts[3];
};

enum {
	TCA_STATS_UNSPEC = 0,
	TCA_STATS_BASIC = 1,
	TCA_STATS_RATE_EST = 2,
	TCA_STATS_QUEUE = 3,
	TCA_STATS_APP = 4,
	TCA_STATS_RATE_EST64 = 5,
	TCA_STATS_PAD = 6,
	TCA_STATS_BASIC_HW = 7,
	TCA_STATS_PKT64 = 8,
	__TCA_STATS_MAX = 9,
};

struct gnet_stats_basic {
	__u64 bytes;
	__u32 packets;
	int: 32;
};

struct gnet_stats_rate_est {
	__u32 bps;
	__u32 pps;
};

struct gnet_stats_rate_est64 {
	__u64 bps;
	__u64 pps;
};

struct gnet_estimator {
	signed char interval;
	unsigned char ewma_log;
};

struct net_rate_estimator {
	struct gnet_stats_basic_sync *bstats;
	spinlock_t *stats_lock;
	bool running;
	struct gnet_stats_basic_sync *cpu_bstats;
	u8 ewma_log;
	u8 intvl_log;
	seqcount_t seq;
	u64 last_packets;
	u64 last_bytes;
	u64 avpps;
	u64 avbps;
	long unsigned int next_jiffies;
	struct timer_list timer;
	struct callback_head rcu;
};

enum {
	RTM_BASE = 16,
	RTM_NEWLINK = 16,
	RTM_DELLINK = 17,
	RTM_GETLINK = 18,
	RTM_SETLINK = 19,
	RTM_NEWADDR = 20,
	RTM_DELADDR = 21,
	RTM_GETADDR = 22,
	RTM_NEWROUTE = 24,
	RTM_DELROUTE = 25,
	RTM_GETROUTE = 26,
	RTM_NEWNEIGH = 28,
	RTM_DELNEIGH = 29,
	RTM_GETNEIGH = 30,
	RTM_NEWRULE = 32,
	RTM_DELRULE = 33,
	RTM_GETRULE = 34,
	RTM_NEWQDISC = 36,
	RTM_DELQDISC = 37,
	RTM_GETQDISC = 38,
	RTM_NEWTCLASS = 40,
	RTM_DELTCLASS = 41,
	RTM_GETTCLASS = 42,
	RTM_NEWTFILTER = 44,
	RTM_DELTFILTER = 45,
	RTM_GETTFILTER = 46,
	RTM_NEWACTION = 48,
	RTM_DELACTION = 49,
	RTM_GETACTION = 50,
	RTM_NEWPREFIX = 52,
	RTM_GETMULTICAST = 58,
	RTM_GETANYCAST = 62,
	RTM_NEWNEIGHTBL = 64,
	RTM_GETNEIGHTBL = 66,
	RTM_SETNEIGHTBL = 67,
	RTM_NEWNDUSEROPT = 68,
	RTM_NEWADDRLABEL = 72,
	RTM_DELADDRLABEL = 73,
	RTM_GETADDRLABEL = 74,
	RTM_GETDCB = 78,
	RTM_SETDCB = 79,
	RTM_NEWNETCONF = 80,
	RTM_DELNETCONF = 81,
	RTM_GETNETCONF = 82,
	RTM_NEWMDB = 84,
	RTM_DELMDB = 85,
	RTM_GETMDB = 86,
	RTM_NEWNSID = 88,
	RTM_DELNSID = 89,
	RTM_GETNSID = 90,
	RTM_NEWSTATS = 92,
	RTM_GETSTATS = 94,
	RTM_SETSTATS = 95,
	RTM_NEWCACHEREPORT = 96,
	RTM_NEWCHAIN = 100,
	RTM_DELCHAIN = 101,
	RTM_GETCHAIN = 102,
	RTM_NEWNEXTHOP = 104,
	RTM_DELNEXTHOP = 105,
	RTM_GETNEXTHOP = 106,
	RTM_NEWLINKPROP = 108,
	RTM_DELLINKPROP = 109,
	RTM_GETLINKPROP = 110,
	RTM_NEWVLAN = 112,
	RTM_DELVLAN = 113,
	RTM_GETVLAN = 114,
	RTM_NEWNEXTHOPBUCKET = 116,
	RTM_DELNEXTHOPBUCKET = 117,
	RTM_GETNEXTHOPBUCKET = 118,
	RTM_NEWTUNNEL = 120,
	RTM_DELTUNNEL = 121,
	RTM_GETTUNNEL = 122,
	__RTM_MAX = 123,
};

struct rtgenmsg {
	unsigned char rtgen_family;
};

enum rtnetlink_groups {
	RTNLGRP_NONE = 0,
	RTNLGRP_LINK = 1,
	RTNLGRP_NOTIFY = 2,
	RTNLGRP_NEIGH = 3,
	RTNLGRP_TC = 4,
	RTNLGRP_IPV4_IFADDR = 5,
	RTNLGRP_IPV4_MROUTE = 6,
	RTNLGRP_IPV4_ROUTE = 7,
	RTNLGRP_IPV4_RULE = 8,
	RTNLGRP_IPV6_IFADDR = 9,
	RTNLGRP_IPV6_MROUTE = 10,
	RTNLGRP_IPV6_ROUTE = 11,
	RTNLGRP_IPV6_IFINFO = 12,
	RTNLGRP_DECnet_IFADDR = 13,
	RTNLGRP_NOP2 = 14,
	RTNLGRP_DECnet_ROUTE = 15,
	RTNLGRP_DECnet_RULE = 16,
	RTNLGRP_NOP4 = 17,
	RTNLGRP_IPV6_PREFIX = 18,
	RTNLGRP_IPV6_RULE = 19,
	RTNLGRP_ND_USEROPT = 20,
	RTNLGRP_PHONET_IFADDR = 21,
	RTNLGRP_PHONET_ROUTE = 22,
	RTNLGRP_DCB = 23,
	RTNLGRP_IPV4_NETCONF = 24,
	RTNLGRP_IPV6_NETCONF = 25,
	RTNLGRP_MDB = 26,
	RTNLGRP_MPLS_ROUTE = 27,
	RTNLGRP_NSID = 28,
	RTNLGRP_MPLS_NETCONF = 29,
	RTNLGRP_IPV4_MROUTE_R = 30,
	RTNLGRP_IPV6_MROUTE_R = 31,
	RTNLGRP_NEXTHOP = 32,
	RTNLGRP_BRVLAN = 33,
	RTNLGRP_MCTP_IFADDR = 34,
	RTNLGRP_TUNNEL = 35,
	RTNLGRP_STATS = 36,
	__RTNLGRP_MAX = 37,
};

enum {
	NETNSA_NONE = 0,
	NETNSA_NSID = 1,
	NETNSA_PID = 2,
	NETNSA_FD = 3,
	NETNSA_TARGET_NSID = 4,
	NETNSA_CURRENT_NSID = 5,
	__NETNSA_MAX = 6,
};

struct pcpu_gen_cookie {
	local_t nesting;
	int: 32;
	u64 last;
};

struct gen_cookie {
	struct pcpu_gen_cookie *local;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic64_t forward_last;
	atomic64_t reverse_last;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

enum rtnl_link_flags {
	RTNL_FLAG_DOIT_UNLOCKED = 1,
	RTNL_FLAG_BULK_DEL_SUPPORTED = 2,
};

struct net_fill_args {
	u32 portid;
	u32 seq;
	int flags;
	int cmd;
	int nsid;
	bool add_ref;
	int ref_nsid;
};

struct rtnl_net_dump_cb {
	struct net *tgt_net;
	struct net *ref_net;
	struct sk_buff *skb;
	struct net_fill_args fillargs;
	int idx;
	int s_idx;
};

typedef u16 u_int16_t;

enum flow_dissect_ret {
	FLOW_DISSECT_RET_OUT_GOOD = 0,
	FLOW_DISSECT_RET_OUT_BAD = 1,
	FLOW_DISSECT_RET_PROTO_AGAIN = 2,
	FLOW_DISSECT_RET_IPPROTO_AGAIN = 3,
	FLOW_DISSECT_RET_CONTINUE = 4,
};

struct flow_dissector_key_tags {
	u32 flow_label;
};

struct flow_dissector_key_vlan {
	union {
		struct {
			u16 vlan_id: 12;
			u16 vlan_dei: 1;
			u16 vlan_priority: 3;
		};
		__be16 vlan_tci;
	};
	__be16 vlan_tpid;
	__be16 vlan_eth_type;
	u16 padding;
};

struct flow_dissector_mpls_lse {
	u32 mpls_ttl: 8;
	u32 mpls_bos: 1;
	u32 mpls_tc: 3;
	u32 mpls_label: 20;
};

struct flow_dissector_key_mpls {
	struct flow_dissector_mpls_lse ls[7];
	u8 used_lses;
};

struct flow_dissector_key_enc_opts {
	u8 data[255];
	u8 len;
	__be16 dst_opt_type;
};

struct flow_dissector_key_keyid {
	__be32 keyid;
};

struct flow_dissector_key_ipv4_addrs {
	__be32 src;
	__be32 dst;
};

struct flow_dissector_key_ipv6_addrs {
	struct in6_addr src;
	struct in6_addr dst;
};

struct flow_dissector_key_tipc {
	__be32 key;
};

struct flow_dissector_key_addrs {
	union {
		struct flow_dissector_key_ipv4_addrs v4addrs;
		struct flow_dissector_key_ipv6_addrs v6addrs;
		struct flow_dissector_key_tipc tipckey;
	};
};

struct flow_dissector_key_arp {
	__u32 sip;
	__u32 tip;
	__u8 op;
	unsigned char sha[6];
	unsigned char tha[6];
};

struct flow_dissector_key_ports {
	union {
		__be32 ports;
		struct {
			__be16 src;
			__be16 dst;
		};
	};
};

struct flow_dissector_key_icmp {
	struct {
		u8 type;
		u8 code;
	};
	u16 id;
};

struct flow_dissector_key_eth_addrs {
	unsigned char dst[6];
	unsigned char src[6];
};

struct flow_dissector_key_tcp {
	__be16 flags;
};

struct flow_dissector_key_ip {
	__u8 tos;
	__u8 ttl;
};

struct flow_dissector_key_meta {
	int ingress_ifindex;
	u16 ingress_iftype;
};

struct flow_dissector_key_ct {
	u16 ct_state;
	u16 ct_zone;
	u32 ct_mark;
	u32 ct_labels[4];
};

struct flow_dissector_key_hash {
	u32 hash;
};

struct flow_dissector_key_num_of_vlans {
	u8 num_of_vlans;
};

struct flow_dissector_key_pppoe {
	__be16 session_id;
	__be16 ppp_proto;
	__be16 type;
};

struct flow_dissector_key_l2tpv3 {
	__be32 session_id;
};

struct flow_dissector_key {
	enum flow_dissector_key_id key_id;
	size_t offset;
};

struct flow_keys {
	struct flow_dissector_key_control control;
	struct flow_dissector_key_basic basic;
	struct flow_dissector_key_tags tags;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_vlan cvlan;
	struct flow_dissector_key_keyid keyid;
	struct flow_dissector_key_ports ports;
	struct flow_dissector_key_icmp icmp;
	struct flow_dissector_key_addrs addrs;
	int: 32;
};

struct flow_keys_digest {
	u8 data[16];
};

enum ip_conntrack_info {
	IP_CT_ESTABLISHED = 0,
	IP_CT_RELATED = 1,
	IP_CT_NEW = 2,
	IP_CT_IS_REPLY = 3,
	IP_CT_ESTABLISHED_REPLY = 3,
	IP_CT_RELATED_REPLY = 4,
	IP_CT_NUMBER = 5,
	IP_CT_UNTRACKED = 7,
};

union nf_inet_addr {
	__u32 all[4];
	__be32 ip;
	__be32 ip6[4];
	struct in_addr in;
	struct in6_addr in6;
};

struct ip_ct_tcp_state {
	u_int32_t td_end;
	u_int32_t td_maxend;
	u_int32_t td_maxwin;
	u_int32_t td_maxack;
	u_int8_t td_scale;
	u_int8_t flags;
};

struct ip_ct_tcp {
	struct ip_ct_tcp_state seen[2];
	u_int8_t state;
	u_int8_t last_dir;
	u_int8_t retrans;
	u_int8_t last_index;
	u_int32_t last_seq;
	u_int32_t last_ack;
	u_int32_t last_end;
	u_int16_t last_win;
	u_int8_t last_wscale;
	u_int8_t last_flags;
};

union nf_conntrack_man_proto {
	__be16 all;
	struct {
		__be16 port;
	} tcp;
	struct {
		__be16 port;
	} udp;
	struct {
		__be16 id;
	} icmp;
	struct {
		__be16 port;
	} dccp;
	struct {
		__be16 port;
	} sctp;
	struct {
		__be16 key;
	} gre;
};

struct nf_ct_dccp {
	u_int8_t role[2];
	u_int8_t state;
	u_int8_t last_pkt;
	u_int8_t last_dir;
	u_int64_t handshake_seq;
};

struct ip_ct_sctp {
	enum sctp_conntrack state;
	__be32 vtag[2];
	u8 last_dir;
	u8 flags;
};

struct nf_ct_event;

struct nf_exp_event;

struct nf_ct_event_notifier {
	int (*ct_event)(unsigned int, const struct nf_ct_event *);
	int (*exp_event)(unsigned int, const struct nf_exp_event *);
};

enum {
	TCA_FLOWER_KEY_CT_FLAGS_NEW = 1,
	TCA_FLOWER_KEY_CT_FLAGS_ESTABLISHED = 2,
	TCA_FLOWER_KEY_CT_FLAGS_RELATED = 4,
	TCA_FLOWER_KEY_CT_FLAGS_TRACKED = 8,
	TCA_FLOWER_KEY_CT_FLAGS_INVALID = 16,
	TCA_FLOWER_KEY_CT_FLAGS_REPLY = 32,
	__TCA_FLOWER_KEY_CT_FLAGS_MAX = 33,
};

enum devlink_port_type {
	DEVLINK_PORT_TYPE_NOTSET = 0,
	DEVLINK_PORT_TYPE_AUTO = 1,
	DEVLINK_PORT_TYPE_ETH = 2,
	DEVLINK_PORT_TYPE_IB = 3,
};

enum devlink_port_flavour {
	DEVLINK_PORT_FLAVOUR_PHYSICAL = 0,
	DEVLINK_PORT_FLAVOUR_CPU = 1,
	DEVLINK_PORT_FLAVOUR_DSA = 2,
	DEVLINK_PORT_FLAVOUR_PCI_PF = 3,
	DEVLINK_PORT_FLAVOUR_PCI_VF = 4,
	DEVLINK_PORT_FLAVOUR_VIRTUAL = 5,
	DEVLINK_PORT_FLAVOUR_UNUSED = 6,
	DEVLINK_PORT_FLAVOUR_PCI_SF = 7,
};

struct devlink_port_phys_attrs {
	u32 port_number;
	u32 split_subport_number;
};

struct devlink_port_pci_pf_attrs {
	u32 controller;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_pci_vf_attrs {
	u32 controller;
	u16 pf;
	u16 vf;
	u8 external: 1;
};

struct devlink_port_pci_sf_attrs {
	u32 controller;
	u32 sf;
	u16 pf;
	u8 external: 1;
};

struct devlink_port_attrs {
	u8 split: 1;
	u8 splittable: 1;
	u32 lanes;
	enum devlink_port_flavour flavour;
	struct netdev_phys_item_id switch_id;
	union {
		struct devlink_port_phys_attrs phys;
		struct devlink_port_pci_pf_attrs pci_pf;
		struct devlink_port_pci_vf_attrs pci_vf;
		struct devlink_port_pci_sf_attrs pci_sf;
	};
};

struct devlink;

struct devlink_rate;

struct devlink_linecard;

struct devlink_port {
	struct list_head list;
	struct list_head region_list;
	struct devlink *devlink;
	unsigned int index;
	spinlock_t type_lock;
	enum devlink_port_type type;
	enum devlink_port_type desired_type;
	void *type_dev;
	struct devlink_port_attrs attrs;
	u8 attrs_set: 1;
	u8 switch_port: 1;
	u8 registered: 1;
	u8 initialized: 1;
	struct delayed_work type_warn_dw;
	struct list_head reporter_list;
	struct mutex reporters_lock;
	struct devlink_rate *devlink_rate;
	struct devlink_linecard *linecard;
};

struct dsa_device_ops;

struct dsa_switch_tree;

struct dsa_switch;

struct dsa_bridge;

struct dsa_lag;

struct dsa_netdevice_ops;

struct dsa_port {
	union {
		struct net_device *master;
		struct net_device *slave;
	};
	const struct dsa_device_ops *tag_ops;
	struct dsa_switch_tree *dst;
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *);
	struct dsa_switch *ds;
	unsigned int index;
	enum {
		DSA_PORT_TYPE_UNUSED = 0,
		DSA_PORT_TYPE_CPU = 1,
		DSA_PORT_TYPE_DSA = 2,
		DSA_PORT_TYPE_USER = 3,
	} type;
	const char *name;
	struct dsa_port *cpu_dp;
	u8 mac[6];
	u8 stp_state;
	u8 vlan_filtering: 1;
	u8 learning: 1;
	u8 lag_tx_enabled: 1;
	u8 master_admin_up: 1;
	u8 master_oper_up: 1;
	u8 cpu_port_in_lag: 1;
	u8 setup: 1;
	struct device_node *dn;
	unsigned int ageing_time;
	struct dsa_bridge *bridge;
	struct devlink_port devlink_port;
	struct phylink *pl;
	struct phylink_config pl_config;
	struct dsa_lag *lag;
	struct net_device *hsr_dev;
	struct list_head list;
	const struct ethtool_ops *orig_ethtool_ops;
	const struct dsa_netdevice_ops *netdev_ops;
	struct mutex addr_lists_lock;
	struct list_head fdbs;
	struct list_head mdbs;
	struct mutex vlans_lock;
	struct list_head vlans;
};

enum netdev_lag_tx_type {
	NETDEV_LAG_TX_TYPE_UNKNOWN = 0,
	NETDEV_LAG_TX_TYPE_RANDOM = 1,
	NETDEV_LAG_TX_TYPE_BROADCAST = 2,
	NETDEV_LAG_TX_TYPE_ROUNDROBIN = 3,
	NETDEV_LAG_TX_TYPE_ACTIVEBACKUP = 4,
	NETDEV_LAG_TX_TYPE_HASH = 5,
};

enum netdev_lag_hash {
	NETDEV_LAG_HASH_NONE = 0,
	NETDEV_LAG_HASH_L2 = 1,
	NETDEV_LAG_HASH_L34 = 2,
	NETDEV_LAG_HASH_L23 = 3,
	NETDEV_LAG_HASH_E23 = 4,
	NETDEV_LAG_HASH_E34 = 5,
	NETDEV_LAG_HASH_VLAN_SRCMAC = 6,
	NETDEV_LAG_HASH_UNKNOWN = 7,
};

struct netdev_lag_upper_info {
	enum netdev_lag_tx_type tx_type;
	enum netdev_lag_hash hash_type;
};

struct netdev_notifier_changeupper_info {
	struct netdev_notifier_info info;
	struct net_device *upper_dev;
	bool master;
	bool linking;
	void *upper_info;
};

union tcp_word_hdr {
	struct tcphdr hdr;
	__be32 words[5];
};

enum bpf_ret_code {
	BPF_OK = 0,
	BPF_DROP = 2,
	BPF_REDIRECT = 7,
	BPF_LWT_REROUTE = 128,
	BPF_FLOW_DISSECTOR_CONTINUE = 129,
};

enum {
	BPF_FLOW_DISSECTOR_F_PARSE_1ST_FRAG = 1,
	BPF_FLOW_DISSECTOR_F_STOP_AT_FLOW_LABEL = 2,
	BPF_FLOW_DISSECTOR_F_STOP_AT_ENCAP = 4,
};

struct flow_match {
	struct flow_dissector *dissector;
	void *mask;
	void *key;
};

enum flow_action_id {
	FLOW_ACTION_ACCEPT = 0,
	FLOW_ACTION_DROP = 1,
	FLOW_ACTION_TRAP = 2,
	FLOW_ACTION_GOTO = 3,
	FLOW_ACTION_REDIRECT = 4,
	FLOW_ACTION_MIRRED = 5,
	FLOW_ACTION_REDIRECT_INGRESS = 6,
	FLOW_ACTION_MIRRED_INGRESS = 7,
	FLOW_ACTION_VLAN_PUSH = 8,
	FLOW_ACTION_VLAN_POP = 9,
	FLOW_ACTION_VLAN_MANGLE = 10,
	FLOW_ACTION_TUNNEL_ENCAP = 11,
	FLOW_ACTION_TUNNEL_DECAP = 12,
	FLOW_ACTION_MANGLE = 13,
	FLOW_ACTION_ADD = 14,
	FLOW_ACTION_CSUM = 15,
	FLOW_ACTION_MARK = 16,
	FLOW_ACTION_PTYPE = 17,
	FLOW_ACTION_PRIORITY = 18,
	FLOW_ACTION_WAKE = 19,
	FLOW_ACTION_QUEUE = 20,
	FLOW_ACTION_SAMPLE = 21,
	FLOW_ACTION_POLICE = 22,
	FLOW_ACTION_CT = 23,
	FLOW_ACTION_CT_METADATA = 24,
	FLOW_ACTION_MPLS_PUSH = 25,
	FLOW_ACTION_MPLS_POP = 26,
	FLOW_ACTION_MPLS_MANGLE = 27,
	FLOW_ACTION_GATE = 28,
	FLOW_ACTION_PPPOE_PUSH = 29,
	FLOW_ACTION_JUMP = 30,
	FLOW_ACTION_PIPE = 31,
	FLOW_ACTION_VLAN_PUSH_ETH = 32,
	FLOW_ACTION_VLAN_POP_ETH = 33,
	FLOW_ACTION_CONTINUE = 34,
	NUM_FLOW_ACTIONS = 35,
};

enum flow_action_mangle_base {
	FLOW_ACT_MANGLE_UNSPEC = 0,
	FLOW_ACT_MANGLE_HDR_TYPE_ETH = 1,
	FLOW_ACT_MANGLE_HDR_TYPE_IP4 = 2,
	FLOW_ACT_MANGLE_HDR_TYPE_IP6 = 3,
	FLOW_ACT_MANGLE_HDR_TYPE_TCP = 4,
	FLOW_ACT_MANGLE_HDR_TYPE_UDP = 5,
};

enum flow_action_hw_stats {
	FLOW_ACTION_HW_STATS_IMMEDIATE = 1,
	FLOW_ACTION_HW_STATS_DELAYED = 2,
	FLOW_ACTION_HW_STATS_ANY = 3,
	FLOW_ACTION_HW_STATS_DISABLED = 4,
	FLOW_ACTION_HW_STATS_DONT_CARE = 7,
};

typedef void (*action_destr)(void *);

struct flow_action_cookie {
	u32 cookie_len;
	u8 cookie[0];
};

struct nf_flowtable;

struct ip_tunnel_key {
	__be64 tun_id;
	union {
		struct {
			__be32 src;
			__be32 dst;
		} ipv4;
		struct {
			struct in6_addr src;
			struct in6_addr dst;
		} ipv6;
	} u;
	__be16 tun_flags;
	u8 tos;
	u8 ttl;
	__be32 label;
	__be16 tp_src;
	__be16 tp_dst;
	__u8 flow_flags;
};

struct dst_cache_pcpu;

struct dst_cache {
	struct dst_cache_pcpu *cache;
	long unsigned int reset_ts;
};

struct ip_tunnel_info {
	struct ip_tunnel_key key;
	struct dst_cache dst_cache;
	u8 options_len;
	u8 mode;
	int: 16;
	int: 32;
};

struct psample_group;

struct action_gate_entry;

struct flow_action_entry {
	enum flow_action_id id;
	u32 hw_index;
	enum flow_action_hw_stats hw_stats;
	action_destr destructor;
	void *destructor_priv;
	int: 32;
	union {
		u32 chain_index;
		struct net_device *dev;
		struct {
			u16 vid;
			__be16 proto;
			u8 prio;
		} vlan;
		struct {
			unsigned char dst[6];
			unsigned char src[6];
		} vlan_push_eth;
		struct {
			enum flow_action_mangle_base htype;
			u32 offset;
			u32 mask;
			u32 val;
		} mangle;
		struct ip_tunnel_info *tunnel;
		u32 csum_flags;
		u32 mark;
		u16 ptype;
		u32 priority;
		struct {
			u32 ctx;
			u32 index;
			u8 vf;
		} queue;
		struct {
			struct psample_group *psample_group;
			u32 rate;
			u32 trunc_size;
			bool truncate;
		} sample;
		struct {
			u32 burst;
			int: 32;
			u64 rate_bytes_ps;
			u64 peakrate_bytes_ps;
			u32 avrate;
			u16 overhead;
			u64 burst_pkt;
			u64 rate_pkt_ps;
			u32 mtu;
			struct {
				enum flow_action_id act_id;
				u32 extval;
			} exceed;
			struct {
				enum flow_action_id act_id;
				u32 extval;
			} notexceed;
			int: 32;
		} police;
		struct {
			int action;
			u16 zone;
			struct nf_flowtable *flow_table;
		} ct;
		struct {
			long unsigned int cookie;
			u32 mark;
			u32 labels[4];
			bool orig_dir;
		} ct_metadata;
		struct {
			u32 label;
			__be16 proto;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_push;
		struct {
			__be16 proto;
		} mpls_pop;
		struct {
			u32 label;
			u8 tc;
			u8 bos;
			u8 ttl;
		} mpls_mangle;
		struct {
			s32 prio;
			int: 32;
			u64 basetime;
			u64 cycletime;
			u64 cycletimeext;
			u32 num_entries;
			struct action_gate_entry *entries;
		} gate;
		struct {
			u16 sid;
		} pppoe;
	};
	struct flow_action_cookie *cookie;
	int: 32;
};

struct flow_action {
	unsigned int num_entries;
	int: 32;
	struct flow_action_entry entries[0];
};

struct flow_rule {
	struct flow_match match;
	int: 32;
	struct flow_action action;
};

struct flow_stats {
	u64 pkts;
	u64 bytes;
	u64 drops;
	u64 lastused;
	enum flow_action_hw_stats used_hw_stats;
	bool used_hw_stats_valid;
};

enum flow_cls_command {
	FLOW_CLS_REPLACE = 0,
	FLOW_CLS_DESTROY = 1,
	FLOW_CLS_STATS = 2,
	FLOW_CLS_TMPLT_CREATE = 3,
	FLOW_CLS_TMPLT_DESTROY = 4,
};

struct flow_cls_common_offload {
	u32 chain_index;
	__be16 protocol;
	u32 prio;
	struct netlink_ext_ack *extack;
};

struct flow_cls_offload {
	struct flow_cls_common_offload common;
	enum flow_cls_command command;
	long unsigned int cookie;
	struct flow_rule *rule;
	int: 32;
	struct flow_stats stats;
	u32 classid;
	int: 32;
};

struct dsa_chip_data {
	struct device *host_dev;
	int sw_addr;
	struct device *netdev[12];
	int eeprom_len;
	struct device_node *of_node;
	char *port_names[12];
	struct device_node *port_dn[12];
	s8 rtable[4];
};

struct dsa_platform_data {
	struct device *netdev;
	struct net_device *of_netdev;
	int nr_chips;
	struct dsa_chip_data *chip;
};

enum devlink_sb_pool_type {
	DEVLINK_SB_POOL_TYPE_INGRESS = 0,
	DEVLINK_SB_POOL_TYPE_EGRESS = 1,
};

enum devlink_sb_threshold_type {
	DEVLINK_SB_THRESHOLD_TYPE_STATIC = 0,
	DEVLINK_SB_THRESHOLD_TYPE_DYNAMIC = 1,
};

enum devlink_rate_type {
	DEVLINK_RATE_TYPE_LEAF = 0,
	DEVLINK_RATE_TYPE_NODE = 1,
};

enum devlink_param_cmode {
	DEVLINK_PARAM_CMODE_RUNTIME = 0,
	DEVLINK_PARAM_CMODE_DRIVERINIT = 1,
	DEVLINK_PARAM_CMODE_PERMANENT = 2,
	__DEVLINK_PARAM_CMODE_MAX = 3,
	DEVLINK_PARAM_CMODE_MAX = 2,
};

struct devlink_rate {
	struct list_head list;
	enum devlink_rate_type type;
	struct devlink *devlink;
	void *priv;
	int: 32;
	u64 tx_share;
	u64 tx_max;
	struct devlink_rate *parent;
	union {
		struct devlink_port *devlink_port;
		struct {
			char *name;
			refcount_t refcnt;
		};
	};
	int: 32;
};

struct devlink_sb_pool_info {
	enum devlink_sb_pool_type pool_type;
	u32 size;
	enum devlink_sb_threshold_type threshold_type;
	u32 cell_size;
};

union devlink_param_value {
	u8 vu8;
	u16 vu16;
	u32 vu32;
	char vstr[32];
	bool vbool;
};

struct devlink_param_gset_ctx {
	union devlink_param_value val;
	enum devlink_param_cmode cmode;
};

struct devlink_info_req;

struct switchdev_mst_state {
	u16 msti;
	u8 state;
};

struct switchdev_brport_flags {
	long unsigned int val;
	long unsigned int mask;
};

struct switchdev_vlan_msti {
	u16 vid;
	u16 msti;
};

enum switchdev_obj_id {
	SWITCHDEV_OBJ_ID_UNDEFINED = 0,
	SWITCHDEV_OBJ_ID_PORT_VLAN = 1,
	SWITCHDEV_OBJ_ID_PORT_MDB = 2,
	SWITCHDEV_OBJ_ID_HOST_MDB = 3,
	SWITCHDEV_OBJ_ID_MRP = 4,
	SWITCHDEV_OBJ_ID_RING_TEST_MRP = 5,
	SWITCHDEV_OBJ_ID_RING_ROLE_MRP = 6,
	SWITCHDEV_OBJ_ID_RING_STATE_MRP = 7,
	SWITCHDEV_OBJ_ID_IN_TEST_MRP = 8,
	SWITCHDEV_OBJ_ID_IN_ROLE_MRP = 9,
	SWITCHDEV_OBJ_ID_IN_STATE_MRP = 10,
};

struct switchdev_obj {
	struct list_head list;
	struct net_device *orig_dev;
	enum switchdev_obj_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
};

struct switchdev_obj_port_vlan {
	struct switchdev_obj obj;
	u16 flags;
	u16 vid;
	bool changed;
};

struct switchdev_obj_port_mdb {
	struct switchdev_obj obj;
	unsigned char addr[6];
	u16 vid;
};

struct switchdev_obj_mrp {
	struct switchdev_obj obj;
	struct net_device *p_port;
	struct net_device *s_port;
	u32 ring_id;
	u16 prio;
};

struct switchdev_obj_ring_role_mrp {
	struct switchdev_obj obj;
	u8 ring_role;
	u32 ring_id;
	u8 sw_backup;
};

enum dsa_tag_protocol {
	DSA_TAG_PROTO_NONE = 0,
	DSA_TAG_PROTO_BRCM = 1,
	DSA_TAG_PROTO_BRCM_LEGACY = 22,
	DSA_TAG_PROTO_BRCM_PREPEND = 2,
	DSA_TAG_PROTO_DSA = 3,
	DSA_TAG_PROTO_EDSA = 4,
	DSA_TAG_PROTO_GSWIP = 5,
	DSA_TAG_PROTO_KSZ9477 = 6,
	DSA_TAG_PROTO_KSZ9893 = 7,
	DSA_TAG_PROTO_LAN9303 = 8,
	DSA_TAG_PROTO_MTK = 9,
	DSA_TAG_PROTO_QCA = 10,
	DSA_TAG_PROTO_TRAILER = 11,
	DSA_TAG_PROTO_8021Q = 12,
	DSA_TAG_PROTO_SJA1105 = 13,
	DSA_TAG_PROTO_KSZ8795 = 14,
	DSA_TAG_PROTO_OCELOT = 15,
	DSA_TAG_PROTO_AR9331 = 16,
	DSA_TAG_PROTO_RTL4_A = 17,
	DSA_TAG_PROTO_HELLCREEK = 18,
	DSA_TAG_PROTO_XRS700X = 19,
	DSA_TAG_PROTO_OCELOT_8021Q = 20,
	DSA_TAG_PROTO_SEVILLE = 21,
	DSA_TAG_PROTO_SJA1110 = 23,
	DSA_TAG_PROTO_RTL8_4 = 24,
	DSA_TAG_PROTO_RTL8_4T = 25,
	DSA_TAG_PROTO_RZN1_A5PSW = 26,
	DSA_TAG_PROTO_LAN937X = 27,
};

struct dsa_device_ops {
	struct sk_buff * (*xmit)(struct sk_buff *, struct net_device *);
	struct sk_buff * (*rcv)(struct sk_buff *, struct net_device *);
	void (*flow_dissect)(const struct sk_buff *, __be16 *, int *);
	int (*connect)(struct dsa_switch *);
	void (*disconnect)(struct dsa_switch *);
	unsigned int needed_headroom;
	unsigned int needed_tailroom;
	const char *name;
	enum dsa_tag_protocol proto;
	bool promisc_on_master;
};

struct dsa_8021q_context;

struct dsa_switch_ops;

struct dsa_switch {
	struct device *dev;
	struct dsa_switch_tree *dst;
	unsigned int index;
	u32 setup: 1;
	u32 vlan_filtering_is_global: 1;
	u32 needs_standalone_vlan_filtering: 1;
	u32 configure_vlan_while_not_filtering: 1;
	u32 untag_bridge_pvid: 1;
	u32 assisted_learning_on_cpu_port: 1;
	u32 vlan_filtering: 1;
	u32 mtu_enforcement_ingress: 1;
	u32 fdb_isolation: 1;
	struct notifier_block nb;
	void *priv;
	void *tagger_data;
	struct dsa_chip_data *cd;
	const struct dsa_switch_ops *ops;
	u32 phys_mii_mask;
	struct mii_bus *slave_mii_bus;
	unsigned int ageing_time_min;
	unsigned int ageing_time_max;
	struct dsa_8021q_context *tag_8021q_ctx;
	struct devlink *devlink;
	unsigned int num_tx_queues;
	unsigned int num_lag_ids;
	unsigned int max_num_bridges;
	unsigned int num_ports;
};

struct dsa_netdevice_ops {
	int (*ndo_eth_ioctl)(struct net_device *, struct ifreq *, int);
};

struct dsa_lag {
	struct net_device *dev;
	unsigned int id;
	struct mutex fdb_lock;
	struct list_head fdbs;
	refcount_t refcount;
};

struct dsa_switch_tree {
	struct list_head list;
	struct list_head ports;
	struct raw_notifier_head nh;
	unsigned int index;
	struct kref refcount;
	struct dsa_lag **lags;
	const struct dsa_device_ops *tag_ops;
	enum dsa_tag_protocol default_proto;
	bool setup;
	struct dsa_platform_data *pd;
	struct list_head rtable;
	unsigned int lags_len;
	unsigned int last_switch;
};

struct dsa_mall_mirror_tc_entry {
	u8 to_local_port;
	bool ingress;
};

struct dsa_mall_policer_tc_entry {
	u32 burst;
	int: 32;
	u64 rate_bytes_per_sec;
};

struct dsa_bridge {
	struct net_device *dev;
	unsigned int num;
	bool tx_fwd_offload;
	refcount_t refcount;
};

enum dsa_db_type {
	DSA_DB_PORT = 0,
	DSA_DB_LAG = 1,
	DSA_DB_BRIDGE = 2,
};

struct dsa_db {
	enum dsa_db_type type;
	union {
		const struct dsa_port *dp;
		struct dsa_lag lag;
		struct dsa_bridge bridge;
	};
};

struct fixed_phy_status;

typedef int dsa_fdb_dump_cb_t(const unsigned char *, u16, bool, void *);

struct dsa_switch_ops {
	enum dsa_tag_protocol (*get_tag_protocol)(struct dsa_switch *, int, enum dsa_tag_protocol);
	int (*change_tag_protocol)(struct dsa_switch *, enum dsa_tag_protocol);
	int (*connect_tag_protocol)(struct dsa_switch *, enum dsa_tag_protocol);
	int (*port_change_master)(struct dsa_switch *, int, struct net_device *, struct netlink_ext_ack *);
	int (*setup)(struct dsa_switch *);
	void (*teardown)(struct dsa_switch *);
	int (*port_setup)(struct dsa_switch *, int);
	void (*port_teardown)(struct dsa_switch *, int);
	u32 (*get_phy_flags)(struct dsa_switch *, int);
	int (*phy_read)(struct dsa_switch *, int, int);
	int (*phy_write)(struct dsa_switch *, int, int, u16);
	void (*adjust_link)(struct dsa_switch *, int, struct phy_device *);
	void (*fixed_link_update)(struct dsa_switch *, int, struct fixed_phy_status *);
	void (*phylink_get_caps)(struct dsa_switch *, int, struct phylink_config *);
	void (*phylink_validate)(struct dsa_switch *, int, long unsigned int *, struct phylink_link_state *);
	struct phylink_pcs * (*phylink_mac_select_pcs)(struct dsa_switch *, int, phy_interface_t);
	int (*phylink_mac_link_state)(struct dsa_switch *, int, struct phylink_link_state *);
	void (*phylink_mac_config)(struct dsa_switch *, int, unsigned int, const struct phylink_link_state *);
	void (*phylink_mac_an_restart)(struct dsa_switch *, int);
	void (*phylink_mac_link_down)(struct dsa_switch *, int, unsigned int, phy_interface_t);
	void (*phylink_mac_link_up)(struct dsa_switch *, int, unsigned int, phy_interface_t, struct phy_device *, int, int, bool, bool);
	void (*phylink_fixed_state)(struct dsa_switch *, int, struct phylink_link_state *);
	void (*get_strings)(struct dsa_switch *, int, u32, uint8_t *);
	void (*get_ethtool_stats)(struct dsa_switch *, int, uint64_t *);
	int (*get_sset_count)(struct dsa_switch *, int, int);
	void (*get_ethtool_phy_stats)(struct dsa_switch *, int, uint64_t *);
	void (*get_eth_phy_stats)(struct dsa_switch *, int, struct ethtool_eth_phy_stats *);
	void (*get_eth_mac_stats)(struct dsa_switch *, int, struct ethtool_eth_mac_stats *);
	void (*get_eth_ctrl_stats)(struct dsa_switch *, int, struct ethtool_eth_ctrl_stats *);
	void (*get_rmon_stats)(struct dsa_switch *, int, struct ethtool_rmon_stats *, const struct ethtool_rmon_hist_range **);
	void (*get_stats64)(struct dsa_switch *, int, struct rtnl_link_stats64 *);
	void (*get_pause_stats)(struct dsa_switch *, int, struct ethtool_pause_stats *);
	void (*self_test)(struct dsa_switch *, int, struct ethtool_test *, u64 *);
	void (*get_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*set_wol)(struct dsa_switch *, int, struct ethtool_wolinfo *);
	int (*get_ts_info)(struct dsa_switch *, int, struct ethtool_ts_info *);
	int (*port_get_default_prio)(struct dsa_switch *, int);
	int (*port_set_default_prio)(struct dsa_switch *, int, u8);
	int (*port_get_dscp_prio)(struct dsa_switch *, int, u8);
	int (*port_add_dscp_prio)(struct dsa_switch *, int, u8, u8);
	int (*port_del_dscp_prio)(struct dsa_switch *, int, u8, u8);
	int (*suspend)(struct dsa_switch *);
	int (*resume)(struct dsa_switch *);
	int (*port_enable)(struct dsa_switch *, int, struct phy_device *);
	void (*port_disable)(struct dsa_switch *, int);
	int (*set_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_mac_eee)(struct dsa_switch *, int, struct ethtool_eee *);
	int (*get_eeprom_len)(struct dsa_switch *);
	int (*get_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*set_eeprom)(struct dsa_switch *, struct ethtool_eeprom *, u8 *);
	int (*get_regs_len)(struct dsa_switch *, int);
	void (*get_regs)(struct dsa_switch *, int, struct ethtool_regs *, void *);
	int (*port_prechangeupper)(struct dsa_switch *, int, struct netdev_notifier_changeupper_info *);
	int (*set_ageing_time)(struct dsa_switch *, unsigned int);
	int (*port_bridge_join)(struct dsa_switch *, int, struct dsa_bridge, bool *, struct netlink_ext_ack *);
	void (*port_bridge_leave)(struct dsa_switch *, int, struct dsa_bridge);
	void (*port_stp_state_set)(struct dsa_switch *, int, u8);
	int (*port_mst_state_set)(struct dsa_switch *, int, const struct switchdev_mst_state *);
	void (*port_fast_age)(struct dsa_switch *, int);
	int (*port_vlan_fast_age)(struct dsa_switch *, int, u16);
	int (*port_pre_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
	int (*port_bridge_flags)(struct dsa_switch *, int, struct switchdev_brport_flags, struct netlink_ext_ack *);
	void (*port_set_host_flood)(struct dsa_switch *, int, bool, bool);
	int (*port_vlan_filtering)(struct dsa_switch *, int, bool, struct netlink_ext_ack *);
	int (*port_vlan_add)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *, struct netlink_ext_ack *);
	int (*port_vlan_del)(struct dsa_switch *, int, const struct switchdev_obj_port_vlan *);
	int (*vlan_msti_set)(struct dsa_switch *, struct dsa_bridge, const struct switchdev_vlan_msti *);
	int (*port_fdb_add)(struct dsa_switch *, int, const unsigned char *, u16, struct dsa_db);
	int (*port_fdb_del)(struct dsa_switch *, int, const unsigned char *, u16, struct dsa_db);
	int (*port_fdb_dump)(struct dsa_switch *, int, dsa_fdb_dump_cb_t *, void *);
	int (*lag_fdb_add)(struct dsa_switch *, struct dsa_lag, const unsigned char *, u16, struct dsa_db);
	int (*lag_fdb_del)(struct dsa_switch *, struct dsa_lag, const unsigned char *, u16, struct dsa_db);
	int (*port_mdb_add)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *, struct dsa_db);
	int (*port_mdb_del)(struct dsa_switch *, int, const struct switchdev_obj_port_mdb *, struct dsa_db);
	int (*get_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *, u32 *);
	int (*set_rxnfc)(struct dsa_switch *, int, struct ethtool_rxnfc *);
	int (*cls_flower_add)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_del)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*cls_flower_stats)(struct dsa_switch *, int, struct flow_cls_offload *, bool);
	int (*port_mirror_add)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *, bool, struct netlink_ext_ack *);
	void (*port_mirror_del)(struct dsa_switch *, int, struct dsa_mall_mirror_tc_entry *);
	int (*port_policer_add)(struct dsa_switch *, int, struct dsa_mall_policer_tc_entry *);
	void (*port_policer_del)(struct dsa_switch *, int);
	int (*port_setup_tc)(struct dsa_switch *, int, enum tc_setup_type, void *);
	int (*crosschip_bridge_join)(struct dsa_switch *, int, int, int, struct dsa_bridge, struct netlink_ext_ack *);
	void (*crosschip_bridge_leave)(struct dsa_switch *, int, int, int, struct dsa_bridge);
	int (*crosschip_lag_change)(struct dsa_switch *, int, int);
	int (*crosschip_lag_join)(struct dsa_switch *, int, int, struct dsa_lag, struct netdev_lag_upper_info *, struct netlink_ext_ack *);
	int (*crosschip_lag_leave)(struct dsa_switch *, int, int, struct dsa_lag);
	int (*port_hwtstamp_get)(struct dsa_switch *, int, struct ifreq *);
	int (*port_hwtstamp_set)(struct dsa_switch *, int, struct ifreq *);
	void (*port_txtstamp)(struct dsa_switch *, int, struct sk_buff *);
	bool (*port_rxtstamp)(struct dsa_switch *, int, struct sk_buff *, unsigned int);
	int (*devlink_param_get)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_param_set)(struct dsa_switch *, u32, struct devlink_param_gset_ctx *);
	int (*devlink_info_get)(struct dsa_switch *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*devlink_sb_pool_get)(struct dsa_switch *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*devlink_sb_pool_set)(struct dsa_switch *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*devlink_sb_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *);
	int (*devlink_sb_port_pool_set)(struct dsa_switch *, int, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*devlink_sb_tc_pool_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*devlink_sb_tc_pool_bind_set)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*devlink_sb_occ_snapshot)(struct dsa_switch *, unsigned int);
	int (*devlink_sb_occ_max_clear)(struct dsa_switch *, unsigned int);
	int (*devlink_sb_occ_port_pool_get)(struct dsa_switch *, int, unsigned int, u16, u32 *, u32 *);
	int (*devlink_sb_occ_tc_port_bind_get)(struct dsa_switch *, int, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*port_change_mtu)(struct dsa_switch *, int, int);
	int (*port_max_mtu)(struct dsa_switch *, int);
	int (*port_lag_change)(struct dsa_switch *, int);
	int (*port_lag_join)(struct dsa_switch *, int, struct dsa_lag, struct netdev_lag_upper_info *, struct netlink_ext_ack *);
	int (*port_lag_leave)(struct dsa_switch *, int, struct dsa_lag);
	int (*port_hsr_join)(struct dsa_switch *, int, struct net_device *);
	int (*port_hsr_leave)(struct dsa_switch *, int, struct net_device *);
	int (*port_mrp_add)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
	int (*port_mrp_del)(struct dsa_switch *, int, const struct switchdev_obj_mrp *);
	int (*port_mrp_add_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
	int (*port_mrp_del_ring_role)(struct dsa_switch *, int, const struct switchdev_obj_ring_role_mrp *);
	int (*tag_8021q_vlan_add)(struct dsa_switch *, int, u16, u16);
	int (*tag_8021q_vlan_del)(struct dsa_switch *, int, u16);
	void (*master_state_change)(struct dsa_switch *, const struct net_device *, bool);
};

enum lwtunnel_encap_types {
	LWTUNNEL_ENCAP_NONE = 0,
	LWTUNNEL_ENCAP_MPLS = 1,
	LWTUNNEL_ENCAP_IP = 2,
	LWTUNNEL_ENCAP_ILA = 3,
	LWTUNNEL_ENCAP_IP6 = 4,
	LWTUNNEL_ENCAP_SEG6 = 5,
	LWTUNNEL_ENCAP_BPF = 6,
	LWTUNNEL_ENCAP_SEG6_LOCAL = 7,
	LWTUNNEL_ENCAP_RPL = 8,
	LWTUNNEL_ENCAP_IOAM6 = 9,
	LWTUNNEL_ENCAP_XFRM = 10,
	__LWTUNNEL_ENCAP_MAX = 11,
};

struct arphdr {
	__be16 ar_hrd;
	__be16 ar_pro;
	unsigned char ar_hln;
	unsigned char ar_pln;
	__be16 ar_op;
};

typedef u64 sci_t;

enum metadata_type {
	METADATA_IP_TUNNEL = 0,
	METADATA_HW_PORT_MUX = 1,
	METADATA_MACSEC = 2,
	METADATA_XFRM = 3,
};

struct hw_port_info {
	struct net_device *lower_dev;
	u32 port_id;
};

struct macsec_info {
	sci_t sci;
};

struct xfrm_md_info {
	u32 if_id;
	int link;
};

struct metadata_dst {
	struct dst_entry dst;
	enum metadata_type type;
	union {
		struct ip_tunnel_info tun_info;
		struct hw_port_info port_info;
		struct macsec_info macsec_info;
		struct xfrm_md_info xfrm_info;
	} u;
};

struct gre_base_hdr {
	__be16 flags;
	__be16 protocol;
};

struct gre_full_hdr {
	struct gre_base_hdr fixed_header;
	__be16 csum;
	__be16 reserved1;
	__be32 key;
	__be32 seq;
};

struct pptp_gre_header {
	struct gre_base_hdr gre_hd;
	__be16 payload_len;
	__be16 call_id;
	__be32 seq;
	__be32 ack;
};

struct tipc_basic_hdr {
	__be32 w[4];
};

struct icmphdr {
	__u8 type;
	__u8 code;
	__sum16 checksum;
	union {
		struct {
			__be16 id;
			__be16 sequence;
		} echo;
		__be32 gateway;
		struct {
			__be16 __unused;
			__be16 mtu;
		} frag;
		__u8 reserved[4];
	} un;
};

enum sctp_msg_flags {
	MSG_NOTIFICATION = 32768,
};

enum dccp_state {
	DCCP_OPEN = 1,
	DCCP_REQUESTING = 2,
	DCCP_LISTEN = 10,
	DCCP_RESPOND = 3,
	DCCP_ACTIVE_CLOSEREQ = 4,
	DCCP_PASSIVE_CLOSE = 8,
	DCCP_CLOSING = 11,
	DCCP_TIME_WAIT = 6,
	DCCP_CLOSED = 7,
	DCCP_NEW_SYN_RECV = 12,
	DCCP_PARTOPEN = 13,
	DCCP_PASSIVE_CLOSEREQ = 14,
	DCCP_MAX_STATES = 15,
};

enum l2tp_debug_flags {
	L2TP_MSG_DEBUG = 1,
	L2TP_MSG_CONTROL = 2,
	L2TP_MSG_SEQ = 4,
	L2TP_MSG_DATA = 8,
};

struct pppoe_tag {
	__be16 tag_type;
	__be16 tag_len;
	char tag_data[0];
};

struct pppoe_hdr {
	__u8 type: 4;
	__u8 ver: 4;
	__u8 code;
	__be16 sid;
	__be16 length;
	struct pppoe_tag tag[0];
};

struct hsr_tag {
	__be16 path_and_LSDU_size;
	__be16 sequence_nr;
	__be16 encap_proto;
};

struct mpls_label {
	__be32 entry;
};

enum batadv_packettype {
	BATADV_IV_OGM = 0,
	BATADV_BCAST = 1,
	BATADV_CODED = 2,
	BATADV_ELP = 3,
	BATADV_OGM2 = 4,
	BATADV_UNICAST = 64,
	BATADV_UNICAST_FRAG = 65,
	BATADV_UNICAST_4ADDR = 66,
	BATADV_ICMP = 67,
	BATADV_UNICAST_TVLV = 68,
};

struct batadv_unicast_packet {
	__u8 packet_type;
	__u8 version;
	__u8 ttl;
	__u8 ttvn;
	__u8 dest[6];
};

struct nf_conntrack_zone {
	u16 id;
	u8 flags;
	u8 dir;
};

struct nf_conntrack_man {
	union nf_inet_addr u3;
	union nf_conntrack_man_proto u;
	u_int16_t l3num;
};

struct nf_conntrack_tuple {
	struct nf_conntrack_man src;
	struct {
		union nf_inet_addr u3;
		union {
			__be16 all;
			struct {
				__be16 port;
			} tcp;
			struct {
				__be16 port;
			} udp;
			struct {
				u_int8_t type;
				u_int8_t code;
			} icmp;
			struct {
				__be16 port;
			} dccp;
			struct {
				__be16 port;
			} sctp;
			struct {
				__be16 key;
			} gre;
		} u;
		u_int8_t protonum;
		u_int8_t dir;
	} dst;
};

struct nf_conntrack_tuple_hash {
	struct hlist_nulls_node hnnode;
	struct nf_conntrack_tuple tuple;
};

struct nf_ct_udp {
	long unsigned int stream_ts;
};

struct nf_ct_gre {
	unsigned int stream_timeout;
	unsigned int timeout;
};

union nf_conntrack_proto {
	struct nf_ct_dccp dccp;
	struct ip_ct_sctp sctp;
	struct ip_ct_tcp tcp;
	struct nf_ct_udp udp;
	struct nf_ct_gre gre;
	unsigned int tmpl_padto;
};

struct nf_ct_ext;

struct nf_conn {
	struct nf_conntrack ct_general;
	spinlock_t lock;
	u32 timeout;
	struct nf_conntrack_zone zone;
	struct nf_conntrack_tuple_hash tuplehash[2];
	long unsigned int status;
	possible_net_t ct_net;
	struct hlist_node nat_bysource;
	struct {	} __nfct_init_offset;
	struct nf_conn *master;
	u_int32_t mark;
	struct nf_ct_ext *ext;
	int: 32;
	union nf_conntrack_proto proto;
};

struct nf_conntrack_tuple_mask {
	struct {
		union nf_inet_addr u3;
		union nf_conntrack_man_proto u;
	} src;
};

struct nf_ct_ext {
	u8 offset[9];
	u8 len;
	unsigned int gen_id;
	char data[0];
};

struct nf_conntrack_helper;

struct nf_conntrack_expect {
	struct hlist_node lnode;
	struct hlist_node hnode;
	struct nf_conntrack_tuple tuple;
	struct nf_conntrack_tuple_mask mask;
	void (*expectfn)(struct nf_conn *, struct nf_conntrack_expect *);
	struct nf_conntrack_helper *helper;
	struct nf_conn *master;
	struct timer_list timeout;
	refcount_t use;
	unsigned int flags;
	unsigned int class;
	union nf_inet_addr saved_addr;
	union nf_conntrack_man_proto saved_proto;
	enum ip_conntrack_dir dir;
	struct callback_head rcu;
};

enum nf_ct_ext_id {
	NF_CT_EXT_HELPER = 0,
	NF_CT_EXT_NAT = 1,
	NF_CT_EXT_SEQADJ = 2,
	NF_CT_EXT_ACCT = 3,
	NF_CT_EXT_ECACHE = 4,
	NF_CT_EXT_TSTAMP = 5,
	NF_CT_EXT_TIMEOUT = 6,
	NF_CT_EXT_LABELS = 7,
	NF_CT_EXT_SYNPROXY = 8,
	NF_CT_EXT_NUM = 9,
};

struct nf_ct_event {
	struct nf_conn *ct;
	u32 portid;
	int report;
};

struct nf_exp_event {
	struct nf_conntrack_expect *exp;
	u32 portid;
	int report;
};

struct nf_conn_labels {
	long unsigned int bits[4];
};

struct _flow_keys_digest_data {
	__be16 n_proto;
	u8 ip_proto;
	u8 padding;
	__be32 ports;
	__be32 src;
	__be32 dst;
};

enum nf_dev_hooks {
	NF_NETDEV_INGRESS = 0,
	NF_NETDEV_EGRESS = 1,
	NF_NETDEV_NUMHOOKS = 2,
};

enum {
	IF_OPER_UNKNOWN = 0,
	IF_OPER_NOTPRESENT = 1,
	IF_OPER_DOWN = 2,
	IF_OPER_LOWERLAYERDOWN = 3,
	IF_OPER_TESTING = 4,
	IF_OPER_DORMANT = 5,
	IF_OPER_UP = 6,
};

struct ifbond {
	__s32 bond_mode;
	__s32 num_slaves;
	__s32 miimon;
};

typedef struct ifbond ifbond;

struct ifslave {
	__s32 slave_id;
	char slave_name[16];
	__s8 link;
	__s8 state;
	__u32 link_failure_count;
};

typedef struct ifslave ifslave;

enum {
	NAPIF_STATE_SCHED = 1,
	NAPIF_STATE_MISSED = 2,
	NAPIF_STATE_DISABLE = 4,
	NAPIF_STATE_NPSVC = 8,
	NAPIF_STATE_LISTED = 16,
	NAPIF_STATE_NO_BUSY_POLL = 32,
	NAPIF_STATE_IN_BUSY_POLL = 64,
	NAPIF_STATE_PREFER_BUSY_POLL = 128,
	NAPIF_STATE_THREADED = 256,
	NAPIF_STATE_SCHED_THREADED = 512,
};

struct net_device_path_stack {
	int num_paths;
	struct net_device_path path[5];
};

struct bpf_xdp_link {
	struct bpf_link link;
	struct net_device *dev;
	int flags;
};

struct netdev_net_notifier {
	struct list_head list;
	struct notifier_block *nb;
};

struct packet_type {
	__be16 type;
	bool ignore_outgoing;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	int (*func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	void (*list_func)(struct list_head *, struct packet_type *, struct net_device *);
	bool (*id_match)(struct packet_type *, struct sock *);
	struct net *af_packet_net;
	void *af_packet_priv;
	struct list_head list;
};

struct netdev_notifier_info_ext {
	struct netdev_notifier_info info;
	union {
		u32 mtu;
	} ext;
};

struct netdev_notifier_change_info {
	struct netdev_notifier_info info;
	unsigned int flags_changed;
};

struct netdev_notifier_changelowerstate_info {
	struct netdev_notifier_info info;
	void *lower_state_info;
};

struct netdev_notifier_pre_changeaddr_info {
	struct netdev_notifier_info info;
	const unsigned char *dev_addr;
};

enum netdev_offload_xstats_type {
	NETDEV_OFFLOAD_XSTATS_TYPE_L3 = 1,
};

struct netdev_notifier_offload_xstats_rd {
	struct rtnl_hw_stats64 stats;
	bool used;
	int: 24;
	int: 32;
};

struct netdev_notifier_offload_xstats_ru {
	bool used;
};

struct netdev_notifier_offload_xstats_info {
	struct netdev_notifier_info info;
	enum netdev_offload_xstats_type type;
	union {
		struct netdev_notifier_offload_xstats_rd *report_delta;
		struct netdev_notifier_offload_xstats_ru *report_used;
	};
};

enum {
	NESTED_SYNC_IMM_BIT = 0,
	NESTED_SYNC_TODO_BIT = 1,
};

struct netdev_nested_priv {
	unsigned char flags;
	void *data;
};

struct netdev_bonding_info {
	ifslave slave;
	ifbond master;
};

struct netdev_notifier_bonding_info {
	struct netdev_notifier_info info;
	struct netdev_bonding_info bonding_info;
};

enum qdisc_state_t {
	__QDISC_STATE_SCHED = 0,
	__QDISC_STATE_DEACTIVATED = 1,
	__QDISC_STATE_MISSED = 2,
	__QDISC_STATE_DRAINING = 3,
};

enum qdisc_state2_t {
	__QDISC_STATE2_RUNNING = 0,
};

struct tcf_walker {
	int stop;
	int skip;
	int count;
	bool nonempty;
	long unsigned int cookie;
	int (*fn)(struct tcf_proto *, void *, struct tcf_walker *);
};

struct tc_skb_cb {
	struct qdisc_skb_cb qdisc_cb;
	u16 mru;
	u8 post_ct: 1;
	u8 post_ct_snat: 1;
	u8 post_ct_dnat: 1;
	u16 zone;
};

typedef int (*bpf_op_t)(struct net_device *, struct netdev_bpf *);

struct dev_kfree_skb_cb {
	enum skb_free_reason reason;
};

struct netdev_adjacent {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	bool master;
	bool ignore;
	u16 ref_nr;
	void *private;
	struct list_head list;
	struct callback_head rcu;
};

enum {
	NDA_UNSPEC = 0,
	NDA_DST = 1,
	NDA_LLADDR = 2,
	NDA_CACHEINFO = 3,
	NDA_PROBES = 4,
	NDA_VLAN = 5,
	NDA_PORT = 6,
	NDA_VNI = 7,
	NDA_IFINDEX = 8,
	NDA_MASTER = 9,
	NDA_LINK_NETNSID = 10,
	NDA_SRC_VNI = 11,
	NDA_PROTOCOL = 12,
	NDA_NH_ID = 13,
	NDA_FDB_EXT_ATTRS = 14,
	NDA_FLAGS_EXT = 15,
	NDA_NDM_STATE_MASK = 16,
	NDA_NDM_FLAGS_MASK = 17,
	__NDA_MAX = 18,
};

struct nda_cacheinfo {
	__u32 ndm_confirmed;
	__u32 ndm_used;
	__u32 ndm_updated;
	__u32 ndm_refcnt;
};

struct ndt_stats {
	__u64 ndts_allocs;
	__u64 ndts_destroys;
	__u64 ndts_hash_grows;
	__u64 ndts_res_failed;
	__u64 ndts_lookups;
	__u64 ndts_hits;
	__u64 ndts_rcv_probes_mcast;
	__u64 ndts_rcv_probes_ucast;
	__u64 ndts_periodic_gc_runs;
	__u64 ndts_forced_gc_runs;
	__u64 ndts_table_fulls;
};

enum {
	NDTPA_UNSPEC = 0,
	NDTPA_IFINDEX = 1,
	NDTPA_REFCNT = 2,
	NDTPA_REACHABLE_TIME = 3,
	NDTPA_BASE_REACHABLE_TIME = 4,
	NDTPA_RETRANS_TIME = 5,
	NDTPA_GC_STALETIME = 6,
	NDTPA_DELAY_PROBE_TIME = 7,
	NDTPA_QUEUE_LEN = 8,
	NDTPA_APP_PROBES = 9,
	NDTPA_UCAST_PROBES = 10,
	NDTPA_MCAST_PROBES = 11,
	NDTPA_ANYCAST_DELAY = 12,
	NDTPA_PROXY_DELAY = 13,
	NDTPA_PROXY_QLEN = 14,
	NDTPA_LOCKTIME = 15,
	NDTPA_QUEUE_LENBYTES = 16,
	NDTPA_MCAST_REPROBES = 17,
	NDTPA_PAD = 18,
	NDTPA_INTERVAL_PROBE_TIME_MS = 19,
	__NDTPA_MAX = 20,
};

struct ndtmsg {
	__u8 ndtm_family;
	__u8 ndtm_pad1;
	__u16 ndtm_pad2;
};

struct ndt_config {
	__u16 ndtc_key_len;
	__u16 ndtc_entry_size;
	__u32 ndtc_entries;
	__u32 ndtc_last_flush;
	__u32 ndtc_last_rand;
	__u32 ndtc_hash_rnd;
	__u32 ndtc_hash_mask;
	__u32 ndtc_hash_chain_gc;
	__u32 ndtc_proxy_qlen;
};

enum {
	NDTA_UNSPEC = 0,
	NDTA_NAME = 1,
	NDTA_THRESH1 = 2,
	NDTA_THRESH2 = 3,
	NDTA_THRESH3 = 4,
	NDTA_CONFIG = 5,
	NDTA_PARMS = 6,
	NDTA_STATS = 7,
	NDTA_GC_INTERVAL = 8,
	NDTA_PAD = 9,
	__NDTA_MAX = 10,
};

enum {
	RTN_UNSPEC = 0,
	RTN_UNICAST = 1,
	RTN_LOCAL = 2,
	RTN_BROADCAST = 3,
	RTN_ANYCAST = 4,
	RTN_MULTICAST = 5,
	RTN_BLACKHOLE = 6,
	RTN_UNREACHABLE = 7,
	RTN_PROHIBIT = 8,
	RTN_THROW = 9,
	RTN_NAT = 10,
	RTN_XRESOLVE = 11,
	__RTN_MAX = 12,
};

enum {
	NEIGH_ARP_TABLE = 0,
	NEIGH_ND_TABLE = 1,
	NEIGH_DN_TABLE = 2,
	NEIGH_NR_TABLES = 3,
	NEIGH_LINK_TABLE = 3,
};

struct neigh_seq_state {
	struct seq_net_private p;
	struct neigh_table *tbl;
	struct neigh_hash_table *nht;
	void * (*neigh_sub_iter)(struct neigh_seq_state *, struct neighbour *, loff_t *);
	unsigned int bucket;
	unsigned int flags;
};

struct neighbour_cb {
	long unsigned int sched_next;
	unsigned int flags;
};

enum netevent_notif_type {
	NETEVENT_NEIGH_UPDATE = 1,
	NETEVENT_REDIRECT = 2,
	NETEVENT_DELAY_PROBE_TIME_UPDATE = 3,
	NETEVENT_IPV4_MPATH_HASH_UPDATE = 4,
	NETEVENT_IPV6_MPATH_HASH_UPDATE = 5,
	NETEVENT_IPV4_FWD_UPDATE_PRIORITY_UPDATE = 6,
};

struct neigh_dump_filter {
	int master_idx;
	int dev_idx;
};

struct neigh_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table neigh_vars[22];
};

struct rtnl_link_stats {
	__u32 rx_packets;
	__u32 tx_packets;
	__u32 rx_bytes;
	__u32 tx_bytes;
	__u32 rx_errors;
	__u32 tx_errors;
	__u32 rx_dropped;
	__u32 tx_dropped;
	__u32 multicast;
	__u32 collisions;
	__u32 rx_length_errors;
	__u32 rx_over_errors;
	__u32 rx_crc_errors;
	__u32 rx_frame_errors;
	__u32 rx_fifo_errors;
	__u32 rx_missed_errors;
	__u32 tx_aborted_errors;
	__u32 tx_carrier_errors;
	__u32 tx_fifo_errors;
	__u32 tx_heartbeat_errors;
	__u32 tx_window_errors;
	__u32 rx_compressed;
	__u32 tx_compressed;
	__u32 rx_nohandler;
};

struct rtnl_link_ifmap {
	__u64 mem_start;
	__u64 mem_end;
	__u64 base_addr;
	__u16 irq;
	__u8 dma;
	__u8 port;
	int: 32;
};

enum {
	IFLA_UNSPEC = 0,
	IFLA_ADDRESS = 1,
	IFLA_BROADCAST = 2,
	IFLA_IFNAME = 3,
	IFLA_MTU = 4,
	IFLA_LINK = 5,
	IFLA_QDISC = 6,
	IFLA_STATS = 7,
	IFLA_COST = 8,
	IFLA_PRIORITY = 9,
	IFLA_MASTER = 10,
	IFLA_WIRELESS = 11,
	IFLA_PROTINFO = 12,
	IFLA_TXQLEN = 13,
	IFLA_MAP = 14,
	IFLA_WEIGHT = 15,
	IFLA_OPERSTATE = 16,
	IFLA_LINKMODE = 17,
	IFLA_LINKINFO = 18,
	IFLA_NET_NS_PID = 19,
	IFLA_IFALIAS = 20,
	IFLA_NUM_VF = 21,
	IFLA_VFINFO_LIST = 22,
	IFLA_STATS64 = 23,
	IFLA_VF_PORTS = 24,
	IFLA_PORT_SELF = 25,
	IFLA_AF_SPEC = 26,
	IFLA_GROUP = 27,
	IFLA_NET_NS_FD = 28,
	IFLA_EXT_MASK = 29,
	IFLA_PROMISCUITY = 30,
	IFLA_NUM_TX_QUEUES = 31,
	IFLA_NUM_RX_QUEUES = 32,
	IFLA_CARRIER = 33,
	IFLA_PHYS_PORT_ID = 34,
	IFLA_CARRIER_CHANGES = 35,
	IFLA_PHYS_SWITCH_ID = 36,
	IFLA_LINK_NETNSID = 37,
	IFLA_PHYS_PORT_NAME = 38,
	IFLA_PROTO_DOWN = 39,
	IFLA_GSO_MAX_SEGS = 40,
	IFLA_GSO_MAX_SIZE = 41,
	IFLA_PAD = 42,
	IFLA_XDP = 43,
	IFLA_EVENT = 44,
	IFLA_NEW_NETNSID = 45,
	IFLA_IF_NETNSID = 46,
	IFLA_TARGET_NETNSID = 46,
	IFLA_CARRIER_UP_COUNT = 47,
	IFLA_CARRIER_DOWN_COUNT = 48,
	IFLA_NEW_IFINDEX = 49,
	IFLA_MIN_MTU = 50,
	IFLA_MAX_MTU = 51,
	IFLA_PROP_LIST = 52,
	IFLA_ALT_IFNAME = 53,
	IFLA_PERM_ADDRESS = 54,
	IFLA_PROTO_DOWN_REASON = 55,
	IFLA_PARENT_DEV_NAME = 56,
	IFLA_PARENT_DEV_BUS_NAME = 57,
	IFLA_GRO_MAX_SIZE = 58,
	IFLA_TSO_MAX_SIZE = 59,
	IFLA_TSO_MAX_SEGS = 60,
	IFLA_ALLMULTI = 61,
	__IFLA_MAX = 62,
};

enum {
	IFLA_PROTO_DOWN_REASON_UNSPEC = 0,
	IFLA_PROTO_DOWN_REASON_MASK = 1,
	IFLA_PROTO_DOWN_REASON_VALUE = 2,
	__IFLA_PROTO_DOWN_REASON_CNT = 3,
	IFLA_PROTO_DOWN_REASON_MAX = 2,
};

enum {
	IFLA_BRPORT_UNSPEC = 0,
	IFLA_BRPORT_STATE = 1,
	IFLA_BRPORT_PRIORITY = 2,
	IFLA_BRPORT_COST = 3,
	IFLA_BRPORT_MODE = 4,
	IFLA_BRPORT_GUARD = 5,
	IFLA_BRPORT_PROTECT = 6,
	IFLA_BRPORT_FAST_LEAVE = 7,
	IFLA_BRPORT_LEARNING = 8,
	IFLA_BRPORT_UNICAST_FLOOD = 9,
	IFLA_BRPORT_PROXYARP = 10,
	IFLA_BRPORT_LEARNING_SYNC = 11,
	IFLA_BRPORT_PROXYARP_WIFI = 12,
	IFLA_BRPORT_ROOT_ID = 13,
	IFLA_BRPORT_BRIDGE_ID = 14,
	IFLA_BRPORT_DESIGNATED_PORT = 15,
	IFLA_BRPORT_DESIGNATED_COST = 16,
	IFLA_BRPORT_ID = 17,
	IFLA_BRPORT_NO = 18,
	IFLA_BRPORT_TOPOLOGY_CHANGE_ACK = 19,
	IFLA_BRPORT_CONFIG_PENDING = 20,
	IFLA_BRPORT_MESSAGE_AGE_TIMER = 21,
	IFLA_BRPORT_FORWARD_DELAY_TIMER = 22,
	IFLA_BRPORT_HOLD_TIMER = 23,
	IFLA_BRPORT_FLUSH = 24,
	IFLA_BRPORT_MULTICAST_ROUTER = 25,
	IFLA_BRPORT_PAD = 26,
	IFLA_BRPORT_MCAST_FLOOD = 27,
	IFLA_BRPORT_MCAST_TO_UCAST = 28,
	IFLA_BRPORT_VLAN_TUNNEL = 29,
	IFLA_BRPORT_BCAST_FLOOD = 30,
	IFLA_BRPORT_GROUP_FWD_MASK = 31,
	IFLA_BRPORT_NEIGH_SUPPRESS = 32,
	IFLA_BRPORT_ISOLATED = 33,
	IFLA_BRPORT_BACKUP_PORT = 34,
	IFLA_BRPORT_MRP_RING_OPEN = 35,
	IFLA_BRPORT_MRP_IN_OPEN = 36,
	IFLA_BRPORT_MCAST_EHT_HOSTS_LIMIT = 37,
	IFLA_BRPORT_MCAST_EHT_HOSTS_CNT = 38,
	IFLA_BRPORT_LOCKED = 39,
	__IFLA_BRPORT_MAX = 40,
};

enum {
	IFLA_VF_INFO_UNSPEC = 0,
	IFLA_VF_INFO = 1,
	__IFLA_VF_INFO_MAX = 2,
};

enum {
	IFLA_VF_UNSPEC = 0,
	IFLA_VF_MAC = 1,
	IFLA_VF_VLAN = 2,
	IFLA_VF_TX_RATE = 3,
	IFLA_VF_SPOOFCHK = 4,
	IFLA_VF_LINK_STATE = 5,
	IFLA_VF_RATE = 6,
	IFLA_VF_RSS_QUERY_EN = 7,
	IFLA_VF_STATS = 8,
	IFLA_VF_TRUST = 9,
	IFLA_VF_IB_NODE_GUID = 10,
	IFLA_VF_IB_PORT_GUID = 11,
	IFLA_VF_VLAN_LIST = 12,
	IFLA_VF_BROADCAST = 13,
	__IFLA_VF_MAX = 14,
};

struct ifla_vf_mac {
	__u32 vf;
	__u8 mac[32];
};

struct ifla_vf_broadcast {
	__u8 broadcast[32];
};

struct ifla_vf_vlan {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
};

enum {
	IFLA_VF_VLAN_INFO_UNSPEC = 0,
	IFLA_VF_VLAN_INFO = 1,
	__IFLA_VF_VLAN_INFO_MAX = 2,
};

struct ifla_vf_vlan_info {
	__u32 vf;
	__u32 vlan;
	__u32 qos;
	__be16 vlan_proto;
};

struct ifla_vf_tx_rate {
	__u32 vf;
	__u32 rate;
};

struct ifla_vf_rate {
	__u32 vf;
	__u32 min_tx_rate;
	__u32 max_tx_rate;
};

struct ifla_vf_spoofchk {
	__u32 vf;
	__u32 setting;
};

struct ifla_vf_link_state {
	__u32 vf;
	__u32 link_state;
};

struct ifla_vf_rss_query_en {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_STATS_RX_PACKETS = 0,
	IFLA_VF_STATS_TX_PACKETS = 1,
	IFLA_VF_STATS_RX_BYTES = 2,
	IFLA_VF_STATS_TX_BYTES = 3,
	IFLA_VF_STATS_BROADCAST = 4,
	IFLA_VF_STATS_MULTICAST = 5,
	IFLA_VF_STATS_PAD = 6,
	IFLA_VF_STATS_RX_DROPPED = 7,
	IFLA_VF_STATS_TX_DROPPED = 8,
	__IFLA_VF_STATS_MAX = 9,
};

struct ifla_vf_trust {
	__u32 vf;
	__u32 setting;
};

enum {
	IFLA_VF_PORT_UNSPEC = 0,
	IFLA_VF_PORT = 1,
	__IFLA_VF_PORT_MAX = 2,
};

enum {
	IFLA_PORT_UNSPEC = 0,
	IFLA_PORT_VF = 1,
	IFLA_PORT_PROFILE = 2,
	IFLA_PORT_VSI_TYPE = 3,
	IFLA_PORT_INSTANCE_UUID = 4,
	IFLA_PORT_HOST_UUID = 5,
	IFLA_PORT_REQUEST = 6,
	IFLA_PORT_RESPONSE = 7,
	__IFLA_PORT_MAX = 8,
};

struct if_stats_msg {
	__u8 family;
	__u8 pad1;
	__u16 pad2;
	__u32 ifindex;
	__u32 filter_mask;
};

enum {
	IFLA_STATS_UNSPEC = 0,
	IFLA_STATS_LINK_64 = 1,
	IFLA_STATS_LINK_XSTATS = 2,
	IFLA_STATS_LINK_XSTATS_SLAVE = 3,
	IFLA_STATS_LINK_OFFLOAD_XSTATS = 4,
	IFLA_STATS_AF_SPEC = 5,
	__IFLA_STATS_MAX = 6,
};

enum {
	IFLA_STATS_GETSET_UNSPEC = 0,
	IFLA_STATS_GET_FILTERS = 1,
	IFLA_STATS_SET_OFFLOAD_XSTATS_L3_STATS = 2,
	__IFLA_STATS_GETSET_MAX = 3,
};

enum {
	IFLA_OFFLOAD_XSTATS_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_CPU_HIT = 1,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO = 2,
	IFLA_OFFLOAD_XSTATS_L3_STATS = 3,
	__IFLA_OFFLOAD_XSTATS_MAX = 4,
};

enum {
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_UNSPEC = 0,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_REQUEST = 1,
	IFLA_OFFLOAD_XSTATS_HW_S_INFO_USED = 2,
	__IFLA_OFFLOAD_XSTATS_HW_S_INFO_MAX = 3,
};

enum {
	XDP_ATTACHED_NONE = 0,
	XDP_ATTACHED_DRV = 1,
	XDP_ATTACHED_SKB = 2,
	XDP_ATTACHED_HW = 3,
	XDP_ATTACHED_MULTI = 4,
};

enum {
	IFLA_XDP_UNSPEC = 0,
	IFLA_XDP_FD = 1,
	IFLA_XDP_ATTACHED = 2,
	IFLA_XDP_FLAGS = 3,
	IFLA_XDP_PROG_ID = 4,
	IFLA_XDP_DRV_PROG_ID = 5,
	IFLA_XDP_SKB_PROG_ID = 6,
	IFLA_XDP_HW_PROG_ID = 7,
	IFLA_XDP_EXPECTED_FD = 8,
	__IFLA_XDP_MAX = 9,
};

enum {
	IFLA_EVENT_NONE = 0,
	IFLA_EVENT_REBOOT = 1,
	IFLA_EVENT_FEATURES = 2,
	IFLA_EVENT_BONDING_FAILOVER = 3,
	IFLA_EVENT_NOTIFY_PEERS = 4,
	IFLA_EVENT_IGMP_RESEND = 5,
	IFLA_EVENT_BONDING_OPTIONS = 6,
};

enum {
	IFLA_BRIDGE_FLAGS = 0,
	IFLA_BRIDGE_MODE = 1,
	IFLA_BRIDGE_VLAN_INFO = 2,
	IFLA_BRIDGE_VLAN_TUNNEL_INFO = 3,
	IFLA_BRIDGE_MRP = 4,
	IFLA_BRIDGE_CFM = 5,
	IFLA_BRIDGE_MST = 6,
	__IFLA_BRIDGE_MAX = 7,
};

enum {
	BR_MCAST_DIR_RX = 0,
	BR_MCAST_DIR_TX = 1,
	BR_MCAST_DIR_SIZE = 2,
};

enum rtattr_type_t {
	RTA_UNSPEC = 0,
	RTA_DST = 1,
	RTA_SRC = 2,
	RTA_IIF = 3,
	RTA_OIF = 4,
	RTA_GATEWAY = 5,
	RTA_PRIORITY = 6,
	RTA_PREFSRC = 7,
	RTA_METRICS = 8,
	RTA_MULTIPATH = 9,
	RTA_PROTOINFO = 10,
	RTA_FLOW = 11,
	RTA_CACHEINFO = 12,
	RTA_SESSION = 13,
	RTA_MP_ALGO = 14,
	RTA_TABLE = 15,
	RTA_MARK = 16,
	RTA_MFC_STATS = 17,
	RTA_VIA = 18,
	RTA_NEWDST = 19,
	RTA_PREF = 20,
	RTA_ENCAP_TYPE = 21,
	RTA_ENCAP = 22,
	RTA_EXPIRES = 23,
	RTA_PAD = 24,
	RTA_UID = 25,
	RTA_TTL_PROPAGATE = 26,
	RTA_IP_PROTO = 27,
	RTA_SPORT = 28,
	RTA_DPORT = 29,
	RTA_NH_ID = 30,
	__RTA_MAX = 31,
};

struct rta_cacheinfo {
	__u32 rta_clntref;
	__u32 rta_lastuse;
	__s32 rta_expires;
	__u32 rta_error;
	__u32 rta_used;
	__u32 rta_id;
	__u32 rta_ts;
	__u32 rta_tsage;
};

struct ifinfomsg {
	unsigned char ifi_family;
	unsigned char __ifi_pad;
	short unsigned int ifi_type;
	int ifi_index;
	unsigned int ifi_flags;
	unsigned int ifi_change;
};

typedef int (*rtnl_doit_func)(struct sk_buff *, struct nlmsghdr *, struct netlink_ext_ack *);

typedef int (*rtnl_dumpit_func)(struct sk_buff *, struct netlink_callback *);

enum rtnl_kinds {
	RTNL_KIND_NEW = 0,
	RTNL_KIND_DEL = 1,
	RTNL_KIND_GET = 2,
	RTNL_KIND_SET = 3,
};

struct rtnl_af_ops {
	struct list_head list;
	int family;
	int (*fill_link_af)(struct sk_buff *, const struct net_device *, u32);
	size_t (*get_link_af_size)(const struct net_device *, u32);
	int (*validate_link_af)(const struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*set_link_af)(struct net_device *, const struct nlattr *, struct netlink_ext_ack *);
	int (*fill_stats_af)(struct sk_buff *, const struct net_device *);
	size_t (*get_stats_af_size)(const struct net_device *);
};

struct rtnl_link {
	rtnl_doit_func doit;
	rtnl_dumpit_func dumpit;
	struct module *owner;
	unsigned int flags;
	struct callback_head rcu;
};

struct rtnl_newlink_tbs {
	struct nlattr *tb[62];
	struct nlattr *attr[51];
	struct nlattr *slave_attr[41];
};

struct rtnl_offload_xstats_request_used {
	bool request;
	bool used;
};

struct rtnl_stats_dump_filters {
	u32 mask[6];
};

enum {
	IF_LINK_MODE_DEFAULT = 0,
	IF_LINK_MODE_DORMANT = 1,
	IF_LINK_MODE_TESTING = 2,
};

enum lw_bits {
	LW_URGENT = 0,
};

enum {
	BPF_F_RECOMPUTE_CSUM = 1,
	BPF_F_INVALIDATE_HASH = 2,
};

enum {
	BPF_F_HDR_FIELD_MASK = 15,
};

enum {
	BPF_F_PSEUDO_HDR = 16,
	BPF_F_MARK_MANGLED_0 = 32,
	BPF_F_MARK_ENFORCE = 64,
};

enum {
	BPF_F_INGRESS = 1,
};

enum {
	BPF_F_TUNINFO_IPV6 = 1,
};

enum {
	BPF_F_ZERO_CSUM_TX = 2,
	BPF_F_DONT_FRAGMENT = 4,
	BPF_F_SEQ_NUMBER = 8,
};

enum {
	BPF_F_TUNINFO_FLAGS = 16,
};

enum {
	BPF_CSUM_LEVEL_QUERY = 0,
	BPF_CSUM_LEVEL_INC = 1,
	BPF_CSUM_LEVEL_DEC = 2,
	BPF_CSUM_LEVEL_RESET = 3,
};

enum {
	BPF_F_ADJ_ROOM_FIXED_GSO = 1,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV4 = 2,
	BPF_F_ADJ_ROOM_ENCAP_L3_IPV6 = 4,
	BPF_F_ADJ_ROOM_ENCAP_L4_GRE = 8,
	BPF_F_ADJ_ROOM_ENCAP_L4_UDP = 16,
	BPF_F_ADJ_ROOM_NO_CSUM_RESET = 32,
	BPF_F_ADJ_ROOM_ENCAP_L2_ETH = 64,
};

enum {
	BPF_ADJ_ROOM_ENCAP_L2_MASK = 255,
	BPF_ADJ_ROOM_ENCAP_L2_SHIFT = 56,
};

enum {
	BPF_SK_LOOKUP_F_REPLACE = 1,
	BPF_SK_LOOKUP_F_NO_REUSEPORT = 2,
};

enum bpf_adj_room_mode {
	BPF_ADJ_ROOM_NET = 0,
	BPF_ADJ_ROOM_MAC = 1,
};

enum bpf_hdr_start_off {
	BPF_HDR_START_MAC = 0,
	BPF_HDR_START_NET = 1,
};

enum {
	BPF_SKB_TSTAMP_UNSPEC = 0,
	BPF_SKB_TSTAMP_DELIVERY_MONO = 1,
};

struct bpf_tunnel_key {
	__u32 tunnel_id;
	union {
		__u32 remote_ipv4;
		__u32 remote_ipv6[4];
	};
	__u8 tunnel_tos;
	__u8 tunnel_ttl;
	union {
		__u16 tunnel_ext;
		__be16 tunnel_flags;
	};
	__u32 tunnel_label;
	union {
		__u32 local_ipv4;
		__u32 local_ipv6[4];
	};
};

struct bpf_tcp_sock {
	__u32 snd_cwnd;
	__u32 srtt_us;
	__u32 rtt_min;
	__u32 snd_ssthresh;
	__u32 rcv_nxt;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 mss_cache;
	__u32 ecn_flags;
	__u32 rate_delivered;
	__u32 rate_interval_us;
	__u32 packets_out;
	__u32 retrans_out;
	__u32 total_retrans;
	__u32 segs_in;
	__u32 data_segs_in;
	__u32 segs_out;
	__u32 data_segs_out;
	__u32 lost_out;
	__u32 sacked_out;
	__u64 bytes_received;
	__u64 bytes_acked;
	__u32 dsack_dups;
	__u32 delivered;
	__u32 delivered_ce;
	__u32 icsk_retransmits;
};

struct bpf_sock_tuple {
	union {
		struct {
			__be32 saddr;
			__be32 daddr;
			__be16 sport;
			__be16 dport;
		} ipv4;
		struct {
			__be32 saddr[4];
			__be32 daddr[4];
			__be16 sport;
			__be16 dport;
		} ipv6;
	};
};

struct bpf_xdp_sock {
	__u32 queue_id;
};

enum {
	BPF_SOCK_OPS_RTO_CB_FLAG = 1,
	BPF_SOCK_OPS_RETRANS_CB_FLAG = 2,
	BPF_SOCK_OPS_STATE_CB_FLAG = 4,
	BPF_SOCK_OPS_RTT_CB_FLAG = 8,
	BPF_SOCK_OPS_PARSE_ALL_HDR_OPT_CB_FLAG = 16,
	BPF_SOCK_OPS_PARSE_UNKNOWN_HDR_OPT_CB_FLAG = 32,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB_FLAG = 64,
	BPF_SOCK_OPS_ALL_CB_FLAGS = 127,
};

enum {
	BPF_SOCK_OPS_VOID = 0,
	BPF_SOCK_OPS_TIMEOUT_INIT = 1,
	BPF_SOCK_OPS_RWND_INIT = 2,
	BPF_SOCK_OPS_TCP_CONNECT_CB = 3,
	BPF_SOCK_OPS_ACTIVE_ESTABLISHED_CB = 4,
	BPF_SOCK_OPS_PASSIVE_ESTABLISHED_CB = 5,
	BPF_SOCK_OPS_NEEDS_ECN = 6,
	BPF_SOCK_OPS_BASE_RTT = 7,
	BPF_SOCK_OPS_RTO_CB = 8,
	BPF_SOCK_OPS_RETRANS_CB = 9,
	BPF_SOCK_OPS_STATE_CB = 10,
	BPF_SOCK_OPS_TCP_LISTEN_CB = 11,
	BPF_SOCK_OPS_RTT_CB = 12,
	BPF_SOCK_OPS_PARSE_HDR_OPT_CB = 13,
	BPF_SOCK_OPS_HDR_OPT_LEN_CB = 14,
	BPF_SOCK_OPS_WRITE_HDR_OPT_CB = 15,
};

enum {
	TCP_BPF_IW = 1001,
	TCP_BPF_SNDCWND_CLAMP = 1002,
	TCP_BPF_DELACK_MAX = 1003,
	TCP_BPF_RTO_MIN = 1004,
	TCP_BPF_SYN = 1005,
	TCP_BPF_SYN_IP = 1006,
	TCP_BPF_SYN_MAC = 1007,
};

enum {
	BPF_LOAD_HDR_OPT_TCP_SYN = 1,
};

enum {
	BPF_FIB_LOOKUP_DIRECT = 1,
	BPF_FIB_LOOKUP_OUTPUT = 2,
};

enum {
	BPF_FIB_LKUP_RET_SUCCESS = 0,
	BPF_FIB_LKUP_RET_BLACKHOLE = 1,
	BPF_FIB_LKUP_RET_UNREACHABLE = 2,
	BPF_FIB_LKUP_RET_PROHIBIT = 3,
	BPF_FIB_LKUP_RET_NOT_FWDED = 4,
	BPF_FIB_LKUP_RET_FWD_DISABLED = 5,
	BPF_FIB_LKUP_RET_UNSUPP_LWT = 6,
	BPF_FIB_LKUP_RET_NO_NEIGH = 7,
	BPF_FIB_LKUP_RET_FRAG_NEEDED = 8,
};

struct bpf_fib_lookup {
	__u8 family;
	__u8 l4_protocol;
	__be16 sport;
	__be16 dport;
	union {
		__u16 tot_len;
		__u16 mtu_result;
	};
	__u32 ifindex;
	union {
		__u8 tos;
		__be32 flowinfo;
		__u32 rt_metric;
	};
	union {
		__be32 ipv4_src;
		__u32 ipv6_src[4];
	};
	union {
		__be32 ipv4_dst;
		__u32 ipv6_dst[4];
	};
	__be16 h_vlan_proto;
	__be16 h_vlan_TCI;
	__u8 smac[6];
	__u8 dmac[6];
};

struct bpf_redir_neigh {
	__u32 nh_family;
	union {
		__be32 ipv4_nh;
		__u32 ipv6_nh[4];
	};
};

enum bpf_check_mtu_flags {
	BPF_MTU_CHK_SEGS = 1,
};

enum bpf_check_mtu_ret {
	BPF_MTU_CHK_RET_SUCCESS = 0,
	BPF_MTU_CHK_RET_FRAG_NEEDED = 1,
	BPF_MTU_CHK_RET_SEGS_TOOBIG = 2,
};

struct seg6_pernet_data {
	struct mutex lock;
	struct in6_addr *tun_src;
};

enum rt_scope_t {
	RT_SCOPE_UNIVERSE = 0,
	RT_SCOPE_SITE = 200,
	RT_SCOPE_LINK = 253,
	RT_SCOPE_HOST = 254,
	RT_SCOPE_NOWHERE = 255,
};

enum rt_class_t {
	RT_TABLE_UNSPEC = 0,
	RT_TABLE_COMPAT = 252,
	RT_TABLE_DEFAULT = 253,
	RT_TABLE_MAIN = 254,
	RT_TABLE_LOCAL = 255,
	RT_TABLE_MAX = 4294967295,
};

struct nl_info {
	struct nlmsghdr *nlh;
	struct net *nl_net;
	u32 portid;
	u8 skip_notify: 1;
	u8 skip_notify_kernel: 1;
};

struct compat_sock_fprog {
	u16 len;
	compat_uptr_t filter;
};

typedef int (*bpf_aux_classic_check_t)(struct sock_filter *, unsigned int);

struct inet_timewait_sock {
	struct sock_common __tw_common;
	__u32 tw_mark;
	volatile unsigned char tw_substate;
	unsigned char tw_rcv_wscale;
	__be16 tw_sport;
	unsigned int tw_transparent: 1;
	unsigned int tw_flowlabel: 20;
	unsigned int tw_pad: 3;
	unsigned int tw_tos: 8;
	u32 tw_txhash;
	u32 tw_priority;
	struct timer_list tw_timer;
	struct inet_bind_bucket *tw_tb;
	int: 32;
};

struct tcp_timewait_sock {
	struct inet_timewait_sock tw_sk;
	u32 tw_rcv_wnd;
	u32 tw_ts_offset;
	u32 tw_ts_recent;
	u32 tw_last_oow_ack_time;
	int tw_ts_recent_stamp;
	u32 tw_tx_delay;
};

struct udp_sock {
	struct inet_sock inet;
	int pending;
	unsigned int corkflag;
	__u8 encap_type;
	unsigned char no_check6_tx: 1;
	unsigned char no_check6_rx: 1;
	unsigned char encap_enabled: 1;
	unsigned char gro_enabled: 1;
	unsigned char accept_udp_l4: 1;
	unsigned char accept_udp_fraglist: 1;
	__u16 len;
	__u16 gso_size;
	__u16 pcslen;
	__u16 pcrlen;
	__u8 pcflag;
	__u8 unused[3];
	int (*encap_rcv)(struct sock *, struct sk_buff *);
	void (*encap_err_rcv)(struct sock *, struct sk_buff *, unsigned int);
	int (*encap_err_lookup)(struct sock *, struct sk_buff *);
	void (*encap_destroy)(struct sock *);
	struct sk_buff * (*gro_receive)(struct sock *, struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sock *, struct sk_buff *, int);
	struct sk_buff_head reader_queue;
	int forward_deficit;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct udp6_sock {
	struct udp_sock udp;
	struct ipv6_pinfo inet6;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct tcp6_sock {
	struct tcp_sock tcp;
	struct ipv6_pinfo inet6;
	int: 32;
};

struct fib_table;

struct fib_result {
	__be32 prefix;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	u32 tclassid;
	struct fib_nh_common *nhc;
	struct fib_info *fi;
	struct fib_table *table;
	struct hlist_head *fa_head;
};

struct fib_table {
	struct hlist_node tb_hlist;
	u32 tb_id;
	int tb_num_default;
	struct callback_head rcu;
	long unsigned int *tb_data;
	long unsigned int __data[0];
};

struct fib6_result;

struct fib6_config;

struct ipv6_stub {
	int (*ipv6_sock_mc_join)(struct sock *, int, const struct in6_addr *);
	int (*ipv6_sock_mc_drop)(struct sock *, int, const struct in6_addr *);
	struct dst_entry * (*ipv6_dst_lookup_flow)(struct net *, const struct sock *, struct flowi6 *, const struct in6_addr *);
	int (*ipv6_route_input)(struct sk_buff *);
	struct fib6_table * (*fib6_get_table)(struct net *, u32);
	int (*fib6_lookup)(struct net *, int, struct flowi6 *, struct fib6_result *, int);
	int (*fib6_table_lookup)(struct net *, struct fib6_table *, int, struct flowi6 *, struct fib6_result *, int);
	void (*fib6_select_path)(const struct net *, struct fib6_result *, struct flowi6 *, int, bool, const struct sk_buff *, int);
	u32 (*ip6_mtu_from_fib6)(const struct fib6_result *, const struct in6_addr *, const struct in6_addr *);
	int (*fib6_nh_init)(struct net *, struct fib6_nh *, struct fib6_config *, gfp_t, struct netlink_ext_ack *);
	void (*fib6_nh_release)(struct fib6_nh *);
	void (*fib6_nh_release_dsts)(struct fib6_nh *);
	void (*fib6_update_sernum)(struct net *, struct fib6_info *);
	int (*ip6_del_rt)(struct net *, struct fib6_info *, bool);
	void (*fib6_rt_update)(struct net *, struct fib6_info *, struct nl_info *);
	void (*udpv6_encap_enable)();
	void (*ndisc_send_na)(struct net_device *, const struct in6_addr *, const struct in6_addr *, bool, bool, bool, bool);
	struct neigh_table *nd_tbl;
	int (*ipv6_fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	struct net_device * (*ipv6_dev_find)(struct net *, const struct in6_addr *, struct net_device *);
};

struct fib6_result {
	struct fib6_nh *nh;
	struct fib6_info *f6i;
	u32 fib6_flags;
	u8 fib6_type;
	struct rt6_info *rt6;
};

struct fib6_config {
	u32 fc_table;
	u32 fc_metric;
	int fc_dst_len;
	int fc_src_len;
	int fc_ifindex;
	u32 fc_flags;
	u32 fc_protocol;
	u16 fc_type;
	u16 fc_delete_all_nh: 1;
	u16 fc_ignore_dev_down: 1;
	u16 __unused: 14;
	u32 fc_nh_id;
	struct in6_addr fc_dst;
	struct in6_addr fc_src;
	struct in6_addr fc_prefsrc;
	struct in6_addr fc_gateway;
	long unsigned int fc_expires;
	struct nlattr *fc_mx;
	int fc_mx_len;
	int fc_mp_len;
	struct nlattr *fc_mp;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
	bool fc_is_fdb;
};

struct ipv6_bpf_stub {
	int (*inet6_bind)(struct sock *, struct sockaddr *, int, u32);
	struct sock * (*udp6_lib_lookup)(struct net *, const struct in6_addr *, __be16, const struct in6_addr *, __be16, int, int, struct udp_table *, struct sk_buff *);
	int (*ipv6_setsockopt)(struct sock *, int, int, sockptr_t, unsigned int);
	int (*ipv6_getsockopt)(struct sock *, int, int, sockptr_t, sockptr_t);
};

enum {
	INET_ECN_NOT_ECT = 0,
	INET_ECN_ECT_1 = 1,
	INET_ECN_ECT_0 = 2,
	INET_ECN_CE = 3,
	INET_ECN_MASK = 3,
};

struct mptcp_sock {};

struct tcp_skb_cb {
	__u32 seq;
	__u32 end_seq;
	union {
		__u32 tcp_tw_isn;
		struct {
			u16 tcp_gso_segs;
			u16 tcp_gso_size;
		};
	};
	__u8 tcp_flags;
	__u8 sacked;
	__u8 ip_dsfield;
	__u8 txstamp_ack: 1;
	__u8 eor: 1;
	__u8 has_rxtstamp: 1;
	__u8 unused: 5;
	__u32 ack_seq;
	int: 32;
	union {
		struct {
			__u32 is_app_limited: 1;
			__u32 delivered_ce: 20;
			__u32 unused: 11;
			__u32 delivered;
			u64 first_tx_mstamp;
			u64 delivered_mstamp;
		} tx;
		union {
			struct inet_skb_parm h4;
			struct inet6_skb_parm h6;
		} header;
	};
};

struct strp_msg {
	int full_len;
	int offset;
};

struct _strp_msg {
	struct strp_msg strp;
	int accum_len;
};

struct tls_msg {
	u8 control;
};

struct sk_skb_cb {
	unsigned char data[20];
	unsigned char pad[4];
	struct _strp_msg strp;
	struct tls_msg tls;
	u64 temp_reg;
};

struct xdp_umem {
	void *addrs;
	int: 32;
	u64 size;
	u32 headroom;
	u32 chunk_size;
	u32 chunks;
	u32 npgs;
	struct user_struct *user;
	refcount_t users;
	u8 flags;
	bool zc;
	struct page **pgs;
	int id;
	struct list_head xsk_dma_list;
	struct work_struct work;
	int: 32;
};

struct xsk_queue;

struct xdp_sock {
	struct sock sk;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct xsk_queue *rx;
	struct net_device *dev;
	struct xdp_umem *umem;
	struct list_head flush_node;
	struct xsk_buff_pool *pool;
	u16 queue_id;
	bool zc;
	enum {
		XSK_READY = 0,
		XSK_BOUND = 1,
		XSK_UNBOUND = 2,
	} state;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct xsk_queue *tx;
	struct list_head tx_list;
	spinlock_t rx_lock;
	u64 rx_dropped;
	u64 rx_queue_full;
	struct list_head map_list;
	spinlock_t map_list_lock;
	struct mutex mutex;
	struct xsk_queue *fq_tmp;
	struct xsk_queue *cq_tmp;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct tls_crypto_info {
	__u16 version;
	__u16 cipher_type;
};

struct tls12_crypto_info_aes_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aes_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_chacha20_poly1305 {
	struct tls_crypto_info info;
	unsigned char iv[12];
	unsigned char key[32];
	unsigned char salt[0];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_sm4_gcm {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_sm4_ccm {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls_strparser {
	struct sock *sk;
	u32 mark: 8;
	u32 stopped: 1;
	u32 copy_mode: 1;
	u32 msg_ready: 1;
	struct strp_msg stm;
	struct sk_buff *anchor;
	struct work_struct work;
};

struct tls_sw_context_rx {
	struct crypto_aead *aead_recv;
	struct crypto_wait async_wait;
	struct sk_buff_head rx_list;
	void (*saved_data_ready)(struct sock *);
	u8 reader_present;
	u8 async_capable: 1;
	u8 zc_capable: 1;
	u8 reader_contended: 1;
	struct tls_strparser strp;
	atomic_t decrypt_pending;
	spinlock_t decrypt_compl_lock;
	struct sk_buff_head async_hold;
	struct wait_queue_head wq;
};

struct tls_prot_info {
	u16 version;
	u16 cipher_type;
	u16 prepend_size;
	u16 tag_size;
	u16 overhead_size;
	u16 iv_size;
	u16 salt_size;
	u16 rec_seq_size;
	u16 aad_size;
	u16 tail_size;
};

struct cipher_context {
	char *iv;
	char *rec_seq;
};

union tls_crypto_context {
	struct tls_crypto_info info;
	union {
		struct tls12_crypto_info_aes_gcm_128 aes_gcm_128;
		struct tls12_crypto_info_aes_gcm_256 aes_gcm_256;
		struct tls12_crypto_info_chacha20_poly1305 chacha20_poly1305;
		struct tls12_crypto_info_sm4_gcm sm4_gcm;
		struct tls12_crypto_info_sm4_ccm sm4_ccm;
	};
};

struct tls_context {
	struct tls_prot_info prot_info;
	u8 tx_conf: 3;
	u8 rx_conf: 3;
	u8 zerocopy_sendfile: 1;
	u8 rx_no_pad: 1;
	int (*push_pending_record)(struct sock *, int);
	void (*sk_write_space)(struct sock *);
	void *priv_ctx_tx;
	void *priv_ctx_rx;
	struct net_device *netdev;
	struct cipher_context tx;
	struct cipher_context rx;
	struct scatterlist *partially_sent_record;
	u16 partially_sent_offset;
	bool in_tcp_sendpages;
	bool pending_open_record_frags;
	struct mutex tx_lock;
	long unsigned int flags;
	struct proto *sk_proto;
	struct sock *sk;
	void (*sk_destruct)(struct sock *);
	union tls_crypto_context crypto_send;
	union tls_crypto_context crypto_recv;
	struct list_head list;
	refcount_t refcount;
	struct callback_head rcu;
};

typedef u64 (*btf_bpf_skb_get_pay_offset)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_get_nlattr)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_get_nlattr_nest)(struct sk_buff *, u32, u32);

typedef u64 (*btf_bpf_skb_load_helper_8)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_8_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_16)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_16_no_cache)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_skb_load_helper_32)(const struct sk_buff *, const void *, int, int);

typedef u64 (*btf_bpf_skb_load_helper_32_no_cache)(const struct sk_buff *, int);

struct bpf_scratchpad {
	union {
		__be32 diff[128];
		u8 buff[512];
	};
};

typedef u64 (*btf_bpf_skb_store_bytes)(struct sk_buff *, u32, const void *, u32, u64);

typedef u64 (*btf_bpf_skb_load_bytes)(const struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_flow_dissector_load_bytes)(const struct bpf_flow_dissector *, u32, void *, u32);

typedef u64 (*btf_bpf_skb_load_bytes_relative)(const struct sk_buff *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_sk_fullsock)(struct sock *);

typedef u64 (*btf_sk_skb_pull_data)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_l3_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_l4_csum_replace)(struct sk_buff *, u32, u64, u64, u64);

typedef u64 (*btf_bpf_csum_diff)(__be32 *, u32, __be32 *, u32, __wsum);

typedef u64 (*btf_bpf_csum_update)(struct sk_buff *, __wsum);

typedef u64 (*btf_bpf_csum_level)(struct sk_buff *, u64);

enum {
	BPF_F_NEIGH = 2,
	BPF_F_PEER = 4,
	BPF_F_NEXTHOP = 8,
};

typedef u64 (*btf_bpf_clone_redirect)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_redirect)(u32, u64);

typedef u64 (*btf_bpf_redirect_peer)(u32, u64);

typedef u64 (*btf_bpf_redirect_neigh)(u32, struct bpf_redir_neigh *, int, u64);

typedef u64 (*btf_bpf_msg_apply_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_cork_bytes)(struct sk_msg *, u32);

typedef u64 (*btf_bpf_msg_pull_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_push_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_msg_pop_data)(struct sk_msg *, u32, u32, u64);

typedef u64 (*btf_bpf_get_cgroup_classid_curr)();

typedef u64 (*btf_bpf_skb_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_cgroup_classid)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_route_realm)(const struct sk_buff *);

typedef u64 (*btf_bpf_get_hash_recalc)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash_invalid)(struct sk_buff *);

typedef u64 (*btf_bpf_set_hash)(struct sk_buff *, u32);

typedef u64 (*btf_bpf_skb_vlan_push)(struct sk_buff *, __be16, u16);

typedef u64 (*btf_bpf_skb_vlan_pop)(struct sk_buff *);

typedef u64 (*btf_bpf_skb_change_proto)(struct sk_buff *, __be16, u64);

typedef u64 (*btf_bpf_skb_change_type)(struct sk_buff *, u32);

typedef u64 (*btf_sk_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_adjust_room)(struct sk_buff *, s32, u32, u64);

typedef u64 (*btf_bpf_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_tail)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_sk_skb_change_head)(struct sk_buff *, u32, u64);

typedef u64 (*btf_bpf_xdp_get_buff_len)(struct xdp_buff *);

typedef u64 (*btf_bpf_xdp_adjust_head)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_load_bytes)(struct xdp_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_xdp_store_bytes)(struct xdp_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_xdp_adjust_tail)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_adjust_meta)(struct xdp_buff *, int);

typedef u64 (*btf_bpf_xdp_redirect)(u32, u64);

typedef u64 (*btf_bpf_xdp_redirect_map)(struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_skb_event_output)(struct sk_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_key)(struct sk_buff *, struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_get_tunnel_opt)(struct sk_buff *, u8 *, u32);

typedef u64 (*btf_bpf_skb_set_tunnel_key)(struct sk_buff *, const struct bpf_tunnel_key *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tunnel_opt)(struct sk_buff *, const u8 *, u32);

typedef u64 (*btf_bpf_skb_under_cgroup)(struct sk_buff *, struct bpf_map *, u32);

typedef u64 (*btf_bpf_skb_cgroup_id)(const struct sk_buff *);

typedef u64 (*btf_bpf_skb_ancestor_cgroup_id)(const struct sk_buff *, int);

typedef u64 (*btf_bpf_sk_cgroup_id)(struct sock *);

typedef u64 (*btf_bpf_sk_ancestor_cgroup_id)(struct sock *, int);

typedef u64 (*btf_bpf_xdp_event_output)(struct xdp_buff *, struct bpf_map *, u64, void *, u64);

typedef u64 (*btf_bpf_get_socket_cookie)(struct sk_buff *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_socket_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_socket_ptr_cookie)(struct sock *);

typedef u64 (*btf_bpf_get_socket_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock)(struct sock *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_addr)(struct bpf_sock_addr_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sock_ops)(struct bpf_sock_ops_kern *);

typedef u64 (*btf_bpf_get_netns_cookie_sk_msg)(struct sk_msg *);

typedef u64 (*btf_bpf_get_socket_uid)(struct sk_buff *);

typedef u64 (*btf_bpf_sk_setsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sk_getsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_unlocked_sk_setsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_unlocked_sk_getsockopt)(struct sock *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_setsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_addr_getsockopt)(struct bpf_sock_addr_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_setsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_getsockopt)(struct bpf_sock_ops_kern *, int, int, char *, int);

typedef u64 (*btf_bpf_sock_ops_cb_flags_set)(struct bpf_sock_ops_kern *, int);

typedef u64 (*btf_bpf_bind)(struct bpf_sock_addr_kern *, struct sockaddr *, int);

typedef u64 (*btf_bpf_xdp_fib_lookup)(struct xdp_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_fib_lookup)(struct sk_buff *, struct bpf_fib_lookup *, int, u32);

typedef u64 (*btf_bpf_skb_check_mtu)(struct sk_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_xdp_check_mtu)(struct xdp_buff *, u32, u32 *, s32, u64);

typedef u64 (*btf_bpf_lwt_in_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_lwt_xmit_push_encap)(struct sk_buff *, u32, void *, u32);

typedef u64 (*btf_bpf_skc_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_tcp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_lookup_udp)(struct sk_buff *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sk_release)(struct sock *);

typedef u64 (*btf_bpf_xdp_sk_lookup_udp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_skc_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_xdp_sk_lookup_tcp)(struct xdp_buff *, struct bpf_sock_tuple *, u32, u32, u64);

typedef u64 (*btf_bpf_sock_addr_skc_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_tcp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_sock_addr_sk_lookup_udp)(struct bpf_sock_addr_kern *, struct bpf_sock_tuple *, u32, u64, u64);

typedef u64 (*btf_bpf_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_get_listener_sock)(struct sock *);

typedef u64 (*btf_bpf_skb_ecn_set_ce)(struct sk_buff *);

typedef u64 (*btf_bpf_tcp_check_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_gen_syncookie)(struct sock *, void *, u32, struct tcphdr *, u32);

typedef u64 (*btf_bpf_sk_assign)(struct sk_buff *, struct sock *, u64);

typedef u64 (*btf_bpf_sock_ops_load_hdr_opt)(struct bpf_sock_ops_kern *, void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_store_hdr_opt)(struct bpf_sock_ops_kern *, const void *, u32, u64);

typedef u64 (*btf_bpf_sock_ops_reserve_hdr_opt)(struct bpf_sock_ops_kern *, u32, u64);

typedef u64 (*btf_bpf_skb_set_tstamp)(struct sk_buff *, u64, u32);

typedef u64 (*btf_bpf_tcp_raw_gen_syncookie_ipv4)(struct iphdr *, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_raw_gen_syncookie_ipv6)(struct ipv6hdr *, struct tcphdr *, u32);

typedef u64 (*btf_bpf_tcp_raw_check_syncookie_ipv4)(struct iphdr *, struct tcphdr *);

typedef u64 (*btf_bpf_tcp_raw_check_syncookie_ipv6)(struct ipv6hdr *, struct tcphdr *);

typedef u64 (*btf_sk_select_reuseport)(struct sk_reuseport_kern *, struct bpf_map *, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes)(const struct sk_reuseport_kern *, u32, void *, u32);

typedef u64 (*btf_sk_reuseport_load_bytes_relative)(const struct sk_reuseport_kern *, u32, void *, u32, u32);

typedef u64 (*btf_bpf_sk_lookup_assign)(struct bpf_sk_lookup_kern *, struct sock *, u64);

typedef u64 (*btf_bpf_skc_to_tcp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_timewait_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_tcp_request_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_udp6_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_unix_sock)(struct sock *);

typedef u64 (*btf_bpf_skc_to_mptcp_sock)(struct sock *);

typedef u64 (*btf_bpf_sock_from_file)(struct file *);

struct unix_sock;

enum {
	INET_DIAG_REQ_NONE = 0,
	INET_DIAG_REQ_BYTECODE = 1,
	INET_DIAG_REQ_SK_BPF_STORAGES = 2,
	INET_DIAG_REQ_PROTOCOL = 3,
	__INET_DIAG_REQ_MAX = 4,
};

struct sock_diag_req {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
};

struct sock_diag_handler {
	__u8 family;
	int (*dump)(struct sk_buff *, struct nlmsghdr *);
	int (*get_info)(struct sk_buff *, struct sock *);
	int (*destroy)(struct sk_buff *, struct nlmsghdr *);
};

struct broadcast_sk {
	struct sock *sk;
	struct work_struct work;
};

struct ifconf {
	int ifc_len;
	union {
		char *ifcu_buf;
		struct ifreq *ifcu_req;
	} ifc_ifcu;
};

enum hwtstamp_flags {
	HWTSTAMP_FLAG_BONDED_PHC_INDEX = 1,
	HWTSTAMP_FLAG_LAST = 1,
	HWTSTAMP_FLAG_MASK = 1,
};

struct compat_ifconf {
	compat_int_t ifc_len;
	compat_caddr_t ifcbuf;
};

struct fib_notifier_info {
	int family;
	struct netlink_ext_ack *extack;
};

enum fib_event_type {
	FIB_EVENT_ENTRY_REPLACE = 0,
	FIB_EVENT_ENTRY_APPEND = 1,
	FIB_EVENT_ENTRY_ADD = 2,
	FIB_EVENT_ENTRY_DEL = 3,
	FIB_EVENT_RULE_ADD = 4,
	FIB_EVENT_RULE_DEL = 5,
	FIB_EVENT_NH_ADD = 6,
	FIB_EVENT_NH_DEL = 7,
	FIB_EVENT_VIF_ADD = 8,
	FIB_EVENT_VIF_DEL = 9,
};

struct fib_notifier_net {
	struct list_head fib_notifier_ops;
	struct atomic_notifier_head fib_chain;
};

struct xdp_frame_bulk {
	int count;
	void *xa;
	void *q[16];
};

struct xdp_attachment_info {
	struct bpf_prog *prog;
	u32 flags;
};

struct xdp_buff_xsk;

struct xdp_desc;

struct xsk_buff_pool {
	struct device *dev;
	struct net_device *netdev;
	struct list_head xsk_tx_list;
	spinlock_t xsk_tx_list_lock;
	refcount_t users;
	struct xdp_umem *umem;
	struct work_struct work;
	struct list_head free_list;
	u32 heads_cnt;
	u16 queue_id;
	int: 16;
	int: 32;
	struct xsk_queue *fq;
	struct xsk_queue *cq;
	dma_addr_t *dma_pages;
	struct xdp_buff_xsk *heads;
	struct xdp_desc *tx_descs;
	int: 32;
	u64 chunk_mask;
	u64 addrs_cnt;
	u32 free_list_cnt;
	u32 dma_pages_cnt;
	u32 free_heads_cnt;
	u32 headroom;
	u32 chunk_size;
	u32 chunk_shift;
	u32 frame_len;
	u8 cached_need_wakeup;
	bool uses_need_wakeup;
	bool dma_need_sync;
	bool unaligned;
	void *addrs;
	spinlock_t cq_lock;
	struct xdp_buff_xsk *free_heads[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct xdp_desc {
	__u64 addr;
	__u32 len;
	__u32 options;
};

struct xdp_buff_xsk {
	struct xdp_buff xdp;
	dma_addr_t dma;
	dma_addr_t frame_dma;
	struct xsk_buff_pool *pool;
	int: 32;
	u64 orig_addr;
	struct list_head free_list_node;
};

struct flow_dissector_key_ports_range {
	union {
		struct flow_dissector_key_ports tp;
		struct {
			struct flow_dissector_key_ports tp_min;
			struct flow_dissector_key_ports tp_max;
		};
	};
};

struct flow_match_meta {
	struct flow_dissector_key_meta *key;
	struct flow_dissector_key_meta *mask;
};

struct flow_match_basic {
	struct flow_dissector_key_basic *key;
	struct flow_dissector_key_basic *mask;
};

struct flow_match_control {
	struct flow_dissector_key_control *key;
	struct flow_dissector_key_control *mask;
};

struct flow_match_eth_addrs {
	struct flow_dissector_key_eth_addrs *key;
	struct flow_dissector_key_eth_addrs *mask;
};

struct flow_match_vlan {
	struct flow_dissector_key_vlan *key;
	struct flow_dissector_key_vlan *mask;
};

struct flow_match_ipv4_addrs {
	struct flow_dissector_key_ipv4_addrs *key;
	struct flow_dissector_key_ipv4_addrs *mask;
};

struct flow_match_ipv6_addrs {
	struct flow_dissector_key_ipv6_addrs *key;
	struct flow_dissector_key_ipv6_addrs *mask;
};

struct flow_match_ip {
	struct flow_dissector_key_ip *key;
	struct flow_dissector_key_ip *mask;
};

struct flow_match_ports {
	struct flow_dissector_key_ports *key;
	struct flow_dissector_key_ports *mask;
};

struct flow_match_ports_range {
	struct flow_dissector_key_ports_range *key;
	struct flow_dissector_key_ports_range *mask;
};

struct flow_match_icmp {
	struct flow_dissector_key_icmp *key;
	struct flow_dissector_key_icmp *mask;
};

struct flow_match_tcp {
	struct flow_dissector_key_tcp *key;
	struct flow_dissector_key_tcp *mask;
};

struct flow_match_mpls {
	struct flow_dissector_key_mpls *key;
	struct flow_dissector_key_mpls *mask;
};

struct flow_match_enc_keyid {
	struct flow_dissector_key_keyid *key;
	struct flow_dissector_key_keyid *mask;
};

struct flow_match_enc_opts {
	struct flow_dissector_key_enc_opts *key;
	struct flow_dissector_key_enc_opts *mask;
};

struct flow_match_ct {
	struct flow_dissector_key_ct *key;
	struct flow_dissector_key_ct *mask;
};

struct flow_match_pppoe {
	struct flow_dissector_key_pppoe *key;
	struct flow_dissector_key_pppoe *mask;
};

struct flow_match_l2tpv3 {
	struct flow_dissector_key_l2tpv3 *key;
	struct flow_dissector_key_l2tpv3 *mask;
};

enum flow_block_command {
	FLOW_BLOCK_BIND = 0,
	FLOW_BLOCK_UNBIND = 1,
};

enum flow_block_binder_type {
	FLOW_BLOCK_BINDER_TYPE_UNSPEC = 0,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_INGRESS = 1,
	FLOW_BLOCK_BINDER_TYPE_CLSACT_EGRESS = 2,
	FLOW_BLOCK_BINDER_TYPE_RED_EARLY_DROP = 3,
	FLOW_BLOCK_BINDER_TYPE_RED_MARK = 4,
};

struct flow_block_offload {
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	bool block_shared;
	bool unlocked_driver_cb;
	struct net *net;
	struct flow_block *block;
	struct list_head cb_list;
	struct list_head *driver_block_list;
	struct netlink_ext_ack *extack;
	struct Qdisc *sch;
	struct list_head *cb_list_head;
};

struct flow_block_cb;

struct flow_block_indr {
	struct list_head list;
	struct net_device *dev;
	struct Qdisc *sch;
	enum flow_block_binder_type binder_type;
	void *data;
	void *cb_priv;
	void (*cleanup)(struct flow_block_cb *);
};

struct flow_block_cb {
	struct list_head driver_list;
	struct list_head list;
	flow_setup_cb_t *cb;
	void *cb_ident;
	void *cb_priv;
	void (*release)(void *);
	struct flow_block_indr indr;
	unsigned int refcnt;
};

enum offload_act_command {
	FLOW_ACT_REPLACE = 0,
	FLOW_ACT_DESTROY = 1,
	FLOW_ACT_STATS = 2,
};

struct flow_offload_action {
	struct netlink_ext_ack *extack;
	enum offload_act_command command;
	enum flow_action_id id;
	u32 index;
	struct flow_stats stats;
	struct flow_action action;
};

typedef int flow_indr_block_bind_cb_t(struct net_device *, struct Qdisc *, void *, enum tc_setup_type, void *, void *, void (*)(struct flow_block_cb *));

struct flow_indr_dev {
	struct list_head list;
	flow_indr_block_bind_cb_t *cb;
	void *cb_priv;
	refcount_t refcnt;
};

struct flow_indir_dev_info {
	void *data;
	struct net_device *dev;
	struct Qdisc *sch;
	enum tc_setup_type type;
	void (*cleanup)(struct flow_block_cb *);
	struct list_head list;
	enum flow_block_command command;
	enum flow_block_binder_type binder_type;
	struct list_head *cb_list;
};

enum gro_result {
	GRO_MERGED = 0,
	GRO_MERGED_FREE = 1,
	GRO_HELD = 2,
	GRO_NORMAL = 3,
	GRO_CONSUMED = 4,
};

typedef enum gro_result gro_result_t;

struct offload_callbacks {
	struct sk_buff * (*gso_segment)(struct sk_buff *, netdev_features_t);
	struct sk_buff * (*gro_receive)(struct list_head *, struct sk_buff *);
	int (*gro_complete)(struct sk_buff *, int);
};

struct packet_offload {
	__be16 type;
	u16 priority;
	struct offload_callbacks callbacks;
	struct list_head list;
};

struct napi_gro_cb {
	void *frag0;
	unsigned int frag0_len;
	int data_offset;
	u16 flush;
	u16 flush_id;
	u16 count;
	u16 proto;
	long unsigned int age;
	union {
		struct {
			u16 gro_remcsum_start;
			u8 same_flow: 1;
			u8 encap_mark: 1;
			u8 csum_valid: 1;
			u8 csum_cnt: 3;
			u8 free: 2;
			u8 is_ipv6: 1;
			u8 is_fou: 1;
			u8 is_atomic: 1;
			u8 recursion_counter: 4;
			u8 is_flist: 1;
		};
		struct {
			u16 gro_remcsum_start;
			u8 same_flow: 1;
			u8 encap_mark: 1;
			u8 csum_valid: 1;
			u8 csum_cnt: 3;
			u8 free: 2;
			u8 is_ipv6: 1;
			u8 is_fou: 1;
			u8 is_atomic: 1;
			u8 recursion_counter: 4;
			u8 is_flist: 1;
		} zeroed;
	};
	__wsum csum;
	struct sk_buff *last;
};

struct rx_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_rx_queue *, char *);
	ssize_t (*store)(struct netdev_rx_queue *, const char *, size_t);
};

struct netdev_queue_attribute {
	struct attribute attr;
	ssize_t (*show)(struct netdev_queue *, char *);
	ssize_t (*store)(struct netdev_queue *, const char *, size_t);
};

struct trace_event_raw_kfree_skb {
	struct trace_entry ent;
	void *skbaddr;
	void *location;
	short unsigned int protocol;
	enum skb_drop_reason reason;
	char __data[0];
};

struct trace_event_raw_consume_skb {
	struct trace_entry ent;
	void *skbaddr;
	char __data[0];
};

struct trace_event_raw_skb_copy_datagram_iovec {
	struct trace_entry ent;
	const void *skbaddr;
	int len;
	char __data[0];
};

struct trace_event_data_offsets_kfree_skb {};

struct trace_event_data_offsets_consume_skb {};

struct trace_event_data_offsets_skb_copy_datagram_iovec {};

typedef void (*btf_trace_kfree_skb)(void *, struct sk_buff *, void *, enum skb_drop_reason);

typedef void (*btf_trace_consume_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_skb_copy_datagram_iovec)(void *, const struct sk_buff *, int);

struct trace_event_raw_net_dev_start_xmit {
	struct trace_entry ent;
	u32 __data_loc_name;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	unsigned int len;
	unsigned int data_len;
	int network_offset;
	bool transport_offset_valid;
	int transport_offset;
	u8 tx_flags;
	u16 gso_size;
	u16 gso_segs;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	int rc;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_xmit_timeout {
	struct trace_entry ent;
	u32 __data_loc_name;
	u32 __data_loc_driver;
	int queue_index;
	char __data[0];
};

struct trace_event_raw_net_dev_template {
	struct trace_entry ent;
	void *skbaddr;
	unsigned int len;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_verbose_template {
	struct trace_entry ent;
	u32 __data_loc_name;
	unsigned int napi_id;
	u16 queue_mapping;
	const void *skbaddr;
	bool vlan_tagged;
	u16 vlan_proto;
	u16 vlan_tci;
	u16 protocol;
	u8 ip_summed;
	u32 hash;
	bool l4_hash;
	unsigned int len;
	unsigned int data_len;
	unsigned int truesize;
	bool mac_header_valid;
	int mac_header;
	unsigned char nr_frags;
	u16 gso_size;
	u16 gso_type;
	char __data[0];
};

struct trace_event_raw_net_dev_rx_exit_template {
	struct trace_entry ent;
	int ret;
	char __data[0];
};

struct trace_event_data_offsets_net_dev_start_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit {
	u32 name;
};

struct trace_event_data_offsets_net_dev_xmit_timeout {
	u32 name;
	u32 driver;
};

struct trace_event_data_offsets_net_dev_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_verbose_template {
	u32 name;
};

struct trace_event_data_offsets_net_dev_rx_exit_template {};

typedef void (*btf_trace_net_dev_start_xmit)(void *, const struct sk_buff *, const struct net_device *);

typedef void (*btf_trace_net_dev_xmit)(void *, struct sk_buff *, int, struct net_device *, unsigned int);

typedef void (*btf_trace_net_dev_xmit_timeout)(void *, struct net_device *, int);

typedef void (*btf_trace_net_dev_queue)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb)(void *, struct sk_buff *);

typedef void (*btf_trace_netif_rx)(void *, struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_receive_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_receive_skb_list_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_netif_rx_entry)(void *, const struct sk_buff *);

typedef void (*btf_trace_napi_gro_frags_exit)(void *, int);

typedef void (*btf_trace_napi_gro_receive_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_exit)(void *, int);

typedef void (*btf_trace_netif_rx_exit)(void *, int);

typedef void (*btf_trace_netif_receive_skb_list_exit)(void *, int);

struct trace_event_raw_napi_poll {
	struct trace_entry ent;
	struct napi_struct *napi;
	u32 __data_loc_dev_name;
	int work;
	int budget;
	char __data[0];
};

struct trace_event_data_offsets_napi_poll {
	u32 dev_name;
};

typedef void (*btf_trace_napi_poll)(void *, struct napi_struct *, int, int);

enum tcp_ca_state {
	TCP_CA_Open = 0,
	TCP_CA_Disorder = 1,
	TCP_CA_CWR = 2,
	TCP_CA_Recovery = 3,
	TCP_CA_Loss = 4,
};

struct trace_event_raw_sock_rcvqueue_full {
	struct trace_entry ent;
	int rmem_alloc;
	unsigned int truesize;
	int sk_rcvbuf;
	char __data[0];
};

struct trace_event_raw_sock_exceed_buf_limit {
	struct trace_entry ent;
	char name[32];
	long int sysctl_mem[3];
	long int allocated;
	int sysctl_rmem;
	int rmem_alloc;
	int sysctl_wmem;
	int wmem_alloc;
	int wmem_queued;
	int kind;
	char __data[0];
};

struct trace_event_raw_inet_sock_set_state {
	struct trace_entry ent;
	const void *skaddr;
	int oldstate;
	int newstate;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_inet_sk_error_report {
	struct trace_entry ent;
	int error;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u16 protocol;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_data_offsets_sock_rcvqueue_full {};

struct trace_event_data_offsets_sock_exceed_buf_limit {};

struct trace_event_data_offsets_inet_sock_set_state {};

struct trace_event_data_offsets_inet_sk_error_report {};

typedef void (*btf_trace_sock_rcvqueue_full)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_sock_exceed_buf_limit)(void *, struct sock *, struct proto *, long int, int);

typedef void (*btf_trace_inet_sock_set_state)(void *, const struct sock *, const int, const int);

typedef void (*btf_trace_inet_sk_error_report)(void *, const struct sock *);

struct trace_event_raw_udp_fail_queue_rcv_skb {
	struct trace_entry ent;
	int rc;
	__u16 lport;
	char __data[0];
};

struct trace_event_data_offsets_udp_fail_queue_rcv_skb {};

typedef void (*btf_trace_udp_fail_queue_rcv_skb)(void *, int, struct sock *);

struct trace_event_raw_tcp_event_sk_skb {
	struct trace_entry ent;
	const void *skbaddr;
	const void *skaddr;
	int state;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_event_sk {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	int: 16;
	int: 32;
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_retransmit_synack {
	struct trace_entry ent;
	const void *skaddr;
	const void *req;
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	char __data[0];
};

struct trace_event_raw_tcp_probe {
	struct trace_entry ent;
	__u8 saddr[28];
	__u8 daddr[28];
	__u16 sport;
	__u16 dport;
	__u16 family;
	__u32 mark;
	__u16 data_len;
	__u32 snd_nxt;
	__u32 snd_una;
	__u32 snd_cwnd;
	__u32 ssthresh;
	__u32 snd_wnd;
	__u32 srtt;
	__u32 rcv_wnd;
	int: 32;
	__u64 sock_cookie;
	char __data[0];
};

struct trace_event_raw_tcp_event_skb {
	struct trace_entry ent;
	const void *skbaddr;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_tcp_cong_state_set {
	struct trace_entry ent;
	const void *skaddr;
	__u16 sport;
	__u16 dport;
	__u8 saddr[4];
	__u8 daddr[4];
	__u8 saddr_v6[16];
	__u8 daddr_v6[16];
	__u8 cong_state;
	char __data[0];
};

struct trace_event_data_offsets_tcp_event_sk_skb {};

struct trace_event_data_offsets_tcp_event_sk {};

struct trace_event_data_offsets_tcp_retransmit_synack {};

struct trace_event_data_offsets_tcp_probe {};

struct trace_event_data_offsets_tcp_event_skb {};

struct trace_event_data_offsets_tcp_cong_state_set {};

typedef void (*btf_trace_tcp_retransmit_skb)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_send_reset)(void *, const struct sock *, const struct sk_buff *);

typedef void (*btf_trace_tcp_receive_reset)(void *, struct sock *);

typedef void (*btf_trace_tcp_destroy_sock)(void *, struct sock *);

typedef void (*btf_trace_tcp_rcv_space_adjust)(void *, struct sock *);

typedef void (*btf_trace_tcp_retransmit_synack)(void *, const struct sock *, const struct request_sock *);

typedef void (*btf_trace_tcp_probe)(void *, struct sock *, struct sk_buff *);

typedef void (*btf_trace_tcp_bad_csum)(void *, const struct sk_buff *);

typedef void (*btf_trace_tcp_cong_state_set)(void *, struct sock *, const u8);

struct trace_event_raw_fib_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	u8 proto;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[4];
	__u8 dst[4];
	__u8 gw4[4];
	__u8 gw6[16];
	u16 sport;
	u16 dport;
	char name[16];
	char __data[0];
};

struct trace_event_data_offsets_fib_table_lookup {};

typedef void (*btf_trace_fib_table_lookup)(void *, u32, const struct flowi4 *, const struct fib_nh_common *, int);

struct trace_event_raw_qdisc_dequeue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	int packets;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	long unsigned int txq_state;
	char __data[0];
};

struct trace_event_raw_qdisc_enqueue {
	struct trace_entry ent;
	struct Qdisc *qdisc;
	const struct netdev_queue *txq;
	void *skbaddr;
	int ifindex;
	u32 handle;
	u32 parent;
	char __data[0];
};

struct trace_event_raw_qdisc_reset {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_destroy {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	u32 handle;
	char __data[0];
};

struct trace_event_raw_qdisc_create {
	struct trace_entry ent;
	u32 __data_loc_dev;
	u32 __data_loc_kind;
	u32 parent;
	char __data[0];
};

struct trace_event_data_offsets_qdisc_dequeue {};

struct trace_event_data_offsets_qdisc_enqueue {};

struct trace_event_data_offsets_qdisc_reset {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_destroy {
	u32 dev;
	u32 kind;
};

struct trace_event_data_offsets_qdisc_create {
	u32 dev;
	u32 kind;
};

typedef void (*btf_trace_qdisc_dequeue)(void *, struct Qdisc *, const struct netdev_queue *, int, struct sk_buff *);

typedef void (*btf_trace_qdisc_enqueue)(void *, struct Qdisc *, const struct netdev_queue *, struct sk_buff *);

typedef void (*btf_trace_qdisc_reset)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_destroy)(void *, struct Qdisc *);

typedef void (*btf_trace_qdisc_create)(void *, const struct Qdisc_ops *, struct net_device *, u32);

struct bridge_stp_xstats {
	__u64 transition_blk;
	__u64 transition_fwd;
	__u64 rx_bpdu;
	__u64 tx_bpdu;
	__u64 rx_tcn;
	__u64 tx_tcn;
};

struct br_mcast_stats {
	__u64 igmp_v1queries[2];
	__u64 igmp_v2queries[2];
	__u64 igmp_v3queries[2];
	__u64 igmp_leaves[2];
	__u64 igmp_v1reports[2];
	__u64 igmp_v2reports[2];
	__u64 igmp_v3reports[2];
	__u64 igmp_parse_errors;
	__u64 mld_v1queries[2];
	__u64 mld_v2queries[2];
	__u64 mld_leaves[2];
	__u64 mld_v1reports[2];
	__u64 mld_v2reports[2];
	__u64 mld_parse_errors;
	__u64 mcast_bytes[2];
	__u64 mcast_packets[2];
};

struct br_ip {
	union {
		__be32 ip4;
		struct in6_addr ip6;
	} src;
	union {
		__be32 ip4;
		struct in6_addr ip6;
		unsigned char mac_addr[6];
	} dst;
	__be16 proto;
	__u16 vid;
};

struct bridge_id {
	unsigned char prio[2];
	unsigned char addr[6];
};

typedef struct bridge_id bridge_id;

struct mac_addr {
	unsigned char addr[6];
};

typedef struct mac_addr mac_addr;

typedef __u16 port_id;

struct bridge_mcast_own_query {
	struct timer_list timer;
	u32 startup_sent;
};

struct bridge_mcast_other_query {
	struct timer_list timer;
	long unsigned int delay_time;
};

struct bridge_mcast_querier {
	struct br_ip addr;
	int port_ifidx;
	seqcount_spinlock_t seq;
};

struct bridge_mcast_stats {
	struct br_mcast_stats mstats;
	struct u64_stats_sync syncp;
	int: 32;
};

struct net_bridge_port;

struct net_bridge_vlan;

struct net_bridge_mcast_port {
	struct net_bridge_port *port;
	struct net_bridge_vlan *vlan;
	struct bridge_mcast_own_query ip4_own_query;
	struct timer_list ip4_mc_router_timer;
	struct hlist_node ip4_rlist;
	struct bridge_mcast_own_query ip6_own_query;
	struct timer_list ip6_mc_router_timer;
	struct hlist_node ip6_rlist;
	unsigned char multicast_router;
};

struct net_bridge;

struct net_bridge_vlan_group;

struct net_bridge_port {
	struct net_bridge *br;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct list_head list;
	long unsigned int flags;
	struct net_bridge_vlan_group *vlgrp;
	struct net_bridge_port *backup_port;
	u8 priority;
	u8 state;
	u16 port_no;
	unsigned char topology_change_ack;
	unsigned char config_pending;
	port_id port_id;
	port_id designated_port;
	bridge_id designated_root;
	bridge_id designated_bridge;
	u32 path_cost;
	u32 designated_cost;
	long unsigned int designated_age;
	struct timer_list forward_delay_timer;
	struct timer_list hold_timer;
	struct timer_list message_age_timer;
	struct kobject kobj;
	struct callback_head rcu;
	struct net_bridge_mcast_port multicast_ctx;
	struct bridge_mcast_stats *mcast_stats;
	u32 multicast_eht_hosts_limit;
	u32 multicast_eht_hosts_cnt;
	struct hlist_head mglist;
	char sysfs_name[16];
	int hwdom;
	int offload_count;
	struct netdev_phys_item_id ppid;
	u16 group_fwd_mask;
	u16 backup_redirected_cnt;
	struct bridge_stp_xstats stp_xstats;
};

struct metadata_dst;

struct br_tunnel_info {
	__be64 tunnel_id;
	struct metadata_dst *tunnel_dst;
	int: 32;
};

struct net_bridge_mcast {
	struct net_bridge *br;
	struct net_bridge_vlan *vlan;
	u32 multicast_last_member_count;
	u32 multicast_startup_query_count;
	u8 multicast_querier;
	u8 multicast_igmp_version;
	u8 multicast_router;
	u8 multicast_mld_version;
	long unsigned int multicast_last_member_interval;
	long unsigned int multicast_membership_interval;
	long unsigned int multicast_querier_interval;
	long unsigned int multicast_query_interval;
	long unsigned int multicast_query_response_interval;
	long unsigned int multicast_startup_query_interval;
	struct hlist_head ip4_mc_router_list;
	struct timer_list ip4_mc_router_timer;
	struct bridge_mcast_other_query ip4_other_query;
	struct bridge_mcast_own_query ip4_own_query;
	struct bridge_mcast_querier ip4_querier;
	struct hlist_head ip6_mc_router_list;
	struct timer_list ip6_mc_router_timer;
	struct bridge_mcast_other_query ip6_other_query;
	struct bridge_mcast_own_query ip6_own_query;
	struct bridge_mcast_querier ip6_querier;
};

struct net_bridge_vlan {
	struct rhash_head vnode;
	struct rhash_head tnode;
	u16 vid;
	u16 flags;
	u16 priv_flags;
	u8 state;
	struct pcpu_sw_netstats *stats;
	union {
		struct net_bridge *br;
		struct net_bridge_port *port;
	};
	union {
		refcount_t refcnt;
		struct net_bridge_vlan *brvlan;
	};
	int: 32;
	struct br_tunnel_info tinfo;
	union {
		struct net_bridge_mcast br_mcast_ctx;
		struct net_bridge_mcast_port port_mcast_ctx;
	};
	u16 msti;
	struct list_head vlist;
	struct callback_head rcu;
};

struct net_bridge {
	spinlock_t lock;
	spinlock_t hash_lock;
	struct hlist_head frame_type_list;
	struct net_device *dev;
	long unsigned int options;
	__be16 vlan_proto;
	u16 default_pvid;
	struct net_bridge_vlan_group *vlgrp;
	struct rhashtable fdb_hash_tbl;
	struct list_head port_list;
	u16 group_fwd_mask;
	u16 group_fwd_mask_required;
	bridge_id designated_root;
	bridge_id bridge_id;
	unsigned char topology_change;
	unsigned char topology_change_detected;
	u16 root_port;
	long unsigned int max_age;
	long unsigned int hello_time;
	long unsigned int forward_delay;
	long unsigned int ageing_time;
	long unsigned int bridge_max_age;
	long unsigned int bridge_hello_time;
	long unsigned int bridge_forward_delay;
	long unsigned int bridge_ageing_time;
	u32 root_path_cost;
	u8 group_addr[6];
	enum {
		BR_NO_STP = 0,
		BR_KERNEL_STP = 1,
		BR_USER_STP = 2,
	} stp_enabled;
	struct net_bridge_mcast multicast_ctx;
	struct bridge_mcast_stats *mcast_stats;
	u32 hash_max;
	spinlock_t multicast_lock;
	struct rhashtable mdb_hash_tbl;
	struct rhashtable sg_port_tbl;
	struct hlist_head mcast_gc_list;
	struct hlist_head mdb_list;
	struct work_struct mcast_gc_work;
	struct timer_list hello_timer;
	struct timer_list tcn_timer;
	struct timer_list topology_change_timer;
	struct delayed_work gc_work;
	struct kobject *ifobj;
	u32 auto_cnt;
	int last_hwdom;
	long unsigned int busy_hwdoms;
	struct hlist_head fdb_list;
};

struct net_bridge_vlan_group {
	struct rhashtable vlan_hash;
	struct rhashtable tunnel_hash;
	struct list_head vlan_list;
	u16 num_vlans;
	u16 pvid;
	u8 pvid_state;
};

struct net_bridge_fdb_key {
	mac_addr addr;
	u16 vlan_id;
};

struct net_bridge_fdb_entry {
	struct rhash_head rhnode;
	struct net_bridge_port *dst;
	struct net_bridge_fdb_key key;
	struct hlist_node fdb_node;
	long unsigned int flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	long unsigned int updated;
	long unsigned int used;
	struct callback_head rcu;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct trace_event_raw_br_fdb_add {
	struct trace_entry ent;
	u8 ndm_flags;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	u16 nlh_flags;
	char __data[0];
};

struct trace_event_raw_br_fdb_external_learn_add {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_fdb_delete {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	char __data[0];
};

struct trace_event_raw_br_fdb_update {
	struct trace_entry ent;
	u32 __data_loc_br_dev;
	u32 __data_loc_dev;
	unsigned char addr[6];
	u16 vid;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_data_offsets_br_fdb_add {
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_external_learn_add {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_fdb_delete {
	u32 br_dev;
	u32 dev;
};

struct trace_event_data_offsets_br_fdb_update {
	u32 br_dev;
	u32 dev;
};

typedef void (*btf_trace_br_fdb_add)(void *, struct ndmsg *, struct net_device *, const unsigned char *, u16, u16);

typedef void (*btf_trace_br_fdb_external_learn_add)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16);

typedef void (*btf_trace_fdb_delete)(void *, struct net_bridge *, struct net_bridge_fdb_entry *);

typedef void (*btf_trace_br_fdb_update)(void *, struct net_bridge *, struct net_bridge_port *, const unsigned char *, u16, long unsigned int);

struct trace_event_raw_page_pool_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	s32 inflight;
	u32 hold;
	u32 release;
	u64 cnt;
	char __data[0];
};

struct trace_event_raw_page_pool_state_release {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 release;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_state_hold {
	struct trace_entry ent;
	const struct page_pool *pool;
	const struct page *page;
	u32 hold;
	long unsigned int pfn;
	char __data[0];
};

struct trace_event_raw_page_pool_update_nid {
	struct trace_entry ent;
	const struct page_pool *pool;
	int pool_nid;
	int new_nid;
	char __data[0];
};

struct trace_event_data_offsets_page_pool_release {};

struct trace_event_data_offsets_page_pool_state_release {};

struct trace_event_data_offsets_page_pool_state_hold {};

struct trace_event_data_offsets_page_pool_update_nid {};

typedef void (*btf_trace_page_pool_release)(void *, const struct page_pool *, s32, u32, u32);

typedef void (*btf_trace_page_pool_state_release)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_state_hold)(void *, const struct page_pool *, const struct page *, u32);

typedef void (*btf_trace_page_pool_update_nid)(void *, const struct page_pool *, int);

struct trace_event_raw_neigh_create {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	int entries;
	u8 created;
	u8 gc_exempt;
	u8 primary_key4[4];
	u8 primary_key6[16];
	char __data[0];
};

struct trace_event_raw_neigh_update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u8 new_lladdr[32];
	u8 new_state;
	u32 update_flags;
	u32 pid;
	char __data[0];
};

struct trace_event_raw_neigh__update {
	struct trace_entry ent;
	u32 family;
	u32 __data_loc_dev;
	u8 lladdr[32];
	u8 lladdr_len;
	u8 flags;
	u8 nud_state;
	u8 type;
	u8 dead;
	int refcnt;
	__u8 primary_key4[4];
	__u8 primary_key6[16];
	long unsigned int confirmed;
	long unsigned int updated;
	long unsigned int used;
	u32 err;
	char __data[0];
};

struct trace_event_data_offsets_neigh_create {
	u32 dev;
};

struct trace_event_data_offsets_neigh_update {
	u32 dev;
};

struct trace_event_data_offsets_neigh__update {
	u32 dev;
};

typedef void (*btf_trace_neigh_create)(void *, struct neigh_table *, struct net_device *, const void *, const struct neighbour *, bool);

typedef void (*btf_trace_neigh_update)(void *, struct neighbour *, const u8 *, u8, u32, u32);

typedef void (*btf_trace_neigh_update_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_timer_handler)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_done)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_event_send_dead)(void *, struct neighbour *, int);

typedef void (*btf_trace_neigh_cleanup_and_release)(void *, struct neighbour *, int);

struct net_packet_attrs {
	const unsigned char *src;
	const unsigned char *dst;
	u32 ip_src;
	u32 ip_dst;
	bool tcp;
	u16 sport;
	u16 dport;
	int timeout;
	int size;
	int max_size;
	u8 id;
	u16 queue_mapping;
};

struct net_test_priv {
	struct net_packet_attrs *packet;
	struct packet_type pt;
	struct completion comp;
	int double_vlan;
	int vlan_id;
	int ok;
};

struct netsfhdr {
	__be32 version;
	__be64 magic;
	u8 id;
} __attribute__((packed));

struct net_test {
	char name[32];
	int (*fn)(struct net_device *);
};

struct update_classid_context {
	u32 classid;
	unsigned int batch;
};

struct dst_cache_pcpu {
	long unsigned int refresh_ts;
	struct dst_entry *dst;
	u32 cookie;
	union {
		struct in_addr in_saddr;
		struct in6_addr in6_saddr;
	};
};

struct irq_poll;

typedef int irq_poll_fn(struct irq_poll *, int);

struct irq_poll {
	struct list_head list;
	long unsigned int state;
	int weight;
	irq_poll_fn *poll;
};

struct dim_sample {
	ktime_t time;
	u32 pkt_ctr;
	u32 byte_ctr;
	u16 event_ctr;
	u32 comp_ctr;
};

struct dim_stats {
	int ppms;
	int bpms;
	int epms;
	int cpms;
	int cpe_ratio;
};

struct dim {
	u8 state;
	struct dim_stats prev_stats;
	struct dim_sample start_sample;
	struct dim_sample measuring_sample;
	struct work_struct work;
	void *priv;
	u8 profile_ix;
	u8 mode;
	u8 tune_state;
	u8 steps_right;
	u8 steps_left;
	u8 tired;
	int: 16;
	int: 32;
};

enum ib_uverbs_write_cmds {
	IB_USER_VERBS_CMD_GET_CONTEXT = 0,
	IB_USER_VERBS_CMD_QUERY_DEVICE = 1,
	IB_USER_VERBS_CMD_QUERY_PORT = 2,
	IB_USER_VERBS_CMD_ALLOC_PD = 3,
	IB_USER_VERBS_CMD_DEALLOC_PD = 4,
	IB_USER_VERBS_CMD_CREATE_AH = 5,
	IB_USER_VERBS_CMD_MODIFY_AH = 6,
	IB_USER_VERBS_CMD_QUERY_AH = 7,
	IB_USER_VERBS_CMD_DESTROY_AH = 8,
	IB_USER_VERBS_CMD_REG_MR = 9,
	IB_USER_VERBS_CMD_REG_SMR = 10,
	IB_USER_VERBS_CMD_REREG_MR = 11,
	IB_USER_VERBS_CMD_QUERY_MR = 12,
	IB_USER_VERBS_CMD_DEREG_MR = 13,
	IB_USER_VERBS_CMD_ALLOC_MW = 14,
	IB_USER_VERBS_CMD_BIND_MW = 15,
	IB_USER_VERBS_CMD_DEALLOC_MW = 16,
	IB_USER_VERBS_CMD_CREATE_COMP_CHANNEL = 17,
	IB_USER_VERBS_CMD_CREATE_CQ = 18,
	IB_USER_VERBS_CMD_RESIZE_CQ = 19,
	IB_USER_VERBS_CMD_DESTROY_CQ = 20,
	IB_USER_VERBS_CMD_POLL_CQ = 21,
	IB_USER_VERBS_CMD_PEEK_CQ = 22,
	IB_USER_VERBS_CMD_REQ_NOTIFY_CQ = 23,
	IB_USER_VERBS_CMD_CREATE_QP = 24,
	IB_USER_VERBS_CMD_QUERY_QP = 25,
	IB_USER_VERBS_CMD_MODIFY_QP = 26,
	IB_USER_VERBS_CMD_DESTROY_QP = 27,
	IB_USER_VERBS_CMD_POST_SEND = 28,
	IB_USER_VERBS_CMD_POST_RECV = 29,
	IB_USER_VERBS_CMD_ATTACH_MCAST = 30,
	IB_USER_VERBS_CMD_DETACH_MCAST = 31,
	IB_USER_VERBS_CMD_CREATE_SRQ = 32,
	IB_USER_VERBS_CMD_MODIFY_SRQ = 33,
	IB_USER_VERBS_CMD_QUERY_SRQ = 34,
	IB_USER_VERBS_CMD_DESTROY_SRQ = 35,
	IB_USER_VERBS_CMD_POST_SRQ_RECV = 36,
	IB_USER_VERBS_CMD_OPEN_XRCD = 37,
	IB_USER_VERBS_CMD_CLOSE_XRCD = 38,
	IB_USER_VERBS_CMD_CREATE_XSRQ = 39,
	IB_USER_VERBS_CMD_OPEN_QP = 40,
};

enum ib_uverbs_wc_opcode {
	IB_UVERBS_WC_SEND = 0,
	IB_UVERBS_WC_RDMA_WRITE = 1,
	IB_UVERBS_WC_RDMA_READ = 2,
	IB_UVERBS_WC_COMP_SWAP = 3,
	IB_UVERBS_WC_FETCH_ADD = 4,
	IB_UVERBS_WC_BIND_MW = 5,
	IB_UVERBS_WC_LOCAL_INV = 6,
	IB_UVERBS_WC_TSO = 7,
};

enum ib_uverbs_create_qp_mask {
	IB_UVERBS_CREATE_QP_MASK_IND_TABLE = 1,
};

enum ib_uverbs_wr_opcode {
	IB_UVERBS_WR_RDMA_WRITE = 0,
	IB_UVERBS_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_UVERBS_WR_SEND = 2,
	IB_UVERBS_WR_SEND_WITH_IMM = 3,
	IB_UVERBS_WR_RDMA_READ = 4,
	IB_UVERBS_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_UVERBS_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_UVERBS_WR_LOCAL_INV = 7,
	IB_UVERBS_WR_BIND_MW = 8,
	IB_UVERBS_WR_SEND_WITH_INV = 9,
	IB_UVERBS_WR_TSO = 10,
	IB_UVERBS_WR_RDMA_READ_WITH_INV = 11,
	IB_UVERBS_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_UVERBS_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
};

enum ib_uverbs_device_cap_flags {
	IB_UVERBS_DEVICE_RESIZE_MAX_WR = 1,
	IB_UVERBS_DEVICE_BAD_PKEY_CNTR = 2,
	IB_UVERBS_DEVICE_BAD_QKEY_CNTR = 4,
	IB_UVERBS_DEVICE_RAW_MULTI = 8,
	IB_UVERBS_DEVICE_AUTO_PATH_MIG = 16,
	IB_UVERBS_DEVICE_CHANGE_PHY_PORT = 32,
	IB_UVERBS_DEVICE_UD_AV_PORT_ENFORCE = 64,
	IB_UVERBS_DEVICE_CURR_QP_STATE_MOD = 128,
	IB_UVERBS_DEVICE_SHUTDOWN_PORT = 256,
	IB_UVERBS_DEVICE_PORT_ACTIVE_EVENT = 1024,
	IB_UVERBS_DEVICE_SYS_IMAGE_GUID = 2048,
	IB_UVERBS_DEVICE_RC_RNR_NAK_GEN = 4096,
	IB_UVERBS_DEVICE_SRQ_RESIZE = 8192,
	IB_UVERBS_DEVICE_N_NOTIFY_CQ = 16384,
	IB_UVERBS_DEVICE_MEM_WINDOW = 131072,
	IB_UVERBS_DEVICE_UD_IP_CSUM = 262144,
	IB_UVERBS_DEVICE_XRC = 1048576,
	IB_UVERBS_DEVICE_MEM_MGT_EXTENSIONS = 2097152,
	IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2A = 8388608,
	IB_UVERBS_DEVICE_MEM_WINDOW_TYPE_2B = 16777216,
	IB_UVERBS_DEVICE_RC_IP_CSUM = 33554432,
	IB_UVERBS_DEVICE_RAW_IP_CSUM = 67108864,
	IB_UVERBS_DEVICE_MANAGED_FLOW_STEERING = 536870912,
	IB_UVERBS_DEVICE_RAW_SCATTER_FCS = 0,
	IB_UVERBS_DEVICE_PCI_WRITE_END_PADDING = 0,
};

enum ib_uverbs_raw_packet_caps {
	IB_UVERBS_RAW_PACKET_CAP_CVLAN_STRIPPING = 1,
	IB_UVERBS_RAW_PACKET_CAP_SCATTER_FCS = 2,
	IB_UVERBS_RAW_PACKET_CAP_IP_CSUM = 4,
	IB_UVERBS_RAW_PACKET_CAP_DELAY_DROP = 8,
};

enum rdma_nl_counter_mode {
	RDMA_COUNTER_MODE_NONE = 0,
	RDMA_COUNTER_MODE_AUTO = 1,
	RDMA_COUNTER_MODE_MANUAL = 2,
	RDMA_COUNTER_MODE_MAX = 3,
};

enum rdma_nl_counter_mask {
	RDMA_COUNTER_MASK_QP_TYPE = 1,
	RDMA_COUNTER_MASK_PID = 2,
};

enum rdma_restrack_type {
	RDMA_RESTRACK_PD = 0,
	RDMA_RESTRACK_CQ = 1,
	RDMA_RESTRACK_QP = 2,
	RDMA_RESTRACK_CM_ID = 3,
	RDMA_RESTRACK_MR = 4,
	RDMA_RESTRACK_CTX = 5,
	RDMA_RESTRACK_COUNTER = 6,
	RDMA_RESTRACK_SRQ = 7,
	RDMA_RESTRACK_MAX = 8,
};

struct rdma_restrack_entry {
	bool valid;
	u8 no_track: 1;
	struct kref kref;
	struct completion comp;
	struct task_struct *task;
	const char *kern_name;
	enum rdma_restrack_type type;
	bool user;
	u32 id;
};

struct rdma_link_ops {
	struct list_head list;
	const char *type;
	int (*newlink)(const char *, struct net_device *);
};

struct auto_mode_param {
	int qp_type;
};

struct rdma_counter_mode {
	enum rdma_nl_counter_mode mode;
	enum rdma_nl_counter_mask mask;
	struct auto_mode_param param;
};

struct rdma_hw_stats;

struct rdma_port_counter {
	struct rdma_counter_mode mode;
	struct rdma_hw_stats *hstats;
	unsigned int num_counters;
	struct mutex lock;
};

struct rdma_stat_desc;

struct rdma_hw_stats {
	struct mutex lock;
	long unsigned int timestamp;
	long unsigned int lifespan;
	const struct rdma_stat_desc *descs;
	long unsigned int *is_disabled;
	int num_counters;
	u64 value[0];
};

struct ib_device;

struct rdma_counter {
	struct rdma_restrack_entry res;
	struct ib_device *device;
	uint32_t id;
	struct kref kref;
	struct rdma_counter_mode mode;
	struct mutex lock;
	struct rdma_hw_stats *stats;
	u32 port;
};

enum rdma_driver_id {
	RDMA_DRIVER_UNKNOWN = 0,
	RDMA_DRIVER_MLX5 = 1,
	RDMA_DRIVER_MLX4 = 2,
	RDMA_DRIVER_CXGB3 = 3,
	RDMA_DRIVER_CXGB4 = 4,
	RDMA_DRIVER_MTHCA = 5,
	RDMA_DRIVER_BNXT_RE = 6,
	RDMA_DRIVER_OCRDMA = 7,
	RDMA_DRIVER_NES = 8,
	RDMA_DRIVER_I40IW = 9,
	RDMA_DRIVER_IRDMA = 9,
	RDMA_DRIVER_VMW_PVRDMA = 10,
	RDMA_DRIVER_QEDR = 11,
	RDMA_DRIVER_HNS = 12,
	RDMA_DRIVER_USNIC = 13,
	RDMA_DRIVER_RXE = 14,
	RDMA_DRIVER_HFI1 = 15,
	RDMA_DRIVER_QIB = 16,
	RDMA_DRIVER_EFA = 17,
	RDMA_DRIVER_SIW = 18,
	RDMA_DRIVER_ERDMA = 19,
};

enum ib_cq_notify_flags {
	IB_CQ_SOLICITED = 1,
	IB_CQ_NEXT_COMP = 2,
	IB_CQ_SOLICITED_MASK = 3,
	IB_CQ_REPORT_MISSED_EVENTS = 4,
};

struct ib_mad;

enum rdma_link_layer {
	IB_LINK_LAYER_UNSPECIFIED = 0,
	IB_LINK_LAYER_INFINIBAND = 1,
	IB_LINK_LAYER_ETHERNET = 2,
};

enum rdma_netdev_t {
	RDMA_NETDEV_OPA_VNIC = 0,
	RDMA_NETDEV_IPOIB = 1,
};

enum ib_srq_attr_mask {
	IB_SRQ_MAX_WR = 1,
	IB_SRQ_LIMIT = 2,
};

enum ib_mr_type {
	IB_MR_TYPE_MEM_REG = 0,
	IB_MR_TYPE_SG_GAPS = 1,
	IB_MR_TYPE_DM = 2,
	IB_MR_TYPE_USER = 3,
	IB_MR_TYPE_DMA = 4,
	IB_MR_TYPE_INTEGRITY = 5,
};

enum ib_uverbs_advise_mr_advice {
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH = 0,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE = 1,
	IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_NO_FAULT = 2,
};

struct uverbs_attr_bundle;

struct rdma_cm_id;

struct iw_cm_id;

struct iw_cm_conn_param;

struct ib_qp;

struct ib_send_wr;

struct ib_recv_wr;

struct ib_cq;

struct ib_wc;

struct ib_srq;

struct ib_grh;

struct ib_device_attr;

struct ib_udata;

struct ib_device_modify;

struct ib_port_attr;

struct ib_port_modify;

struct ib_port_immutable;

struct rdma_netdev_alloc_params;

union ib_gid;

struct ib_gid_attr;

struct ib_ucontext;

struct rdma_user_mmap_entry;

struct ib_pd;

struct ib_ah;

struct rdma_ah_init_attr;

struct rdma_ah_attr;

struct ib_srq_init_attr;

struct ib_srq_attr;

struct ib_qp_init_attr;

struct ib_qp_attr;

struct ib_cq_init_attr;

struct ib_mr;

struct ib_sge;

struct ib_mr_status;

struct ib_mw;

struct ib_xrcd;

struct ib_flow;

struct ib_flow_attr;

struct ib_flow_action;

struct ib_wq;

struct ib_wq_init_attr;

struct ib_wq_attr;

struct ib_rwq_ind_table;

struct ib_rwq_ind_table_init_attr;

struct ib_dm;

struct ib_dm_alloc_attr;

struct ib_dm_mr_attr;

struct ib_counters;

struct ib_counters_read_attr;

struct ib_device_ops {
	struct module *owner;
	enum rdma_driver_id driver_id;
	u32 uverbs_abi_ver;
	unsigned int uverbs_no_driver_id_binding: 1;
	const struct attribute_group *device_group;
	const struct attribute_group **port_groups;
	int (*post_send)(struct ib_qp *, const struct ib_send_wr *, const struct ib_send_wr **);
	int (*post_recv)(struct ib_qp *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	void (*drain_rq)(struct ib_qp *);
	void (*drain_sq)(struct ib_qp *);
	int (*poll_cq)(struct ib_cq *, int, struct ib_wc *);
	int (*peek_cq)(struct ib_cq *, int);
	int (*req_notify_cq)(struct ib_cq *, enum ib_cq_notify_flags);
	int (*post_srq_recv)(struct ib_srq *, const struct ib_recv_wr *, const struct ib_recv_wr **);
	int (*process_mad)(struct ib_device *, int, u32, const struct ib_wc *, const struct ib_grh *, const struct ib_mad *, struct ib_mad *, size_t *, u16 *);
	int (*query_device)(struct ib_device *, struct ib_device_attr *, struct ib_udata *);
	int (*modify_device)(struct ib_device *, int, struct ib_device_modify *);
	void (*get_dev_fw_str)(struct ib_device *, char *);
	const struct cpumask * (*get_vector_affinity)(struct ib_device *, int);
	int (*query_port)(struct ib_device *, u32, struct ib_port_attr *);
	int (*modify_port)(struct ib_device *, u32, int, struct ib_port_modify *);
	int (*get_port_immutable)(struct ib_device *, u32, struct ib_port_immutable *);
	enum rdma_link_layer (*get_link_layer)(struct ib_device *, u32);
	struct net_device * (*get_netdev)(struct ib_device *, u32);
	struct net_device * (*alloc_rdma_netdev)(struct ib_device *, u32, enum rdma_netdev_t, const char *, unsigned char, void (*)(struct net_device *));
	int (*rdma_netdev_get_params)(struct ib_device *, u32, enum rdma_netdev_t, struct rdma_netdev_alloc_params *);
	int (*query_gid)(struct ib_device *, u32, int, union ib_gid *);
	int (*add_gid)(const struct ib_gid_attr *, void **);
	int (*del_gid)(const struct ib_gid_attr *, void **);
	int (*query_pkey)(struct ib_device *, u32, u16, u16 *);
	int (*alloc_ucontext)(struct ib_ucontext *, struct ib_udata *);
	void (*dealloc_ucontext)(struct ib_ucontext *);
	int (*mmap)(struct ib_ucontext *, struct vm_area_struct *);
	void (*mmap_free)(struct rdma_user_mmap_entry *);
	void (*disassociate_ucontext)(struct ib_ucontext *);
	int (*alloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*dealloc_pd)(struct ib_pd *, struct ib_udata *);
	int (*create_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*create_user_ah)(struct ib_ah *, struct rdma_ah_init_attr *, struct ib_udata *);
	int (*modify_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*query_ah)(struct ib_ah *, struct rdma_ah_attr *);
	int (*destroy_ah)(struct ib_ah *, u32);
	int (*create_srq)(struct ib_srq *, struct ib_srq_init_attr *, struct ib_udata *);
	int (*modify_srq)(struct ib_srq *, struct ib_srq_attr *, enum ib_srq_attr_mask, struct ib_udata *);
	int (*query_srq)(struct ib_srq *, struct ib_srq_attr *);
	int (*destroy_srq)(struct ib_srq *, struct ib_udata *);
	int (*create_qp)(struct ib_qp *, struct ib_qp_init_attr *, struct ib_udata *);
	int (*modify_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_udata *);
	int (*query_qp)(struct ib_qp *, struct ib_qp_attr *, int, struct ib_qp_init_attr *);
	int (*destroy_qp)(struct ib_qp *, struct ib_udata *);
	int (*create_cq)(struct ib_cq *, const struct ib_cq_init_attr *, struct ib_udata *);
	int (*modify_cq)(struct ib_cq *, u16, u16);
	int (*destroy_cq)(struct ib_cq *, struct ib_udata *);
	int (*resize_cq)(struct ib_cq *, int, struct ib_udata *);
	struct ib_mr * (*get_dma_mr)(struct ib_pd *, int);
	struct ib_mr * (*reg_user_mr)(struct ib_pd *, u64, u64, u64, int, struct ib_udata *);
	struct ib_mr * (*reg_user_mr_dmabuf)(struct ib_pd *, u64, u64, u64, int, int, struct ib_udata *);
	struct ib_mr * (*rereg_user_mr)(struct ib_mr *, int, u64, u64, u64, int, struct ib_pd *, struct ib_udata *);
	int (*dereg_mr)(struct ib_mr *, struct ib_udata *);
	struct ib_mr * (*alloc_mr)(struct ib_pd *, enum ib_mr_type, u32);
	struct ib_mr * (*alloc_mr_integrity)(struct ib_pd *, u32, u32);
	int (*advise_mr)(struct ib_pd *, enum ib_uverbs_advise_mr_advice, u32, struct ib_sge *, u32, struct uverbs_attr_bundle *);
	int (*map_mr_sg)(struct ib_mr *, struct scatterlist *, int, unsigned int *);
	int (*check_mr_status)(struct ib_mr *, u32, struct ib_mr_status *);
	int (*alloc_mw)(struct ib_mw *, struct ib_udata *);
	int (*dealloc_mw)(struct ib_mw *);
	int (*attach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*detach_mcast)(struct ib_qp *, union ib_gid *, u16);
	int (*alloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	int (*dealloc_xrcd)(struct ib_xrcd *, struct ib_udata *);
	struct ib_flow * (*create_flow)(struct ib_qp *, struct ib_flow_attr *, struct ib_udata *);
	int (*destroy_flow)(struct ib_flow *);
	int (*destroy_flow_action)(struct ib_flow_action *);
	int (*set_vf_link_state)(struct ib_device *, int, u32, int);
	int (*get_vf_config)(struct ib_device *, int, u32, struct ifla_vf_info *);
	int (*get_vf_stats)(struct ib_device *, int, u32, struct ifla_vf_stats *);
	int (*get_vf_guid)(struct ib_device *, int, u32, struct ifla_vf_guid *, struct ifla_vf_guid *);
	int (*set_vf_guid)(struct ib_device *, int, u32, u64, int);
	struct ib_wq * (*create_wq)(struct ib_pd *, struct ib_wq_init_attr *, struct ib_udata *);
	int (*destroy_wq)(struct ib_wq *, struct ib_udata *);
	int (*modify_wq)(struct ib_wq *, struct ib_wq_attr *, u32, struct ib_udata *);
	int (*create_rwq_ind_table)(struct ib_rwq_ind_table *, struct ib_rwq_ind_table_init_attr *, struct ib_udata *);
	int (*destroy_rwq_ind_table)(struct ib_rwq_ind_table *);
	struct ib_dm * (*alloc_dm)(struct ib_device *, struct ib_ucontext *, struct ib_dm_alloc_attr *, struct uverbs_attr_bundle *);
	int (*dealloc_dm)(struct ib_dm *, struct uverbs_attr_bundle *);
	struct ib_mr * (*reg_dm_mr)(struct ib_pd *, struct ib_dm *, struct ib_dm_mr_attr *, struct uverbs_attr_bundle *);
	int (*create_counters)(struct ib_counters *, struct uverbs_attr_bundle *);
	int (*destroy_counters)(struct ib_counters *);
	int (*read_counters)(struct ib_counters *, struct ib_counters_read_attr *, struct uverbs_attr_bundle *);
	int (*map_mr_sg_pi)(struct ib_mr *, struct scatterlist *, int, unsigned int *, struct scatterlist *, int, unsigned int *);
	struct rdma_hw_stats * (*alloc_hw_device_stats)(struct ib_device *);
	struct rdma_hw_stats * (*alloc_hw_port_stats)(struct ib_device *, u32);
	int (*get_hw_stats)(struct ib_device *, struct rdma_hw_stats *, u32, int);
	int (*modify_hw_stat)(struct ib_device *, u32, unsigned int, bool);
	int (*fill_res_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_mr_entry_raw)(struct sk_buff *, struct ib_mr *);
	int (*fill_res_cq_entry)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_cq_entry_raw)(struct sk_buff *, struct ib_cq *);
	int (*fill_res_qp_entry)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_qp_entry_raw)(struct sk_buff *, struct ib_qp *);
	int (*fill_res_cm_id_entry)(struct sk_buff *, struct rdma_cm_id *);
	int (*enable_driver)(struct ib_device *);
	void (*dealloc_driver)(struct ib_device *);
	void (*iw_add_ref)(struct ib_qp *);
	void (*iw_rem_ref)(struct ib_qp *);
	struct ib_qp * (*iw_get_qp)(struct ib_device *, int);
	int (*iw_connect)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_accept)(struct iw_cm_id *, struct iw_cm_conn_param *);
	int (*iw_reject)(struct iw_cm_id *, const void *, u8);
	int (*iw_create_listen)(struct iw_cm_id *, int);
	int (*iw_destroy_listen)(struct iw_cm_id *);
	int (*counter_bind_qp)(struct rdma_counter *, struct ib_qp *);
	int (*counter_unbind_qp)(struct ib_qp *);
	int (*counter_dealloc)(struct rdma_counter *);
	struct rdma_hw_stats * (*counter_alloc_stats)(struct rdma_counter *);
	int (*counter_update_stats)(struct rdma_counter *);
	int (*fill_stat_mr_entry)(struct sk_buff *, struct ib_mr *);
	int (*query_ucontext)(struct ib_ucontext *, struct uverbs_attr_bundle *);
	int (*get_numa_node)(struct ib_device *);
	size_t size_ib_ah;
	size_t size_ib_counters;
	size_t size_ib_cq;
	size_t size_ib_mw;
	size_t size_ib_pd;
	size_t size_ib_qp;
	size_t size_ib_rwq_ind_table;
	size_t size_ib_srq;
	size_t size_ib_ucontext;
	size_t size_ib_xrcd;
};

struct ib_core_device {
	struct device dev;
	possible_net_t rdma_net;
	struct kobject *ports_kobj;
	struct list_head port_list;
	struct ib_device *owner;
	int: 32;
};

enum ib_atomic_cap {
	IB_ATOMIC_NONE = 0,
	IB_ATOMIC_HCA = 1,
	IB_ATOMIC_GLOB = 2,
};

struct ib_odp_caps {
	uint64_t general_caps;
	struct {
		uint32_t rc_odp_caps;
		uint32_t uc_odp_caps;
		uint32_t ud_odp_caps;
		uint32_t xrc_odp_caps;
	} per_transport_caps;
};

struct ib_rss_caps {
	u32 supported_qpts;
	u32 max_rwq_indirection_tables;
	u32 max_rwq_indirection_table_size;
};

struct ib_tm_caps {
	u32 max_rndv_hdr_size;
	u32 max_num_tags;
	u32 flags;
	u32 max_ops;
	u32 max_sge;
};

struct ib_cq_caps {
	u16 max_cq_moderation_count;
	u16 max_cq_moderation_period;
};

struct ib_device_attr {
	u64 fw_ver;
	__be64 sys_image_guid;
	u64 max_mr_size;
	u64 page_size_cap;
	u32 vendor_id;
	u32 vendor_part_id;
	u32 hw_ver;
	int max_qp;
	int max_qp_wr;
	int: 32;
	u64 device_cap_flags;
	u64 kernel_cap_flags;
	int max_send_sge;
	int max_recv_sge;
	int max_sge_rd;
	int max_cq;
	int max_cqe;
	int max_mr;
	int max_pd;
	int max_qp_rd_atom;
	int max_ee_rd_atom;
	int max_res_rd_atom;
	int max_qp_init_rd_atom;
	int max_ee_init_rd_atom;
	enum ib_atomic_cap atomic_cap;
	enum ib_atomic_cap masked_atomic_cap;
	int max_ee;
	int max_rdd;
	int max_mw;
	int max_raw_ipv6_qp;
	int max_raw_ethy_qp;
	int max_mcast_grp;
	int max_mcast_qp_attach;
	int max_total_mcast_qp_attach;
	int max_ah;
	int max_srq;
	int max_srq_wr;
	int max_srq_sge;
	unsigned int max_fast_reg_page_list_len;
	unsigned int max_pi_fast_reg_page_list_len;
	u16 max_pkeys;
	u8 local_ca_ack_delay;
	int sig_prot_cap;
	int sig_guard_cap;
	int: 32;
	struct ib_odp_caps odp_caps;
	uint64_t timestamp_mask;
	uint64_t hca_core_clock;
	struct ib_rss_caps rss_caps;
	u32 max_wq_type_rq;
	u32 raw_packet_caps;
	struct ib_tm_caps tm_caps;
	struct ib_cq_caps cq_caps;
	int: 32;
	u64 max_dm_size;
	u32 max_sgl_rd;
	int: 32;
};

struct hw_stats_device_data;

struct rdma_restrack_root;

struct uapi_definition;

struct ib_port_data;

struct ib_device {
	struct device *dma_device;
	struct ib_device_ops ops;
	char name[64];
	struct callback_head callback_head;
	struct list_head event_handler_list;
	struct rw_semaphore event_handler_rwsem;
	spinlock_t qp_open_list_lock;
	struct rw_semaphore client_data_rwsem;
	struct xarray client_data;
	struct mutex unregistration_lock;
	rwlock_t cache_lock;
	struct ib_port_data *port_data;
	int num_comp_vectors;
	union {
		struct device dev;
		struct ib_core_device coredev;
	};
	const struct attribute_group *groups[4];
	u64 uverbs_cmd_mask;
	char node_desc[64];
	__be64 node_guid;
	u32 local_dma_lkey;
	u16 is_switch: 1;
	u16 kverbs_provider: 1;
	u16 use_cq_dim: 1;
	u8 node_type;
	u32 phys_port_cnt;
	int: 32;
	struct ib_device_attr attrs;
	struct hw_stats_device_data *hw_stats_data;
	u32 index;
	spinlock_t cq_pools_lock;
	struct list_head cq_pools[3];
	struct rdma_restrack_root *res;
	const struct uapi_definition *driver_def;
	refcount_t refcount;
	struct completion unreg_completion;
	struct work_struct unregistration_work;
	const struct rdma_link_ops *link_ops;
	struct mutex compat_devs_mutex;
	struct xarray compat_devs;
	char iw_ifname[16];
	u32 iw_driver_flags;
	u32 lag_flags;
	int: 32;
};

enum ib_signature_type {
	IB_SIG_TYPE_NONE = 0,
	IB_SIG_TYPE_T10_DIF = 1,
};

enum ib_t10_dif_bg_type {
	IB_T10DIF_CRC = 0,
	IB_T10DIF_CSUM = 1,
};

struct ib_t10_dif_domain {
	enum ib_t10_dif_bg_type bg_type;
	u16 pi_interval;
	u16 bg;
	u16 app_tag;
	u32 ref_tag;
	bool ref_remap;
	bool app_escape;
	bool ref_escape;
	u16 apptag_check_mask;
};

struct ib_sig_domain {
	enum ib_signature_type sig_type;
	union {
		struct ib_t10_dif_domain dif;
	} sig;
};

struct ib_sig_attrs {
	u8 check_mask;
	struct ib_sig_domain mem;
	struct ib_sig_domain wire;
	int meta_length;
};

enum ib_sig_err_type {
	IB_SIG_BAD_GUARD = 0,
	IB_SIG_BAD_REFTAG = 1,
	IB_SIG_BAD_APPTAG = 2,
};

struct ib_sig_err {
	enum ib_sig_err_type err_type;
	u32 expected;
	u32 actual;
	int: 32;
	u64 sig_err_offset;
	u32 key;
	int: 32;
};

enum ib_uverbs_access_flags {
	IB_UVERBS_ACCESS_LOCAL_WRITE = 1,
	IB_UVERBS_ACCESS_REMOTE_WRITE = 2,
	IB_UVERBS_ACCESS_REMOTE_READ = 4,
	IB_UVERBS_ACCESS_REMOTE_ATOMIC = 8,
	IB_UVERBS_ACCESS_MW_BIND = 16,
	IB_UVERBS_ACCESS_ZERO_BASED = 32,
	IB_UVERBS_ACCESS_ON_DEMAND = 64,
	IB_UVERBS_ACCESS_HUGETLB = 128,
	IB_UVERBS_ACCESS_RELAXED_ORDERING = 1048576,
	IB_UVERBS_ACCESS_OPTIONAL_RANGE = 1072693248,
};

enum ib_uverbs_srq_type {
	IB_UVERBS_SRQT_BASIC = 0,
	IB_UVERBS_SRQT_XRC = 1,
	IB_UVERBS_SRQT_TM = 2,
};

enum ib_uverbs_wq_type {
	IB_UVERBS_WQT_RQ = 0,
};

enum ib_uverbs_wq_flags {
	IB_UVERBS_WQ_FLAGS_CVLAN_STRIPPING = 1,
	IB_UVERBS_WQ_FLAGS_SCATTER_FCS = 2,
	IB_UVERBS_WQ_FLAGS_DELAY_DROP = 4,
	IB_UVERBS_WQ_FLAGS_PCI_WRITE_END_PADDING = 8,
};

enum ib_uverbs_qp_type {
	IB_UVERBS_QPT_RC = 2,
	IB_UVERBS_QPT_UC = 3,
	IB_UVERBS_QPT_UD = 4,
	IB_UVERBS_QPT_RAW_PACKET = 8,
	IB_UVERBS_QPT_XRC_INI = 9,
	IB_UVERBS_QPT_XRC_TGT = 10,
	IB_UVERBS_QPT_DRIVER = 255,
};

enum ib_uverbs_qp_create_flags {
	IB_UVERBS_QP_CREATE_BLOCK_MULTICAST_LOOPBACK = 2,
	IB_UVERBS_QP_CREATE_SCATTER_FCS = 256,
	IB_UVERBS_QP_CREATE_CVLAN_STRIPPING = 512,
	IB_UVERBS_QP_CREATE_PCI_WRITE_END_PADDING = 2048,
	IB_UVERBS_QP_CREATE_SQ_SIG_ALL = 4096,
};

enum ib_uverbs_gid_type {
	IB_UVERBS_GID_TYPE_IB = 0,
	IB_UVERBS_GID_TYPE_ROCE_V1 = 1,
	IB_UVERBS_GID_TYPE_ROCE_V2 = 2,
};

union ib_gid {
	u8 raw[16];
	struct {
		__be64 subnet_prefix;
		__be64 interface_id;
	} global;
};

enum ib_gid_type {
	IB_GID_TYPE_IB = 0,
	IB_GID_TYPE_ROCE = 1,
	IB_GID_TYPE_ROCE_UDP_ENCAP = 2,
	IB_GID_TYPE_SIZE = 3,
};

struct ib_gid_attr {
	struct net_device *ndev;
	struct ib_device *device;
	union ib_gid gid;
	enum ib_gid_type gid_type;
	u16 index;
	u32 port_num;
	int: 32;
};

struct ib_cq_init_attr {
	unsigned int cqe;
	u32 comp_vector;
	u32 flags;
};

struct ib_dm_mr_attr {
	u64 length;
	u64 offset;
	u32 access_flags;
	int: 32;
};

struct ib_dm_alloc_attr {
	u64 length;
	u32 alignment;
	u32 flags;
};

enum ib_mtu {
	IB_MTU_256 = 1,
	IB_MTU_512 = 2,
	IB_MTU_1024 = 3,
	IB_MTU_2048 = 4,
	IB_MTU_4096 = 5,
};

enum ib_port_state {
	IB_PORT_NOP = 0,
	IB_PORT_DOWN = 1,
	IB_PORT_INIT = 2,
	IB_PORT_ARMED = 3,
	IB_PORT_ACTIVE = 4,
	IB_PORT_ACTIVE_DEFER = 5,
};

struct rdma_stat_desc {
	const char *name;
	unsigned int flags;
	const void *priv;
};

struct ib_port_attr {
	u64 subnet_prefix;
	enum ib_port_state state;
	enum ib_mtu max_mtu;
	enum ib_mtu active_mtu;
	u32 phys_mtu;
	int gid_tbl_len;
	unsigned int ip_gids: 1;
	u32 port_cap_flags;
	u32 max_msg_sz;
	u32 bad_pkey_cntr;
	u32 qkey_viol_cntr;
	u16 pkey_tbl_len;
	u32 sm_lid;
	u32 lid;
	u8 lmc;
	u8 max_vl_num;
	u8 sm_sl;
	u8 subnet_timeout;
	u8 init_type_reply;
	u8 active_width;
	u16 active_speed;
	u8 phys_state;
	u16 port_cap_flags2;
};

struct ib_device_modify {
	u64 sys_image_guid;
	char node_desc[64];
};

struct ib_port_modify {
	u32 set_port_cap_mask;
	u32 clr_port_cap_mask;
	u8 init_type;
};

enum ib_event_type {
	IB_EVENT_CQ_ERR = 0,
	IB_EVENT_QP_FATAL = 1,
	IB_EVENT_QP_REQ_ERR = 2,
	IB_EVENT_QP_ACCESS_ERR = 3,
	IB_EVENT_COMM_EST = 4,
	IB_EVENT_SQ_DRAINED = 5,
	IB_EVENT_PATH_MIG = 6,
	IB_EVENT_PATH_MIG_ERR = 7,
	IB_EVENT_DEVICE_FATAL = 8,
	IB_EVENT_PORT_ACTIVE = 9,
	IB_EVENT_PORT_ERR = 10,
	IB_EVENT_LID_CHANGE = 11,
	IB_EVENT_PKEY_CHANGE = 12,
	IB_EVENT_SM_CHANGE = 13,
	IB_EVENT_SRQ_ERR = 14,
	IB_EVENT_SRQ_LIMIT_REACHED = 15,
	IB_EVENT_QP_LAST_WQE_REACHED = 16,
	IB_EVENT_CLIENT_REREGISTER = 17,
	IB_EVENT_GID_CHANGE = 18,
	IB_EVENT_WQ_FATAL = 19,
};

struct ib_ucq_object;

typedef void (*ib_comp_handler)(struct ib_cq *, void *);

enum ib_poll_context {
	IB_POLL_SOFTIRQ = 0,
	IB_POLL_WORKQUEUE = 1,
	IB_POLL_UNBOUND_WORKQUEUE = 2,
	IB_POLL_LAST_POOL_TYPE = 2,
	IB_POLL_DIRECT = 3,
};

struct ib_event;

struct ib_cq {
	struct ib_device *device;
	struct ib_ucq_object *uobject;
	ib_comp_handler comp_handler;
	void (*event_handler)(struct ib_event *, void *);
	void *cq_context;
	int cqe;
	unsigned int cqe_used;
	atomic_t usecnt;
	enum ib_poll_context poll_ctx;
	struct ib_wc *wc;
	struct list_head pool_entry;
	union {
		struct irq_poll iop;
		struct work_struct work;
	};
	struct workqueue_struct *comp_wq;
	struct dim *dim;
	int: 32;
	ktime_t timestamp;
	u8 interrupt: 1;
	u8 shared: 1;
	unsigned int comp_vector;
	struct rdma_restrack_entry res;
	int: 32;
};

struct ib_uqp_object;

enum ib_qp_type {
	IB_QPT_SMI = 0,
	IB_QPT_GSI = 1,
	IB_QPT_RC = 2,
	IB_QPT_UC = 3,
	IB_QPT_UD = 4,
	IB_QPT_RAW_IPV6 = 5,
	IB_QPT_RAW_ETHERTYPE = 6,
	IB_QPT_RAW_PACKET = 8,
	IB_QPT_XRC_INI = 9,
	IB_QPT_XRC_TGT = 10,
	IB_QPT_MAX = 11,
	IB_QPT_DRIVER = 255,
	IB_QPT_RESERVED1 = 4096,
	IB_QPT_RESERVED2 = 4097,
	IB_QPT_RESERVED3 = 4098,
	IB_QPT_RESERVED4 = 4099,
	IB_QPT_RESERVED5 = 4100,
	IB_QPT_RESERVED6 = 4101,
	IB_QPT_RESERVED7 = 4102,
	IB_QPT_RESERVED8 = 4103,
	IB_QPT_RESERVED9 = 4104,
	IB_QPT_RESERVED10 = 4105,
};

struct ib_qp_security;

struct ib_qp {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	spinlock_t mr_lock;
	int mrs_used;
	struct list_head rdma_mrs;
	struct list_head sig_mrs;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct list_head xrcd_list;
	atomic_t usecnt;
	struct list_head open_list;
	struct ib_qp *real_qp;
	struct ib_uqp_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	const struct ib_gid_attr *av_sgid_attr;
	const struct ib_gid_attr *alt_path_sgid_attr;
	u32 qp_num;
	u32 max_write_sge;
	u32 max_read_sge;
	enum ib_qp_type qp_type;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	struct ib_qp_security *qp_sec;
	u32 port;
	bool integrity_en;
	struct rdma_restrack_entry res;
	struct rdma_counter *counter;
};

struct ib_usrq_object;

enum ib_srq_type {
	IB_SRQT_BASIC = 0,
	IB_SRQT_XRC = 1,
	IB_SRQT_TM = 2,
};

struct ib_srq {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_usrq_object *uobject;
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	enum ib_srq_type srq_type;
	atomic_t usecnt;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
				u32 srq_num;
			} xrc;
		};
	} ext;
	struct rdma_restrack_entry res;
};

struct ib_uwq_object;

enum ib_wq_state {
	IB_WQS_RESET = 0,
	IB_WQS_RDY = 1,
	IB_WQS_ERR = 2,
};

enum ib_wq_type {
	IB_WQT_RQ = 0,
};

struct ib_wq {
	struct ib_device *device;
	struct ib_uwq_object *uobject;
	void *wq_context;
	void (*event_handler)(struct ib_event *, void *);
	struct ib_pd *pd;
	struct ib_cq *cq;
	u32 wq_num;
	enum ib_wq_state state;
	enum ib_wq_type wq_type;
	atomic_t usecnt;
};

struct ib_event {
	struct ib_device *device;
	union {
		struct ib_cq *cq;
		struct ib_qp *qp;
		struct ib_srq *srq;
		struct ib_wq *wq;
		u32 port_num;
	} element;
	enum ib_event_type event;
};

struct ib_global_route {
	const struct ib_gid_attr *sgid_attr;
	int: 32;
	union ib_gid dgid;
	u32 flow_label;
	u8 sgid_index;
	u8 hop_limit;
	u8 traffic_class;
};

struct ib_grh {
	__be32 version_tclass_flow;
	__be16 paylen;
	u8 next_hdr;
	u8 hop_limit;
	union ib_gid sgid;
	union ib_gid dgid;
};

struct ib_mr_status {
	u32 fail_status;
	int: 32;
	struct ib_sig_err sig_err;
};

struct rdma_ah_init_attr {
	struct rdma_ah_attr *ah_attr;
	u32 flags;
	struct net_device *xmit_slave;
};

enum rdma_ah_attr_type {
	RDMA_AH_ATTR_TYPE_UNDEFINED = 0,
	RDMA_AH_ATTR_TYPE_IB = 1,
	RDMA_AH_ATTR_TYPE_ROCE = 2,
	RDMA_AH_ATTR_TYPE_OPA = 3,
};

struct ib_ah_attr {
	u16 dlid;
	u8 src_path_bits;
};

struct roce_ah_attr {
	u8 dmac[6];
};

struct opa_ah_attr {
	u32 dlid;
	u8 src_path_bits;
	bool make_grd;
};

struct rdma_ah_attr {
	struct ib_global_route grh;
	u8 sl;
	u8 static_rate;
	u32 port_num;
	u8 ah_flags;
	enum rdma_ah_attr_type type;
	union {
		struct ib_ah_attr ib;
		struct roce_ah_attr roce;
		struct opa_ah_attr opa;
	};
};

enum ib_wc_status {
	IB_WC_SUCCESS = 0,
	IB_WC_LOC_LEN_ERR = 1,
	IB_WC_LOC_QP_OP_ERR = 2,
	IB_WC_LOC_EEC_OP_ERR = 3,
	IB_WC_LOC_PROT_ERR = 4,
	IB_WC_WR_FLUSH_ERR = 5,
	IB_WC_MW_BIND_ERR = 6,
	IB_WC_BAD_RESP_ERR = 7,
	IB_WC_LOC_ACCESS_ERR = 8,
	IB_WC_REM_INV_REQ_ERR = 9,
	IB_WC_REM_ACCESS_ERR = 10,
	IB_WC_REM_OP_ERR = 11,
	IB_WC_RETRY_EXC_ERR = 12,
	IB_WC_RNR_RETRY_EXC_ERR = 13,
	IB_WC_LOC_RDD_VIOL_ERR = 14,
	IB_WC_REM_INV_RD_REQ_ERR = 15,
	IB_WC_REM_ABORT_ERR = 16,
	IB_WC_INV_EECN_ERR = 17,
	IB_WC_INV_EEC_STATE_ERR = 18,
	IB_WC_FATAL_ERR = 19,
	IB_WC_RESP_TIMEOUT_ERR = 20,
	IB_WC_GENERAL_ERR = 21,
};

enum ib_wc_opcode {
	IB_WC_SEND = 0,
	IB_WC_RDMA_WRITE = 1,
	IB_WC_RDMA_READ = 2,
	IB_WC_COMP_SWAP = 3,
	IB_WC_FETCH_ADD = 4,
	IB_WC_BIND_MW = 5,
	IB_WC_LOCAL_INV = 6,
	IB_WC_LSO = 7,
	IB_WC_REG_MR = 8,
	IB_WC_MASKED_COMP_SWAP = 9,
	IB_WC_MASKED_FETCH_ADD = 10,
	IB_WC_RECV = 128,
	IB_WC_RECV_RDMA_WITH_IMM = 129,
};

struct ib_cqe {
	void (*done)(struct ib_cq *, struct ib_wc *);
};

struct ib_wc {
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	enum ib_wc_status status;
	enum ib_wc_opcode opcode;
	u32 vendor_err;
	u32 byte_len;
	struct ib_qp *qp;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	u32 src_qp;
	u32 slid;
	int wc_flags;
	u16 pkey_index;
	u8 sl;
	u8 dlid_path_bits;
	u32 port_num;
	u8 smac[6];
	u16 vlan_id;
	u8 network_hdr_type;
};

struct ib_srq_attr {
	u32 max_wr;
	u32 max_sge;
	u32 srq_limit;
};

struct ib_xrcd {
	struct ib_device *device;
	atomic_t usecnt;
	struct inode *inode;
	struct rw_semaphore tgt_qps_rwsem;
	struct xarray tgt_qps;
};

struct ib_srq_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *srq_context;
	struct ib_srq_attr attr;
	enum ib_srq_type srq_type;
	struct {
		struct ib_cq *cq;
		union {
			struct {
				struct ib_xrcd *xrcd;
			} xrc;
			struct {
				u32 max_num_tags;
			} tag_matching;
		};
	} ext;
};

struct ib_qp_cap {
	u32 max_send_wr;
	u32 max_recv_wr;
	u32 max_send_sge;
	u32 max_recv_sge;
	u32 max_inline_data;
	u32 max_rdma_ctxs;
};

enum ib_sig_type {
	IB_SIGNAL_ALL_WR = 0,
	IB_SIGNAL_REQ_WR = 1,
};

struct ib_qp_init_attr {
	void (*event_handler)(struct ib_event *, void *);
	void *qp_context;
	struct ib_cq *send_cq;
	struct ib_cq *recv_cq;
	struct ib_srq *srq;
	struct ib_xrcd *xrcd;
	struct ib_qp_cap cap;
	enum ib_sig_type sq_sig_type;
	enum ib_qp_type qp_type;
	u32 create_flags;
	u32 port_num;
	struct ib_rwq_ind_table *rwq_ind_tbl;
	u32 source_qpn;
};

struct ib_uobject;

struct ib_rwq_ind_table {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 ind_tbl_num;
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum ib_qp_state {
	IB_QPS_RESET = 0,
	IB_QPS_INIT = 1,
	IB_QPS_RTR = 2,
	IB_QPS_RTS = 3,
	IB_QPS_SQD = 4,
	IB_QPS_SQE = 5,
	IB_QPS_ERR = 6,
};

enum ib_mig_state {
	IB_MIG_MIGRATED = 0,
	IB_MIG_REARM = 1,
	IB_MIG_ARMED = 2,
};

enum ib_mw_type {
	IB_MW_TYPE_1 = 1,
	IB_MW_TYPE_2 = 2,
};

struct ib_qp_attr {
	enum ib_qp_state qp_state;
	enum ib_qp_state cur_qp_state;
	enum ib_mtu path_mtu;
	enum ib_mig_state path_mig_state;
	u32 qkey;
	u32 rq_psn;
	u32 sq_psn;
	u32 dest_qp_num;
	int qp_access_flags;
	struct ib_qp_cap cap;
	int: 32;
	struct rdma_ah_attr ah_attr;
	struct rdma_ah_attr alt_ah_attr;
	u16 pkey_index;
	u16 alt_pkey_index;
	u8 en_sqd_async_notify;
	u8 sq_draining;
	u8 max_rd_atomic;
	u8 max_dest_rd_atomic;
	u8 min_rnr_timer;
	u32 port_num;
	u8 timeout;
	u8 retry_cnt;
	u8 rnr_retry;
	u32 alt_port_num;
	u8 alt_timeout;
	u32 rate_limit;
	struct net_device *xmit_slave;
	int: 32;
};

enum ib_wr_opcode {
	IB_WR_RDMA_WRITE = 0,
	IB_WR_RDMA_WRITE_WITH_IMM = 1,
	IB_WR_SEND = 2,
	IB_WR_SEND_WITH_IMM = 3,
	IB_WR_RDMA_READ = 4,
	IB_WR_ATOMIC_CMP_AND_SWP = 5,
	IB_WR_ATOMIC_FETCH_AND_ADD = 6,
	IB_WR_BIND_MW = 8,
	IB_WR_LSO = 10,
	IB_WR_SEND_WITH_INV = 9,
	IB_WR_RDMA_READ_WITH_INV = 11,
	IB_WR_LOCAL_INV = 7,
	IB_WR_MASKED_ATOMIC_CMP_AND_SWP = 12,
	IB_WR_MASKED_ATOMIC_FETCH_AND_ADD = 13,
	IB_WR_REG_MR = 32,
	IB_WR_REG_MR_INTEGRITY = 33,
	IB_WR_RESERVED1 = 240,
	IB_WR_RESERVED2 = 241,
	IB_WR_RESERVED3 = 242,
	IB_WR_RESERVED4 = 243,
	IB_WR_RESERVED5 = 244,
	IB_WR_RESERVED6 = 245,
	IB_WR_RESERVED7 = 246,
	IB_WR_RESERVED8 = 247,
	IB_WR_RESERVED9 = 248,
	IB_WR_RESERVED10 = 249,
};

struct ib_sge {
	u64 addr;
	u32 length;
	u32 lkey;
};

struct ib_send_wr {
	struct ib_send_wr *next;
	int: 32;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
	enum ib_wr_opcode opcode;
	int send_flags;
	union {
		__be32 imm_data;
		u32 invalidate_rkey;
	} ex;
	int: 32;
};

struct ib_ah {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	const struct ib_gid_attr *sgid_attr;
	enum rdma_ah_attr_type type;
};

struct ib_mr {
	struct ib_device *device;
	struct ib_pd *pd;
	u32 lkey;
	u32 rkey;
	u64 iova;
	u64 length;
	unsigned int page_size;
	enum ib_mr_type type;
	bool need_inval;
	union {
		struct ib_uobject *uobject;
		struct list_head qp_entry;
	};
	struct ib_dm *dm;
	struct ib_sig_attrs *sig_attrs;
	struct rdma_restrack_entry res;
};

struct ib_recv_wr {
	struct ib_recv_wr *next;
	int: 32;
	union {
		u64 wr_id;
		struct ib_cqe *wr_cqe;
	};
	struct ib_sge *sg_list;
	int num_sge;
};

struct ib_rdmacg_object {};

struct ib_uverbs_file;

struct ib_ucontext {
	struct ib_device *device;
	struct ib_uverbs_file *ufile;
	struct ib_rdmacg_object cg_obj;
	struct rdma_restrack_entry res;
	struct xarray mmap_xa;
};

struct uverbs_api_object;

struct ib_uobject {
	u64 user_handle;
	struct ib_uverbs_file *ufile;
	struct ib_ucontext *context;
	void *object;
	struct list_head list;
	struct ib_rdmacg_object cg_obj;
	int id;
	struct kref ref;
	atomic_t usecnt;
	struct callback_head rcu;
	const struct uverbs_api_object *uapi_object;
	int: 32;
};

struct ib_udata {
	const void *inbuf;
	void *outbuf;
	size_t inlen;
	size_t outlen;
};

struct ib_pd {
	u32 local_dma_lkey;
	u32 flags;
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
	u32 unsafe_global_rkey;
	struct ib_mr *__internal_mr;
	struct rdma_restrack_entry res;
};

struct ib_wq_init_attr {
	void *wq_context;
	enum ib_wq_type wq_type;
	u32 max_wr;
	u32 max_sge;
	struct ib_cq *cq;
	void (*event_handler)(struct ib_event *, void *);
	u32 create_flags;
};

struct ib_wq_attr {
	enum ib_wq_state wq_state;
	enum ib_wq_state curr_wq_state;
	u32 flags;
	u32 flags_mask;
};

struct ib_rwq_ind_table_init_attr {
	u32 log_ind_tbl_size;
	struct ib_wq **ind_tbl;
};

enum port_pkey_state {
	IB_PORT_PKEY_NOT_VALID = 0,
	IB_PORT_PKEY_VALID = 1,
	IB_PORT_PKEY_LISTED = 2,
};

struct ib_port_pkey {
	enum port_pkey_state state;
	u16 pkey_index;
	u32 port_num;
	struct list_head qp_list;
	struct list_head to_error_list;
	struct ib_qp_security *sec;
};

struct ib_ports_pkeys;

struct ib_qp_security {
	struct ib_qp *qp;
	struct ib_device *dev;
	struct mutex mutex;
	struct ib_ports_pkeys *ports_pkeys;
	struct list_head shared_qp_list;
	void *security;
	bool destroying;
	atomic_t error_list_count;
	struct completion error_complete;
	int error_comps_pending;
};

struct ib_ports_pkeys {
	struct ib_port_pkey main;
	struct ib_port_pkey alt;
};

struct ib_dm {
	struct ib_device *device;
	u32 length;
	u32 flags;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

struct ib_mw {
	struct ib_device *device;
	struct ib_pd *pd;
	struct ib_uobject *uobject;
	u32 rkey;
	enum ib_mw_type type;
};

enum ib_flow_attr_type {
	IB_FLOW_ATTR_NORMAL = 0,
	IB_FLOW_ATTR_ALL_DEFAULT = 1,
	IB_FLOW_ATTR_MC_DEFAULT = 2,
	IB_FLOW_ATTR_SNIFFER = 3,
};

enum ib_flow_spec_type {
	IB_FLOW_SPEC_ETH = 32,
	IB_FLOW_SPEC_IB = 34,
	IB_FLOW_SPEC_IPV4 = 48,
	IB_FLOW_SPEC_IPV6 = 49,
	IB_FLOW_SPEC_ESP = 52,
	IB_FLOW_SPEC_TCP = 64,
	IB_FLOW_SPEC_UDP = 65,
	IB_FLOW_SPEC_VXLAN_TUNNEL = 80,
	IB_FLOW_SPEC_GRE = 81,
	IB_FLOW_SPEC_MPLS = 96,
	IB_FLOW_SPEC_INNER = 256,
	IB_FLOW_SPEC_ACTION_TAG = 4096,
	IB_FLOW_SPEC_ACTION_DROP = 4097,
	IB_FLOW_SPEC_ACTION_HANDLE = 4098,
	IB_FLOW_SPEC_ACTION_COUNT = 4099,
};

struct ib_flow_eth_filter {
	u8 dst_mac[6];
	u8 src_mac[6];
	__be16 ether_type;
	__be16 vlan_tag;
	u8 real_sz[0];
};

struct ib_flow_spec_eth {
	u32 type;
	u16 size;
	struct ib_flow_eth_filter val;
	struct ib_flow_eth_filter mask;
};

struct ib_flow_ib_filter {
	__be16 dlid;
	__u8 sl;
	u8 real_sz[0];
};

struct ib_flow_spec_ib {
	u32 type;
	u16 size;
	struct ib_flow_ib_filter val;
	struct ib_flow_ib_filter mask;
};

struct ib_flow_ipv4_filter {
	__be32 src_ip;
	__be32 dst_ip;
	u8 proto;
	u8 tos;
	u8 ttl;
	u8 flags;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv4 {
	u32 type;
	u16 size;
	struct ib_flow_ipv4_filter val;
	struct ib_flow_ipv4_filter mask;
};

struct ib_flow_ipv6_filter {
	u8 src_ip[16];
	u8 dst_ip[16];
	__be32 flow_label;
	u8 next_hdr;
	u8 traffic_class;
	u8 hop_limit;
	u8 real_sz[0];
};

struct ib_flow_spec_ipv6 {
	u32 type;
	u16 size;
	struct ib_flow_ipv6_filter val;
	struct ib_flow_ipv6_filter mask;
};

struct ib_flow_tcp_udp_filter {
	__be16 dst_port;
	__be16 src_port;
	u8 real_sz[0];
};

struct ib_flow_spec_tcp_udp {
	u32 type;
	u16 size;
	struct ib_flow_tcp_udp_filter val;
	struct ib_flow_tcp_udp_filter mask;
};

struct ib_flow_tunnel_filter {
	__be32 tunnel_id;
	u8 real_sz[0];
};

struct ib_flow_spec_tunnel {
	u32 type;
	u16 size;
	struct ib_flow_tunnel_filter val;
	struct ib_flow_tunnel_filter mask;
};

struct ib_flow_esp_filter {
	__be32 spi;
	__be32 seq;
	u8 real_sz[0];
};

struct ib_flow_spec_esp {
	u32 type;
	u16 size;
	struct ib_flow_esp_filter val;
	struct ib_flow_esp_filter mask;
};

struct ib_flow_gre_filter {
	__be16 c_ks_res0_ver;
	__be16 protocol;
	__be32 key;
	u8 real_sz[0];
};

struct ib_flow_spec_gre {
	u32 type;
	u16 size;
	struct ib_flow_gre_filter val;
	struct ib_flow_gre_filter mask;
};

struct ib_flow_mpls_filter {
	__be32 tag;
	u8 real_sz[0];
};

struct ib_flow_spec_mpls {
	u32 type;
	u16 size;
	struct ib_flow_mpls_filter val;
	struct ib_flow_mpls_filter mask;
};

struct ib_flow_spec_action_tag {
	enum ib_flow_spec_type type;
	u16 size;
	u32 tag_id;
};

struct ib_flow_spec_action_drop {
	enum ib_flow_spec_type type;
	u16 size;
};

struct ib_flow_spec_action_handle {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_flow_action *act;
};

enum ib_flow_action_type {
	IB_FLOW_ACTION_UNSPECIFIED = 0,
	IB_FLOW_ACTION_ESP = 1,
};

struct ib_flow_action {
	struct ib_device *device;
	struct ib_uobject *uobject;
	enum ib_flow_action_type type;
	atomic_t usecnt;
};

struct ib_flow_spec_action_count {
	enum ib_flow_spec_type type;
	u16 size;
	struct ib_counters *counters;
};

struct ib_counters {
	struct ib_device *device;
	struct ib_uobject *uobject;
	atomic_t usecnt;
};

union ib_flow_spec {
	struct {
		u32 type;
		u16 size;
	};
	struct ib_flow_spec_eth eth;
	struct ib_flow_spec_ib ib;
	struct ib_flow_spec_ipv4 ipv4;
	struct ib_flow_spec_tcp_udp tcp_udp;
	struct ib_flow_spec_ipv6 ipv6;
	struct ib_flow_spec_tunnel tunnel;
	struct ib_flow_spec_esp esp;
	struct ib_flow_spec_gre gre;
	struct ib_flow_spec_mpls mpls;
	struct ib_flow_spec_action_tag flow_tag;
	struct ib_flow_spec_action_drop drop;
	struct ib_flow_spec_action_handle action;
	struct ib_flow_spec_action_count flow_count;
};

struct ib_flow_attr {
	enum ib_flow_attr_type type;
	u16 size;
	u16 priority;
	u32 flags;
	u8 num_of_specs;
	u32 port;
	union ib_flow_spec flows[0];
};

struct ib_flow {
	struct ib_qp *qp;
	struct ib_device *device;
	struct ib_uobject *uobject;
};

struct ib_pkey_cache;

struct ib_gid_table;

struct ib_port_cache {
	u64 subnet_prefix;
	struct ib_pkey_cache *pkey;
	struct ib_gid_table *gid;
	u8 lmc;
	enum ib_port_state port_state;
};

struct ib_port_immutable {
	int pkey_tbl_len;
	int gid_tbl_len;
	u32 core_cap_flags;
	u32 max_mad_size;
};

struct ib_port;

struct ib_port_data {
	struct ib_device *ib_dev;
	struct ib_port_immutable immutable;
	spinlock_t pkey_list_lock;
	spinlock_t netdev_lock;
	struct list_head pkey_list;
	int: 32;
	struct ib_port_cache cache;
	struct net_device *netdev;
	struct hlist_node ndev_hash_link;
	struct rdma_port_counter port_counter;
	struct ib_port *sysfs;
};

struct rdma_netdev_alloc_params {
	size_t sizeof_priv;
	unsigned int txqs;
	unsigned int rxqs;
	void *param;
	int (*initialize_rdma_netdev)(struct ib_device *, u32, struct net_device *, void *);
};

struct ib_counters_read_attr {
	u64 *counters_buff;
	u32 ncounters;
	u32 flags;
};

struct rdma_user_mmap_entry {
	struct kref ref;
	struct ib_ucontext *ucontext;
	long unsigned int start_pgoff;
	size_t npages;
	bool driver_removed;
};

enum genl_validate_flags {
	GENL_DONT_VALIDATE_STRICT = 1,
	GENL_DONT_VALIDATE_DUMP = 2,
	GENL_DONT_VALIDATE_DUMP_STRICT = 4,
};

struct genl_dumpit_info {
	const struct genl_family *family;
	struct genl_ops op;
	struct nlattr **attrs;
};

enum devlink_command {
	DEVLINK_CMD_UNSPEC = 0,
	DEVLINK_CMD_GET = 1,
	DEVLINK_CMD_SET = 2,
	DEVLINK_CMD_NEW = 3,
	DEVLINK_CMD_DEL = 4,
	DEVLINK_CMD_PORT_GET = 5,
	DEVLINK_CMD_PORT_SET = 6,
	DEVLINK_CMD_PORT_NEW = 7,
	DEVLINK_CMD_PORT_DEL = 8,
	DEVLINK_CMD_PORT_SPLIT = 9,
	DEVLINK_CMD_PORT_UNSPLIT = 10,
	DEVLINK_CMD_SB_GET = 11,
	DEVLINK_CMD_SB_SET = 12,
	DEVLINK_CMD_SB_NEW = 13,
	DEVLINK_CMD_SB_DEL = 14,
	DEVLINK_CMD_SB_POOL_GET = 15,
	DEVLINK_CMD_SB_POOL_SET = 16,
	DEVLINK_CMD_SB_POOL_NEW = 17,
	DEVLINK_CMD_SB_POOL_DEL = 18,
	DEVLINK_CMD_SB_PORT_POOL_GET = 19,
	DEVLINK_CMD_SB_PORT_POOL_SET = 20,
	DEVLINK_CMD_SB_PORT_POOL_NEW = 21,
	DEVLINK_CMD_SB_PORT_POOL_DEL = 22,
	DEVLINK_CMD_SB_TC_POOL_BIND_GET = 23,
	DEVLINK_CMD_SB_TC_POOL_BIND_SET = 24,
	DEVLINK_CMD_SB_TC_POOL_BIND_NEW = 25,
	DEVLINK_CMD_SB_TC_POOL_BIND_DEL = 26,
	DEVLINK_CMD_SB_OCC_SNAPSHOT = 27,
	DEVLINK_CMD_SB_OCC_MAX_CLEAR = 28,
	DEVLINK_CMD_ESWITCH_GET = 29,
	DEVLINK_CMD_ESWITCH_SET = 30,
	DEVLINK_CMD_DPIPE_TABLE_GET = 31,
	DEVLINK_CMD_DPIPE_ENTRIES_GET = 32,
	DEVLINK_CMD_DPIPE_HEADERS_GET = 33,
	DEVLINK_CMD_DPIPE_TABLE_COUNTERS_SET = 34,
	DEVLINK_CMD_RESOURCE_SET = 35,
	DEVLINK_CMD_RESOURCE_DUMP = 36,
	DEVLINK_CMD_RELOAD = 37,
	DEVLINK_CMD_PARAM_GET = 38,
	DEVLINK_CMD_PARAM_SET = 39,
	DEVLINK_CMD_PARAM_NEW = 40,
	DEVLINK_CMD_PARAM_DEL = 41,
	DEVLINK_CMD_REGION_GET = 42,
	DEVLINK_CMD_REGION_SET = 43,
	DEVLINK_CMD_REGION_NEW = 44,
	DEVLINK_CMD_REGION_DEL = 45,
	DEVLINK_CMD_REGION_READ = 46,
	DEVLINK_CMD_PORT_PARAM_GET = 47,
	DEVLINK_CMD_PORT_PARAM_SET = 48,
	DEVLINK_CMD_PORT_PARAM_NEW = 49,
	DEVLINK_CMD_PORT_PARAM_DEL = 50,
	DEVLINK_CMD_INFO_GET = 51,
	DEVLINK_CMD_HEALTH_REPORTER_GET = 52,
	DEVLINK_CMD_HEALTH_REPORTER_SET = 53,
	DEVLINK_CMD_HEALTH_REPORTER_RECOVER = 54,
	DEVLINK_CMD_HEALTH_REPORTER_DIAGNOSE = 55,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_GET = 56,
	DEVLINK_CMD_HEALTH_REPORTER_DUMP_CLEAR = 57,
	DEVLINK_CMD_FLASH_UPDATE = 58,
	DEVLINK_CMD_FLASH_UPDATE_END = 59,
	DEVLINK_CMD_FLASH_UPDATE_STATUS = 60,
	DEVLINK_CMD_TRAP_GET = 61,
	DEVLINK_CMD_TRAP_SET = 62,
	DEVLINK_CMD_TRAP_NEW = 63,
	DEVLINK_CMD_TRAP_DEL = 64,
	DEVLINK_CMD_TRAP_GROUP_GET = 65,
	DEVLINK_CMD_TRAP_GROUP_SET = 66,
	DEVLINK_CMD_TRAP_GROUP_NEW = 67,
	DEVLINK_CMD_TRAP_GROUP_DEL = 68,
	DEVLINK_CMD_TRAP_POLICER_GET = 69,
	DEVLINK_CMD_TRAP_POLICER_SET = 70,
	DEVLINK_CMD_TRAP_POLICER_NEW = 71,
	DEVLINK_CMD_TRAP_POLICER_DEL = 72,
	DEVLINK_CMD_HEALTH_REPORTER_TEST = 73,
	DEVLINK_CMD_RATE_GET = 74,
	DEVLINK_CMD_RATE_SET = 75,
	DEVLINK_CMD_RATE_NEW = 76,
	DEVLINK_CMD_RATE_DEL = 77,
	DEVLINK_CMD_LINECARD_GET = 78,
	DEVLINK_CMD_LINECARD_SET = 79,
	DEVLINK_CMD_LINECARD_NEW = 80,
	DEVLINK_CMD_LINECARD_DEL = 81,
	DEVLINK_CMD_SELFTESTS_GET = 82,
	DEVLINK_CMD_SELFTESTS_RUN = 83,
	__DEVLINK_CMD_MAX = 84,
	DEVLINK_CMD_MAX = 83,
};

enum devlink_eswitch_mode {
	DEVLINK_ESWITCH_MODE_LEGACY = 0,
	DEVLINK_ESWITCH_MODE_SWITCHDEV = 1,
};

enum devlink_eswitch_encap_mode {
	DEVLINK_ESWITCH_ENCAP_MODE_NONE = 0,
	DEVLINK_ESWITCH_ENCAP_MODE_BASIC = 1,
};

enum {
	DEVLINK_ATTR_STATS_RX_PACKETS = 0,
	DEVLINK_ATTR_STATS_RX_BYTES = 1,
	DEVLINK_ATTR_STATS_RX_DROPPED = 2,
	__DEVLINK_ATTR_STATS_MAX = 3,
	DEVLINK_ATTR_STATS_MAX = 2,
};

enum {
	DEVLINK_FLASH_OVERWRITE_SETTINGS_BIT = 0,
	DEVLINK_FLASH_OVERWRITE_IDENTIFIERS_BIT = 1,
	__DEVLINK_FLASH_OVERWRITE_MAX_BIT = 2,
	DEVLINK_FLASH_OVERWRITE_MAX_BIT = 1,
};

enum devlink_attr_selftest_id {
	DEVLINK_ATTR_SELFTEST_ID_UNSPEC = 0,
	DEVLINK_ATTR_SELFTEST_ID_FLASH = 1,
	__DEVLINK_ATTR_SELFTEST_ID_MAX = 2,
	DEVLINK_ATTR_SELFTEST_ID_MAX = 1,
};

enum devlink_selftest_status {
	DEVLINK_SELFTEST_STATUS_SKIP = 0,
	DEVLINK_SELFTEST_STATUS_PASS = 1,
	DEVLINK_SELFTEST_STATUS_FAIL = 2,
};

enum devlink_attr_selftest_result {
	DEVLINK_ATTR_SELFTEST_RESULT_UNSPEC = 0,
	DEVLINK_ATTR_SELFTEST_RESULT = 1,
	DEVLINK_ATTR_SELFTEST_RESULT_ID = 2,
	DEVLINK_ATTR_SELFTEST_RESULT_STATUS = 3,
	__DEVLINK_ATTR_SELFTEST_RESULT_MAX = 4,
	DEVLINK_ATTR_SELFTEST_RESULT_MAX = 3,
};

enum devlink_trap_action {
	DEVLINK_TRAP_ACTION_DROP = 0,
	DEVLINK_TRAP_ACTION_TRAP = 1,
	DEVLINK_TRAP_ACTION_MIRROR = 2,
};

enum devlink_trap_type {
	DEVLINK_TRAP_TYPE_DROP = 0,
	DEVLINK_TRAP_TYPE_EXCEPTION = 1,
	DEVLINK_TRAP_TYPE_CONTROL = 2,
};

enum {
	DEVLINK_ATTR_TRAP_METADATA_TYPE_IN_PORT = 0,
	DEVLINK_ATTR_TRAP_METADATA_TYPE_FA_COOKIE = 1,
};

enum devlink_reload_action {
	DEVLINK_RELOAD_ACTION_UNSPEC = 0,
	DEVLINK_RELOAD_ACTION_DRIVER_REINIT = 1,
	DEVLINK_RELOAD_ACTION_FW_ACTIVATE = 2,
	__DEVLINK_RELOAD_ACTION_MAX = 3,
	DEVLINK_RELOAD_ACTION_MAX = 2,
};

enum devlink_reload_limit {
	DEVLINK_RELOAD_LIMIT_UNSPEC = 0,
	DEVLINK_RELOAD_LIMIT_NO_RESET = 1,
	__DEVLINK_RELOAD_LIMIT_MAX = 2,
	DEVLINK_RELOAD_LIMIT_MAX = 1,
};

enum devlink_linecard_state {
	DEVLINK_LINECARD_STATE_UNSPEC = 0,
	DEVLINK_LINECARD_STATE_UNPROVISIONED = 1,
	DEVLINK_LINECARD_STATE_UNPROVISIONING = 2,
	DEVLINK_LINECARD_STATE_PROVISIONING = 3,
	DEVLINK_LINECARD_STATE_PROVISIONING_FAILED = 4,
	DEVLINK_LINECARD_STATE_PROVISIONED = 5,
	DEVLINK_LINECARD_STATE_ACTIVE = 6,
	__DEVLINK_LINECARD_STATE_MAX = 7,
	DEVLINK_LINECARD_STATE_MAX = 6,
};

enum devlink_attr {
	DEVLINK_ATTR_UNSPEC = 0,
	DEVLINK_ATTR_BUS_NAME = 1,
	DEVLINK_ATTR_DEV_NAME = 2,
	DEVLINK_ATTR_PORT_INDEX = 3,
	DEVLINK_ATTR_PORT_TYPE = 4,
	DEVLINK_ATTR_PORT_DESIRED_TYPE = 5,
	DEVLINK_ATTR_PORT_NETDEV_IFINDEX = 6,
	DEVLINK_ATTR_PORT_NETDEV_NAME = 7,
	DEVLINK_ATTR_PORT_IBDEV_NAME = 8,
	DEVLINK_ATTR_PORT_SPLIT_COUNT = 9,
	DEVLINK_ATTR_PORT_SPLIT_GROUP = 10,
	DEVLINK_ATTR_SB_INDEX = 11,
	DEVLINK_ATTR_SB_SIZE = 12,
	DEVLINK_ATTR_SB_INGRESS_POOL_COUNT = 13,
	DEVLINK_ATTR_SB_EGRESS_POOL_COUNT = 14,
	DEVLINK_ATTR_SB_INGRESS_TC_COUNT = 15,
	DEVLINK_ATTR_SB_EGRESS_TC_COUNT = 16,
	DEVLINK_ATTR_SB_POOL_INDEX = 17,
	DEVLINK_ATTR_SB_POOL_TYPE = 18,
	DEVLINK_ATTR_SB_POOL_SIZE = 19,
	DEVLINK_ATTR_SB_POOL_THRESHOLD_TYPE = 20,
	DEVLINK_ATTR_SB_THRESHOLD = 21,
	DEVLINK_ATTR_SB_TC_INDEX = 22,
	DEVLINK_ATTR_SB_OCC_CUR = 23,
	DEVLINK_ATTR_SB_OCC_MAX = 24,
	DEVLINK_ATTR_ESWITCH_MODE = 25,
	DEVLINK_ATTR_ESWITCH_INLINE_MODE = 26,
	DEVLINK_ATTR_DPIPE_TABLES = 27,
	DEVLINK_ATTR_DPIPE_TABLE = 28,
	DEVLINK_ATTR_DPIPE_TABLE_NAME = 29,
	DEVLINK_ATTR_DPIPE_TABLE_SIZE = 30,
	DEVLINK_ATTR_DPIPE_TABLE_MATCHES = 31,
	DEVLINK_ATTR_DPIPE_TABLE_ACTIONS = 32,
	DEVLINK_ATTR_DPIPE_TABLE_COUNTERS_ENABLED = 33,
	DEVLINK_ATTR_DPIPE_ENTRIES = 34,
	DEVLINK_ATTR_DPIPE_ENTRY = 35,
	DEVLINK_ATTR_DPIPE_ENTRY_INDEX = 36,
	DEVLINK_ATTR_DPIPE_ENTRY_MATCH_VALUES = 37,
	DEVLINK_ATTR_DPIPE_ENTRY_ACTION_VALUES = 38,
	DEVLINK_ATTR_DPIPE_ENTRY_COUNTER = 39,
	DEVLINK_ATTR_DPIPE_MATCH = 40,
	DEVLINK_ATTR_DPIPE_MATCH_VALUE = 41,
	DEVLINK_ATTR_DPIPE_MATCH_TYPE = 42,
	DEVLINK_ATTR_DPIPE_ACTION = 43,
	DEVLINK_ATTR_DPIPE_ACTION_VALUE = 44,
	DEVLINK_ATTR_DPIPE_ACTION_TYPE = 45,
	DEVLINK_ATTR_DPIPE_VALUE = 46,
	DEVLINK_ATTR_DPIPE_VALUE_MASK = 47,
	DEVLINK_ATTR_DPIPE_VALUE_MAPPING = 48,
	DEVLINK_ATTR_DPIPE_HEADERS = 49,
	DEVLINK_ATTR_DPIPE_HEADER = 50,
	DEVLINK_ATTR_DPIPE_HEADER_NAME = 51,
	DEVLINK_ATTR_DPIPE_HEADER_ID = 52,
	DEVLINK_ATTR_DPIPE_HEADER_FIELDS = 53,
	DEVLINK_ATTR_DPIPE_HEADER_GLOBAL = 54,
	DEVLINK_ATTR_DPIPE_HEADER_INDEX = 55,
	DEVLINK_ATTR_DPIPE_FIELD = 56,
	DEVLINK_ATTR_DPIPE_FIELD_NAME = 57,
	DEVLINK_ATTR_DPIPE_FIELD_ID = 58,
	DEVLINK_ATTR_DPIPE_FIELD_BITWIDTH = 59,
	DEVLINK_ATTR_DPIPE_FIELD_MAPPING_TYPE = 60,
	DEVLINK_ATTR_PAD = 61,
	DEVLINK_ATTR_ESWITCH_ENCAP_MODE = 62,
	DEVLINK_ATTR_RESOURCE_LIST = 63,
	DEVLINK_ATTR_RESOURCE = 64,
	DEVLINK_ATTR_RESOURCE_NAME = 65,
	DEVLINK_ATTR_RESOURCE_ID = 66,
	DEVLINK_ATTR_RESOURCE_SIZE = 67,
	DEVLINK_ATTR_RESOURCE_SIZE_NEW = 68,
	DEVLINK_ATTR_RESOURCE_SIZE_VALID = 69,
	DEVLINK_ATTR_RESOURCE_SIZE_MIN = 70,
	DEVLINK_ATTR_RESOURCE_SIZE_MAX = 71,
	DEVLINK_ATTR_RESOURCE_SIZE_GRAN = 72,
	DEVLINK_ATTR_RESOURCE_UNIT = 73,
	DEVLINK_ATTR_RESOURCE_OCC = 74,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_ID = 75,
	DEVLINK_ATTR_DPIPE_TABLE_RESOURCE_UNITS = 76,
	DEVLINK_ATTR_PORT_FLAVOUR = 77,
	DEVLINK_ATTR_PORT_NUMBER = 78,
	DEVLINK_ATTR_PORT_SPLIT_SUBPORT_NUMBER = 79,
	DEVLINK_ATTR_PARAM = 80,
	DEVLINK_ATTR_PARAM_NAME = 81,
	DEVLINK_ATTR_PARAM_GENERIC = 82,
	DEVLINK_ATTR_PARAM_TYPE = 83,
	DEVLINK_ATTR_PARAM_VALUES_LIST = 84,
	DEVLINK_ATTR_PARAM_VALUE = 85,
	DEVLINK_ATTR_PARAM_VALUE_DATA = 86,
	DEVLINK_ATTR_PARAM_VALUE_CMODE = 87,
	DEVLINK_ATTR_REGION_NAME = 88,
	DEVLINK_ATTR_REGION_SIZE = 89,
	DEVLINK_ATTR_REGION_SNAPSHOTS = 90,
	DEVLINK_ATTR_REGION_SNAPSHOT = 91,
	DEVLINK_ATTR_REGION_SNAPSHOT_ID = 92,
	DEVLINK_ATTR_REGION_CHUNKS = 93,
	DEVLINK_ATTR_REGION_CHUNK = 94,
	DEVLINK_ATTR_REGION_CHUNK_DATA = 95,
	DEVLINK_ATTR_REGION_CHUNK_ADDR = 96,
	DEVLINK_ATTR_REGION_CHUNK_LEN = 97,
	DEVLINK_ATTR_INFO_DRIVER_NAME = 98,
	DEVLINK_ATTR_INFO_SERIAL_NUMBER = 99,
	DEVLINK_ATTR_INFO_VERSION_FIXED = 100,
	DEVLINK_ATTR_INFO_VERSION_RUNNING = 101,
	DEVLINK_ATTR_INFO_VERSION_STORED = 102,
	DEVLINK_ATTR_INFO_VERSION_NAME = 103,
	DEVLINK_ATTR_INFO_VERSION_VALUE = 104,
	DEVLINK_ATTR_SB_POOL_CELL_SIZE = 105,
	DEVLINK_ATTR_FMSG = 106,
	DEVLINK_ATTR_FMSG_OBJ_NEST_START = 107,
	DEVLINK_ATTR_FMSG_PAIR_NEST_START = 108,
	DEVLINK_ATTR_FMSG_ARR_NEST_START = 109,
	DEVLINK_ATTR_FMSG_NEST_END = 110,
	DEVLINK_ATTR_FMSG_OBJ_NAME = 111,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_TYPE = 112,
	DEVLINK_ATTR_FMSG_OBJ_VALUE_DATA = 113,
	DEVLINK_ATTR_HEALTH_REPORTER = 114,
	DEVLINK_ATTR_HEALTH_REPORTER_NAME = 115,
	DEVLINK_ATTR_HEALTH_REPORTER_STATE = 116,
	DEVLINK_ATTR_HEALTH_REPORTER_ERR_COUNT = 117,
	DEVLINK_ATTR_HEALTH_REPORTER_RECOVER_COUNT = 118,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS = 119,
	DEVLINK_ATTR_HEALTH_REPORTER_GRACEFUL_PERIOD = 120,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_RECOVER = 121,
	DEVLINK_ATTR_FLASH_UPDATE_FILE_NAME = 122,
	DEVLINK_ATTR_FLASH_UPDATE_COMPONENT = 123,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_MSG = 124,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_DONE = 125,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TOTAL = 126,
	DEVLINK_ATTR_PORT_PCI_PF_NUMBER = 127,
	DEVLINK_ATTR_PORT_PCI_VF_NUMBER = 128,
	DEVLINK_ATTR_STATS = 129,
	DEVLINK_ATTR_TRAP_NAME = 130,
	DEVLINK_ATTR_TRAP_ACTION = 131,
	DEVLINK_ATTR_TRAP_TYPE = 132,
	DEVLINK_ATTR_TRAP_GENERIC = 133,
	DEVLINK_ATTR_TRAP_METADATA = 134,
	DEVLINK_ATTR_TRAP_GROUP_NAME = 135,
	DEVLINK_ATTR_RELOAD_FAILED = 136,
	DEVLINK_ATTR_HEALTH_REPORTER_DUMP_TS_NS = 137,
	DEVLINK_ATTR_NETNS_FD = 138,
	DEVLINK_ATTR_NETNS_PID = 139,
	DEVLINK_ATTR_NETNS_ID = 140,
	DEVLINK_ATTR_HEALTH_REPORTER_AUTO_DUMP = 141,
	DEVLINK_ATTR_TRAP_POLICER_ID = 142,
	DEVLINK_ATTR_TRAP_POLICER_RATE = 143,
	DEVLINK_ATTR_TRAP_POLICER_BURST = 144,
	DEVLINK_ATTR_PORT_FUNCTION = 145,
	DEVLINK_ATTR_INFO_BOARD_SERIAL_NUMBER = 146,
	DEVLINK_ATTR_PORT_LANES = 147,
	DEVLINK_ATTR_PORT_SPLITTABLE = 148,
	DEVLINK_ATTR_PORT_EXTERNAL = 149,
	DEVLINK_ATTR_PORT_CONTROLLER_NUMBER = 150,
	DEVLINK_ATTR_FLASH_UPDATE_STATUS_TIMEOUT = 151,
	DEVLINK_ATTR_FLASH_UPDATE_OVERWRITE_MASK = 152,
	DEVLINK_ATTR_RELOAD_ACTION = 153,
	DEVLINK_ATTR_RELOAD_ACTIONS_PERFORMED = 154,
	DEVLINK_ATTR_RELOAD_LIMITS = 155,
	DEVLINK_ATTR_DEV_STATS = 156,
	DEVLINK_ATTR_RELOAD_STATS = 157,
	DEVLINK_ATTR_RELOAD_STATS_ENTRY = 158,
	DEVLINK_ATTR_RELOAD_STATS_LIMIT = 159,
	DEVLINK_ATTR_RELOAD_STATS_VALUE = 160,
	DEVLINK_ATTR_REMOTE_RELOAD_STATS = 161,
	DEVLINK_ATTR_RELOAD_ACTION_INFO = 162,
	DEVLINK_ATTR_RELOAD_ACTION_STATS = 163,
	DEVLINK_ATTR_PORT_PCI_SF_NUMBER = 164,
	DEVLINK_ATTR_RATE_TYPE = 165,
	DEVLINK_ATTR_RATE_TX_SHARE = 166,
	DEVLINK_ATTR_RATE_TX_MAX = 167,
	DEVLINK_ATTR_RATE_NODE_NAME = 168,
	DEVLINK_ATTR_RATE_PARENT_NODE_NAME = 169,
	DEVLINK_ATTR_REGION_MAX_SNAPSHOTS = 170,
	DEVLINK_ATTR_LINECARD_INDEX = 171,
	DEVLINK_ATTR_LINECARD_STATE = 172,
	DEVLINK_ATTR_LINECARD_TYPE = 173,
	DEVLINK_ATTR_LINECARD_SUPPORTED_TYPES = 174,
	DEVLINK_ATTR_NESTED_DEVLINK = 175,
	DEVLINK_ATTR_SELFTESTS = 176,
	__DEVLINK_ATTR_MAX = 177,
	DEVLINK_ATTR_MAX = 176,
};

enum devlink_dpipe_field_mapping_type {
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_NONE = 0,
	DEVLINK_DPIPE_FIELD_MAPPING_TYPE_IFINDEX = 1,
};

enum devlink_dpipe_match_type {
	DEVLINK_DPIPE_MATCH_TYPE_FIELD_EXACT = 0,
};

enum devlink_dpipe_action_type {
	DEVLINK_DPIPE_ACTION_TYPE_FIELD_MODIFY = 0,
};

enum devlink_dpipe_field_ethernet_id {
	DEVLINK_DPIPE_FIELD_ETHERNET_DST_MAC = 0,
};

enum devlink_dpipe_field_ipv4_id {
	DEVLINK_DPIPE_FIELD_IPV4_DST_IP = 0,
};

enum devlink_dpipe_field_ipv6_id {
	DEVLINK_DPIPE_FIELD_IPV6_DST_IP = 0,
};

enum devlink_dpipe_header_id {
	DEVLINK_DPIPE_HEADER_ETHERNET = 0,
	DEVLINK_DPIPE_HEADER_IPV4 = 1,
	DEVLINK_DPIPE_HEADER_IPV6 = 2,
};

enum devlink_resource_unit {
	DEVLINK_RESOURCE_UNIT_ENTRY = 0,
};

enum devlink_port_function_attr {
	DEVLINK_PORT_FUNCTION_ATTR_UNSPEC = 0,
	DEVLINK_PORT_FUNCTION_ATTR_HW_ADDR = 1,
	DEVLINK_PORT_FN_ATTR_STATE = 2,
	DEVLINK_PORT_FN_ATTR_OPSTATE = 3,
	__DEVLINK_PORT_FUNCTION_ATTR_MAX = 4,
	DEVLINK_PORT_FUNCTION_ATTR_MAX = 3,
};

enum devlink_port_fn_state {
	DEVLINK_PORT_FN_STATE_INACTIVE = 0,
	DEVLINK_PORT_FN_STATE_ACTIVE = 1,
};

enum devlink_port_fn_opstate {
	DEVLINK_PORT_FN_OPSTATE_DETACHED = 0,
	DEVLINK_PORT_FN_OPSTATE_ATTACHED = 1,
};

struct devlink_dev_stats {
	u32 reload_stats[6];
	u32 remote_reload_stats[6];
};

struct devlink_dpipe_headers;

struct devlink_ops;

struct devlink {
	u32 index;
	struct list_head port_list;
	struct list_head rate_list;
	struct list_head sb_list;
	struct list_head dpipe_table_list;
	struct list_head resource_list;
	struct list_head param_list;
	struct list_head region_list;
	struct list_head reporter_list;
	struct mutex reporters_lock;
	struct devlink_dpipe_headers *dpipe_headers;
	struct list_head trap_list;
	struct list_head trap_group_list;
	struct list_head trap_policer_list;
	struct list_head linecard_list;
	struct mutex linecards_lock;
	const struct devlink_ops *ops;
	int: 32;
	u64 features;
	struct xarray snapshot_ids;
	struct devlink_dev_stats stats;
	struct device *dev;
	possible_net_t _net;
	struct mutex lock;
	struct lock_class_key lock_key;
	u8 reload_failed: 1;
	refcount_t refcount;
	struct completion comp;
	struct callback_head rcu;
	int: 32;
	int: 32;
	char priv[0];
};

struct devlink_linecard_ops;

struct devlink_linecard_type;

struct devlink_linecard {
	struct list_head list;
	struct devlink *devlink;
	unsigned int index;
	refcount_t refcount;
	const struct devlink_linecard_ops *ops;
	void *priv;
	enum devlink_linecard_state state;
	struct mutex state_lock;
	const char *type;
	struct devlink_linecard_type *types;
	unsigned int types_count;
	struct devlink *nested_devlink;
};

struct devlink_port_new_attrs {
	enum devlink_port_flavour flavour;
	unsigned int port_index;
	u32 controller;
	u32 sfnum;
	u16 pfnum;
	u8 port_index_valid: 1;
	u8 controller_valid: 1;
	u8 sfnum_valid: 1;
};

struct devlink_linecard_ops {
	int (*provision)(struct devlink_linecard *, void *, const char *, const void *, struct netlink_ext_ack *);
	int (*unprovision)(struct devlink_linecard *, void *, struct netlink_ext_ack *);
	bool (*same_provision)(struct devlink_linecard *, void *, const char *, const void *);
	unsigned int (*types_count)(struct devlink_linecard *, void *);
	void (*types_get)(struct devlink_linecard *, void *, unsigned int, const char **, const void **);
};

struct devlink_dpipe_field {
	const char *name;
	unsigned int id;
	unsigned int bitwidth;
	enum devlink_dpipe_field_mapping_type mapping_type;
};

struct devlink_dpipe_header {
	const char *name;
	unsigned int id;
	struct devlink_dpipe_field *fields;
	unsigned int fields_count;
	bool global;
};

struct devlink_dpipe_match {
	enum devlink_dpipe_match_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_action {
	enum devlink_dpipe_action_type type;
	unsigned int header_index;
	struct devlink_dpipe_header *header;
	unsigned int field_id;
};

struct devlink_dpipe_value {
	union {
		struct devlink_dpipe_action *action;
		struct devlink_dpipe_match *match;
	};
	unsigned int mapping_value;
	bool mapping_valid;
	unsigned int value_size;
	void *value;
	void *mask;
};

struct devlink_dpipe_entry {
	u64 index;
	struct devlink_dpipe_value *match_values;
	unsigned int match_values_count;
	struct devlink_dpipe_value *action_values;
	unsigned int action_values_count;
	u64 counter;
	bool counter_valid;
	int: 24;
	int: 32;
};

struct devlink_dpipe_dump_ctx {
	struct genl_info *info;
	enum devlink_command cmd;
	struct sk_buff *skb;
	struct nlattr *nest;
	void *hdr;
};

struct devlink_dpipe_table_ops;

struct devlink_dpipe_table {
	void *priv;
	struct list_head list;
	const char *name;
	bool counters_enabled;
	bool counter_control_extern;
	bool resource_valid;
	int: 8;
	int: 32;
	u64 resource_id;
	u64 resource_units;
	struct devlink_dpipe_table_ops *table_ops;
	struct callback_head rcu;
	int: 32;
};

struct devlink_dpipe_table_ops {
	int (*actions_dump)(void *, struct sk_buff *);
	int (*matches_dump)(void *, struct sk_buff *);
	int (*entries_dump)(void *, bool, struct devlink_dpipe_dump_ctx *);
	int (*counters_set_update)(void *, bool);
	u64 (*size_get)(void *);
};

struct devlink_dpipe_headers {
	struct devlink_dpipe_header **headers;
	unsigned int headers_count;
};

struct devlink_resource_size_params {
	u64 size_min;
	u64 size_max;
	u64 size_granularity;
	enum devlink_resource_unit unit;
	int: 32;
};

typedef u64 devlink_resource_occ_get_t(void *);

enum devlink_param_type {
	DEVLINK_PARAM_TYPE_U8 = 0,
	DEVLINK_PARAM_TYPE_U16 = 1,
	DEVLINK_PARAM_TYPE_U32 = 2,
	DEVLINK_PARAM_TYPE_STRING = 3,
	DEVLINK_PARAM_TYPE_BOOL = 4,
};

struct devlink_flash_notify {
	const char *status_msg;
	const char *component;
	long unsigned int done;
	long unsigned int total;
	long unsigned int timeout;
};

struct devlink_param {
	u32 id;
	const char *name;
	bool generic;
	enum devlink_param_type type;
	long unsigned int supported_cmodes;
	int (*get)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*set)(struct devlink *, u32, struct devlink_param_gset_ctx *);
	int (*validate)(struct devlink *, u32, union devlink_param_value, struct netlink_ext_ack *);
};

struct devlink_param_item {
	struct list_head list;
	const struct devlink_param *param;
	union devlink_param_value driverinit_value;
	bool driverinit_value_valid;
};

enum devlink_param_generic_id {
	DEVLINK_PARAM_GENERIC_ID_INT_ERR_RESET = 0,
	DEVLINK_PARAM_GENERIC_ID_MAX_MACS = 1,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_SRIOV = 2,
	DEVLINK_PARAM_GENERIC_ID_REGION_SNAPSHOT = 3,
	DEVLINK_PARAM_GENERIC_ID_IGNORE_ARI = 4,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MAX = 5,
	DEVLINK_PARAM_GENERIC_ID_MSIX_VEC_PER_PF_MIN = 6,
	DEVLINK_PARAM_GENERIC_ID_FW_LOAD_POLICY = 7,
	DEVLINK_PARAM_GENERIC_ID_RESET_DEV_ON_DRV_PROBE = 8,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_ROCE = 9,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_REMOTE_DEV_RESET = 10,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_ETH = 11,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_RDMA = 12,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_VNET = 13,
	DEVLINK_PARAM_GENERIC_ID_ENABLE_IWARP = 14,
	DEVLINK_PARAM_GENERIC_ID_IO_EQ_SIZE = 15,
	DEVLINK_PARAM_GENERIC_ID_EVENT_EQ_SIZE = 16,
	__DEVLINK_PARAM_GENERIC_ID_MAX = 17,
	DEVLINK_PARAM_GENERIC_ID_MAX = 16,
};

struct devlink_flash_update_params {
	const struct firmware *fw;
	const char *component;
	u32 overwrite_mask;
};

struct devlink_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink *, const struct devlink_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

struct devlink_port_region_ops {
	const char *name;
	void (*destructor)(const void *);
	int (*snapshot)(struct devlink_port *, const struct devlink_port_region_ops *, struct netlink_ext_ack *, u8 **);
	void *priv;
};

enum devlink_health_reporter_state {
	DEVLINK_HEALTH_REPORTER_STATE_HEALTHY = 0,
	DEVLINK_HEALTH_REPORTER_STATE_ERROR = 1,
};

struct devlink_health_reporter;

struct devlink_fmsg;

struct devlink_health_reporter_ops {
	char *name;
	int (*recover)(struct devlink_health_reporter *, void *, struct netlink_ext_ack *);
	int (*dump)(struct devlink_health_reporter *, struct devlink_fmsg *, void *, struct netlink_ext_ack *);
	int (*diagnose)(struct devlink_health_reporter *, struct devlink_fmsg *, struct netlink_ext_ack *);
	int (*test)(struct devlink_health_reporter *, struct netlink_ext_ack *);
};

struct devlink_health_reporter {
	struct list_head list;
	void *priv;
	const struct devlink_health_reporter_ops *ops;
	struct devlink *devlink;
	struct devlink_port *devlink_port;
	struct devlink_fmsg *dump_fmsg;
	struct mutex dump_lock;
	u64 graceful_period;
	bool auto_recover;
	bool auto_dump;
	u8 health_state;
	int: 8;
	int: 32;
	u64 dump_ts;
	u64 dump_real_ts;
	u64 error_count;
	u64 recovery_count;
	u64 last_recovery_ts;
	refcount_t refcount;
	int: 32;
};

struct devlink_fmsg {
	struct list_head item_list;
	bool putting_binary;
};

struct devlink_trap_metadata {
	const char *trap_name;
	const char *trap_group_name;
	struct net_device *input_dev;
	netdevice_tracker dev_tracker;
	const struct flow_action_cookie *fa_cookie;
	enum devlink_trap_type trap_type;
};

struct devlink_trap_policer {
	u32 id;
	int: 32;
	u64 init_rate;
	u64 init_burst;
	u64 max_rate;
	u64 min_rate;
	u64 max_burst;
	u64 min_burst;
};

struct devlink_trap_group {
	const char *name;
	u16 id;
	bool generic;
	u32 init_policer_id;
};

struct devlink_trap {
	enum devlink_trap_type type;
	enum devlink_trap_action init_action;
	bool generic;
	u16 id;
	const char *name;
	u16 init_group_id;
	u32 metadata_cap;
};

enum devlink_trap_generic_id {
	DEVLINK_TRAP_GENERIC_ID_SMAC_MC = 0,
	DEVLINK_TRAP_GENERIC_ID_VLAN_TAG_MISMATCH = 1,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_VLAN_FILTER = 2,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_STP_FILTER = 3,
	DEVLINK_TRAP_GENERIC_ID_EMPTY_TX_LIST = 4,
	DEVLINK_TRAP_GENERIC_ID_PORT_LOOPBACK_FILTER = 5,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_ROUTE = 6,
	DEVLINK_TRAP_GENERIC_ID_TTL_ERROR = 7,
	DEVLINK_TRAP_GENERIC_ID_TAIL_DROP = 8,
	DEVLINK_TRAP_GENERIC_ID_NON_IP_PACKET = 9,
	DEVLINK_TRAP_GENERIC_ID_UC_DIP_MC_DMAC = 10,
	DEVLINK_TRAP_GENERIC_ID_DIP_LB = 11,
	DEVLINK_TRAP_GENERIC_ID_SIP_MC = 12,
	DEVLINK_TRAP_GENERIC_ID_SIP_LB = 13,
	DEVLINK_TRAP_GENERIC_ID_CORRUPTED_IP_HDR = 14,
	DEVLINK_TRAP_GENERIC_ID_IPV4_SIP_BC = 15,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_RESERVED_SCOPE = 16,
	DEVLINK_TRAP_GENERIC_ID_IPV6_MC_DIP_INTERFACE_LOCAL_SCOPE = 17,
	DEVLINK_TRAP_GENERIC_ID_MTU_ERROR = 18,
	DEVLINK_TRAP_GENERIC_ID_UNRESOLVED_NEIGH = 19,
	DEVLINK_TRAP_GENERIC_ID_RPF = 20,
	DEVLINK_TRAP_GENERIC_ID_REJECT_ROUTE = 21,
	DEVLINK_TRAP_GENERIC_ID_IPV4_LPM_UNICAST_MISS = 22,
	DEVLINK_TRAP_GENERIC_ID_IPV6_LPM_UNICAST_MISS = 23,
	DEVLINK_TRAP_GENERIC_ID_NON_ROUTABLE = 24,
	DEVLINK_TRAP_GENERIC_ID_DECAP_ERROR = 25,
	DEVLINK_TRAP_GENERIC_ID_OVERLAY_SMAC_MC = 26,
	DEVLINK_TRAP_GENERIC_ID_INGRESS_FLOW_ACTION_DROP = 27,
	DEVLINK_TRAP_GENERIC_ID_EGRESS_FLOW_ACTION_DROP = 28,
	DEVLINK_TRAP_GENERIC_ID_STP = 29,
	DEVLINK_TRAP_GENERIC_ID_LACP = 30,
	DEVLINK_TRAP_GENERIC_ID_LLDP = 31,
	DEVLINK_TRAP_GENERIC_ID_IGMP_QUERY = 32,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V1_REPORT = 33,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_REPORT = 34,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V3_REPORT = 35,
	DEVLINK_TRAP_GENERIC_ID_IGMP_V2_LEAVE = 36,
	DEVLINK_TRAP_GENERIC_ID_MLD_QUERY = 37,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_REPORT = 38,
	DEVLINK_TRAP_GENERIC_ID_MLD_V2_REPORT = 39,
	DEVLINK_TRAP_GENERIC_ID_MLD_V1_DONE = 40,
	DEVLINK_TRAP_GENERIC_ID_IPV4_DHCP = 41,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DHCP = 42,
	DEVLINK_TRAP_GENERIC_ID_ARP_REQUEST = 43,
	DEVLINK_TRAP_GENERIC_ID_ARP_RESPONSE = 44,
	DEVLINK_TRAP_GENERIC_ID_ARP_OVERLAY = 45,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_SOLICIT = 46,
	DEVLINK_TRAP_GENERIC_ID_IPV6_NEIGH_ADVERT = 47,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BFD = 48,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BFD = 49,
	DEVLINK_TRAP_GENERIC_ID_IPV4_OSPF = 50,
	DEVLINK_TRAP_GENERIC_ID_IPV6_OSPF = 51,
	DEVLINK_TRAP_GENERIC_ID_IPV4_BGP = 52,
	DEVLINK_TRAP_GENERIC_ID_IPV6_BGP = 53,
	DEVLINK_TRAP_GENERIC_ID_IPV4_VRRP = 54,
	DEVLINK_TRAP_GENERIC_ID_IPV6_VRRP = 55,
	DEVLINK_TRAP_GENERIC_ID_IPV4_PIM = 56,
	DEVLINK_TRAP_GENERIC_ID_IPV6_PIM = 57,
	DEVLINK_TRAP_GENERIC_ID_UC_LB = 58,
	DEVLINK_TRAP_GENERIC_ID_LOCAL_ROUTE = 59,
	DEVLINK_TRAP_GENERIC_ID_EXTERNAL_ROUTE = 60,
	DEVLINK_TRAP_GENERIC_ID_IPV6_UC_DIP_LINK_LOCAL_SCOPE = 61,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_NODES = 62,
	DEVLINK_TRAP_GENERIC_ID_IPV6_DIP_ALL_ROUTERS = 63,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_SOLICIT = 64,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ADVERT = 65,
	DEVLINK_TRAP_GENERIC_ID_IPV6_REDIRECT = 66,
	DEVLINK_TRAP_GENERIC_ID_IPV4_ROUTER_ALERT = 67,
	DEVLINK_TRAP_GENERIC_ID_IPV6_ROUTER_ALERT = 68,
	DEVLINK_TRAP_GENERIC_ID_PTP_EVENT = 69,
	DEVLINK_TRAP_GENERIC_ID_PTP_GENERAL = 70,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_SAMPLE = 71,
	DEVLINK_TRAP_GENERIC_ID_FLOW_ACTION_TRAP = 72,
	DEVLINK_TRAP_GENERIC_ID_EARLY_DROP = 73,
	DEVLINK_TRAP_GENERIC_ID_VXLAN_PARSING = 74,
	DEVLINK_TRAP_GENERIC_ID_LLC_SNAP_PARSING = 75,
	DEVLINK_TRAP_GENERIC_ID_VLAN_PARSING = 76,
	DEVLINK_TRAP_GENERIC_ID_PPPOE_PPP_PARSING = 77,
	DEVLINK_TRAP_GENERIC_ID_MPLS_PARSING = 78,
	DEVLINK_TRAP_GENERIC_ID_ARP_PARSING = 79,
	DEVLINK_TRAP_GENERIC_ID_IP_1_PARSING = 80,
	DEVLINK_TRAP_GENERIC_ID_IP_N_PARSING = 81,
	DEVLINK_TRAP_GENERIC_ID_GRE_PARSING = 82,
	DEVLINK_TRAP_GENERIC_ID_UDP_PARSING = 83,
	DEVLINK_TRAP_GENERIC_ID_TCP_PARSING = 84,
	DEVLINK_TRAP_GENERIC_ID_IPSEC_PARSING = 85,
	DEVLINK_TRAP_GENERIC_ID_SCTP_PARSING = 86,
	DEVLINK_TRAP_GENERIC_ID_DCCP_PARSING = 87,
	DEVLINK_TRAP_GENERIC_ID_GTP_PARSING = 88,
	DEVLINK_TRAP_GENERIC_ID_ESP_PARSING = 89,
	DEVLINK_TRAP_GENERIC_ID_BLACKHOLE_NEXTHOP = 90,
	DEVLINK_TRAP_GENERIC_ID_DMAC_FILTER = 91,
	__DEVLINK_TRAP_GENERIC_ID_MAX = 92,
	DEVLINK_TRAP_GENERIC_ID_MAX = 91,
};

enum devlink_trap_group_generic_id {
	DEVLINK_TRAP_GROUP_GENERIC_ID_L2_DROPS = 0,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_DROPS = 1,
	DEVLINK_TRAP_GROUP_GENERIC_ID_L3_EXCEPTIONS = 2,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BUFFER_DROPS = 3,
	DEVLINK_TRAP_GROUP_GENERIC_ID_TUNNEL_DROPS = 4,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_DROPS = 5,
	DEVLINK_TRAP_GROUP_GENERIC_ID_STP = 6,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LACP = 7,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LLDP = 8,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MC_SNOOPING = 9,
	DEVLINK_TRAP_GROUP_GENERIC_ID_DHCP = 10,
	DEVLINK_TRAP_GROUP_GENERIC_ID_NEIGH_DISCOVERY = 11,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BFD = 12,
	DEVLINK_TRAP_GROUP_GENERIC_ID_OSPF = 13,
	DEVLINK_TRAP_GROUP_GENERIC_ID_BGP = 14,
	DEVLINK_TRAP_GROUP_GENERIC_ID_VRRP = 15,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PIM = 16,
	DEVLINK_TRAP_GROUP_GENERIC_ID_UC_LB = 17,
	DEVLINK_TRAP_GROUP_GENERIC_ID_LOCAL_DELIVERY = 18,
	DEVLINK_TRAP_GROUP_GENERIC_ID_EXTERNAL_DELIVERY = 19,
	DEVLINK_TRAP_GROUP_GENERIC_ID_IPV6 = 20,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_EVENT = 21,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PTP_GENERAL = 22,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_SAMPLE = 23,
	DEVLINK_TRAP_GROUP_GENERIC_ID_ACL_TRAP = 24,
	DEVLINK_TRAP_GROUP_GENERIC_ID_PARSER_ERROR_DROPS = 25,
	__DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 26,
	DEVLINK_TRAP_GROUP_GENERIC_ID_MAX = 25,
};

enum {
	DEVLINK_F_RELOAD = 1,
};

struct devlink_info_req;

struct devlink_ops {
	u32 supported_flash_update_params;
	long unsigned int reload_actions;
	long unsigned int reload_limits;
	int (*reload_down)(struct devlink *, bool, enum devlink_reload_action, enum devlink_reload_limit, struct netlink_ext_ack *);
	int (*reload_up)(struct devlink *, enum devlink_reload_action, enum devlink_reload_limit, u32 *, struct netlink_ext_ack *);
	int (*port_type_set)(struct devlink_port *, enum devlink_port_type);
	int (*port_split)(struct devlink *, struct devlink_port *, unsigned int, struct netlink_ext_ack *);
	int (*port_unsplit)(struct devlink *, struct devlink_port *, struct netlink_ext_ack *);
	int (*sb_pool_get)(struct devlink *, unsigned int, u16, struct devlink_sb_pool_info *);
	int (*sb_pool_set)(struct devlink *, unsigned int, u16, u32, enum devlink_sb_threshold_type, struct netlink_ext_ack *);
	int (*sb_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *);
	int (*sb_port_pool_set)(struct devlink_port *, unsigned int, u16, u32, struct netlink_ext_ack *);
	int (*sb_tc_pool_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16 *, u32 *);
	int (*sb_tc_pool_bind_set)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u16, u32, struct netlink_ext_ack *);
	int (*sb_occ_snapshot)(struct devlink *, unsigned int);
	int (*sb_occ_max_clear)(struct devlink *, unsigned int);
	int (*sb_occ_port_pool_get)(struct devlink_port *, unsigned int, u16, u32 *, u32 *);
	int (*sb_occ_tc_port_bind_get)(struct devlink_port *, unsigned int, u16, enum devlink_sb_pool_type, u32 *, u32 *);
	int (*eswitch_mode_get)(struct devlink *, u16 *);
	int (*eswitch_mode_set)(struct devlink *, u16, struct netlink_ext_ack *);
	int (*eswitch_inline_mode_get)(struct devlink *, u8 *);
	int (*eswitch_inline_mode_set)(struct devlink *, u8, struct netlink_ext_ack *);
	int (*eswitch_encap_mode_get)(struct devlink *, enum devlink_eswitch_encap_mode *);
	int (*eswitch_encap_mode_set)(struct devlink *, enum devlink_eswitch_encap_mode, struct netlink_ext_ack *);
	int (*info_get)(struct devlink *, struct devlink_info_req *, struct netlink_ext_ack *);
	int (*flash_update)(struct devlink *, struct devlink_flash_update_params *, struct netlink_ext_ack *);
	int (*trap_init)(struct devlink *, const struct devlink_trap *, void *);
	void (*trap_fini)(struct devlink *, const struct devlink_trap *, void *);
	int (*trap_action_set)(struct devlink *, const struct devlink_trap *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_group_init)(struct devlink *, const struct devlink_trap_group *);
	int (*trap_group_set)(struct devlink *, const struct devlink_trap_group *, const struct devlink_trap_policer *, struct netlink_ext_ack *);
	int (*trap_group_action_set)(struct devlink *, const struct devlink_trap_group *, enum devlink_trap_action, struct netlink_ext_ack *);
	int (*trap_drop_counter_get)(struct devlink *, const struct devlink_trap *, u64 *);
	int (*trap_policer_init)(struct devlink *, const struct devlink_trap_policer *);
	void (*trap_policer_fini)(struct devlink *, const struct devlink_trap_policer *);
	int (*trap_policer_set)(struct devlink *, const struct devlink_trap_policer *, u64, u64, struct netlink_ext_ack *);
	int (*trap_policer_counter_get)(struct devlink *, const struct devlink_trap_policer *, u64 *);
	int (*port_function_hw_addr_get)(struct devlink_port *, u8 *, int *, struct netlink_ext_ack *);
	int (*port_function_hw_addr_set)(struct devlink_port *, const u8 *, int, struct netlink_ext_ack *);
	int (*port_new)(struct devlink *, const struct devlink_port_new_attrs *, struct netlink_ext_ack *, unsigned int *);
	int (*port_del)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	int (*port_fn_state_get)(struct devlink_port *, enum devlink_port_fn_state *, enum devlink_port_fn_opstate *, struct netlink_ext_ack *);
	int (*port_fn_state_set)(struct devlink_port *, enum devlink_port_fn_state, struct netlink_ext_ack *);
	int (*rate_leaf_tx_share_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_leaf_tx_max_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_node_tx_share_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_node_tx_max_set)(struct devlink_rate *, void *, u64, struct netlink_ext_ack *);
	int (*rate_node_new)(struct devlink_rate *, void **, struct netlink_ext_ack *);
	int (*rate_node_del)(struct devlink_rate *, void *, struct netlink_ext_ack *);
	int (*rate_leaf_parent_set)(struct devlink_rate *, struct devlink_rate *, void *, void *, struct netlink_ext_ack *);
	int (*rate_node_parent_set)(struct devlink_rate *, struct devlink_rate *, void *, void *, struct netlink_ext_ack *);
	bool (*selftest_check)(struct devlink *, unsigned int, struct netlink_ext_ack *);
	enum devlink_selftest_status (*selftest_run)(struct devlink *, unsigned int, struct netlink_ext_ack *);
};

enum devlink_info_version_type {
	DEVLINK_INFO_VERSION_TYPE_NONE = 0,
	DEVLINK_INFO_VERSION_TYPE_COMPONENT = 1,
};

struct devlink_info_req {
	struct sk_buff *msg;
	void (*version_cb)(const char *, enum devlink_info_version_type, void *);
	void *version_cb_priv;
};

struct trace_event_raw_devlink_hwmsg {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	bool incoming;
	long unsigned int type;
	u32 __data_loc_buf;
	size_t len;
	char __data[0];
};

struct trace_event_raw_devlink_hwerr {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	int err;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_devlink_health_recover_aborted {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	bool health_state;
	int: 24;
	int: 32;
	u64 time_since_last_recover;
	char __data[0];
};

struct trace_event_raw_devlink_health_reporter_state_update {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_reporter_name;
	u8 new_state;
	char __data[0];
};

struct trace_event_raw_devlink_trap_report {
	struct trace_entry ent;
	u32 __data_loc_bus_name;
	u32 __data_loc_dev_name;
	u32 __data_loc_driver_name;
	u32 __data_loc_trap_name;
	u32 __data_loc_trap_group_name;
	char input_dev_name[16];
	char __data[0];
};

struct trace_event_data_offsets_devlink_hwmsg {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 buf;
};

struct trace_event_data_offsets_devlink_hwerr {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
	u32 msg;
};

struct trace_event_data_offsets_devlink_health_recover_aborted {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_health_reporter_state_update {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 reporter_name;
};

struct trace_event_data_offsets_devlink_trap_report {
	u32 bus_name;
	u32 dev_name;
	u32 driver_name;
	u32 trap_name;
	u32 trap_group_name;
};

typedef void (*btf_trace_devlink_hwmsg)(void *, const struct devlink *, bool, long unsigned int, const u8 *, size_t);

typedef void (*btf_trace_devlink_hwerr)(void *, const struct devlink *, int, const char *);

typedef void (*btf_trace_devlink_health_report)(void *, const struct devlink *, const char *, const char *);

typedef void (*btf_trace_devlink_health_recover_aborted)(void *, const struct devlink *, const char *, bool, u64);

typedef void (*btf_trace_devlink_health_reporter_state_update)(void *, const struct devlink *, const char *, bool);

typedef void (*btf_trace_devlink_trap_report)(void *, const struct devlink *, struct sk_buff *, const struct devlink_trap_metadata *);

struct devlink_linecard_type {
	const char *type;
	const void *priv;
};

struct devlink_resource {
	const char *name;
	int: 32;
	u64 id;
	u64 size;
	u64 size_new;
	bool size_valid;
	struct devlink_resource *parent;
	struct devlink_resource_size_params size_params;
	struct list_head list;
	struct list_head resource_list;
	devlink_resource_occ_get_t *occ_get;
	void *occ_get_priv;
};

struct devlink_sb {
	struct list_head list;
	unsigned int index;
	u32 size;
	u16 ingress_pools_count;
	u16 egress_pools_count;
	u16 ingress_tc_count;
	u16 egress_tc_count;
};

struct devlink_region {
	struct devlink *devlink;
	struct devlink_port *port;
	struct list_head list;
	union {
		const struct devlink_region_ops *ops;
		const struct devlink_port_region_ops *port_ops;
	};
	struct mutex snapshot_lock;
	struct list_head snapshot_list;
	u32 max_snapshots;
	u32 cur_snapshots;
	u64 size;
};

struct devlink_snapshot {
	struct list_head list;
	struct devlink_region *region;
	u8 *data;
	u32 id;
};

enum devlink_multicast_groups {
	DEVLINK_MCGRP_CONFIG = 0,
};

struct devlink_reload_combination {
	enum devlink_reload_action action;
	enum devlink_reload_limit limit;
};

struct devlink_flash_component_lookup_ctx {
	const char *lookup_name;
	bool lookup_name_found;
};

struct devlink_fmsg_item {
	struct list_head list;
	int attrtype;
	u8 nla_type;
	u16 len;
	int value[0];
};

struct devlink_stats {
	u64_stats_t rx_bytes;
	u64_stats_t rx_packets;
	struct u64_stats_sync syncp;
	int: 32;
};

struct devlink_trap_policer_item {
	const struct devlink_trap_policer *policer;
	int: 32;
	u64 rate;
	u64 burst;
	struct list_head list;
};

struct devlink_trap_group_item {
	const struct devlink_trap_group *group;
	struct devlink_trap_policer_item *policer_item;
	struct list_head list;
	struct devlink_stats *stats;
};

struct devlink_trap_item {
	const struct devlink_trap *trap;
	struct devlink_trap_group_item *group_item;
	struct list_head list;
	enum devlink_trap_action action;
	struct devlink_stats *stats;
	void *priv;
};

struct gro_cell;

struct gro_cells {
	struct gro_cell *cells;
};

struct gro_cell {
	struct sk_buff_head napi_skbs;
	struct napi_struct napi;
};

struct percpu_free_defer {
	struct callback_head rcu;
	void *ptr;
};

enum __sk_action {
	__SK_DROP = 0,
	__SK_PASS = 1,
	__SK_REDIRECT = 2,
	__SK_NONE = 3,
};

enum sk_psock_state_bits {
	SK_PSOCK_TX_ENABLED = 0,
};

struct sk_psock_link {
	struct list_head list;
	struct bpf_map *map;
	void *link_raw;
};

struct bpf_stab {
	struct bpf_map map;
	struct sock **sks;
	struct sk_psock_progs progs;
	raw_spinlock_t lock;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef u64 (*btf_bpf_sock_map_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_map)(struct sk_buff *, struct bpf_map *, u32, u64);

typedef u64 (*btf_bpf_msg_redirect_map)(struct sk_msg *, struct bpf_map *, u32, u64);

struct sock_map_seq_info {
	struct bpf_map *map;
	struct sock *sk;
	u32 index;
};

struct bpf_iter__sockmap {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		void *key;
	};
	union {
		struct sock *sk;
	};
};

struct bpf_shtab_elem {
	struct callback_head rcu;
	u32 hash;
	struct sock *sk;
	struct hlist_node node;
	u8 key[0];
};

struct bpf_shtab_bucket {
	struct hlist_head head;
	raw_spinlock_t lock;
};

struct bpf_shtab {
	struct bpf_map map;
	struct bpf_shtab_bucket *buckets;
	u32 buckets_num;
	u32 elem_size;
	struct sk_psock_progs progs;
	atomic_t count;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

typedef u64 (*btf_bpf_sock_hash_update)(struct bpf_sock_ops_kern *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_sk_redirect_hash)(struct sk_buff *, struct bpf_map *, void *, u64);

typedef u64 (*btf_bpf_msg_redirect_hash)(struct sk_msg *, struct bpf_map *, void *, u64);

struct sock_hash_seq_info {
	struct bpf_map *map;
	struct bpf_shtab *htab;
	u32 bucket_id;
};

enum {
	SK_DIAG_BPF_STORAGE_REQ_NONE = 0,
	SK_DIAG_BPF_STORAGE_REQ_MAP_FD = 1,
	__SK_DIAG_BPF_STORAGE_REQ_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_REP_NONE = 0,
	SK_DIAG_BPF_STORAGE = 1,
	__SK_DIAG_BPF_STORAGE_REP_MAX = 2,
};

enum {
	SK_DIAG_BPF_STORAGE_NONE = 0,
	SK_DIAG_BPF_STORAGE_PAD = 1,
	SK_DIAG_BPF_STORAGE_MAP_ID = 2,
	SK_DIAG_BPF_STORAGE_MAP_VALUE = 3,
	__SK_DIAG_BPF_STORAGE_MAX = 4,
};

typedef u64 (*btf_bpf_sk_storage_get)(struct bpf_map *, struct sock *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_sk_storage_delete)(struct bpf_map *, struct sock *);

typedef u64 (*btf_bpf_sk_storage_get_tracing)(struct bpf_map *, struct sock *, void *, u64, gfp_t);

typedef u64 (*btf_bpf_sk_storage_delete_tracing)(struct bpf_map *, struct sock *);

struct bpf_sk_storage_diag {
	u32 nr_maps;
	struct bpf_map *maps[0];
};

struct bpf_iter_seq_sk_storage_map_info {
	struct bpf_map *map;
	unsigned int bucket_id;
	unsigned int skip_elems;
};

struct bpf_iter__bpf_sk_storage_map {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct bpf_map *map;
	};
	union {
		struct sock *sk;
	};
	union {
		void *value;
	};
};

struct llc_addr {
	unsigned char lsap;
	unsigned char mac[6];
};

struct llc_sap {
	unsigned char state;
	unsigned char p_bit;
	unsigned char f_bit;
	refcount_t refcnt;
	int (*rcv_func)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	struct llc_addr laddr;
	struct list_head node;
	spinlock_t sk_lock;
	int sk_count;
	struct hlist_nulls_head sk_laddr_hash[64];
	struct hlist_head sk_dev_hash[64];
	struct callback_head rcu;
};

struct llc_pdu_sn {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
	u8 ctrl_2;
};

struct llc_pdu_un {
	u8 dsap;
	u8 ssap;
	u8 ctrl_1;
};

struct sockaddr_llc {
	__kernel_sa_family_t sllc_family;
	__kernel_sa_family_t sllc_arphrd;
	unsigned char sllc_test;
	unsigned char sllc_xid;
	unsigned char sllc_ua;
	unsigned char sllc_sap;
	unsigned char sllc_mac[6];
	unsigned char __pad[2];
};

struct llc_timer {
	struct timer_list timer;
	long unsigned int expire;
};

struct llc_sock {
	struct sock sk;
	struct sockaddr_llc addr;
	u8 state;
	struct llc_sap *sap;
	struct llc_addr laddr;
	struct llc_addr daddr;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 copied_seq;
	u8 retry_count;
	u8 ack_must_be_send;
	u8 first_pdu_Ns;
	u8 npta;
	struct llc_timer ack_timer;
	struct llc_timer pf_cycle_timer;
	struct llc_timer rej_sent_timer;
	struct llc_timer busy_state_timer;
	u8 vS;
	u8 vR;
	u32 n2;
	u32 n1;
	u8 k;
	u8 rw;
	u8 p_flag;
	u8 f_flag;
	u8 s_flag;
	u8 data_flag;
	u8 remote_busy_flag;
	u8 cause_flag;
	struct sk_buff_head pdu_unack_q;
	u16 link;
	u8 X;
	u8 ack_pf;
	u8 failed_data_req;
	u8 dec_step;
	u8 inc_cntr;
	u8 dec_cntr;
	u8 connect_step;
	u8 last_nr;
	u32 rx_pdu_hdr;
	u32 cmsg_flags;
	struct hlist_node dev_hash_node;
	int: 32;
};

struct llc_conn_state_ev {
	u8 type;
	u8 prim;
	u8 prim_type;
	u8 reason;
	u8 status;
	u8 ind_prim;
	u8 cfm_prim;
};

typedef int (*llc_conn_ev_t)(struct sock *, struct sk_buff *);

typedef int (*llc_conn_ev_qfyr_t)(struct sock *, struct sk_buff *);

typedef int (*llc_conn_action_t)(struct sock *, struct sk_buff *);

struct llc_conn_state_trans {
	llc_conn_ev_t ev;
	u8 next_state;
	const llc_conn_ev_qfyr_t *ev_qualifiers;
	const llc_conn_action_t *ev_actions;
};

struct llc_conn_state {
	u8 current_state;
	struct llc_conn_state_trans **transitions;
};

struct llc_frmr_info {
	u16 rej_pdu_ctrl;
	u8 curr_ssv;
	u8 curr_rsv;
	u8 ind_bits;
} __attribute__((packed));

typedef int (*llc_sap_action_t)(struct llc_sap *, struct sk_buff *);

struct llc_sap_state_ev {
	u8 prim;
	u8 prim_type;
	u8 type;
	u8 reason;
	u8 ind_cfm_flag;
	struct llc_addr saddr;
	struct llc_addr daddr;
};

typedef int (*llc_sap_ev_t)(struct llc_sap *, struct sk_buff *);

struct llc_sap_state_trans {
	llc_sap_ev_t ev;
	u8 next_state;
	const llc_sap_action_t *ev_actions;
};

struct llc_sap_state {
	u8 curr_state;
	struct llc_sap_state_trans **transitions;
};

struct llc_xid_info {
	u8 fmt_id;
	u8 type;
	u8 rw;
};

enum llc_sockopts {
	LLC_OPT_UNKNOWN = 0,
	LLC_OPT_RETRY = 1,
	LLC_OPT_SIZE = 2,
	LLC_OPT_ACK_TMR_EXP = 3,
	LLC_OPT_P_TMR_EXP = 4,
	LLC_OPT_REJ_TMR_EXP = 5,
	LLC_OPT_BUSY_TMR_EXP = 6,
	LLC_OPT_TX_WIN = 7,
	LLC_OPT_RX_WIN = 8,
	LLC_OPT_PKTINFO = 9,
	LLC_OPT_MAX = 10,
};

struct llc_pktinfo {
	int lpi_ifindex;
	unsigned char lpi_sap;
	unsigned char lpi_mac[6];
};

struct datalink_proto {
	unsigned char type[8];
	struct llc_sap *sap;
	short unsigned int header_length;
	int (*rcvfunc)(struct sk_buff *, struct net_device *, struct packet_type *, struct net_device *);
	int (*request)(struct datalink_proto *, struct sk_buff *, const unsigned char *);
	struct list_head node;
};

struct tc_ratespec {
	unsigned char cell_log;
	__u8 linklayer;
	short unsigned int overhead;
	short int cell_align;
	short unsigned int mpu;
	__u32 rate;
};

struct tc_prio_qopt {
	int bands;
	__u8 priomap[16];
};

enum {
	TCA_UNSPEC = 0,
	TCA_KIND = 1,
	TCA_OPTIONS = 2,
	TCA_STATS = 3,
	TCA_XSTATS = 4,
	TCA_RATE = 5,
	TCA_FCNT = 6,
	TCA_STATS2 = 7,
	TCA_STAB = 8,
	TCA_PAD = 9,
	TCA_DUMP_INVISIBLE = 10,
	TCA_CHAIN = 11,
	TCA_HW_OFFLOAD = 12,
	TCA_INGRESS_BLOCK = 13,
	TCA_EGRESS_BLOCK = 14,
	TCA_DUMP_FLAGS = 15,
	__TCA_MAX = 16,
};

struct skb_array {
	struct ptr_ring ring;
};

struct psched_ratecfg {
	u64 rate_bytes_ps;
	u32 mult;
	u16 overhead;
	u16 mpu;
	u8 linklayer;
	u8 shift;
	int: 16;
	int: 32;
};

struct psched_pktrate {
	u64 rate_pkts_ps;
	u32 mult;
	u8 shift;
};

struct mini_Qdisc_pair {
	struct mini_Qdisc miniq1;
	struct mini_Qdisc miniq2;
	struct mini_Qdisc **p_miniq;
};

struct xfrm_offload {
	struct {
		__u32 low;
		__u32 hi;
	} seq;
	__u32 flags;
	__u32 status;
	__u8 proto;
	__u8 inner_ipproto;
};

struct pfifo_fast_priv {
	struct skb_array q[3];
};

struct tc_qopt_offload_stats {
	struct gnet_stats_basic_sync *bstats;
	struct gnet_stats_queue *qstats;
};

enum tc_mq_command {
	TC_MQ_CREATE = 0,
	TC_MQ_DESTROY = 1,
	TC_MQ_STATS = 2,
	TC_MQ_GRAFT = 3,
};

struct tc_mq_opt_offload_graft_params {
	long unsigned int queue;
	u32 child_handle;
};

struct tc_mq_qopt_offload {
	enum tc_mq_command command;
	u32 handle;
	union {
		struct tc_qopt_offload_stats stats;
		struct tc_mq_opt_offload_graft_params graft_params;
	};
};

struct mq_sched {
	struct Qdisc **qdiscs;
};

struct sch_frag_data {
	long unsigned int dst;
	struct qdisc_skb_cb cb;
	__be16 inner_protocol;
	u16 vlan_tci;
	__be16 vlan_proto;
	unsigned int l2_len;
	u8 l2_data[18];
	int (*xmit)(struct sk_buff *);
};

enum tc_link_layer {
	TC_LINKLAYER_UNAWARE = 0,
	TC_LINKLAYER_ETHERNET = 1,
	TC_LINKLAYER_ATM = 2,
};

enum {
	TCA_STAB_UNSPEC = 0,
	TCA_STAB_BASE = 1,
	TCA_STAB_DATA = 2,
	__TCA_STAB_MAX = 3,
};

struct qdisc_rate_table {
	struct tc_ratespec rate;
	u32 data[256];
	struct qdisc_rate_table *next;
	int refcnt;
};

struct Qdisc_class_common {
	u32 classid;
	struct hlist_node hnode;
};

struct Qdisc_class_hash {
	struct hlist_head *hash;
	unsigned int hashsize;
	unsigned int hashmask;
	unsigned int hashelems;
};

struct qdisc_watchdog {
	u64 last_expires;
	struct hrtimer timer;
	struct Qdisc *qdisc;
	int: 32;
};

struct tc_query_caps_base {
	enum tc_setup_type type;
	void *caps;
};

enum tc_root_command {
	TC_ROOT_GRAFT = 0,
};

struct tc_root_qopt_offload {
	enum tc_root_command command;
	u32 handle;
	bool ingress;
};

struct check_loop_arg {
	struct qdisc_walker w;
	struct Qdisc *p;
	int depth;
};

struct tcf_bind_args {
	struct tcf_walker w;
	long unsigned int base;
	long unsigned int cl;
	u32 classid;
};

struct tc_bind_class_args {
	struct qdisc_walker w;
	long unsigned int new_cl;
	u32 portid;
	u32 clid;
};

struct qdisc_dump_args {
	struct qdisc_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
};

enum net_xmit_qdisc_t {
	__NET_XMIT_STOLEN = 65536,
	__NET_XMIT_BYPASS = 131072,
};

enum {
	TCA_ACT_UNSPEC = 0,
	TCA_ACT_KIND = 1,
	TCA_ACT_OPTIONS = 2,
	TCA_ACT_INDEX = 3,
	TCA_ACT_STATS = 4,
	TCA_ACT_PAD = 5,
	TCA_ACT_COOKIE = 6,
	TCA_ACT_FLAGS = 7,
	TCA_ACT_HW_STATS = 8,
	TCA_ACT_USED_HW_STATS = 9,
	TCA_ACT_IN_HW_COUNT = 10,
	__TCA_ACT_MAX = 11,
};

enum tca_id {
	TCA_ID_UNSPEC = 0,
	TCA_ID_POLICE = 1,
	TCA_ID_GACT = 5,
	TCA_ID_IPT = 6,
	TCA_ID_PEDIT = 7,
	TCA_ID_MIRRED = 8,
	TCA_ID_NAT = 9,
	TCA_ID_XT = 10,
	TCA_ID_SKBEDIT = 11,
	TCA_ID_VLAN = 12,
	TCA_ID_BPF = 13,
	TCA_ID_CONNMARK = 14,
	TCA_ID_SKBMOD = 15,
	TCA_ID_CSUM = 16,
	TCA_ID_TUNNEL_KEY = 17,
	TCA_ID_SIMP = 22,
	TCA_ID_IFE = 25,
	TCA_ID_SAMPLE = 26,
	TCA_ID_CTINFO = 27,
	TCA_ID_MPLS = 28,
	TCA_ID_CT = 29,
	TCA_ID_GATE = 30,
	__TCA_ID_MAX = 255,
};

struct tcf_t {
	__u64 install;
	__u64 lastuse;
	__u64 expires;
	__u64 firstuse;
};

struct psample_group {
	struct list_head list;
	struct net *net;
	u32 group_num;
	u32 refcount;
	u32 seq;
	struct callback_head rcu;
};

struct action_gate_entry {
	u8 gate_state;
	u32 interval;
	s32 ipv;
	s32 maxoctets;
};

enum qdisc_class_ops_flags {
	QDISC_CLASS_OPS_DOIT_UNLOCKED = 1,
};

enum tcf_proto_ops_flags {
	TCF_PROTO_OPS_DOIT_UNLOCKED = 1,
};

typedef void tcf_chain_head_change_t(struct tcf_proto *, void *);

struct tcf_idrinfo {
	struct mutex lock;
	struct idr action_idr;
	struct net *net;
};

struct tc_action_ops;

struct tc_cookie;

struct tc_action {
	const struct tc_action_ops *ops;
	__u32 type;
	struct tcf_idrinfo *idrinfo;
	u32 tcfa_index;
	refcount_t tcfa_refcnt;
	atomic_t tcfa_bindcnt;
	int tcfa_action;
	int: 32;
	struct tcf_t tcfa_tm;
	struct gnet_stats_basic_sync tcfa_bstats;
	struct gnet_stats_basic_sync tcfa_bstats_hw;
	struct gnet_stats_queue tcfa_qstats;
	struct net_rate_estimator *tcfa_rate_est;
	spinlock_t tcfa_lock;
	struct gnet_stats_basic_sync *cpu_bstats;
	struct gnet_stats_basic_sync *cpu_bstats_hw;
	struct gnet_stats_queue *cpu_qstats;
	struct tc_cookie *act_cookie;
	struct tcf_chain *goto_chain;
	u32 tcfa_flags;
	u8 hw_stats;
	u8 used_hw_stats;
	bool used_hw_stats_valid;
	u32 in_hw_count;
	int: 32;
};

typedef void (*tc_action_priv_destructor)(void *);

struct tc_action_ops {
	struct list_head head;
	char kind[16];
	enum tca_id id;
	unsigned int net_id;
	size_t size;
	struct module *owner;
	int (*act)(struct sk_buff *, const struct tc_action *, struct tcf_result *);
	int (*dump)(struct sk_buff *, struct tc_action *, int, int);
	void (*cleanup)(struct tc_action *);
	int (*lookup)(struct net *, struct tc_action **, u32);
	int (*init)(struct net *, struct nlattr *, struct nlattr *, struct tc_action **, struct tcf_proto *, u32, struct netlink_ext_ack *);
	int (*walk)(struct net *, struct sk_buff *, struct netlink_callback *, int, const struct tc_action_ops *, struct netlink_ext_ack *);
	void (*stats_update)(struct tc_action *, u64, u64, u64, u64, bool);
	size_t (*get_fill_size)(const struct tc_action *);
	struct net_device * (*get_dev)(const struct tc_action *, tc_action_priv_destructor *);
	struct psample_group * (*get_psample_group)(const struct tc_action *, tc_action_priv_destructor *);
	int (*offload_act_setup)(struct tc_action *, void *, u32 *, bool, struct netlink_ext_ack *);
};

struct tc_cookie {
	u8 *data;
	u32 len;
	struct callback_head rcu;
};

struct tcf_block_ext_info {
	enum flow_block_binder_type binder_type;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
	u32 block_index;
};

struct tcf_qevent {
	struct tcf_block *block;
	struct tcf_block_ext_info info;
	struct tcf_proto *filter_chain;
};

struct tcf_exts {
	__u32 type;
	int nr_actions;
	struct tc_action **actions;
	struct net *net;
	netns_tracker ns_tracker;
	int action;
	int police;
};

enum pedit_header_type {
	TCA_PEDIT_KEY_EX_HDR_TYPE_NETWORK = 0,
	TCA_PEDIT_KEY_EX_HDR_TYPE_ETH = 1,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP4 = 2,
	TCA_PEDIT_KEY_EX_HDR_TYPE_IP6 = 3,
	TCA_PEDIT_KEY_EX_HDR_TYPE_TCP = 4,
	TCA_PEDIT_KEY_EX_HDR_TYPE_UDP = 5,
	__PEDIT_HDR_TYPE_MAX = 6,
};

enum pedit_cmd {
	TCA_PEDIT_KEY_EX_CMD_SET = 0,
	TCA_PEDIT_KEY_EX_CMD_ADD = 1,
	__PEDIT_CMD_MAX = 2,
};

struct tc_pedit_key {
	__u32 mask;
	__u32 val;
	__u32 off;
	__u32 at;
	__u32 offmask;
	__u32 shift;
};

struct tcf_pedit_key_ex {
	enum pedit_header_type htype;
	enum pedit_cmd cmd;
};

struct tcf_pedit {
	struct tc_action common;
	unsigned char tcfp_nkeys;
	unsigned char tcfp_flags;
	u32 tcfp_off_max_hint;
	struct tc_pedit_key *tcfp_keys;
	struct tcf_pedit_key_ex *tcfp_keys_ex;
};

struct tcf_filter_chain_list_item {
	struct list_head list;
	tcf_chain_head_change_t *chain_head_change;
	void *chain_head_change_priv;
};

struct tcf_net {
	spinlock_t idr_lock;
	struct idr idr;
};

struct tcf_block_owner_item {
	struct list_head list;
	struct Qdisc *q;
	enum flow_block_binder_type binder_type;
};

struct tcf_chain_info {
	struct tcf_proto **pprev;
	struct tcf_proto *next;
};

struct tcf_dump_args {
	struct tcf_walker w;
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct tcf_block *block;
	struct Qdisc *q;
	u32 parent;
	bool terse_dump;
};

struct tcamsg {
	unsigned char tca_family;
	unsigned char tca__pad1;
	short unsigned int tca__pad2;
};

enum {
	TCA_ROOT_UNSPEC = 0,
	TCA_ROOT_TAB = 1,
	TCA_ROOT_FLAGS = 2,
	TCA_ROOT_COUNT = 3,
	TCA_ROOT_TIME_DELTA = 4,
	__TCA_ROOT_MAX = 5,
};

struct tc_action_net {
	struct tcf_idrinfo *idrinfo;
	const struct tc_action_ops *ops;
};

struct tc_act_pernet_id {
	struct list_head list;
	unsigned int id;
};

struct tc_act_bpf {
	__u32 index;
	__u32 capab;
	int action;
	int refcnt;
	int bindcnt;
};

enum {
	TCA_ACT_BPF_UNSPEC = 0,
	TCA_ACT_BPF_TM = 1,
	TCA_ACT_BPF_PARMS = 2,
	TCA_ACT_BPF_OPS_LEN = 3,
	TCA_ACT_BPF_OPS = 4,
	TCA_ACT_BPF_FD = 5,
	TCA_ACT_BPF_NAME = 6,
	TCA_ACT_BPF_PAD = 7,
	TCA_ACT_BPF_TAG = 8,
	TCA_ACT_BPF_ID = 9,
	__TCA_ACT_BPF_MAX = 10,
};

struct tcf_bpf {
	struct tc_action common;
	struct bpf_prog *filter;
	union {
		u32 bpf_fd;
		u16 bpf_num_ops;
	};
	struct sock_filter *bpf_ops;
	const char *bpf_name;
};

struct tcf_bpf_cfg {
	struct bpf_prog *filter;
	struct sock_filter *bpf_ops;
	const char *bpf_name;
	u16 bpf_num_ops;
	bool is_ebpf;
};

struct tc_fifo_qopt {
	__u32 limit;
};

enum tc_fifo_command {
	TC_FIFO_REPLACE = 0,
	TC_FIFO_DESTROY = 1,
	TC_FIFO_STATS = 2,
};

struct tc_fifo_qopt_offload {
	enum tc_fifo_command command;
	u32 handle;
	u32 parent;
	union {
		struct tc_qopt_offload_stats stats;
	};
};

struct ingress_sched_data {
	struct tcf_block *block;
	struct tcf_block_ext_info block_info;
	struct mini_Qdisc_pair miniqp;
};

struct clsact_sched_data {
	struct tcf_block *ingress_block;
	struct tcf_block *egress_block;
	struct tcf_block_ext_info ingress_block_info;
	struct tcf_block_ext_info egress_block_info;
	struct mini_Qdisc_pair miniqp_ingress;
	struct mini_Qdisc_pair miniqp_egress;
};

enum {
	TCA_BPF_UNSPEC = 0,
	TCA_BPF_ACT = 1,
	TCA_BPF_POLICE = 2,
	TCA_BPF_CLASSID = 3,
	TCA_BPF_OPS_LEN = 4,
	TCA_BPF_OPS = 5,
	TCA_BPF_FD = 6,
	TCA_BPF_NAME = 7,
	TCA_BPF_FLAGS = 8,
	TCA_BPF_FLAGS_GEN = 9,
	TCA_BPF_TAG = 10,
	TCA_BPF_ID = 11,
	__TCA_BPF_MAX = 12,
};

enum tc_clsbpf_command {
	TC_CLSBPF_OFFLOAD = 0,
	TC_CLSBPF_STATS = 1,
};

struct tc_cls_bpf_offload {
	struct flow_cls_common_offload common;
	enum tc_clsbpf_command command;
	struct tcf_exts *exts;
	struct bpf_prog *prog;
	struct bpf_prog *oldprog;
	const char *name;
	bool exts_integrated;
};

struct cls_bpf_head {
	struct list_head plist;
	struct idr handle_idr;
	struct callback_head rcu;
};

struct cls_bpf_prog {
	struct bpf_prog *filter;
	struct list_head link;
	struct tcf_result res;
	bool exts_integrated;
	u32 gen_flags;
	unsigned int in_hw_count;
	struct tcf_exts exts;
	u32 handle;
	u16 bpf_num_ops;
	struct sock_filter *bpf_ops;
	const char *bpf_name;
	struct tcf_proto *tp;
	struct rcu_work rwork;
};

struct sockaddr_nl {
	__kernel_sa_family_t nl_family;
	short unsigned int nl_pad;
	__u32 nl_pid;
	__u32 nl_groups;
};

struct nlmsgerr {
	int error;
	struct nlmsghdr msg;
};

enum nlmsgerr_attrs {
	NLMSGERR_ATTR_UNUSED = 0,
	NLMSGERR_ATTR_MSG = 1,
	NLMSGERR_ATTR_OFFS = 2,
	NLMSGERR_ATTR_COOKIE = 3,
	NLMSGERR_ATTR_POLICY = 4,
	NLMSGERR_ATTR_MISS_TYPE = 5,
	NLMSGERR_ATTR_MISS_NEST = 6,
	__NLMSGERR_ATTR_MAX = 7,
	NLMSGERR_ATTR_MAX = 6,
};

struct nl_pktinfo {
	__u32 group;
};

enum {
	NETLINK_UNCONNECTED = 0,
	NETLINK_CONNECTED = 1,
};

enum netlink_skb_flags {
	NETLINK_SKB_DST = 8,
};

struct netlink_notify {
	struct net *net;
	u32 portid;
	int protocol;
};

struct netlink_tap {
	struct net_device *dev;
	struct module *module;
	struct list_head list;
};

struct trace_event_raw_netlink_extack {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_data_offsets_netlink_extack {
	u32 msg;
};

typedef void (*btf_trace_netlink_extack)(void *, const char *);

struct netlink_sock {
	struct sock sk;
	u32 portid;
	u32 dst_portid;
	u32 dst_group;
	u32 flags;
	u32 subscriptions;
	u32 ngroups;
	long unsigned int *groups;
	long unsigned int state;
	size_t max_recvmsg_len;
	wait_queue_head_t wait;
	bool bound;
	bool cb_running;
	int dump_done_errno;
	struct netlink_callback cb;
	struct mutex *cb_mutex;
	struct mutex cb_def_mutex;
	void (*netlink_rcv)(struct sk_buff *);
	int (*netlink_bind)(struct net *, int);
	void (*netlink_unbind)(struct net *, int);
	struct module *module;
	struct rhash_head node;
	struct callback_head rcu;
	struct work_struct work;
	int: 32;
};

struct listeners;

struct netlink_table {
	struct rhashtable hash;
	struct hlist_head mc_list;
	struct listeners *listeners;
	unsigned int flags;
	unsigned int groups;
	struct mutex *cb_mutex;
	struct module *module;
	int (*bind)(struct net *, int);
	void (*unbind)(struct net *, int);
	bool (*compare)(struct net *, struct sock *);
	int registered;
};

struct listeners {
	struct callback_head rcu;
	long unsigned int masks[0];
};

struct netlink_tap_net {
	struct list_head netlink_tap_all;
	struct mutex netlink_tap_lock;
};

struct netlink_compare_arg {
	possible_net_t pnet;
	u32 portid;
};

struct netlink_broadcast_data {
	struct sock *exclude_sk;
	struct net *net;
	u32 portid;
	u32 group;
	int failure;
	int delivery_failure;
	int congested;
	int delivered;
	gfp_t allocation;
	struct sk_buff *skb;
	struct sk_buff *skb2;
};

struct netlink_set_err_data {
	struct sock *exclude_sk;
	u32 portid;
	u32 group;
	int code;
};

struct nl_seq_iter {
	struct seq_net_private p;
	struct rhashtable_iter hti;
	int link;
};

struct bpf_iter__netlink {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct netlink_sock *sk;
	};
};

enum {
	CTRL_CMD_UNSPEC = 0,
	CTRL_CMD_NEWFAMILY = 1,
	CTRL_CMD_DELFAMILY = 2,
	CTRL_CMD_GETFAMILY = 3,
	CTRL_CMD_NEWOPS = 4,
	CTRL_CMD_DELOPS = 5,
	CTRL_CMD_GETOPS = 6,
	CTRL_CMD_NEWMCAST_GRP = 7,
	CTRL_CMD_DELMCAST_GRP = 8,
	CTRL_CMD_GETMCAST_GRP = 9,
	CTRL_CMD_GETPOLICY = 10,
	__CTRL_CMD_MAX = 11,
};

enum {
	CTRL_ATTR_UNSPEC = 0,
	CTRL_ATTR_FAMILY_ID = 1,
	CTRL_ATTR_FAMILY_NAME = 2,
	CTRL_ATTR_VERSION = 3,
	CTRL_ATTR_HDRSIZE = 4,
	CTRL_ATTR_MAXATTR = 5,
	CTRL_ATTR_OPS = 6,
	CTRL_ATTR_MCAST_GROUPS = 7,
	CTRL_ATTR_POLICY = 8,
	CTRL_ATTR_OP_POLICY = 9,
	CTRL_ATTR_OP = 10,
	__CTRL_ATTR_MAX = 11,
};

enum {
	CTRL_ATTR_OP_UNSPEC = 0,
	CTRL_ATTR_OP_ID = 1,
	CTRL_ATTR_OP_FLAGS = 2,
	__CTRL_ATTR_OP_MAX = 3,
};

enum {
	CTRL_ATTR_MCAST_GRP_UNSPEC = 0,
	CTRL_ATTR_MCAST_GRP_NAME = 1,
	CTRL_ATTR_MCAST_GRP_ID = 2,
	__CTRL_ATTR_MCAST_GRP_MAX = 3,
};

enum {
	CTRL_ATTR_POLICY_UNSPEC = 0,
	CTRL_ATTR_POLICY_DO = 1,
	CTRL_ATTR_POLICY_DUMP = 2,
	__CTRL_ATTR_POLICY_DUMP_MAX = 3,
	CTRL_ATTR_POLICY_DUMP_MAX = 2,
};

struct genl_start_context {
	const struct genl_family *family;
	struct nlmsghdr *nlh;
	struct netlink_ext_ack *extack;
	const struct genl_ops *ops;
	int hdrlen;
};

struct netlink_policy_dump_state;

struct ctrl_dump_policy_ctx {
	struct netlink_policy_dump_state *state;
	const struct genl_family *rt;
	unsigned int opidx;
	u32 op;
	u16 fam_id;
	u8 policies: 1;
	u8 single_op: 1;
};

enum netlink_attribute_type {
	NL_ATTR_TYPE_INVALID = 0,
	NL_ATTR_TYPE_FLAG = 1,
	NL_ATTR_TYPE_U8 = 2,
	NL_ATTR_TYPE_U16 = 3,
	NL_ATTR_TYPE_U32 = 4,
	NL_ATTR_TYPE_U64 = 5,
	NL_ATTR_TYPE_S8 = 6,
	NL_ATTR_TYPE_S16 = 7,
	NL_ATTR_TYPE_S32 = 8,
	NL_ATTR_TYPE_S64 = 9,
	NL_ATTR_TYPE_BINARY = 10,
	NL_ATTR_TYPE_STRING = 11,
	NL_ATTR_TYPE_NUL_STRING = 12,
	NL_ATTR_TYPE_NESTED = 13,
	NL_ATTR_TYPE_NESTED_ARRAY = 14,
	NL_ATTR_TYPE_BITFIELD32 = 15,
};

enum netlink_policy_type_attr {
	NL_POLICY_TYPE_ATTR_UNSPEC = 0,
	NL_POLICY_TYPE_ATTR_TYPE = 1,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_S = 2,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_S = 3,
	NL_POLICY_TYPE_ATTR_MIN_VALUE_U = 4,
	NL_POLICY_TYPE_ATTR_MAX_VALUE_U = 5,
	NL_POLICY_TYPE_ATTR_MIN_LENGTH = 6,
	NL_POLICY_TYPE_ATTR_MAX_LENGTH = 7,
	NL_POLICY_TYPE_ATTR_POLICY_IDX = 8,
	NL_POLICY_TYPE_ATTR_POLICY_MAXTYPE = 9,
	NL_POLICY_TYPE_ATTR_BITFIELD32_MASK = 10,
	NL_POLICY_TYPE_ATTR_PAD = 11,
	NL_POLICY_TYPE_ATTR_MASK = 12,
	__NL_POLICY_TYPE_ATTR_MAX = 13,
	NL_POLICY_TYPE_ATTR_MAX = 12,
};

struct netlink_policy_dump_state {
	unsigned int policy_idx;
	unsigned int attr_idx;
	unsigned int n_alloc;
	struct {
		const struct nla_policy *policy;
		unsigned int maxtype;
	} policies[0];
};

struct trace_event_raw_bpf_test_finish {
	struct trace_entry ent;
	int err;
	char __data[0];
};

struct trace_event_data_offsets_bpf_test_finish {};

typedef void (*btf_trace_bpf_test_finish)(void *, int *);

struct bpf_test_timer {
	enum {
		NO_PREEMPT = 0,
		NO_MIGRATE = 1,
	} mode;
	u32 i;
	u64 time_start;
	u64 time_spent;
};

struct xdp_page_head {
	struct xdp_buff orig_ctx;
	struct xdp_buff ctx;
	struct xdp_frame frm;
	u8 data[0];
};

struct xdp_test_data {
	struct xdp_buff *orig_ctx;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct xdp_rxq_info rxq;
	struct net_device *dev;
	struct page_pool *pp;
	struct xdp_frame **frames;
	struct sk_buff **skbs;
	struct xdp_mem_info mem;
	u32 batch_size;
	u32 frame_cnt;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct bpf_fentry_test_t {
	struct bpf_fentry_test_t *a;
};

struct prog_test_member1 {
	int a;
};

struct prog_test_member {
	struct prog_test_member1 m;
	int c;
};

struct prog_test_ref_kfunc {
	int a;
	int b;
	struct prog_test_member memb;
	struct prog_test_ref_kfunc *next;
	refcount_t cnt;
};

struct prog_test_pass1 {
	int x0;
	struct {
		int x1;
		struct {
			int x2;
			struct {
				int x3;
			};
		};
	};
};

struct prog_test_pass2 {
	int len;
	short int arr1[4];
	struct {
		char arr2[4];
		long unsigned int arr3[8];
	} x;
};

struct prog_test_fail1 {
	void *p;
	int x;
};

struct prog_test_fail2 {
	int x8;
	struct prog_test_pass1 x;
};

struct prog_test_fail3 {
	int len;
	char arr1[2];
	char arr2[0];
};

struct bpf_raw_tp_test_run_info {
	struct bpf_prog *prog;
	void *ctx;
	u32 retval;
};

typedef int (*dummy_ops_test_ret_fn)(struct bpf_dummy_ops_state *, ...);

struct bpf_dummy_ops_test_args {
	u64 args[12];
	struct bpf_dummy_ops_state state;
	int: 32;
};

struct ethtool_value {
	__u32 cmd;
	__u32 data;
};

enum tunable_type_id {
	ETHTOOL_TUNABLE_UNSPEC = 0,
	ETHTOOL_TUNABLE_U8 = 1,
	ETHTOOL_TUNABLE_U16 = 2,
	ETHTOOL_TUNABLE_U32 = 3,
	ETHTOOL_TUNABLE_U64 = 4,
	ETHTOOL_TUNABLE_STRING = 5,
	ETHTOOL_TUNABLE_S8 = 6,
	ETHTOOL_TUNABLE_S16 = 7,
	ETHTOOL_TUNABLE_S32 = 8,
	ETHTOOL_TUNABLE_S64 = 9,
};

struct ethtool_gstrings {
	__u32 cmd;
	__u32 string_set;
	__u32 len;
	__u8 data[0];
};

struct ethtool_sset_info {
	__u32 cmd;
	__u32 reserved;
	__u64 sset_mask;
	__u32 data[0];
};

struct ethtool_perm_addr {
	__u32 cmd;
	__u32 size;
	__u8 data[0];
};

enum ethtool_flags {
	ETH_FLAG_TXVLAN = 128,
	ETH_FLAG_RXVLAN = 256,
	ETH_FLAG_LRO = 32768,
	ETH_FLAG_NTUPLE = 134217728,
	ETH_FLAG_RXHASH = 268435456,
};

struct ethtool_rxfh {
	__u32 cmd;
	__u32 rss_context;
	__u32 indir_size;
	__u32 key_size;
	__u8 hfunc;
	__u8 rsvd8[3];
	__u32 rsvd32;
	__u32 rss_config[0];
};

struct ethtool_get_features_block {
	__u32 available;
	__u32 requested;
	__u32 active;
	__u32 never_changed;
};

struct ethtool_gfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_get_features_block features[0];
};

struct ethtool_set_features_block {
	__u32 valid;
	__u32 requested;
};

struct ethtool_sfeatures {
	__u32 cmd;
	__u32 size;
	struct ethtool_set_features_block features[0];
};

enum ethtool_sfeatures_retval_bits {
	ETHTOOL_F_UNSUPPORTED__BIT = 0,
	ETHTOOL_F_WISH__BIT = 1,
	ETHTOOL_F_COMPAT__BIT = 2,
};

struct ethtool_per_queue_op {
	__u32 cmd;
	__u32 sub_command;
	__u32 queue_mask[128];
	char data[0];
};

enum ethtool_fec_config_bits {
	ETHTOOL_FEC_NONE_BIT = 0,
	ETHTOOL_FEC_AUTO_BIT = 1,
	ETHTOOL_FEC_OFF_BIT = 2,
	ETHTOOL_FEC_RS_BIT = 3,
	ETHTOOL_FEC_BASER_BIT = 4,
	ETHTOOL_FEC_LLRS_BIT = 5,
};

enum {
	ETH_RSS_HASH_TOP_BIT = 0,
	ETH_RSS_HASH_XOR_BIT = 1,
	ETH_RSS_HASH_CRC32_BIT = 2,
	ETH_RSS_HASH_FUNCS_COUNT = 3,
};

struct ethtool_rx_flow_rule {
	struct flow_rule *rule;
	long unsigned int priv[0];
};

struct ethtool_rx_flow_spec_input {
	const struct ethtool_rx_flow_spec *fs;
	u32 rss_ctx;
};

struct ethtool_devlink_compat {
	struct devlink *devlink;
	union {
		struct ethtool_flash efl;
		struct ethtool_drvinfo info;
	};
};

struct ethtool_link_usettings {
	struct ethtool_link_settings base;
	struct {
		__u32 supported[3];
		__u32 advertising[3];
		__u32 lp_advertising[3];
	} link_modes;
};

struct ethtool_rx_flow_key {
	struct flow_dissector_key_basic basic;
	union {
		struct flow_dissector_key_ipv4_addrs ipv4;
		struct flow_dissector_key_ipv6_addrs ipv6;
	};
	struct flow_dissector_key_ports tp;
	struct flow_dissector_key_ip ip;
	struct flow_dissector_key_vlan vlan;
	struct flow_dissector_key_eth_addrs eth_addrs;
};

struct ethtool_rx_flow_match {
	struct flow_dissector dissector;
	struct ethtool_rx_flow_key key;
	struct ethtool_rx_flow_key mask;
};

enum {
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN = 0,
	ETHTOOL_UDP_TUNNEL_TYPE_GENEVE = 1,
	ETHTOOL_UDP_TUNNEL_TYPE_VXLAN_GPE = 2,
	__ETHTOOL_UDP_TUNNEL_TYPE_CNT = 3,
};

struct link_mode_info {
	int speed;
	u8 lanes;
	u8 duplex;
};

enum {
	ETHTOOL_MSG_USER_NONE = 0,
	ETHTOOL_MSG_STRSET_GET = 1,
	ETHTOOL_MSG_LINKINFO_GET = 2,
	ETHTOOL_MSG_LINKINFO_SET = 3,
	ETHTOOL_MSG_LINKMODES_GET = 4,
	ETHTOOL_MSG_LINKMODES_SET = 5,
	ETHTOOL_MSG_LINKSTATE_GET = 6,
	ETHTOOL_MSG_DEBUG_GET = 7,
	ETHTOOL_MSG_DEBUG_SET = 8,
	ETHTOOL_MSG_WOL_GET = 9,
	ETHTOOL_MSG_WOL_SET = 10,
	ETHTOOL_MSG_FEATURES_GET = 11,
	ETHTOOL_MSG_FEATURES_SET = 12,
	ETHTOOL_MSG_PRIVFLAGS_GET = 13,
	ETHTOOL_MSG_PRIVFLAGS_SET = 14,
	ETHTOOL_MSG_RINGS_GET = 15,
	ETHTOOL_MSG_RINGS_SET = 16,
	ETHTOOL_MSG_CHANNELS_GET = 17,
	ETHTOOL_MSG_CHANNELS_SET = 18,
	ETHTOOL_MSG_COALESCE_GET = 19,
	ETHTOOL_MSG_COALESCE_SET = 20,
	ETHTOOL_MSG_PAUSE_GET = 21,
	ETHTOOL_MSG_PAUSE_SET = 22,
	ETHTOOL_MSG_EEE_GET = 23,
	ETHTOOL_MSG_EEE_SET = 24,
	ETHTOOL_MSG_TSINFO_GET = 25,
	ETHTOOL_MSG_CABLE_TEST_ACT = 26,
	ETHTOOL_MSG_CABLE_TEST_TDR_ACT = 27,
	ETHTOOL_MSG_TUNNEL_INFO_GET = 28,
	ETHTOOL_MSG_FEC_GET = 29,
	ETHTOOL_MSG_FEC_SET = 30,
	ETHTOOL_MSG_MODULE_EEPROM_GET = 31,
	ETHTOOL_MSG_STATS_GET = 32,
	ETHTOOL_MSG_PHC_VCLOCKS_GET = 33,
	ETHTOOL_MSG_MODULE_GET = 34,
	ETHTOOL_MSG_MODULE_SET = 35,
	ETHTOOL_MSG_PSE_GET = 36,
	ETHTOOL_MSG_PSE_SET = 37,
	__ETHTOOL_MSG_USER_CNT = 38,
	ETHTOOL_MSG_USER_MAX = 37,
};

enum {
	ETHTOOL_A_HEADER_UNSPEC = 0,
	ETHTOOL_A_HEADER_DEV_INDEX = 1,
	ETHTOOL_A_HEADER_DEV_NAME = 2,
	ETHTOOL_A_HEADER_FLAGS = 3,
	__ETHTOOL_A_HEADER_CNT = 4,
	ETHTOOL_A_HEADER_MAX = 3,
};

enum {
	ETHTOOL_A_STRSET_UNSPEC = 0,
	ETHTOOL_A_STRSET_HEADER = 1,
	ETHTOOL_A_STRSET_STRINGSETS = 2,
	ETHTOOL_A_STRSET_COUNTS_ONLY = 3,
	__ETHTOOL_A_STRSET_CNT = 4,
	ETHTOOL_A_STRSET_MAX = 3,
};

enum {
	ETHTOOL_A_LINKINFO_UNSPEC = 0,
	ETHTOOL_A_LINKINFO_HEADER = 1,
	ETHTOOL_A_LINKINFO_PORT = 2,
	ETHTOOL_A_LINKINFO_PHYADDR = 3,
	ETHTOOL_A_LINKINFO_TP_MDIX = 4,
	ETHTOOL_A_LINKINFO_TP_MDIX_CTRL = 5,
	ETHTOOL_A_LINKINFO_TRANSCEIVER = 6,
	__ETHTOOL_A_LINKINFO_CNT = 7,
	ETHTOOL_A_LINKINFO_MAX = 6,
};

enum {
	ETHTOOL_A_LINKMODES_UNSPEC = 0,
	ETHTOOL_A_LINKMODES_HEADER = 1,
	ETHTOOL_A_LINKMODES_AUTONEG = 2,
	ETHTOOL_A_LINKMODES_OURS = 3,
	ETHTOOL_A_LINKMODES_PEER = 4,
	ETHTOOL_A_LINKMODES_SPEED = 5,
	ETHTOOL_A_LINKMODES_DUPLEX = 6,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_CFG = 7,
	ETHTOOL_A_LINKMODES_MASTER_SLAVE_STATE = 8,
	ETHTOOL_A_LINKMODES_LANES = 9,
	ETHTOOL_A_LINKMODES_RATE_MATCHING = 10,
	__ETHTOOL_A_LINKMODES_CNT = 11,
	ETHTOOL_A_LINKMODES_MAX = 10,
};

enum {
	ETHTOOL_A_LINKSTATE_UNSPEC = 0,
	ETHTOOL_A_LINKSTATE_HEADER = 1,
	ETHTOOL_A_LINKSTATE_LINK = 2,
	ETHTOOL_A_LINKSTATE_SQI = 3,
	ETHTOOL_A_LINKSTATE_SQI_MAX = 4,
	ETHTOOL_A_LINKSTATE_EXT_STATE = 5,
	ETHTOOL_A_LINKSTATE_EXT_SUBSTATE = 6,
	__ETHTOOL_A_LINKSTATE_CNT = 7,
	ETHTOOL_A_LINKSTATE_MAX = 6,
};

enum {
	ETHTOOL_A_DEBUG_UNSPEC = 0,
	ETHTOOL_A_DEBUG_HEADER = 1,
	ETHTOOL_A_DEBUG_MSGMASK = 2,
	__ETHTOOL_A_DEBUG_CNT = 3,
	ETHTOOL_A_DEBUG_MAX = 2,
};

enum {
	ETHTOOL_A_WOL_UNSPEC = 0,
	ETHTOOL_A_WOL_HEADER = 1,
	ETHTOOL_A_WOL_MODES = 2,
	ETHTOOL_A_WOL_SOPASS = 3,
	__ETHTOOL_A_WOL_CNT = 4,
	ETHTOOL_A_WOL_MAX = 3,
};

enum {
	ETHTOOL_A_FEATURES_UNSPEC = 0,
	ETHTOOL_A_FEATURES_HEADER = 1,
	ETHTOOL_A_FEATURES_HW = 2,
	ETHTOOL_A_FEATURES_WANTED = 3,
	ETHTOOL_A_FEATURES_ACTIVE = 4,
	ETHTOOL_A_FEATURES_NOCHANGE = 5,
	__ETHTOOL_A_FEATURES_CNT = 6,
	ETHTOOL_A_FEATURES_MAX = 5,
};

enum {
	ETHTOOL_A_PRIVFLAGS_UNSPEC = 0,
	ETHTOOL_A_PRIVFLAGS_HEADER = 1,
	ETHTOOL_A_PRIVFLAGS_FLAGS = 2,
	__ETHTOOL_A_PRIVFLAGS_CNT = 3,
	ETHTOOL_A_PRIVFLAGS_MAX = 2,
};

enum {
	ETHTOOL_A_RINGS_UNSPEC = 0,
	ETHTOOL_A_RINGS_HEADER = 1,
	ETHTOOL_A_RINGS_RX_MAX = 2,
	ETHTOOL_A_RINGS_RX_MINI_MAX = 3,
	ETHTOOL_A_RINGS_RX_JUMBO_MAX = 4,
	ETHTOOL_A_RINGS_TX_MAX = 5,
	ETHTOOL_A_RINGS_RX = 6,
	ETHTOOL_A_RINGS_RX_MINI = 7,
	ETHTOOL_A_RINGS_RX_JUMBO = 8,
	ETHTOOL_A_RINGS_TX = 9,
	ETHTOOL_A_RINGS_RX_BUF_LEN = 10,
	ETHTOOL_A_RINGS_TCP_DATA_SPLIT = 11,
	ETHTOOL_A_RINGS_CQE_SIZE = 12,
	ETHTOOL_A_RINGS_TX_PUSH = 13,
	__ETHTOOL_A_RINGS_CNT = 14,
	ETHTOOL_A_RINGS_MAX = 13,
};

enum {
	ETHTOOL_A_CHANNELS_UNSPEC = 0,
	ETHTOOL_A_CHANNELS_HEADER = 1,
	ETHTOOL_A_CHANNELS_RX_MAX = 2,
	ETHTOOL_A_CHANNELS_TX_MAX = 3,
	ETHTOOL_A_CHANNELS_OTHER_MAX = 4,
	ETHTOOL_A_CHANNELS_COMBINED_MAX = 5,
	ETHTOOL_A_CHANNELS_RX_COUNT = 6,
	ETHTOOL_A_CHANNELS_TX_COUNT = 7,
	ETHTOOL_A_CHANNELS_OTHER_COUNT = 8,
	ETHTOOL_A_CHANNELS_COMBINED_COUNT = 9,
	__ETHTOOL_A_CHANNELS_CNT = 10,
	ETHTOOL_A_CHANNELS_MAX = 9,
};

enum {
	ETHTOOL_A_COALESCE_UNSPEC = 0,
	ETHTOOL_A_COALESCE_HEADER = 1,
	ETHTOOL_A_COALESCE_RX_USECS = 2,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES = 3,
	ETHTOOL_A_COALESCE_RX_USECS_IRQ = 4,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_IRQ = 5,
	ETHTOOL_A_COALESCE_TX_USECS = 6,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES = 7,
	ETHTOOL_A_COALESCE_TX_USECS_IRQ = 8,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_IRQ = 9,
	ETHTOOL_A_COALESCE_STATS_BLOCK_USECS = 10,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_RX = 11,
	ETHTOOL_A_COALESCE_USE_ADAPTIVE_TX = 12,
	ETHTOOL_A_COALESCE_PKT_RATE_LOW = 13,
	ETHTOOL_A_COALESCE_RX_USECS_LOW = 14,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_LOW = 15,
	ETHTOOL_A_COALESCE_TX_USECS_LOW = 16,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_LOW = 17,
	ETHTOOL_A_COALESCE_PKT_RATE_HIGH = 18,
	ETHTOOL_A_COALESCE_RX_USECS_HIGH = 19,
	ETHTOOL_A_COALESCE_RX_MAX_FRAMES_HIGH = 20,
	ETHTOOL_A_COALESCE_TX_USECS_HIGH = 21,
	ETHTOOL_A_COALESCE_TX_MAX_FRAMES_HIGH = 22,
	ETHTOOL_A_COALESCE_RATE_SAMPLE_INTERVAL = 23,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_TX = 24,
	ETHTOOL_A_COALESCE_USE_CQE_MODE_RX = 25,
	__ETHTOOL_A_COALESCE_CNT = 26,
	ETHTOOL_A_COALESCE_MAX = 25,
};

enum {
	ETHTOOL_A_PAUSE_UNSPEC = 0,
	ETHTOOL_A_PAUSE_HEADER = 1,
	ETHTOOL_A_PAUSE_AUTONEG = 2,
	ETHTOOL_A_PAUSE_RX = 3,
	ETHTOOL_A_PAUSE_TX = 4,
	ETHTOOL_A_PAUSE_STATS = 5,
	__ETHTOOL_A_PAUSE_CNT = 6,
	ETHTOOL_A_PAUSE_MAX = 5,
};

enum {
	ETHTOOL_A_EEE_UNSPEC = 0,
	ETHTOOL_A_EEE_HEADER = 1,
	ETHTOOL_A_EEE_MODES_OURS = 2,
	ETHTOOL_A_EEE_MODES_PEER = 3,
	ETHTOOL_A_EEE_ACTIVE = 4,
	ETHTOOL_A_EEE_ENABLED = 5,
	ETHTOOL_A_EEE_TX_LPI_ENABLED = 6,
	ETHTOOL_A_EEE_TX_LPI_TIMER = 7,
	__ETHTOOL_A_EEE_CNT = 8,
	ETHTOOL_A_EEE_MAX = 7,
};

enum {
	ETHTOOL_A_TSINFO_UNSPEC = 0,
	ETHTOOL_A_TSINFO_HEADER = 1,
	ETHTOOL_A_TSINFO_TIMESTAMPING = 2,
	ETHTOOL_A_TSINFO_TX_TYPES = 3,
	ETHTOOL_A_TSINFO_RX_FILTERS = 4,
	ETHTOOL_A_TSINFO_PHC_INDEX = 5,
	__ETHTOOL_A_TSINFO_CNT = 6,
	ETHTOOL_A_TSINFO_MAX = 5,
};

enum {
	ETHTOOL_A_PHC_VCLOCKS_UNSPEC = 0,
	ETHTOOL_A_PHC_VCLOCKS_HEADER = 1,
	ETHTOOL_A_PHC_VCLOCKS_NUM = 2,
	ETHTOOL_A_PHC_VCLOCKS_INDEX = 3,
	__ETHTOOL_A_PHC_VCLOCKS_CNT = 4,
	ETHTOOL_A_PHC_VCLOCKS_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_HEADER = 1,
	__ETHTOOL_A_CABLE_TEST_CNT = 2,
	ETHTOOL_A_CABLE_TEST_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG = 2,
	__ETHTOOL_A_CABLE_TEST_TDR_CNT = 3,
	ETHTOOL_A_CABLE_TEST_TDR_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_INFO_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_INFO_HEADER = 1,
	ETHTOOL_A_TUNNEL_INFO_UDP_PORTS = 2,
	__ETHTOOL_A_TUNNEL_INFO_CNT = 3,
	ETHTOOL_A_TUNNEL_INFO_MAX = 2,
};

enum {
	ETHTOOL_A_FEC_UNSPEC = 0,
	ETHTOOL_A_FEC_HEADER = 1,
	ETHTOOL_A_FEC_MODES = 2,
	ETHTOOL_A_FEC_AUTO = 3,
	ETHTOOL_A_FEC_ACTIVE = 4,
	ETHTOOL_A_FEC_STATS = 5,
	__ETHTOOL_A_FEC_CNT = 6,
	ETHTOOL_A_FEC_MAX = 5,
};

enum {
	ETHTOOL_A_MODULE_EEPROM_UNSPEC = 0,
	ETHTOOL_A_MODULE_EEPROM_HEADER = 1,
	ETHTOOL_A_MODULE_EEPROM_OFFSET = 2,
	ETHTOOL_A_MODULE_EEPROM_LENGTH = 3,
	ETHTOOL_A_MODULE_EEPROM_PAGE = 4,
	ETHTOOL_A_MODULE_EEPROM_BANK = 5,
	ETHTOOL_A_MODULE_EEPROM_I2C_ADDRESS = 6,
	ETHTOOL_A_MODULE_EEPROM_DATA = 7,
	__ETHTOOL_A_MODULE_EEPROM_CNT = 8,
	ETHTOOL_A_MODULE_EEPROM_MAX = 7,
};

enum {
	ETHTOOL_STATS_ETH_PHY = 0,
	ETHTOOL_STATS_ETH_MAC = 1,
	ETHTOOL_STATS_ETH_CTRL = 2,
	ETHTOOL_STATS_RMON = 3,
	__ETHTOOL_STATS_CNT = 4,
};

enum {
	ETHTOOL_A_STATS_ETH_PHY_5_SYM_ERR = 0,
	__ETHTOOL_A_STATS_ETH_PHY_CNT = 1,
	ETHTOOL_A_STATS_ETH_PHY_MAX = 0,
};

enum {
	ETHTOOL_A_STATS_ETH_MAC_2_TX_PKT = 0,
	ETHTOOL_A_STATS_ETH_MAC_3_SINGLE_COL = 1,
	ETHTOOL_A_STATS_ETH_MAC_4_MULTI_COL = 2,
	ETHTOOL_A_STATS_ETH_MAC_5_RX_PKT = 3,
	ETHTOOL_A_STATS_ETH_MAC_6_FCS_ERR = 4,
	ETHTOOL_A_STATS_ETH_MAC_7_ALIGN_ERR = 5,
	ETHTOOL_A_STATS_ETH_MAC_8_TX_BYTES = 6,
	ETHTOOL_A_STATS_ETH_MAC_9_TX_DEFER = 7,
	ETHTOOL_A_STATS_ETH_MAC_10_LATE_COL = 8,
	ETHTOOL_A_STATS_ETH_MAC_11_XS_COL = 9,
	ETHTOOL_A_STATS_ETH_MAC_12_TX_INT_ERR = 10,
	ETHTOOL_A_STATS_ETH_MAC_13_CS_ERR = 11,
	ETHTOOL_A_STATS_ETH_MAC_14_RX_BYTES = 12,
	ETHTOOL_A_STATS_ETH_MAC_15_RX_INT_ERR = 13,
	ETHTOOL_A_STATS_ETH_MAC_18_TX_MCAST = 14,
	ETHTOOL_A_STATS_ETH_MAC_19_TX_BCAST = 15,
	ETHTOOL_A_STATS_ETH_MAC_20_XS_DEFER = 16,
	ETHTOOL_A_STATS_ETH_MAC_21_RX_MCAST = 17,
	ETHTOOL_A_STATS_ETH_MAC_22_RX_BCAST = 18,
	ETHTOOL_A_STATS_ETH_MAC_23_IR_LEN_ERR = 19,
	ETHTOOL_A_STATS_ETH_MAC_24_OOR_LEN = 20,
	ETHTOOL_A_STATS_ETH_MAC_25_TOO_LONG_ERR = 21,
	__ETHTOOL_A_STATS_ETH_MAC_CNT = 22,
	ETHTOOL_A_STATS_ETH_MAC_MAX = 21,
};

enum {
	ETHTOOL_A_STATS_ETH_CTRL_3_TX = 0,
	ETHTOOL_A_STATS_ETH_CTRL_4_RX = 1,
	ETHTOOL_A_STATS_ETH_CTRL_5_RX_UNSUP = 2,
	__ETHTOOL_A_STATS_ETH_CTRL_CNT = 3,
	ETHTOOL_A_STATS_ETH_CTRL_MAX = 2,
};

enum {
	ETHTOOL_A_STATS_RMON_UNDERSIZE = 0,
	ETHTOOL_A_STATS_RMON_OVERSIZE = 1,
	ETHTOOL_A_STATS_RMON_FRAG = 2,
	ETHTOOL_A_STATS_RMON_JABBER = 3,
	__ETHTOOL_A_STATS_RMON_CNT = 4,
	ETHTOOL_A_STATS_RMON_MAX = 3,
};

enum {
	ETHTOOL_A_MODULE_UNSPEC = 0,
	ETHTOOL_A_MODULE_HEADER = 1,
	ETHTOOL_A_MODULE_POWER_MODE_POLICY = 2,
	ETHTOOL_A_MODULE_POWER_MODE = 3,
	__ETHTOOL_A_MODULE_CNT = 4,
	ETHTOOL_A_MODULE_MAX = 3,
};

enum {
	ETHTOOL_A_PSE_UNSPEC = 0,
	ETHTOOL_A_PSE_HEADER = 1,
	ETHTOOL_A_PODL_PSE_ADMIN_STATE = 2,
	ETHTOOL_A_PODL_PSE_ADMIN_CONTROL = 3,
	ETHTOOL_A_PODL_PSE_PW_D_STATUS = 4,
	__ETHTOOL_A_PSE_CNT = 5,
	ETHTOOL_A_PSE_MAX = 4,
};

enum ethtool_multicast_groups {
	ETHNL_MCGRP_MONITOR = 0,
};

struct ethnl_req_info {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	u32 flags;
};

struct ethnl_reply_data {
	struct net_device *dev;
};

struct ethnl_request_ops {
	u8 request_cmd;
	u8 reply_cmd;
	u16 hdr_attr;
	unsigned int req_info_size;
	unsigned int reply_data_size;
	bool allow_nodev_do;
	int (*parse_request)(struct ethnl_req_info *, struct nlattr **, struct netlink_ext_ack *);
	int (*prepare_data)(const struct ethnl_req_info *, struct ethnl_reply_data *, struct genl_info *);
	int (*reply_size)(const struct ethnl_req_info *, const struct ethnl_reply_data *);
	int (*fill_reply)(struct sk_buff *, const struct ethnl_req_info *, const struct ethnl_reply_data *);
	void (*cleanup_data)(struct ethnl_reply_data *);
};

struct ethnl_dump_ctx {
	const struct ethnl_request_ops *ops;
	struct ethnl_req_info *req_info;
	struct ethnl_reply_data *reply_data;
	int pos_hash;
	int pos_idx;
};

typedef void (*ethnl_notify_handler_t)(struct net_device *, unsigned int, const void *);

enum {
	ETHTOOL_A_BITSET_BIT_UNSPEC = 0,
	ETHTOOL_A_BITSET_BIT_INDEX = 1,
	ETHTOOL_A_BITSET_BIT_NAME = 2,
	ETHTOOL_A_BITSET_BIT_VALUE = 3,
	__ETHTOOL_A_BITSET_BIT_CNT = 4,
	ETHTOOL_A_BITSET_BIT_MAX = 3,
};

enum {
	ETHTOOL_A_BITSET_BITS_UNSPEC = 0,
	ETHTOOL_A_BITSET_BITS_BIT = 1,
	__ETHTOOL_A_BITSET_BITS_CNT = 2,
	ETHTOOL_A_BITSET_BITS_MAX = 1,
};

enum {
	ETHTOOL_A_BITSET_UNSPEC = 0,
	ETHTOOL_A_BITSET_NOMASK = 1,
	ETHTOOL_A_BITSET_SIZE = 2,
	ETHTOOL_A_BITSET_BITS = 3,
	ETHTOOL_A_BITSET_VALUE = 4,
	ETHTOOL_A_BITSET_MASK = 5,
	__ETHTOOL_A_BITSET_CNT = 6,
	ETHTOOL_A_BITSET_MAX = 5,
};

typedef const char (* const ethnl_string_array_t)[32];

enum {
	ETHTOOL_A_STRING_UNSPEC = 0,
	ETHTOOL_A_STRING_INDEX = 1,
	ETHTOOL_A_STRING_VALUE = 2,
	__ETHTOOL_A_STRING_CNT = 3,
	ETHTOOL_A_STRING_MAX = 2,
};

enum {
	ETHTOOL_A_STRINGS_UNSPEC = 0,
	ETHTOOL_A_STRINGS_STRING = 1,
	__ETHTOOL_A_STRINGS_CNT = 2,
	ETHTOOL_A_STRINGS_MAX = 1,
};

enum {
	ETHTOOL_A_STRINGSET_UNSPEC = 0,
	ETHTOOL_A_STRINGSET_ID = 1,
	ETHTOOL_A_STRINGSET_COUNT = 2,
	ETHTOOL_A_STRINGSET_STRINGS = 3,
	__ETHTOOL_A_STRINGSET_CNT = 4,
	ETHTOOL_A_STRINGSET_MAX = 3,
};

enum {
	ETHTOOL_A_STRINGSETS_UNSPEC = 0,
	ETHTOOL_A_STRINGSETS_STRINGSET = 1,
	__ETHTOOL_A_STRINGSETS_CNT = 2,
	ETHTOOL_A_STRINGSETS_MAX = 1,
};

struct strset_info {
	bool per_dev;
	bool free_strings;
	unsigned int count;
	const char (*strings)[32];
};

struct strset_req_info {
	struct ethnl_req_info base;
	u32 req_ids;
	bool counts_only;
};

struct strset_reply_data {
	struct ethnl_reply_data base;
	struct strset_info sets[21];
};

struct linkinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
};

struct linkmodes_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_link_ksettings ksettings;
	struct ethtool_link_settings *lsettings;
	bool peer_empty;
};

struct linkstate_reply_data {
	struct ethnl_reply_data base;
	int link;
	int sqi;
	int sqi_max;
	bool link_ext_state_provided;
	struct ethtool_link_ext_state_info ethtool_link_ext_state_info;
};

struct debug_reply_data {
	struct ethnl_reply_data base;
	u32 msg_mask;
};

struct wol_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_wolinfo wol;
	bool show_sopass;
};

struct features_reply_data {
	struct ethnl_reply_data base;
	u32 hw[2];
	u32 wanted[2];
	u32 active[2];
	u32 nochange[2];
	u32 all[2];
};

struct privflags_reply_data {
	struct ethnl_reply_data base;
	const char (*priv_flag_names)[32];
	unsigned int n_priv_flags;
	u32 priv_flags;
};

enum ethtool_supported_ring_param {
	ETHTOOL_RING_USE_RX_BUF_LEN = 1,
	ETHTOOL_RING_USE_CQE_SIZE = 2,
	ETHTOOL_RING_USE_TX_PUSH = 4,
};

enum {
	ETHTOOL_TCP_DATA_SPLIT_UNKNOWN = 0,
	ETHTOOL_TCP_DATA_SPLIT_DISABLED = 1,
	ETHTOOL_TCP_DATA_SPLIT_ENABLED = 2,
};

struct rings_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ringparam ringparam;
	struct kernel_ethtool_ringparam kernel_ringparam;
};

struct channels_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_channels channels;
};

struct coalesce_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_coalesce coalesce;
	struct kernel_ethtool_coalesce kernel_coalesce;
	u32 supported_params;
};

enum {
	ETHTOOL_A_PAUSE_STAT_UNSPEC = 0,
	ETHTOOL_A_PAUSE_STAT_PAD = 1,
	ETHTOOL_A_PAUSE_STAT_TX_FRAMES = 2,
	ETHTOOL_A_PAUSE_STAT_RX_FRAMES = 3,
	__ETHTOOL_A_PAUSE_STAT_CNT = 4,
	ETHTOOL_A_PAUSE_STAT_MAX = 3,
};

struct pause_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_pauseparam pauseparam;
	int: 32;
	struct ethtool_pause_stats pausestat;
};

struct eee_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_eee eee;
};

struct tsinfo_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_ts_info ts_info;
};

enum {
	ETHTOOL_A_CABLE_RESULT_UNSPEC = 0,
	ETHTOOL_A_CABLE_RESULT_PAIR = 1,
	ETHTOOL_A_CABLE_RESULT_CODE = 2,
	__ETHTOOL_A_CABLE_RESULT_CNT = 3,
	ETHTOOL_A_CABLE_RESULT_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_FAULT_LENGTH_UNSPEC = 0,
	ETHTOOL_A_CABLE_FAULT_LENGTH_PAIR = 1,
	ETHTOOL_A_CABLE_FAULT_LENGTH_CM = 2,
	__ETHTOOL_A_CABLE_FAULT_LENGTH_CNT = 3,
	ETHTOOL_A_CABLE_FAULT_LENGTH_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_STARTED = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS_COMPLETED = 2,
};

enum {
	ETHTOOL_A_CABLE_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_NEST_RESULT = 1,
	ETHTOOL_A_CABLE_NEST_FAULT_LENGTH = 2,
	__ETHTOOL_A_CABLE_NEST_CNT = 3,
	ETHTOOL_A_CABLE_NEST_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_TEST_NTF_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_NTF_HEADER = 1,
	ETHTOOL_A_CABLE_TEST_NTF_STATUS = 2,
	ETHTOOL_A_CABLE_TEST_NTF_NEST = 3,
	__ETHTOOL_A_CABLE_TEST_NTF_CNT = 4,
	ETHTOOL_A_CABLE_TEST_NTF_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TEST_TDR_CFG_UNSPEC = 0,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_FIRST = 1,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_LAST = 2,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_STEP = 3,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_PAIR = 4,
	__ETHTOOL_A_CABLE_TEST_TDR_CFG_CNT = 5,
	ETHTOOL_A_CABLE_TEST_TDR_CFG_MAX = 4,
};

enum {
	ETHTOOL_A_CABLE_AMPLITUDE_UNSPEC = 0,
	ETHTOOL_A_CABLE_AMPLITUDE_PAIR = 1,
	ETHTOOL_A_CABLE_AMPLITUDE_mV = 2,
	__ETHTOOL_A_CABLE_AMPLITUDE_CNT = 3,
	ETHTOOL_A_CABLE_AMPLITUDE_MAX = 2,
};

enum {
	ETHTOOL_A_CABLE_PULSE_UNSPEC = 0,
	ETHTOOL_A_CABLE_PULSE_mV = 1,
	__ETHTOOL_A_CABLE_PULSE_CNT = 2,
	ETHTOOL_A_CABLE_PULSE_MAX = 1,
};

enum {
	ETHTOOL_A_CABLE_STEP_UNSPEC = 0,
	ETHTOOL_A_CABLE_STEP_FIRST_DISTANCE = 1,
	ETHTOOL_A_CABLE_STEP_LAST_DISTANCE = 2,
	ETHTOOL_A_CABLE_STEP_STEP_DISTANCE = 3,
	__ETHTOOL_A_CABLE_STEP_CNT = 4,
	ETHTOOL_A_CABLE_STEP_MAX = 3,
};

enum {
	ETHTOOL_A_CABLE_TDR_NEST_UNSPEC = 0,
	ETHTOOL_A_CABLE_TDR_NEST_STEP = 1,
	ETHTOOL_A_CABLE_TDR_NEST_AMPLITUDE = 2,
	ETHTOOL_A_CABLE_TDR_NEST_PULSE = 3,
	__ETHTOOL_A_CABLE_TDR_NEST_CNT = 4,
	ETHTOOL_A_CABLE_TDR_NEST_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_ENTRY_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_PORT = 1,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_TYPE = 2,
	__ETHTOOL_A_TUNNEL_UDP_ENTRY_CNT = 3,
	ETHTOOL_A_TUNNEL_UDP_ENTRY_MAX = 2,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_TABLE_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE_SIZE = 1,
	ETHTOOL_A_TUNNEL_UDP_TABLE_TYPES = 2,
	ETHTOOL_A_TUNNEL_UDP_TABLE_ENTRY = 3,
	__ETHTOOL_A_TUNNEL_UDP_TABLE_CNT = 4,
	ETHTOOL_A_TUNNEL_UDP_TABLE_MAX = 3,
};

enum {
	ETHTOOL_A_TUNNEL_UDP_UNSPEC = 0,
	ETHTOOL_A_TUNNEL_UDP_TABLE = 1,
	__ETHTOOL_A_TUNNEL_UDP_CNT = 2,
	ETHTOOL_A_TUNNEL_UDP_MAX = 1,
};

enum udp_parsable_tunnel_type {
	UDP_TUNNEL_TYPE_VXLAN = 1,
	UDP_TUNNEL_TYPE_GENEVE = 2,
	UDP_TUNNEL_TYPE_VXLAN_GPE = 4,
};

enum udp_tunnel_nic_info_flags {
	UDP_TUNNEL_NIC_INFO_MAY_SLEEP = 1,
	UDP_TUNNEL_NIC_INFO_OPEN_ONLY = 2,
	UDP_TUNNEL_NIC_INFO_IPV4_ONLY = 4,
	UDP_TUNNEL_NIC_INFO_STATIC_IANA_VXLAN = 8,
};

struct udp_tunnel_nic_ops {
	void (*get_port)(struct net_device *, unsigned int, unsigned int, struct udp_tunnel_info *);
	void (*set_port_priv)(struct net_device *, unsigned int, unsigned int, u8);
	void (*add_port)(struct net_device *, struct udp_tunnel_info *);
	void (*del_port)(struct net_device *, struct udp_tunnel_info *);
	void (*reset_ntf)(struct net_device *);
	size_t (*dump_size)(struct net_device *, unsigned int);
	int (*dump_write)(struct net_device *, unsigned int, struct sk_buff *);
};

struct ethnl_tunnel_info_dump_ctx {
	struct ethnl_req_info req_info;
	int pos_hash;
	int pos_idx;
};

enum {
	ETHTOOL_A_FEC_STAT_UNSPEC = 0,
	ETHTOOL_A_FEC_STAT_PAD = 1,
	ETHTOOL_A_FEC_STAT_CORRECTED = 2,
	ETHTOOL_A_FEC_STAT_UNCORR = 3,
	ETHTOOL_A_FEC_STAT_CORR_BITS = 4,
	__ETHTOOL_A_FEC_STAT_CNT = 5,
	ETHTOOL_A_FEC_STAT_MAX = 4,
};

struct fec_stat_grp {
	u64 stats[9];
	u8 cnt;
	int: 24;
	int: 32;
};

struct fec_reply_data {
	struct ethnl_reply_data base;
	long unsigned int fec_link_modes[3];
	u32 active_fec;
	u8 fec_auto;
	struct fec_stat_grp corr;
	struct fec_stat_grp uncorr;
	struct fec_stat_grp corr_bits;
};

struct eeprom_req_info {
	struct ethnl_req_info base;
	u32 offset;
	u32 length;
	u8 page;
	u8 bank;
	u8 i2c_address;
};

struct eeprom_reply_data {
	struct ethnl_reply_data base;
	u32 length;
	u8 *data;
};

enum {
	ETHTOOL_A_STATS_GRP_UNSPEC = 0,
	ETHTOOL_A_STATS_GRP_PAD = 1,
	ETHTOOL_A_STATS_GRP_ID = 2,
	ETHTOOL_A_STATS_GRP_SS_ID = 3,
	ETHTOOL_A_STATS_GRP_STAT = 4,
	ETHTOOL_A_STATS_GRP_HIST_RX = 5,
	ETHTOOL_A_STATS_GRP_HIST_TX = 6,
	ETHTOOL_A_STATS_GRP_HIST_BKT_LOW = 7,
	ETHTOOL_A_STATS_GRP_HIST_BKT_HI = 8,
	ETHTOOL_A_STATS_GRP_HIST_VAL = 9,
	__ETHTOOL_A_STATS_GRP_CNT = 10,
	ETHTOOL_A_STATS_GRP_MAX = 4,
};

struct stats_req_info {
	struct ethnl_req_info base;
	long unsigned int stat_mask[1];
};

struct stats_reply_data {
	struct ethnl_reply_data base;
	int: 32;
	union {
		struct {
			struct ethtool_eth_phy_stats phy_stats;
			struct ethtool_eth_mac_stats mac_stats;
			struct ethtool_eth_ctrl_stats ctrl_stats;
			struct ethtool_rmon_stats rmon_stats;
		};
		struct {
			struct ethtool_eth_phy_stats phy_stats;
			struct ethtool_eth_mac_stats mac_stats;
			struct ethtool_eth_ctrl_stats ctrl_stats;
			struct ethtool_rmon_stats rmon_stats;
		} stats;
	};
	const struct ethtool_rmon_hist_range *rmon_ranges;
	int: 32;
};

struct phc_vclocks_reply_data {
	struct ethnl_reply_data base;
	int num;
	int *index;
};

struct module_reply_data {
	struct ethnl_reply_data base;
	struct ethtool_module_power_mode_params power;
};

enum ethtool_podl_pse_admin_state {
	ETHTOOL_PODL_PSE_ADMIN_STATE_UNKNOWN = 1,
	ETHTOOL_PODL_PSE_ADMIN_STATE_DISABLED = 2,
	ETHTOOL_PODL_PSE_ADMIN_STATE_ENABLED = 3,
};

enum ethtool_podl_pse_pw_d_status {
	ETHTOOL_PODL_PSE_PW_D_STATUS_UNKNOWN = 1,
	ETHTOOL_PODL_PSE_PW_D_STATUS_DISABLED = 2,
	ETHTOOL_PODL_PSE_PW_D_STATUS_SEARCHING = 3,
	ETHTOOL_PODL_PSE_PW_D_STATUS_DELIVERING = 4,
	ETHTOOL_PODL_PSE_PW_D_STATUS_SLEEP = 5,
	ETHTOOL_PODL_PSE_PW_D_STATUS_IDLE = 6,
	ETHTOOL_PODL_PSE_PW_D_STATUS_ERROR = 7,
};

struct pse_control_config {
	enum ethtool_podl_pse_admin_state admin_cotrol;
};

struct pse_control_status {
	enum ethtool_podl_pse_admin_state podl_admin_state;
	enum ethtool_podl_pse_pw_d_status podl_pw_status;
};

struct pse_reply_data {
	struct ethnl_reply_data base;
	struct pse_control_status status;
};

enum nf_hook_ops_type {
	NF_HOOK_OP_UNDEFINED = 0,
	NF_HOOK_OP_NF_TABLES = 1,
};

struct nf_hook_ops {
	nf_hookfn *hook;
	struct net_device *dev;
	void *priv;
	u8 pf;
	enum nf_hook_ops_type hook_ops_type: 8;
	unsigned int hooknum;
	int priority;
};

struct nf_hook_entries_rcu_head {
	struct callback_head head;
	void *allocation;
};

struct nf_conn;

enum nf_nat_manip_type;

struct nf_nat_hook {
	int (*parse_nat_setup)(struct nf_conn *, enum nf_nat_manip_type, const struct nlattr *);
	void (*decode_session)(struct sk_buff *, struct flowi *);
	unsigned int (*manip_pkt)(struct sk_buff *, struct nf_conn *, enum nf_nat_manip_type, enum ip_conntrack_dir);
	void (*remove_nat_bysrc)(struct nf_conn *);
};

struct nf_conntrack_tuple;

struct nf_ct_hook {
	int (*update)(struct net *, struct sk_buff *);
	void (*destroy)(struct nf_conntrack *);
	bool (*get_tuple_skb)(struct nf_conntrack_tuple *, const struct sk_buff *);
	void (*attach)(struct sk_buff *, const struct sk_buff *);
};

struct nfnl_ct_hook {
	size_t (*build_size)(const struct nf_conn *);
	int (*build)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, u_int16_t, u_int16_t);
	int (*parse)(const struct nlattr *, struct nf_conn *);
	int (*attach_expect)(const struct nlattr *, struct nf_conn *, u32, u32);
	void (*seq_adjust)(struct sk_buff *, struct nf_conn *, enum ip_conntrack_info, s32);
};

struct nf_queue_entry;

struct nf_ipv6_ops {
	void (*route_input)(struct sk_buff *);
	int (*fragment)(struct net *, struct sock *, struct sk_buff *, int (*)(struct net *, struct sock *, struct sk_buff *));
	int (*reroute)(struct sk_buff *, const struct nf_queue_entry *);
};

struct nf_queue_entry {
	struct list_head list;
	struct sk_buff *skb;
	unsigned int id;
	unsigned int hook_index;
	struct nf_hook_state state;
	u16 size;
};

struct nf_loginfo {
	u_int8_t type;
	union {
		struct {
			u_int32_t copy_len;
			u_int16_t group;
			u_int16_t qthreshold;
			u_int16_t flags;
		} ulog;
		struct {
			u_int8_t level;
			u_int8_t logflags;
		} log;
	} u;
};

struct nf_log_buf {
	unsigned int count;
	char buf[1020];
};

struct ip_rt_info {
	__be32 daddr;
	__be32 saddr;
	u_int8_t tos;
	u_int32_t mark;
};

struct ip6_rt_info {
	struct in6_addr daddr;
	struct in6_addr saddr;
	u_int32_t mark;
};

struct nf_queue_handler {
	int (*outfn)(struct nf_queue_entry *, unsigned int);
	void (*nf_hook_drop)(struct net *);
};

struct nf_sockopt_ops {
	struct list_head list;
	u_int8_t pf;
	int set_optmin;
	int set_optmax;
	int (*set)(struct sock *, int, sockptr_t, unsigned int);
	int get_optmin;
	int get_optmax;
	int (*get)(struct sock *, int, void *, int *);
	struct module *owner;
};

struct ip_mreqn {
	struct in_addr imr_multiaddr;
	struct in_addr imr_address;
	int imr_ifindex;
};

struct rtmsg {
	unsigned char rtm_family;
	unsigned char rtm_dst_len;
	unsigned char rtm_src_len;
	unsigned char rtm_tos;
	unsigned char rtm_table;
	unsigned char rtm_protocol;
	unsigned char rtm_scope;
	unsigned char rtm_type;
	unsigned int rtm_flags;
};

struct rtvia {
	__kernel_sa_family_t rtvia_family;
	__u8 rtvia_addr[0];
};

struct ip_sf_list;

struct ip_mc_list {
	struct in_device *interface;
	__be32 multiaddr;
	unsigned int sfmode;
	struct ip_sf_list *sources;
	struct ip_sf_list *tomb;
	long unsigned int sfcount[2];
	union {
		struct ip_mc_list *next;
		struct ip_mc_list *next_rcu;
	};
	struct ip_mc_list *next_hash;
	struct timer_list timer;
	int users;
	refcount_t refcnt;
	spinlock_t lock;
	char tm_running;
	char reporter;
	char unsolicit_count;
	char loaded;
	unsigned char gsquery;
	unsigned char crcount;
	struct callback_head rcu;
};

struct ip_sf_socklist {
	unsigned int sl_max;
	unsigned int sl_count;
	struct callback_head rcu;
	__be32 sl_addr[0];
};

struct ip_mc_socklist {
	struct ip_mc_socklist *next_rcu;
	struct ip_mreqn multi;
	unsigned int sfmode;
	struct ip_sf_socklist *sflist;
	struct callback_head rcu;
};

struct ip_sf_list {
	struct ip_sf_list *sf_next;
	long unsigned int sf_count[2];
	__be32 sf_inaddr;
	unsigned char sf_gsresp;
	unsigned char sf_oldin;
	unsigned char sf_crcount;
};

typedef u8 dscp_t;

struct ipv4_addr_key {
	__be32 addr;
	int vif;
};

struct inetpeer_addr {
	union {
		struct ipv4_addr_key a4;
		struct in6_addr a6;
		u32 key[4];
	};
	__u16 family;
};

struct inet_peer {
	struct rb_node rb_node;
	struct inetpeer_addr daddr;
	u32 metrics[17];
	u32 rate_tokens;
	u32 n_redirects;
	long unsigned int rate_last;
	union {
		struct {
			atomic_t rid;
		};
		struct callback_head rcu;
	};
	__u32 dtime;
	refcount_t refcnt;
};

struct fib_rt_info {
	struct fib_info *fi;
	u32 tb_id;
	__be32 dst;
	int dst_len;
	dscp_t dscp;
	u8 type;
	u8 offload: 1;
	u8 trap: 1;
	u8 offload_failed: 1;
	u8 unused: 5;
};

struct uncached_list {
	spinlock_t lock;
	struct list_head head;
	struct list_head quarantine;
};

struct ip_rt_acct {
	__u32 o_bytes;
	__u32 o_packets;
	__u32 i_bytes;
	__u32 i_packets;
};

struct rt_cache_stat {
	unsigned int in_slow_tot;
	unsigned int in_slow_mc;
	unsigned int in_no_route;
	unsigned int in_brd;
	unsigned int in_martian_dst;
	unsigned int in_martian_src;
	unsigned int out_slow_tot;
	unsigned int out_slow_mc;
};

struct fib_alias {
	struct hlist_node fa_list;
	struct fib_info *fa_info;
	dscp_t fa_dscp;
	u8 fa_type;
	u8 fa_state;
	u8 fa_slen;
	u32 tb_id;
	s16 fa_default;
	u8 offload;
	u8 trap;
	u8 offload_failed;
	struct callback_head rcu;
};

struct fib_prop {
	int error;
	u8 scope;
};

struct net_offload {
	struct offload_callbacks callbacks;
	unsigned int flags;
};

struct raw_hashinfo {
	spinlock_t lock;
	struct hlist_nulls_head ht[256];
};

enum ip_defrag_users {
	IP_DEFRAG_LOCAL_DELIVER = 0,
	IP_DEFRAG_CALL_RA_CHAIN = 1,
	IP_DEFRAG_CONNTRACK_IN = 2,
	__IP_DEFRAG_CONNTRACK_IN_END = 65537,
	IP_DEFRAG_CONNTRACK_OUT = 65538,
	__IP_DEFRAG_CONNTRACK_OUT_END = 131073,
	IP_DEFRAG_CONNTRACK_BRIDGE_IN = 131074,
	__IP_DEFRAG_CONNTRACK_BRIDGE_IN = 196609,
	IP_DEFRAG_VS_IN = 196610,
	IP_DEFRAG_VS_OUT = 196611,
	IP_DEFRAG_VS_FWD = 196612,
	IP_DEFRAG_AF_PACKET = 196613,
	IP_DEFRAG_MACVLAN = 196614,
};

enum {
	INET_FRAG_FIRST_IN = 1,
	INET_FRAG_LAST_IN = 2,
	INET_FRAG_COMPLETE = 4,
	INET_FRAG_HASH_DEAD = 8,
};

struct ipq {
	struct inet_frag_queue q;
	u8 ecn;
	u16 max_df_size;
	int iif;
	unsigned int rid;
	struct inet_peer *peer;
};

typedef union {
	__be32 a4;
	__be32 a6[4];
	struct in6_addr in6;
} xfrm_address_t;

struct xfrm_id {
	xfrm_address_t daddr;
	__be32 spi;
	__u8 proto;
};

struct xfrm_sec_ctx {
	__u8 ctx_doi;
	__u8 ctx_alg;
	__u16 ctx_len;
	__u32 ctx_sid;
	char ctx_str[0];
};

struct xfrm_selector {
	xfrm_address_t daddr;
	xfrm_address_t saddr;
	__be16 dport;
	__be16 dport_mask;
	__be16 sport;
	__be16 sport_mask;
	__u16 family;
	__u8 prefixlen_d;
	__u8 prefixlen_s;
	__u8 proto;
	int ifindex;
	__kernel_uid32_t user;
};

struct xfrm_lifetime_cfg {
	__u64 soft_byte_limit;
	__u64 hard_byte_limit;
	__u64 soft_packet_limit;
	__u64 hard_packet_limit;
	__u64 soft_add_expires_seconds;
	__u64 hard_add_expires_seconds;
	__u64 soft_use_expires_seconds;
	__u64 hard_use_expires_seconds;
};

struct xfrm_lifetime_cur {
	__u64 bytes;
	__u64 packets;
	__u64 add_time;
	__u64 use_time;
};

struct xfrm_replay_state {
	__u32 oseq;
	__u32 seq;
	__u32 bitmap;
};

struct xfrm_replay_state_esn {
	unsigned int bmp_len;
	__u32 oseq;
	__u32 seq;
	__u32 oseq_hi;
	__u32 seq_hi;
	__u32 replay_window;
	__u32 bmp[0];
};

struct xfrm_algo {
	char alg_name[64];
	unsigned int alg_key_len;
	char alg_key[0];
};

struct xfrm_algo_auth {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_trunc_len;
	char alg_key[0];
};

struct xfrm_algo_aead {
	char alg_name[64];
	unsigned int alg_key_len;
	unsigned int alg_icv_len;
	char alg_key[0];
};

struct xfrm_stats {
	__u32 replay_window;
	__u32 replay;
	__u32 integrity_failed;
};

struct xfrm_encap_tmpl {
	__u16 encap_type;
	__be16 encap_sport;
	__be16 encap_dport;
	xfrm_address_t encap_oa;
};

struct xfrm_mark {
	__u32 v;
	__u32 m;
};

struct xfrm_address_filter {
	xfrm_address_t saddr;
	xfrm_address_t daddr;
	__u16 family;
	__u8 splen;
	__u8 dplen;
};

struct xfrm_state_walk {
	struct list_head all;
	u8 state;
	u8 dying;
	u8 proto;
	u32 seq;
	struct xfrm_address_filter *filter;
};

struct xfrm_dev_offload {
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct net_device *real_dev;
	long unsigned int offload_handle;
	u8 dir: 2;
};

struct xfrm_mode {
	u8 encap;
	u8 family;
	u8 flags;
};

enum xfrm_replay_mode {
	XFRM_REPLAY_MODE_LEGACY = 0,
	XFRM_REPLAY_MODE_BMP = 1,
	XFRM_REPLAY_MODE_ESN = 2,
};

struct xfrm_type;

struct xfrm_type_offload;

struct xfrm_state {
	possible_net_t xs_net;
	union {
		struct hlist_node gclist;
		struct hlist_node bydst;
	};
	struct hlist_node bysrc;
	struct hlist_node byspi;
	struct hlist_node byseq;
	refcount_t refcnt;
	spinlock_t lock;
	struct xfrm_id id;
	struct xfrm_selector sel;
	struct xfrm_mark mark;
	u32 if_id;
	u32 tfcpad;
	u32 genid;
	struct xfrm_state_walk km;
	struct {
		u32 reqid;
		u8 mode;
		u8 replay_window;
		u8 aalgo;
		u8 ealgo;
		u8 calgo;
		u8 flags;
		u16 family;
		xfrm_address_t saddr;
		int header_len;
		int trailer_len;
		u32 extra_flags;
		struct xfrm_mark smark;
	} props;
	int: 32;
	struct xfrm_lifetime_cfg lft;
	struct xfrm_algo_auth *aalg;
	struct xfrm_algo *ealg;
	struct xfrm_algo *calg;
	struct xfrm_algo_aead *aead;
	const char *geniv;
	__be16 new_mapping_sport;
	u32 new_mapping;
	u32 mapping_maxage;
	struct xfrm_encap_tmpl *encap;
	struct sock *encap_sk;
	xfrm_address_t *coaddr;
	struct xfrm_state *tunnel;
	atomic_t tunnel_users;
	struct xfrm_replay_state replay;
	struct xfrm_replay_state_esn *replay_esn;
	struct xfrm_replay_state preplay;
	struct xfrm_replay_state_esn *preplay_esn;
	enum xfrm_replay_mode repl_mode;
	u32 xflags;
	u32 replay_maxage;
	u32 replay_maxdiff;
	struct timer_list rtimer;
	struct xfrm_stats stats;
	int: 32;
	struct xfrm_lifetime_cur curlft;
	struct hrtimer mtimer;
	struct xfrm_dev_offload xso;
	long int saved_tmo;
	int: 32;
	time64_t lastused;
	struct page_frag xfrag;
	const struct xfrm_type *type;
	struct xfrm_mode inner_mode;
	struct xfrm_mode inner_mode_iaf;
	struct xfrm_mode outer_mode;
	const struct xfrm_type_offload *type_offload;
	struct xfrm_sec_ctx *security;
	void *data;
	int: 32;
};

struct xfrm_type {
	struct module *owner;
	u8 proto;
	u8 flags;
	int (*init_state)(struct xfrm_state *, struct netlink_ext_ack *);
	void (*destructor)(struct xfrm_state *);
	int (*input)(struct xfrm_state *, struct sk_buff *);
	int (*output)(struct xfrm_state *, struct sk_buff *);
	int (*reject)(struct xfrm_state *, struct sk_buff *, const struct flowi *);
};

struct xfrm_type_offload {
	struct module *owner;
	u8 proto;
	void (*encap)(struct xfrm_state *, struct sk_buff *);
	int (*input_tail)(struct xfrm_state *, struct sk_buff *);
	int (*xmit)(struct xfrm_state *, struct sk_buff *, netdev_features_t);
};

struct sec_path {
	int len;
	int olen;
	struct xfrm_state *xvec[6];
	struct xfrm_offload ovec[1];
};

struct ip_options_data {
	struct ip_options_rcu opt;
	char data[40];
};

enum {
	LWTUNNEL_XMIT_DONE = 0,
	LWTUNNEL_XMIT_CONTINUE = 1,
};

struct ipcm_cookie {
	struct sockcm_cookie sockc;
	__be32 addr;
	int oif;
	struct ip_options_rcu *opt;
	__u8 ttl;
	__s16 tos;
	char priority;
	__u16 gso_size;
	int: 32;
};

struct ip_fraglist_iter {
	struct sk_buff *frag;
	struct iphdr *iph;
	int offset;
	unsigned int hlen;
};

struct ip_frag_state {
	bool DF;
	unsigned int hlen;
	unsigned int ll_rs;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	__be16 not_last_frag;
};

struct ip_reply_arg {
	struct kvec iov[1];
	int flags;
	__wsum csum;
	int csumoffset;
	int bound_dev_if;
	u8 tos;
	kuid_t uid;
};

struct ip_mreq_source {
	__be32 imr_multiaddr;
	__be32 imr_interface;
	__be32 imr_sourceaddr;
};

struct ip_msfilter {
	__be32 imsf_multiaddr;
	__be32 imsf_interface;
	__u32 imsf_fmode;
	__u32 imsf_numsrc;
	union {
		__be32 imsf_slist[1];
		struct {
			struct {			} __empty_imsf_slist_flex;
			__be32 imsf_slist_flex[0];
		};
	};
};

struct group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		};
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		};
	};
};

struct in_pktinfo {
	int ipi_ifindex;
	struct in_addr ipi_spec_dst;
	struct in_addr ipi_addr;
};

struct compat_group_req {
	__u32 gr_interface;
	struct __kernel_sockaddr_storage gr_group;
};

struct compat_group_source_req {
	__u32 gsr_interface;
	struct __kernel_sockaddr_storage gsr_group;
	struct __kernel_sockaddr_storage gsr_source;
};

struct compat_group_filter {
	union {
		struct {
			__u32 gf_interface_aux;
			struct __kernel_sockaddr_storage gf_group_aux;
			__u32 gf_fmode_aux;
			__u32 gf_numsrc_aux;
			struct __kernel_sockaddr_storage gf_slist[1];
		};
		struct {
			__u32 gf_interface;
			struct __kernel_sockaddr_storage gf_group;
			__u32 gf_fmode;
			__u32 gf_numsrc;
			struct __kernel_sockaddr_storage gf_slist_flex[0];
		};
	};
};

enum {
	BPFILTER_IPT_SO_SET_REPLACE = 64,
	BPFILTER_IPT_SO_SET_ADD_COUNTERS = 65,
	BPFILTER_IPT_SET_MAX = 66,
};

enum {
	BPFILTER_IPT_SO_GET_INFO = 64,
	BPFILTER_IPT_SO_GET_ENTRIES = 65,
	BPFILTER_IPT_SO_GET_REVISION_MATCH = 66,
	BPFILTER_IPT_SO_GET_REVISION_TARGET = 67,
	BPFILTER_IPT_GET_MAX = 68,
};

struct tcpvegas_info {
	__u32 tcpv_enabled;
	__u32 tcpv_rttcnt;
	__u32 tcpv_rtt;
	__u32 tcpv_minrtt;
};

struct tcp_dctcp_info {
	__u16 dctcp_enabled;
	__u16 dctcp_ce_state;
	__u32 dctcp_alpha;
	__u32 dctcp_ab_ecn;
	__u32 dctcp_ab_tot;
};

struct tcp_bbr_info {
	__u32 bbr_bw_lo;
	__u32 bbr_bw_hi;
	__u32 bbr_min_rtt;
	__u32 bbr_pacing_gain;
	__u32 bbr_cwnd_gain;
};

union tcp_cc_info {
	struct tcpvegas_info vegas;
	struct tcp_dctcp_info dctcp;
	struct tcp_bbr_info bbr;
};

enum inet_csk_ack_state_t {
	ICSK_ACK_SCHED = 1,
	ICSK_ACK_TIMER = 2,
	ICSK_ACK_PUSHED = 4,
	ICSK_ACK_PUSHED2 = 8,
	ICSK_ACK_NOW = 16,
};

enum {
	TCP_FLAG_CWR = 32768,
	TCP_FLAG_ECE = 16384,
	TCP_FLAG_URG = 8192,
	TCP_FLAG_ACK = 4096,
	TCP_FLAG_PSH = 2048,
	TCP_FLAG_RST = 1024,
	TCP_FLAG_SYN = 512,
	TCP_FLAG_FIN = 256,
	TCP_RESERVED_BITS = 15,
	TCP_DATA_OFFSET = 240,
};

struct tcp_repair_opt {
	__u32 opt_code;
	__u32 opt_val;
};

struct tcp_repair_window {
	__u32 snd_wl1;
	__u32 snd_wnd;
	__u32 max_window;
	__u32 rcv_wnd;
	__u32 rcv_wup;
};

enum {
	TCP_NO_QUEUE = 0,
	TCP_RECV_QUEUE = 1,
	TCP_SEND_QUEUE = 2,
	TCP_QUEUES_NR = 3,
};

struct tcp_info {
	__u8 tcpi_state;
	__u8 tcpi_ca_state;
	__u8 tcpi_retransmits;
	__u8 tcpi_probes;
	__u8 tcpi_backoff;
	__u8 tcpi_options;
	__u8 tcpi_snd_wscale: 4;
	__u8 tcpi_rcv_wscale: 4;
	__u8 tcpi_delivery_rate_app_limited: 1;
	__u8 tcpi_fastopen_client_fail: 2;
	__u32 tcpi_rto;
	__u32 tcpi_ato;
	__u32 tcpi_snd_mss;
	__u32 tcpi_rcv_mss;
	__u32 tcpi_unacked;
	__u32 tcpi_sacked;
	__u32 tcpi_lost;
	__u32 tcpi_retrans;
	__u32 tcpi_fackets;
	__u32 tcpi_last_data_sent;
	__u32 tcpi_last_ack_sent;
	__u32 tcpi_last_data_recv;
	__u32 tcpi_last_ack_recv;
	__u32 tcpi_pmtu;
	__u32 tcpi_rcv_ssthresh;
	__u32 tcpi_rtt;
	__u32 tcpi_rttvar;
	__u32 tcpi_snd_ssthresh;
	__u32 tcpi_snd_cwnd;
	__u32 tcpi_advmss;
	__u32 tcpi_reordering;
	__u32 tcpi_rcv_rtt;
	__u32 tcpi_rcv_space;
	__u32 tcpi_total_retrans;
	__u64 tcpi_pacing_rate;
	__u64 tcpi_max_pacing_rate;
	__u64 tcpi_bytes_acked;
	__u64 tcpi_bytes_received;
	__u32 tcpi_segs_out;
	__u32 tcpi_segs_in;
	__u32 tcpi_notsent_bytes;
	__u32 tcpi_min_rtt;
	__u32 tcpi_data_segs_in;
	__u32 tcpi_data_segs_out;
	__u64 tcpi_delivery_rate;
	__u64 tcpi_busy_time;
	__u64 tcpi_rwnd_limited;
	__u64 tcpi_sndbuf_limited;
	__u32 tcpi_delivered;
	__u32 tcpi_delivered_ce;
	__u64 tcpi_bytes_sent;
	__u64 tcpi_bytes_retrans;
	__u32 tcpi_dsack_dups;
	__u32 tcpi_reord_seen;
	__u32 tcpi_rcv_ooopack;
	__u32 tcpi_snd_wnd;
};

enum {
	TCP_NLA_PAD = 0,
	TCP_NLA_BUSY = 1,
	TCP_NLA_RWND_LIMITED = 2,
	TCP_NLA_SNDBUF_LIMITED = 3,
	TCP_NLA_DATA_SEGS_OUT = 4,
	TCP_NLA_TOTAL_RETRANS = 5,
	TCP_NLA_PACING_RATE = 6,
	TCP_NLA_DELIVERY_RATE = 7,
	TCP_NLA_SND_CWND = 8,
	TCP_NLA_REORDERING = 9,
	TCP_NLA_MIN_RTT = 10,
	TCP_NLA_RECUR_RETRANS = 11,
	TCP_NLA_DELIVERY_RATE_APP_LMT = 12,
	TCP_NLA_SNDQ_SIZE = 13,
	TCP_NLA_CA_STATE = 14,
	TCP_NLA_SND_SSTHRESH = 15,
	TCP_NLA_DELIVERED = 16,
	TCP_NLA_DELIVERED_CE = 17,
	TCP_NLA_BYTES_SENT = 18,
	TCP_NLA_BYTES_RETRANS = 19,
	TCP_NLA_DSACK_DUPS = 20,
	TCP_NLA_REORD_SEEN = 21,
	TCP_NLA_SRTT = 22,
	TCP_NLA_TIMEOUT_REHASH = 23,
	TCP_NLA_BYTES_NOTSENT = 24,
	TCP_NLA_EDT = 25,
	TCP_NLA_TTL = 26,
};

struct tcp_zerocopy_receive {
	__u64 address;
	__u32 length;
	__u32 recv_skip_hint;
	__u32 inq;
	__s32 err;
	__u64 copybuf_address;
	__s32 copybuf_len;
	__u32 flags;
	__u64 msg_control;
	__u64 msg_controllen;
	__u32 msg_flags;
	__u32 reserved;
};

enum {
	BPF_TCP_ESTABLISHED = 1,
	BPF_TCP_SYN_SENT = 2,
	BPF_TCP_SYN_RECV = 3,
	BPF_TCP_FIN_WAIT1 = 4,
	BPF_TCP_FIN_WAIT2 = 5,
	BPF_TCP_TIME_WAIT = 6,
	BPF_TCP_CLOSE = 7,
	BPF_TCP_CLOSE_WAIT = 8,
	BPF_TCP_LAST_ACK = 9,
	BPF_TCP_LISTEN = 10,
	BPF_TCP_CLOSING = 11,
	BPF_TCP_NEW_SYN_RECV = 12,
	BPF_TCP_MAX_STATES = 13,
};

enum tcp_chrono {
	TCP_CHRONO_UNSPEC = 0,
	TCP_CHRONO_BUSY = 1,
	TCP_CHRONO_RWND_LIMITED = 2,
	TCP_CHRONO_SNDBUF_LIMITED = 3,
	__TCP_CHRONO_MAX = 4,
};

enum {
	TCP_CMSG_INQ = 1,
	TCP_CMSG_TS = 2,
};

struct tcp_splice_state {
	struct pipe_inode_info *pipe;
	size_t len;
	unsigned int flags;
};

enum tcp_fastopen_client_fail {
	TFO_STATUS_UNSPEC = 0,
	TFO_COOKIE_UNAVAILABLE = 1,
	TFO_DATA_NOT_ACKED = 2,
	TFO_SYN_RETRANSMITTED = 3,
};

struct tcp_sack_block_wire {
	__be32 start_seq;
	__be32 end_seq;
};

struct static_key_false_deferred {
	struct static_key_false key;
};

enum tcp_queue {
	TCP_FRAG_IN_WRITE_QUEUE = 0,
	TCP_FRAG_IN_RTX_QUEUE = 1,
};

enum tcp_ca_ack_event_flags {
	CA_ACK_SLOWPATH = 1,
	CA_ACK_WIN_UPDATE = 2,
	CA_ACK_ECE = 4,
};

struct tcp_sacktag_state {
	u64 first_sackt;
	u64 last_sackt;
	u32 reord;
	u32 sack_delivered;
	int flag;
	unsigned int mss_now;
	struct rate_sample *rate;
	int: 32;
};

enum tsq_flags {
	TSQF_THROTTLED = 1,
	TSQF_QUEUED = 2,
	TCPF_TSQ_DEFERRED = 4,
	TCPF_WRITE_TIMER_DEFERRED = 8,
	TCPF_DELACK_TIMER_DEFERRED = 16,
	TCPF_MTU_REDUCED_DEFERRED = 32,
};

enum {
	BPF_WRITE_HDR_TCP_CURRENT_MSS = 1,
	BPF_WRITE_HDR_TCP_SYNACK_COOKIE = 2,
};

struct mptcp_out_options {};

union tcp_md5_addr {
	struct in_addr a4;
	struct in6_addr a6;
};

struct tcp_md5sig_key {
	struct hlist_node node;
	u8 keylen;
	u8 family;
	u8 prefixlen;
	u8 flags;
	union tcp_md5_addr addr;
	int l3index;
	u8 key[80];
	struct callback_head rcu;
};

struct tcp_out_options {
	u16 options;
	u16 mss;
	u8 ws;
	u8 num_sack_blocks;
	u8 hash_size;
	u8 bpf_opt_len;
	__u8 *hash_location;
	__u32 tsval;
	__u32 tsecr;
	struct tcp_fastopen_cookie *fastopen_cookie;
	struct mptcp_out_options mptcp;
};

struct tsq_tasklet {
	struct tasklet_struct tasklet;
	struct list_head head;
};

struct icmp_err {
	int errno;
	unsigned int fatal: 1;
};

enum tcp_tw_status {
	TCP_TW_SUCCESS = 0,
	TCP_TW_RST = 1,
	TCP_TW_ACK = 2,
	TCP_TW_SYN = 3,
};

enum tcp_seq_states {
	TCP_SEQ_STATE_LISTENING = 0,
	TCP_SEQ_STATE_ESTABLISHED = 1,
};

struct tcp_seq_afinfo {
	sa_family_t family;
};

struct tcp_iter_state {
	struct seq_net_private p;
	enum tcp_seq_states state;
	struct sock *syn_wait_sk;
	int bucket;
	int offset;
	int sbucket;
	int num;
	int: 32;
	loff_t last_pos;
};

struct bpf_tcp_iter_state {
	struct tcp_iter_state state;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	struct sock **batch;
	bool st_bucket_done;
	int: 24;
	int: 32;
};

struct bpf_iter__tcp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct sock_common *sk_common;
	};
	uid_t uid;
	int: 32;
};

enum tcp_metric_index {
	TCP_METRIC_RTT = 0,
	TCP_METRIC_RTTVAR = 1,
	TCP_METRIC_SSTHRESH = 2,
	TCP_METRIC_CWND = 3,
	TCP_METRIC_REORDERING = 4,
	TCP_METRIC_RTT_US = 5,
	TCP_METRIC_RTTVAR_US = 6,
	__TCP_METRIC_MAX = 7,
};

enum {
	TCP_METRICS_ATTR_UNSPEC = 0,
	TCP_METRICS_ATTR_ADDR_IPV4 = 1,
	TCP_METRICS_ATTR_ADDR_IPV6 = 2,
	TCP_METRICS_ATTR_AGE = 3,
	TCP_METRICS_ATTR_TW_TSVAL = 4,
	TCP_METRICS_ATTR_TW_TS_STAMP = 5,
	TCP_METRICS_ATTR_VALS = 6,
	TCP_METRICS_ATTR_FOPEN_MSS = 7,
	TCP_METRICS_ATTR_FOPEN_SYN_DROPS = 8,
	TCP_METRICS_ATTR_FOPEN_SYN_DROP_TS = 9,
	TCP_METRICS_ATTR_FOPEN_COOKIE = 10,
	TCP_METRICS_ATTR_SADDR_IPV4 = 11,
	TCP_METRICS_ATTR_SADDR_IPV6 = 12,
	TCP_METRICS_ATTR_PAD = 13,
	__TCP_METRICS_ATTR_MAX = 14,
};

enum {
	TCP_METRICS_CMD_UNSPEC = 0,
	TCP_METRICS_CMD_GET = 1,
	TCP_METRICS_CMD_DEL = 2,
	__TCP_METRICS_CMD_MAX = 3,
};

struct tcp_fastopen_metrics {
	u16 mss;
	u16 syn_loss: 10;
	u16 try_exp: 2;
	long unsigned int last_syn_loss;
	struct tcp_fastopen_cookie cookie;
};

struct tcp_metrics_block {
	struct tcp_metrics_block *tcpm_next;
	possible_net_t tcpm_net;
	struct inetpeer_addr tcpm_saddr;
	struct inetpeer_addr tcpm_daddr;
	long unsigned int tcpm_stamp;
	u32 tcpm_lock;
	u32 tcpm_vals[5];
	int: 32;
	struct tcp_fastopen_metrics tcpm_fastopen;
	struct callback_head callback_head;
};

struct tcpm_hash_bucket {
	struct tcp_metrics_block *chain;
};

struct icmp_filter {
	__u32 data;
};

struct raw_iter_state {
	struct seq_net_private p;
	int bucket;
};

struct raw_sock {
	struct inet_sock inet;
	struct icmp_filter filter;
	u32 ipmr_table;
};

struct raw_frag_vec {
	struct msghdr *msg;
	union {
		struct icmphdr icmph;
		char c[1];
	} hdr;
	int hlen;
};

struct ip_tunnel_encap {
	u16 type;
	u16 flags;
	__be16 sport;
	__be16 dport;
};

struct ip_tunnel_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi4 *);
	int (*err_handler)(struct sk_buff *, u32);
};

struct udp_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	} header;
	__u16 cscov;
	__u8 partial_cov;
};

struct udp_dev_scratch {
	u32 _tsize_state;
};

struct udp_seq_afinfo {
	sa_family_t family;
	struct udp_table *udp_table;
};

struct udp_iter_state {
	struct seq_net_private p;
	int bucket;
	struct udp_seq_afinfo *bpf_seq_afinfo;
};

struct bpf_iter__udp {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct udp_sock *udp_sk;
	};
	uid_t uid;
	int: 32;
	int bucket;
	int: 32;
};

struct inet_protosw {
	struct list_head list;
	short unsigned int type;
	short unsigned int protocol;
	struct proto *prot;
	const struct proto_ops *ops;
	unsigned char flags;
};

typedef struct sock * (*udp_lookup_t)(const struct sk_buff *, __be16, __be16);

typedef struct sk_buff * (*gro_receive_t)(struct list_head *, struct sk_buff *);

typedef struct sk_buff * (*gro_receive_sk_t)(struct sock *, struct list_head *, struct sk_buff *);

struct xfrm_state;

struct arpreq {
	struct sockaddr arp_pa;
	struct sockaddr arp_ha;
	int arp_flags;
	struct sockaddr arp_netmask;
	char arp_dev[16];
};

enum ip_conntrack_status {
	IPS_EXPECTED_BIT = 0,
	IPS_EXPECTED = 1,
	IPS_SEEN_REPLY_BIT = 1,
	IPS_SEEN_REPLY = 2,
	IPS_ASSURED_BIT = 2,
	IPS_ASSURED = 4,
	IPS_CONFIRMED_BIT = 3,
	IPS_CONFIRMED = 8,
	IPS_SRC_NAT_BIT = 4,
	IPS_SRC_NAT = 16,
	IPS_DST_NAT_BIT = 5,
	IPS_DST_NAT = 32,
	IPS_NAT_MASK = 48,
	IPS_SEQ_ADJUST_BIT = 6,
	IPS_SEQ_ADJUST = 64,
	IPS_SRC_NAT_DONE_BIT = 7,
	IPS_SRC_NAT_DONE = 128,
	IPS_DST_NAT_DONE_BIT = 8,
	IPS_DST_NAT_DONE = 256,
	IPS_NAT_DONE_MASK = 384,
	IPS_DYING_BIT = 9,
	IPS_DYING = 512,
	IPS_FIXED_TIMEOUT_BIT = 10,
	IPS_FIXED_TIMEOUT = 1024,
	IPS_TEMPLATE_BIT = 11,
	IPS_TEMPLATE = 2048,
	IPS_UNTRACKED_BIT = 12,
	IPS_UNTRACKED = 4096,
	IPS_NAT_CLASH_BIT = 12,
	IPS_NAT_CLASH = 4096,
	IPS_HELPER_BIT = 13,
	IPS_HELPER = 8192,
	IPS_OFFLOAD_BIT = 14,
	IPS_OFFLOAD = 16384,
	IPS_HW_OFFLOAD_BIT = 15,
	IPS_HW_OFFLOAD = 32768,
	IPS_UNCHANGEABLE_MASK = 56313,
	__IPS_MAX_BIT = 16,
};

enum {
	XFRM_LOOKUP_ICMP = 1,
	XFRM_LOOKUP_QUEUE = 2,
	XFRM_LOOKUP_KEEP_DST_REF = 4,
};

struct icmp_ext_hdr {
	__u8 reserved1: 4;
	__u8 version: 4;
	__u8 reserved2;
	__sum16 checksum;
};

struct icmp_extobj_hdr {
	__be16 length;
	__u8 class_num;
	__u8 class_type;
};

struct icmp_ext_echo_ctype3_hdr {
	__be16 afi;
	__u8 addrlen;
	__u8 reserved;
};

struct icmp_ext_echo_iio {
	struct icmp_extobj_hdr extobj_hdr;
	union {
		char name[16];
		__be32 ifindex;
		struct {
			struct icmp_ext_echo_ctype3_hdr ctype3_hdr;
			union {
				__be32 ipv4_addr;
				struct in6_addr ipv6_addr;
			} ip_addr;
		} addr;
	} ident;
};

struct icmp_bxm {
	struct sk_buff *skb;
	int offset;
	int data_len;
	struct {
		struct icmphdr icmph;
		__be32 times[3];
	} data;
	int head_len;
	struct ip_options_data replyopts;
};

struct icmp_control {
	enum skb_drop_reason (*handler)(struct sk_buff *);
	short int error;
};

struct ifaddrmsg {
	__u8 ifa_family;
	__u8 ifa_prefixlen;
	__u8 ifa_flags;
	__u8 ifa_scope;
	__u32 ifa_index;
};

enum {
	IFA_UNSPEC = 0,
	IFA_ADDRESS = 1,
	IFA_LOCAL = 2,
	IFA_LABEL = 3,
	IFA_BROADCAST = 4,
	IFA_ANYCAST = 5,
	IFA_CACHEINFO = 6,
	IFA_MULTICAST = 7,
	IFA_FLAGS = 8,
	IFA_RT_PRIORITY = 9,
	IFA_TARGET_NETNSID = 10,
	IFA_PROTO = 11,
	__IFA_MAX = 12,
};

struct ifa_cacheinfo {
	__u32 ifa_prefered;
	__u32 ifa_valid;
	__u32 cstamp;
	__u32 tstamp;
};

enum {
	IFLA_INET_UNSPEC = 0,
	IFLA_INET_CONF = 1,
	__IFLA_INET_MAX = 2,
};

struct in_validator_info {
	__be32 ivi_addr;
	struct in_device *ivi_dev;
	struct netlink_ext_ack *extack;
};

struct netconfmsg {
	__u8 ncm_family;
};

enum {
	NETCONFA_UNSPEC = 0,
	NETCONFA_IFINDEX = 1,
	NETCONFA_FORWARDING = 2,
	NETCONFA_RP_FILTER = 3,
	NETCONFA_MC_FORWARDING = 4,
	NETCONFA_PROXY_NEIGH = 5,
	NETCONFA_IGNORE_ROUTES_WITH_LINKDOWN = 6,
	NETCONFA_INPUT = 7,
	NETCONFA_BC_FORWARDING = 8,
	__NETCONFA_MAX = 9,
};

struct inet_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
};

struct devinet_sysctl_table {
	struct ctl_table_header *sysctl_header;
	struct ctl_table devinet_vars[34];
};

struct rtentry {
	long unsigned int rt_pad1;
	struct sockaddr rt_dst;
	struct sockaddr rt_gateway;
	struct sockaddr rt_genmask;
	short unsigned int rt_flags;
	short int rt_pad2;
	long unsigned int rt_pad3;
	void *rt_pad4;
	short int rt_metric;
	char *rt_dev;
	long unsigned int rt_mtu;
	long unsigned int rt_window;
	short unsigned int rt_irtt;
};

struct pingv6_ops {
	int (*ipv6_recv_error)(struct sock *, struct msghdr *, int, int *);
	void (*ip6_datagram_recv_common_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	void (*ip6_datagram_recv_specific_ctl)(struct sock *, struct msghdr *, struct sk_buff *);
	int (*icmpv6_err_convert)(u8, u8, int *);
	void (*ipv6_icmp_error)(struct sock *, struct sk_buff *, int, __be16, u32, u8 *);
	int (*ipv6_chk_addr)(struct net *, const struct in6_addr *, const struct net_device *, int);
};

struct igmphdr {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
};

struct igmpv3_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	__be32 grec_mca;
	__be32 grec_src[0];
};

struct igmpv3_report {
	__u8 type;
	__u8 resv1;
	__sum16 csum;
	__be16 resv2;
	__be16 ngrec;
	struct igmpv3_grec grec[0];
};

struct igmpv3_query {
	__u8 type;
	__u8 code;
	__sum16 csum;
	__be32 group;
	__u8 qrv: 3;
	__u8 suppress: 1;
	__u8 resv: 4;
	__u8 qqic;
	__be16 nsrcs;
	__be32 srcs[0];
};

struct igmp_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *in_dev;
};

struct igmp_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct in_device *idev;
	struct ip_mc_list *im;
};

struct rtnexthop {
	short unsigned int rtnh_len;
	unsigned char rtnh_flags;
	unsigned char rtnh_hops;
	int rtnh_ifindex;
};

struct fib_config {
	u8 fc_dst_len;
	dscp_t fc_dscp;
	u8 fc_protocol;
	u8 fc_scope;
	u8 fc_type;
	u8 fc_gw_family;
	u32 fc_table;
	__be32 fc_dst;
	union {
		__be32 fc_gw4;
		struct in6_addr fc_gw6;
	};
	int fc_oif;
	u32 fc_flags;
	u32 fc_priority;
	__be32 fc_prefsrc;
	u32 fc_nh_id;
	struct nlattr *fc_mx;
	struct rtnexthop *fc_mp;
	int fc_mx_len;
	int fc_mp_len;
	u32 fc_flow;
	u32 fc_nlflags;
	struct nl_info fc_nlinfo;
	struct nlattr *fc_encap;
	u16 fc_encap_type;
};

struct fib_result_nl {
	__be32 fl_addr;
	u32 fl_mark;
	unsigned char fl_tos;
	unsigned char fl_scope;
	unsigned char tb_id_in;
	unsigned char tb_id;
	unsigned char prefixlen;
	unsigned char nh_sel;
	unsigned char type;
	unsigned char scope;
	int err;
};

struct fib_dump_filter {
	u32 table_id;
	bool filter_set;
	bool dump_routes;
	bool dump_exceptions;
	unsigned char protocol;
	unsigned char rt_type;
	unsigned int flags;
	struct net_device *dev;
};

struct fib_nh_notifier_info {
	struct fib_notifier_info info;
	struct fib_nh *fib_nh;
};

struct fib_entry_notifier_info {
	struct fib_notifier_info info;
	u32 dst;
	int dst_len;
	struct fib_info *fi;
	dscp_t dscp;
	u8 type;
	u32 tb_id;
};

typedef unsigned int t_key;

struct key_vector {
	t_key key;
	unsigned char pos;
	unsigned char bits;
	unsigned char slen;
	union {
		struct hlist_head leaf;
		struct {
			struct {			} __empty_tnode;
			struct key_vector *tnode[0];
		};
	};
};

struct tnode {
	struct callback_head rcu;
	t_key empty_children;
	t_key full_children;
	struct key_vector *parent;
	struct key_vector kv[1];
};

struct trie_stat {
	unsigned int totdepth;
	unsigned int maxdepth;
	unsigned int tnodes;
	unsigned int leaves;
	unsigned int nullpointers;
	unsigned int prefixes;
	unsigned int nodesizes[32];
};

struct trie {
	struct key_vector kv[1];
};

struct fib_trie_iter {
	struct seq_net_private p;
	struct fib_table *tb;
	struct key_vector *tnode;
	unsigned int index;
	unsigned int depth;
};

struct fib_route_iter {
	struct seq_net_private p;
	struct fib_table *main_tb;
	struct key_vector *tnode;
	int: 32;
	loff_t pos;
	t_key key;
	int: 32;
};

struct ipfrag_skb_cb {
	union {
		struct inet_skb_parm h4;
		struct inet6_skb_parm h6;
	};
	struct sk_buff *next_frag;
	int frag_run_len;
};

struct icmpv6_echo {
	__be16 identifier;
	__be16 sequence;
};

struct icmpv6_nd_advt {
	__u32 reserved: 5;
	__u32 override: 1;
	__u32 solicited: 1;
	__u32 router: 1;
	__u32 reserved2: 24;
};

struct icmpv6_nd_ra {
	__u8 hop_limit;
	__u8 reserved: 3;
	__u8 router_pref: 2;
	__u8 home_agent: 1;
	__u8 other: 1;
	__u8 managed: 1;
	__be16 rt_lifetime;
};

struct icmp6hdr {
	__u8 icmp6_type;
	__u8 icmp6_code;
	__sum16 icmp6_cksum;
	union {
		__be32 un_data32[1];
		__be16 un_data16[2];
		__u8 un_data8[4];
		struct icmpv6_echo u_echo;
		struct icmpv6_nd_advt u_nd_advt;
		struct icmpv6_nd_ra u_nd_ra;
	} icmp6_dataun;
};

struct ping_iter_state {
	struct seq_net_private p;
	int bucket;
	sa_family_t family;
};

struct pingfakehdr {
	struct icmphdr icmph;
	struct msghdr *msg;
	sa_family_t family;
	__wsum wcheck;
};

struct ping_table {
	struct hlist_nulls_head hash[64];
	spinlock_t lock;
};

enum lwtunnel_ip_t {
	LWTUNNEL_IP_UNSPEC = 0,
	LWTUNNEL_IP_ID = 1,
	LWTUNNEL_IP_DST = 2,
	LWTUNNEL_IP_SRC = 3,
	LWTUNNEL_IP_TTL = 4,
	LWTUNNEL_IP_TOS = 5,
	LWTUNNEL_IP_FLAGS = 6,
	LWTUNNEL_IP_PAD = 7,
	LWTUNNEL_IP_OPTS = 8,
	__LWTUNNEL_IP_MAX = 9,
};

enum lwtunnel_ip6_t {
	LWTUNNEL_IP6_UNSPEC = 0,
	LWTUNNEL_IP6_ID = 1,
	LWTUNNEL_IP6_DST = 2,
	LWTUNNEL_IP6_SRC = 3,
	LWTUNNEL_IP6_HOPLIMIT = 4,
	LWTUNNEL_IP6_TC = 5,
	LWTUNNEL_IP6_FLAGS = 6,
	LWTUNNEL_IP6_PAD = 7,
	LWTUNNEL_IP6_OPTS = 8,
	__LWTUNNEL_IP6_MAX = 9,
};

enum {
	LWTUNNEL_IP_OPTS_UNSPEC = 0,
	LWTUNNEL_IP_OPTS_GENEVE = 1,
	LWTUNNEL_IP_OPTS_VXLAN = 2,
	LWTUNNEL_IP_OPTS_ERSPAN = 3,
	__LWTUNNEL_IP_OPTS_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_GENEVE_UNSPEC = 0,
	LWTUNNEL_IP_OPT_GENEVE_CLASS = 1,
	LWTUNNEL_IP_OPT_GENEVE_TYPE = 2,
	LWTUNNEL_IP_OPT_GENEVE_DATA = 3,
	__LWTUNNEL_IP_OPT_GENEVE_MAX = 4,
};

enum {
	LWTUNNEL_IP_OPT_VXLAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_VXLAN_GBP = 1,
	__LWTUNNEL_IP_OPT_VXLAN_MAX = 2,
};

enum {
	LWTUNNEL_IP_OPT_ERSPAN_UNSPEC = 0,
	LWTUNNEL_IP_OPT_ERSPAN_VER = 1,
	LWTUNNEL_IP_OPT_ERSPAN_INDEX = 2,
	LWTUNNEL_IP_OPT_ERSPAN_DIR = 3,
	LWTUNNEL_IP_OPT_ERSPAN_HWID = 4,
	__LWTUNNEL_IP_OPT_ERSPAN_MAX = 5,
};

struct lwtunnel_encap_ops {
	int (*build_state)(struct net *, struct nlattr *, unsigned int, const void *, struct lwtunnel_state **, struct netlink_ext_ack *);
	void (*destroy_state)(struct lwtunnel_state *);
	int (*output)(struct net *, struct sock *, struct sk_buff *);
	int (*input)(struct sk_buff *);
	int (*fill_encap)(struct sk_buff *, struct lwtunnel_state *);
	int (*get_encap_size)(struct lwtunnel_state *);
	int (*cmp_encap)(struct lwtunnel_state *, struct lwtunnel_state *);
	int (*xmit)(struct sk_buff *);
	struct module *owner;
};

enum {
	IFLA_IPTUN_UNSPEC = 0,
	IFLA_IPTUN_LINK = 1,
	IFLA_IPTUN_LOCAL = 2,
	IFLA_IPTUN_REMOTE = 3,
	IFLA_IPTUN_TTL = 4,
	IFLA_IPTUN_TOS = 5,
	IFLA_IPTUN_ENCAP_LIMIT = 6,
	IFLA_IPTUN_FLOWINFO = 7,
	IFLA_IPTUN_FLAGS = 8,
	IFLA_IPTUN_PROTO = 9,
	IFLA_IPTUN_PMTUDISC = 10,
	IFLA_IPTUN_6RD_PREFIX = 11,
	IFLA_IPTUN_6RD_RELAY_PREFIX = 12,
	IFLA_IPTUN_6RD_PREFIXLEN = 13,
	IFLA_IPTUN_6RD_RELAY_PREFIXLEN = 14,
	IFLA_IPTUN_ENCAP_TYPE = 15,
	IFLA_IPTUN_ENCAP_FLAGS = 16,
	IFLA_IPTUN_ENCAP_SPORT = 17,
	IFLA_IPTUN_ENCAP_DPORT = 18,
	IFLA_IPTUN_COLLECT_METADATA = 19,
	IFLA_IPTUN_FWMARK = 20,
	__IFLA_IPTUN_MAX = 21,
};

struct ip6_tnl_encap_ops {
	size_t (*encap_hlen)(struct ip_tunnel_encap *);
	int (*build_header)(struct sk_buff *, struct ip_tunnel_encap *, u8 *, struct flowi6 *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
};

struct geneve_opt {
	__be16 opt_class;
	u8 type;
	u8 length: 5;
	u8 r3: 1;
	u8 r2: 1;
	u8 r1: 1;
	u8 opt_data[0];
};

struct vxlan_metadata {
	u32 gbp;
};

struct erspan_md2 {
	__be32 timestamp;
	__be16 sgt;
	__u8 hwid_upper: 2;
	__u8 ft: 5;
	__u8 p: 1;
	__u8 o: 1;
	__u8 gra: 2;
	__u8 dir: 1;
	__u8 hwid: 4;
};

struct erspan_metadata {
	int version;
	union {
		__be32 index;
		struct erspan_md2 md2;
	} u;
};

struct nhmsg {
	unsigned char nh_family;
	unsigned char nh_scope;
	unsigned char nh_protocol;
	unsigned char resvd;
	unsigned int nh_flags;
};

struct nexthop_grp {
	__u32 id;
	__u8 weight;
	__u8 resvd1;
	__u16 resvd2;
};

enum {
	NEXTHOP_GRP_TYPE_MPATH = 0,
	NEXTHOP_GRP_TYPE_RES = 1,
	__NEXTHOP_GRP_TYPE_MAX = 2,
};

enum {
	NHA_UNSPEC = 0,
	NHA_ID = 1,
	NHA_GROUP = 2,
	NHA_GROUP_TYPE = 3,
	NHA_BLACKHOLE = 4,
	NHA_OIF = 5,
	NHA_GATEWAY = 6,
	NHA_ENCAP_TYPE = 7,
	NHA_ENCAP = 8,
	NHA_GROUPS = 9,
	NHA_MASTER = 10,
	NHA_FDB = 11,
	NHA_RES_GROUP = 12,
	NHA_RES_BUCKET = 13,
	__NHA_MAX = 14,
};

enum {
	NHA_RES_GROUP_UNSPEC = 0,
	NHA_RES_GROUP_PAD = 0,
	NHA_RES_GROUP_BUCKETS = 1,
	NHA_RES_GROUP_IDLE_TIMER = 2,
	NHA_RES_GROUP_UNBALANCED_TIMER = 3,
	NHA_RES_GROUP_UNBALANCED_TIME = 4,
	__NHA_RES_GROUP_MAX = 5,
};

enum {
	NHA_RES_BUCKET_UNSPEC = 0,
	NHA_RES_BUCKET_PAD = 0,
	NHA_RES_BUCKET_INDEX = 1,
	NHA_RES_BUCKET_IDLE_TIME = 2,
	NHA_RES_BUCKET_NH_ID = 3,
	__NHA_RES_BUCKET_MAX = 4,
};

struct nh_config {
	u32 nh_id;
	u8 nh_family;
	u8 nh_protocol;
	u8 nh_blackhole;
	u8 nh_fdb;
	u32 nh_flags;
	int nh_ifindex;
	struct net_device *dev;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	} gw;
	struct nlattr *nh_grp;
	u16 nh_grp_type;
	u16 nh_grp_res_num_buckets;
	long unsigned int nh_grp_res_idle_timer;
	long unsigned int nh_grp_res_unbalanced_timer;
	bool nh_grp_res_has_num_buckets;
	bool nh_grp_res_has_idle_timer;
	bool nh_grp_res_has_unbalanced_timer;
	struct nlattr *nh_encap;
	u16 nh_encap_type;
	u32 nlflags;
	struct nl_info nlinfo;
};

enum nexthop_event_type {
	NEXTHOP_EVENT_DEL = 0,
	NEXTHOP_EVENT_REPLACE = 1,
	NEXTHOP_EVENT_RES_TABLE_PRE_REPLACE = 2,
	NEXTHOP_EVENT_BUCKET_REPLACE = 3,
};

enum nh_notifier_info_type {
	NH_NOTIFIER_INFO_TYPE_SINGLE = 0,
	NH_NOTIFIER_INFO_TYPE_GRP = 1,
	NH_NOTIFIER_INFO_TYPE_RES_TABLE = 2,
	NH_NOTIFIER_INFO_TYPE_RES_BUCKET = 3,
};

struct nh_notifier_single_info {
	struct net_device *dev;
	u8 gw_family;
	union {
		__be32 ipv4;
		struct in6_addr ipv6;
	};
	u8 is_reject: 1;
	u8 is_fdb: 1;
	u8 has_encap: 1;
};

struct nh_notifier_grp_entry_info {
	u8 weight;
	u32 id;
	struct nh_notifier_single_info nh;
};

struct nh_notifier_grp_info {
	u16 num_nh;
	bool is_fdb;
	struct nh_notifier_grp_entry_info nh_entries[0];
};

struct nh_notifier_res_bucket_info {
	u16 bucket_index;
	unsigned int idle_timer_ms;
	bool force;
	struct nh_notifier_single_info old_nh;
	struct nh_notifier_single_info new_nh;
};

struct nh_notifier_res_table_info {
	u16 num_nh_buckets;
	struct nh_notifier_single_info nhs[0];
};

struct nh_notifier_info {
	struct net *net;
	struct netlink_ext_ack *extack;
	u32 id;
	enum nh_notifier_info_type type;
	union {
		struct nh_notifier_single_info *nh;
		struct nh_notifier_grp_info *nh_grp;
		struct nh_notifier_res_table_info *nh_res_table;
		struct nh_notifier_res_bucket_info *nh_res_bucket;
	};
};

struct nh_dump_filter {
	u32 nh_id;
	int dev_idx;
	int master_idx;
	bool group_filter;
	bool fdb_filter;
	u32 res_bucket_nh_id;
};

struct rtm_dump_nh_ctx {
	u32 idx;
};

struct rtm_dump_res_bucket_ctx {
	struct rtm_dump_nh_ctx nh;
	u16 bucket_index;
	u32 done_nh_idx;
};

struct rtm_dump_nexthop_bucket_data {
	struct rtm_dump_res_bucket_ctx *ctx;
	struct nh_dump_filter filter;
};

struct bpfilter_umh_ops {
	struct umd_info info;
	struct mutex lock;
	int (*sockopt)(struct sock *, int, sockptr_t, unsigned int, bool);
	int (*start)();
};

enum tunnel_encap_types {
	TUNNEL_ENCAP_NONE = 0,
	TUNNEL_ENCAP_FOU = 1,
	TUNNEL_ENCAP_GUE = 2,
	TUNNEL_ENCAP_MPLS = 3,
};

struct ip_tunnel_prl_entry {
	struct ip_tunnel_prl_entry *next;
	__be32 addr;
	u16 flags;
	struct callback_head callback_head;
};

struct ip_tunnel {
	struct ip_tunnel *next;
	struct hlist_node hash_node;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	struct net *net;
	long unsigned int err_time;
	int err_count;
	u32 i_seqno;
	atomic_t o_seqno;
	int tun_hlen;
	u32 index;
	u8 erspan_ver;
	u8 dir;
	u16 hwid;
	struct dst_cache dst_cache;
	struct ip_tunnel_parm parms;
	int mlink;
	int encap_hlen;
	int hlen;
	struct ip_tunnel_encap encap;
	struct ip_tunnel_prl_entry *prl;
	unsigned int prl_count;
	unsigned int ip_tnl_net_id;
	struct gro_cells gro_cells;
	__u32 fwmark;
	bool collect_md;
	bool ignore_df;
};

struct tnl_ptk_info {
	__be16 flags;
	__be16 proto;
	__be32 key;
	__be32 seq;
	int hdr_len;
};

struct ip_tunnel_net {
	struct net_device *fb_tunnel_dev;
	struct rtnl_link_ops *rtnl_link_ops;
	struct hlist_head tunnels[128];
	struct ip_tunnel *collect_md_tun;
	int type;
};

struct snmp_mib {
	const char *name;
	int entry;
};

struct xfrm_tunnel {
	int (*handler)(struct sk_buff *);
	int (*cb_handler)(struct sk_buff *, int);
	int (*err_handler)(struct sk_buff *, u32);
	struct xfrm_tunnel *next;
	int priority;
};

struct ic_device {
	struct ic_device *next;
	struct net_device *dev;
	short unsigned int flags;
	short int able;
	__be32 xid;
};

struct bootp_pkt {
	struct iphdr iph;
	struct udphdr udph;
	u8 op;
	u8 htype;
	u8 hlen;
	u8 hops;
	__be32 xid;
	__be16 secs;
	__be16 flags;
	__be32 client_ip;
	__be32 your_ip;
	__be32 server_ip;
	__be32 relay_ip;
	u8 hw_addr[16];
	u8 serv_name[64];
	u8 boot_file[128];
	u8 exten[312];
};

struct inet_diag_sockid {
	__be16 idiag_sport;
	__be16 idiag_dport;
	__be32 idiag_src[4];
	__be32 idiag_dst[4];
	__u32 idiag_if;
	__u32 idiag_cookie[2];
};

struct inet_diag_req {
	__u8 idiag_family;
	__u8 idiag_src_len;
	__u8 idiag_dst_len;
	__u8 idiag_ext;
	struct inet_diag_sockid id;
	__u32 idiag_states;
	__u32 idiag_dbs;
};

struct inet_diag_req_v2 {
	__u8 sdiag_family;
	__u8 sdiag_protocol;
	__u8 idiag_ext;
	__u8 pad;
	__u32 idiag_states;
	struct inet_diag_sockid id;
};

struct inet_diag_bc_op {
	unsigned char code;
	unsigned char yes;
	short unsigned int no;
};

enum {
	INET_DIAG_BC_NOP = 0,
	INET_DIAG_BC_JMP = 1,
	INET_DIAG_BC_S_GE = 2,
	INET_DIAG_BC_S_LE = 3,
	INET_DIAG_BC_D_GE = 4,
	INET_DIAG_BC_D_LE = 5,
	INET_DIAG_BC_AUTO = 6,
	INET_DIAG_BC_S_COND = 7,
	INET_DIAG_BC_D_COND = 8,
	INET_DIAG_BC_DEV_COND = 9,
	INET_DIAG_BC_MARK_COND = 10,
	INET_DIAG_BC_S_EQ = 11,
	INET_DIAG_BC_D_EQ = 12,
	INET_DIAG_BC_CGROUP_COND = 13,
};

struct inet_diag_hostcond {
	__u8 family;
	__u8 prefix_len;
	int port;
	__be32 addr[0];
};

struct inet_diag_markcond {
	__u32 mark;
	__u32 mask;
};

struct inet_diag_msg {
	__u8 idiag_family;
	__u8 idiag_state;
	__u8 idiag_timer;
	__u8 idiag_retrans;
	struct inet_diag_sockid id;
	__u32 idiag_expires;
	__u32 idiag_rqueue;
	__u32 idiag_wqueue;
	__u32 idiag_uid;
	__u32 idiag_inode;
};

enum {
	INET_DIAG_NONE = 0,
	INET_DIAG_MEMINFO = 1,
	INET_DIAG_INFO = 2,
	INET_DIAG_VEGASINFO = 3,
	INET_DIAG_CONG = 4,
	INET_DIAG_TOS = 5,
	INET_DIAG_TCLASS = 6,
	INET_DIAG_SKMEMINFO = 7,
	INET_DIAG_SHUTDOWN = 8,
	INET_DIAG_DCTCPINFO = 9,
	INET_DIAG_PROTOCOL = 10,
	INET_DIAG_SKV6ONLY = 11,
	INET_DIAG_LOCALS = 12,
	INET_DIAG_PEERS = 13,
	INET_DIAG_PAD = 14,
	INET_DIAG_MARK = 15,
	INET_DIAG_BBRINFO = 16,
	INET_DIAG_CLASS_ID = 17,
	INET_DIAG_MD5SIG = 18,
	INET_DIAG_ULP_INFO = 19,
	INET_DIAG_SK_BPF_STORAGES = 20,
	INET_DIAG_CGROUP_ID = 21,
	INET_DIAG_SOCKOPT = 22,
	__INET_DIAG_MAX = 23,
};

struct inet_diag_meminfo {
	__u32 idiag_rmem;
	__u32 idiag_wmem;
	__u32 idiag_fmem;
	__u32 idiag_tmem;
};

struct inet_diag_sockopt {
	__u8 recverr: 1;
	__u8 is_icsk: 1;
	__u8 freebind: 1;
	__u8 hdrincl: 1;
	__u8 mc_loop: 1;
	__u8 transparent: 1;
	__u8 mc_all: 1;
	__u8 nodefrag: 1;
	__u8 bind_address_no_port: 1;
	__u8 recverr_rfc4884: 1;
	__u8 defer_connect: 1;
	__u8 unused: 5;
};

struct inet_diag_handler {
	void (*dump)(struct sk_buff *, struct netlink_callback *, const struct inet_diag_req_v2 *);
	int (*dump_one)(struct netlink_callback *, const struct inet_diag_req_v2 *);
	void (*idiag_get_info)(struct sock *, struct inet_diag_msg *, void *);
	int (*idiag_get_aux)(struct sock *, bool, struct sk_buff *);
	size_t (*idiag_get_aux_size)(struct sock *, bool);
	int (*destroy)(struct sk_buff *, const struct inet_diag_req_v2 *);
	__u16 idiag_type;
	__u16 idiag_info_size;
};

struct bpf_sk_storage_diag;

struct inet_diag_dump_data {
	struct nlattr *req_nlas[4];
	struct bpf_sk_storage_diag *bpf_stg_diag;
};

struct inet_diag_entry {
	const __be32 *saddr;
	const __be32 *daddr;
	u16 sport;
	u16 dport;
	u16 family;
	u16 userlocks;
	u32 ifindex;
	u32 mark;
	u64 cgroup_id;
};

enum {
	INET_ULP_INFO_UNSPEC = 0,
	INET_ULP_INFO_NAME = 1,
	INET_ULP_INFO_TLS = 2,
	INET_ULP_INFO_MPTCP = 3,
	__INET_ULP_INFO_MAX = 4,
};

struct bictcp {
	u32 cnt;
	u32 last_max_cwnd;
	u32 last_cwnd;
	u32 last_time;
	u32 bic_origin_point;
	u32 bic_K;
	u32 delay_min;
	u32 epoch_start;
	u32 ack_cnt;
	u32 tcp_cwnd;
	u16 unused;
	u8 sample_cnt;
	u8 found;
	u32 round_start;
	u32 end_seq;
	u32 last_ack;
	u32 curr_rtt;
};

struct tx_work {
	struct delayed_work work;
	struct sock *sk;
};

struct tls_rec;

struct tls_sw_context_tx {
	struct crypto_aead *aead_send;
	struct crypto_wait async_wait;
	struct tx_work tx_work;
	struct tls_rec *open_rec;
	struct list_head tx_list;
	atomic_t encrypt_pending;
	spinlock_t encrypt_compl_lock;
	int async_notify;
	u8 async_capable: 1;
	long unsigned int tx_bitmask;
};

enum {
	TCP_BPF_IPV4 = 0,
	TCP_BPF_IPV6 = 1,
	TCP_BPF_NUM_PROTS = 2,
};

enum {
	TCP_BPF_BASE = 0,
	TCP_BPF_TX = 1,
	TCP_BPF_RX = 2,
	TCP_BPF_TXRX = 3,
	TCP_BPF_NUM_CFGS = 4,
};

enum {
	UDP_BPF_IPV4 = 0,
	UDP_BPF_IPV6 = 1,
	UDP_BPF_NUM_PROTS = 2,
};

typedef u64 (*btf_bpf_tcp_send_ack)(struct tcp_sock *, u32);

struct tls12_crypto_info_aes_ccm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aria_gcm_128 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[16];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

struct tls12_crypto_info_aria_gcm_256 {
	struct tls_crypto_info info;
	unsigned char iv[8];
	unsigned char key[32];
	unsigned char salt[4];
	unsigned char rec_seq[8];
};

enum {
	TLS_INFO_UNSPEC = 0,
	TLS_INFO_VERSION = 1,
	TLS_INFO_CIPHER = 2,
	TLS_INFO_TXCONF = 3,
	TLS_INFO_RXCONF = 4,
	TLS_INFO_ZC_RO_TX = 5,
	TLS_INFO_RX_NO_PAD = 6,
	__TLS_INFO_MAX = 7,
};

struct tls_cipher_size_desc {
	unsigned int iv;
	unsigned int key;
	unsigned int salt;
	unsigned int tag;
	unsigned int rec_seq;
};

enum {
	TLS_BASE = 0,
	TLS_SW = 1,
	TLS_HW = 2,
	TLS_HW_RECORD = 3,
	TLS_NUM_CONFIG = 4,
};

enum {
	TLSV4 = 0,
	TLSV6 = 1,
	TLS_NUM_PROTS = 2,
};

struct tls_rec {
	struct list_head list;
	int tx_ready;
	int tx_flags;
	struct sk_msg msg_plaintext;
	struct sk_msg msg_encrypted;
	struct scatterlist sg_aead_in[2];
	struct scatterlist sg_aead_out[2];
	char content_type;
	struct scatterlist sg_content_type;
	char aad_space[13];
	u8 iv_data[16];
	int: 24;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct aead_request aead_req;
	u8 aead_req_ctx[0];
};

struct tls_decrypt_arg {
	union {
		struct {
			bool zc;
			bool async;
			u8 tail;
		};
		struct {
			bool zc;
			bool async;
			u8 tail;
		} inargs;
	};
	struct sk_buff *skb;
};

struct tls_decrypt_ctx {
	u8 iv[16];
	u8 aad[13];
	u8 tail;
	struct scatterlist sg[0];
};

struct trace_event_raw_tls_device_offload_set {
	struct trace_entry ent;
	struct sock *sk;
	int: 32;
	u64 rec_no;
	int dir;
	u32 tcp_seq;
	int ret;
	char __data[0];
	int: 32;
};

struct trace_event_raw_tls_device_decrypted {
	struct trace_entry ent;
	struct sock *sk;
	int: 32;
	u64 rec_no;
	u32 tcp_seq;
	u32 rec_len;
	bool encrypted;
	bool decrypted;
	char __data[0];
	int: 16;
	int: 32;
};

struct trace_event_raw_tls_device_rx_resync_send {
	struct trace_entry ent;
	struct sock *sk;
	int: 32;
	u64 rec_no;
	u32 tcp_seq;
	int sync_type;
	char __data[0];
};

struct trace_event_raw_tls_device_rx_resync_nh_schedule {
	struct trace_entry ent;
	struct sock *sk;
	char __data[0];
};

struct trace_event_raw_tls_device_rx_resync_nh_delay {
	struct trace_entry ent;
	struct sock *sk;
	u32 sock_data;
	u32 rec_len;
	char __data[0];
};

struct trace_event_raw_tls_device_tx_resync_req {
	struct trace_entry ent;
	struct sock *sk;
	u32 tcp_seq;
	u32 exp_tcp_seq;
	char __data[0];
};

struct trace_event_raw_tls_device_tx_resync_send {
	struct trace_entry ent;
	struct sock *sk;
	int: 32;
	u64 rec_no;
	u32 tcp_seq;
	char __data[0];
	int: 32;
};

struct trace_event_data_offsets_tls_device_offload_set {};

struct trace_event_data_offsets_tls_device_decrypted {};

struct trace_event_data_offsets_tls_device_rx_resync_send {};

struct trace_event_data_offsets_tls_device_rx_resync_nh_schedule {};

struct trace_event_data_offsets_tls_device_rx_resync_nh_delay {};

struct trace_event_data_offsets_tls_device_tx_resync_req {};

struct trace_event_data_offsets_tls_device_tx_resync_send {};

typedef void (*btf_trace_tls_device_offload_set)(void *, struct sock *, int, u32, u8 *, int);

typedef void (*btf_trace_tls_device_decrypted)(void *, struct sock *, u32, u8 *, u32, bool, bool);

typedef void (*btf_trace_tls_device_rx_resync_send)(void *, struct sock *, u32, u8 *, int);

typedef void (*btf_trace_tls_device_rx_resync_nh_schedule)(void *, struct sock *);

typedef void (*btf_trace_tls_device_rx_resync_nh_delay)(void *, struct sock *, u32, u32);

typedef void (*btf_trace_tls_device_tx_resync_req)(void *, struct sock *, u32, u32);

typedef void (*btf_trace_tls_device_tx_resync_send)(void *, struct sock *, u32, u8 *);

struct tls_record_info {
	struct list_head list;
	u32 end_seq;
	int len;
	int num_frags;
	skb_frag_t frags[17];
};

struct tls_offload_context_tx {
	struct crypto_aead *aead_send;
	spinlock_t lock;
	struct list_head records_list;
	struct tls_record_info *open_record;
	struct tls_record_info *retransmit_hint;
	u64 hint_record_sn;
	u64 unacked_record_sn;
	struct scatterlist sg_tx_data[17];
	void (*sk_destruct)(struct sock *);
	struct work_struct destruct_work;
	struct tls_context *ctx;
	u8 driver_state[0];
};

enum tls_context_flags {
	TLS_RX_DEV_DEGRADED = 0,
	TLS_TX_SYNC_SCHED = 1,
	TLS_RX_DEV_CLOSED = 2,
};

enum tls_offload_sync_type {
	TLS_OFFLOAD_SYNC_TYPE_DRIVER_REQ = 0,
	TLS_OFFLOAD_SYNC_TYPE_CORE_NEXT_HINT = 1,
	TLS_OFFLOAD_SYNC_TYPE_DRIVER_REQ_ASYNC = 2,
};

struct tls_offload_resync_async {
	atomic64_t req;
	u16 loglen;
	u16 rcd_delta;
	u32 log[13];
};

struct tls_offload_context_rx {
	struct tls_sw_context_rx sw;
	enum tls_offload_sync_type resync_type;
	u8 resync_nh_reset: 1;
	u8 resync_nh_do_now: 1;
	union {
		struct {
			atomic64_t resync_req;
		};
		struct {
			u32 decrypted_failed;
			u32 decrypted_tgt;
		} resync_nh;
		struct {
			struct tls_offload_resync_async *resync_async;
		};
	};
	u8 driver_state[0];
};

union tls_iter_offset {
	struct iov_iter *msg_iter;
	int offset;
};

struct sockaddr_un {
	__kernel_sa_family_t sun_family;
	char sun_path[108];
};

struct unix_address {
	refcount_t refcnt;
	int len;
	struct sockaddr_un name[0];
};

struct scm_stat {
	atomic_t nr_fds;
};

struct unix_sock {
	struct sock sk;
	struct unix_address *addr;
	struct path path;
	struct mutex iolock;
	struct mutex bindlock;
	struct sock *peer;
	struct list_head link;
	atomic_long_t inflight;
	spinlock_t lock;
	long unsigned int gc_flags;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct socket_wq peer_wq;
	wait_queue_entry_t peer_wake;
	struct scm_stat scm_stat;
	struct sk_buff *oob_skb;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct unix_stream_read_state {
	int (*recv_actor)(struct sk_buff *, int, int, struct unix_stream_read_state *);
	struct socket *socket;
	struct msghdr *msg;
	struct pipe_inode_info *pipe;
	size_t size;
	int flags;
	unsigned int splice_flags;
};

struct bpf_unix_iter_state {
	struct seq_net_private p;
	unsigned int cur_sk;
	unsigned int end_sk;
	unsigned int max_sk;
	struct sock **batch;
	bool st_bucket_done;
};

struct bpf_iter__unix {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct unix_sock *unix_sk;
	};
	uid_t uid;
	int: 32;
};

struct ioam6_pernet_data {
	struct mutex lock;
	struct rhashtable namespaces;
	struct rhashtable schemas;
};

struct ipv6_params {
	__s32 disable_ipv6;
	__s32 autoconf;
};

enum flowlabel_reflect {
	FLOWLABEL_REFLECT_ESTABLISHED = 1,
	FLOWLABEL_REFLECT_TCP_RESET = 2,
	FLOWLABEL_REFLECT_ICMPV6_ECHO_REPLIES = 4,
};

struct in6_rtmsg {
	struct in6_addr rtmsg_dst;
	struct in6_addr rtmsg_src;
	struct in6_addr rtmsg_gateway;
	__u32 rtmsg_type;
	__u16 rtmsg_dst_len;
	__u16 rtmsg_src_len;
	__u32 rtmsg_metric;
	long unsigned int rtmsg_info;
	__u32 rtmsg_flags;
	int rtmsg_ifindex;
};

struct ac6_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct hop_jumbo_hdr {
	u8 nexthdr;
	u8 hdrlen;
	u8 tlv_type;
	u8 tlv_len;
	__be32 jumbo_payload_len;
};

struct ip6_fraglist_iter {
	struct ipv6hdr *tmp_hdr;
	struct sk_buff *frag;
	int offset;
	unsigned int hlen;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_frag_state {
	u8 *prevhdr;
	unsigned int hlen;
	unsigned int mtu;
	unsigned int left;
	int offset;
	int ptr;
	int hroom;
	int troom;
	__be32 frag_id;
	u8 nexthdr;
};

struct ip6_ra_chain {
	struct ip6_ra_chain *next;
	struct sock *sk;
	int sel;
	void (*destructor)(struct sock *);
};

struct ipcm6_cookie {
	struct sockcm_cookie sockc;
	__s16 hlimit;
	__s16 tclass;
	__u16 gso_size;
	__s8 dontfrag;
	struct ipv6_txoptions *opt;
	int: 32;
};

struct inet6_protocol {
	int (*handler)(struct sk_buff *);
	int (*err_handler)(struct sk_buff *, struct inet6_skb_parm *, u8, u8, int, __be32);
	unsigned int flags;
};

enum {
	IFLA_INET6_UNSPEC = 0,
	IFLA_INET6_FLAGS = 1,
	IFLA_INET6_CONF = 2,
	IFLA_INET6_STATS = 3,
	IFLA_INET6_MCAST = 4,
	IFLA_INET6_CACHEINFO = 5,
	IFLA_INET6_ICMP6STATS = 6,
	IFLA_INET6_TOKEN = 7,
	IFLA_INET6_ADDR_GEN_MODE = 8,
	IFLA_INET6_RA_MTU = 9,
	__IFLA_INET6_MAX = 10,
};

enum in6_addr_gen_mode {
	IN6_ADDR_GEN_MODE_EUI64 = 0,
	IN6_ADDR_GEN_MODE_NONE = 1,
	IN6_ADDR_GEN_MODE_STABLE_PRIVACY = 2,
	IN6_ADDR_GEN_MODE_RANDOM = 3,
};

struct ifla_cacheinfo {
	__u32 max_reasm_len;
	__u32 tstamp;
	__u32 reachable_time;
	__u32 retrans_time;
};

struct prefixmsg {
	unsigned char prefix_family;
	unsigned char prefix_pad1;
	short unsigned int prefix_pad2;
	int prefix_ifindex;
	unsigned char prefix_type;
	unsigned char prefix_len;
	unsigned char prefix_flags;
	unsigned char prefix_pad3;
};

enum {
	PREFIX_UNSPEC = 0,
	PREFIX_ADDRESS = 1,
	PREFIX_CACHEINFO = 2,
	__PREFIX_MAX = 3,
};

struct prefix_cacheinfo {
	__u32 preferred_time;
	__u32 valid_time;
};

struct in6_ifreq {
	struct in6_addr ifr6_addr;
	__u32 ifr6_prefixlen;
	int ifr6_ifindex;
};

enum {
	DEVCONF_FORWARDING = 0,
	DEVCONF_HOPLIMIT = 1,
	DEVCONF_MTU6 = 2,
	DEVCONF_ACCEPT_RA = 3,
	DEVCONF_ACCEPT_REDIRECTS = 4,
	DEVCONF_AUTOCONF = 5,
	DEVCONF_DAD_TRANSMITS = 6,
	DEVCONF_RTR_SOLICITS = 7,
	DEVCONF_RTR_SOLICIT_INTERVAL = 8,
	DEVCONF_RTR_SOLICIT_DELAY = 9,
	DEVCONF_USE_TEMPADDR = 10,
	DEVCONF_TEMP_VALID_LFT = 11,
	DEVCONF_TEMP_PREFERED_LFT = 12,
	DEVCONF_REGEN_MAX_RETRY = 13,
	DEVCONF_MAX_DESYNC_FACTOR = 14,
	DEVCONF_MAX_ADDRESSES = 15,
	DEVCONF_FORCE_MLD_VERSION = 16,
	DEVCONF_ACCEPT_RA_DEFRTR = 17,
	DEVCONF_ACCEPT_RA_PINFO = 18,
	DEVCONF_ACCEPT_RA_RTR_PREF = 19,
	DEVCONF_RTR_PROBE_INTERVAL = 20,
	DEVCONF_ACCEPT_RA_RT_INFO_MAX_PLEN = 21,
	DEVCONF_PROXY_NDP = 22,
	DEVCONF_OPTIMISTIC_DAD = 23,
	DEVCONF_ACCEPT_SOURCE_ROUTE = 24,
	DEVCONF_MC_FORWARDING = 25,
	DEVCONF_DISABLE_IPV6 = 26,
	DEVCONF_ACCEPT_DAD = 27,
	DEVCONF_FORCE_TLLAO = 28,
	DEVCONF_NDISC_NOTIFY = 29,
	DEVCONF_MLDV1_UNSOLICITED_REPORT_INTERVAL = 30,
	DEVCONF_MLDV2_UNSOLICITED_REPORT_INTERVAL = 31,
	DEVCONF_SUPPRESS_FRAG_NDISC = 32,
	DEVCONF_ACCEPT_RA_FROM_LOCAL = 33,
	DEVCONF_USE_OPTIMISTIC = 34,
	DEVCONF_ACCEPT_RA_MTU = 35,
	DEVCONF_STABLE_SECRET = 36,
	DEVCONF_USE_OIF_ADDRS_ONLY = 37,
	DEVCONF_ACCEPT_RA_MIN_HOP_LIMIT = 38,
	DEVCONF_IGNORE_ROUTES_WITH_LINKDOWN = 39,
	DEVCONF_DROP_UNICAST_IN_L2_MULTICAST = 40,
	DEVCONF_DROP_UNSOLICITED_NA = 41,
	DEVCONF_KEEP_ADDR_ON_DOWN = 42,
	DEVCONF_RTR_SOLICIT_MAX_INTERVAL = 43,
	DEVCONF_SEG6_ENABLED = 44,
	DEVCONF_SEG6_REQUIRE_HMAC = 45,
	DEVCONF_ENHANCED_DAD = 46,
	DEVCONF_ADDR_GEN_MODE = 47,
	DEVCONF_DISABLE_POLICY = 48,
	DEVCONF_ACCEPT_RA_RT_INFO_MIN_PLEN = 49,
	DEVCONF_NDISC_TCLASS = 50,
	DEVCONF_RPL_SEG_ENABLED = 51,
	DEVCONF_RA_DEFRTR_METRIC = 52,
	DEVCONF_IOAM6_ENABLED = 53,
	DEVCONF_IOAM6_ID = 54,
	DEVCONF_IOAM6_ID_WIDE = 55,
	DEVCONF_NDISC_EVICT_NOCARRIER = 56,
	DEVCONF_ACCEPT_UNTRACKED_NA = 57,
	DEVCONF_MAX = 58,
};

enum {
	INET6_IFADDR_STATE_PREDAD = 0,
	INET6_IFADDR_STATE_DAD = 1,
	INET6_IFADDR_STATE_POSTDAD = 2,
	INET6_IFADDR_STATE_ERRDAD = 3,
	INET6_IFADDR_STATE_DEAD = 4,
};

union fwnet_hwaddr {
	u8 u[16];
	struct {
		__be64 uniq_id;
		u8 max_rec;
		u8 sspd;
		u8 fifo[6];
	} uc;
};

struct in6_validator_info {
	struct in6_addr i6vi_addr;
	struct inet6_dev *i6vi_dev;
	struct netlink_ext_ack *extack;
};

struct ifa6_config {
	const struct in6_addr *pfx;
	unsigned int plen;
	u8 ifa_proto;
	const struct in6_addr *peer_pfx;
	u32 rt_priority;
	u32 ifa_flags;
	u32 preferred_lft;
	u32 valid_lft;
	u16 scope;
};

enum cleanup_prefix_rt_t {
	CLEANUP_PREFIX_RT_NOP = 0,
	CLEANUP_PREFIX_RT_DEL = 1,
	CLEANUP_PREFIX_RT_EXPIRE = 2,
};

enum {
	IPV6_SADDR_RULE_INIT = 0,
	IPV6_SADDR_RULE_LOCAL = 1,
	IPV6_SADDR_RULE_SCOPE = 2,
	IPV6_SADDR_RULE_PREFERRED = 3,
	IPV6_SADDR_RULE_OIF = 4,
	IPV6_SADDR_RULE_LABEL = 5,
	IPV6_SADDR_RULE_PRIVACY = 6,
	IPV6_SADDR_RULE_ORCHID = 7,
	IPV6_SADDR_RULE_PREFIX = 8,
	IPV6_SADDR_RULE_MAX = 9,
};

struct ipv6_saddr_score {
	int rule;
	int addr_type;
	struct inet6_ifaddr *ifa;
	long unsigned int scorebits[1];
	int scopedist;
	int matchlen;
};

struct ipv6_saddr_dst {
	const struct in6_addr *addr;
	int ifindex;
	int scope;
	int label;
	unsigned int prefs;
};

struct if6_iter_state {
	struct seq_net_private p;
	int bucket;
	int offset;
};

enum addr_type_t {
	UNICAST_ADDR = 0,
	MULTICAST_ADDR = 1,
	ANYCAST_ADDR = 2,
};

struct inet6_fill_args {
	u32 portid;
	u32 seq;
	int event;
	unsigned int flags;
	int netnsid;
	int ifindex;
	enum addr_type_t type;
};

enum {
	DAD_PROCESS = 0,
	DAD_BEGIN = 1,
	DAD_ABORT = 2,
};

struct ifaddrlblmsg {
	__u8 ifal_family;
	__u8 __ifal_reserved;
	__u8 ifal_prefixlen;
	__u8 ifal_flags;
	__u32 ifal_index;
	__u32 ifal_seq;
};

enum {
	IFAL_ADDRESS = 1,
	IFAL_LABEL = 2,
	__IFAL_MAX = 3,
};

struct ip6addrlbl_entry {
	struct in6_addr prefix;
	int prefixlen;
	int ifindex;
	int addrtype;
	u32 label;
	struct hlist_node list;
	struct callback_head rcu;
};

struct ip6addrlbl_init_table {
	const struct in6_addr *prefix;
	int prefixlen;
	u32 label;
};

struct fib6_gc_args {
	int timeout;
	int more;
};

struct rt6_exception {
	struct hlist_node hlist;
	struct rt6_info *rt6i;
	long unsigned int stamp;
	struct callback_head rcu;
};

struct rd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	struct in6_addr dest;
	__u8 opt[0];
};

struct rt6_rtnl_dump_arg {
	struct sk_buff *skb;
	struct netlink_callback *cb;
	struct net *net;
	struct fib_dump_filter filter;
};

struct netevent_redirect {
	struct dst_entry *old;
	struct dst_entry *new;
	struct neighbour *neigh;
	const void *daddr;
};

struct trace_event_raw_fib6_table_lookup {
	struct trace_entry ent;
	u32 tb_id;
	int err;
	int oif;
	int iif;
	__u8 tos;
	__u8 scope;
	__u8 flags;
	__u8 src[16];
	__u8 dst[16];
	u16 sport;
	u16 dport;
	u8 proto;
	u8 rt_type;
	char name[16];
	__u8 gw[16];
	char __data[0];
};

struct trace_event_data_offsets_fib6_table_lookup {};

typedef void (*btf_trace_fib6_table_lookup)(void *, const struct net *, const struct fib6_result *, struct fib6_table *, const struct flowi6 *);

enum rt6_nud_state {
	RT6_NUD_FAIL_HARD = 4294967293,
	RT6_NUD_FAIL_PROBE = 4294967294,
	RT6_NUD_FAIL_DO_RR = 4294967295,
	RT6_NUD_SUCCEED = 1,
};

struct fib6_nh_dm_arg {
	struct net *net;
	const struct in6_addr *saddr;
	int oif;
	int flags;
	struct fib6_nh *nh;
};

struct fib6_nh_frl_arg {
	u32 flags;
	int oif;
	int strict;
	int *mpri;
	bool *do_rr;
	struct fib6_nh *nh;
};

struct fib6_nh_excptn_arg {
	struct rt6_info *rt;
	int plen;
};

struct fib6_nh_match_arg {
	const struct net_device *dev;
	const struct in6_addr *gw;
	struct fib6_nh *match;
};

struct fib6_nh_age_excptn_arg {
	struct fib6_gc_args *gc_args;
	long unsigned int now;
};

struct fib6_nh_rd_arg {
	struct fib6_result *res;
	struct flowi6 *fl6;
	const struct in6_addr *gw;
	struct rt6_info **ret;
};

struct ip6rd_flowi {
	struct flowi6 fl6;
	struct in6_addr gateway;
};

struct fib6_nh_del_cached_rt_arg {
	struct fib6_config *cfg;
	struct fib6_info *f6i;
};

struct arg_dev_net_ip {
	struct net_device *dev;
	struct net *net;
	struct in6_addr *addr;
};

struct arg_netdev_event {
	const struct net_device *dev;
	union {
		unsigned char nh_flags;
		long unsigned int event;
	};
};

struct rt6_mtu_change_arg {
	struct net_device *dev;
	unsigned int mtu;
	struct fib6_info *f6i;
};

struct rt6_nh {
	struct fib6_info *fib6_info;
	struct fib6_config r_cfg;
	struct list_head next;
};

struct fib6_nh_exception_dump_walker {
	struct rt6_rtnl_dump_arg *dump;
	struct fib6_info *rt;
	unsigned int flags;
	unsigned int skip;
	unsigned int count;
};

enum fib6_walk_state {
	FWS_L = 0,
	FWS_R = 1,
	FWS_C = 2,
	FWS_U = 3,
};

struct fib6_walker {
	struct list_head lh;
	struct fib6_node *root;
	struct fib6_node *node;
	struct fib6_info *leaf;
	enum fib6_walk_state state;
	unsigned int skip;
	unsigned int count;
	unsigned int skip_in_node;
	int (*func)(struct fib6_walker *);
	void *args;
};

typedef struct rt6_info * (*pol_lookup_t)(struct net *, struct fib6_table *, struct flowi6 *, const struct sk_buff *, int);

struct fib6_entry_notifier_info {
	struct fib_notifier_info info;
	struct fib6_info *rt;
	unsigned int nsiblings;
};

struct ipv6_route_iter {
	struct seq_net_private p;
	struct fib6_walker w;
	loff_t skip;
	struct fib6_table *tbl;
	int sernum;
};

struct bpf_iter__ipv6_route {
	union {
		struct bpf_iter_meta *meta;
	};
	union {
		struct fib6_info *rt;
	};
};

struct fib6_cleaner {
	struct fib6_walker w;
	struct net *net;
	int (*func)(struct fib6_info *, void *);
	int sernum;
	void *arg;
	bool skip_notify;
};

enum {
	FIB6_NO_SERNUM_CHANGE = 0,
};

struct fib6_dump_arg {
	struct net *net;
	struct notifier_block *nb;
	struct netlink_ext_ack *extack;
};

struct fib6_nh_pcpu_arg {
	struct fib6_info *from;
	const struct fib6_table *table;
};

struct lookup_args {
	int offset;
	const struct in6_addr *addr;
};

struct ipv6_mreq {
	struct in6_addr ipv6mr_multiaddr;
	int ipv6mr_ifindex;
};

struct in6_flowlabel_req {
	struct in6_addr flr_dst;
	__be32 flr_label;
	__u8 flr_action;
	__u8 flr_share;
	__u16 flr_flags;
	__u16 flr_expires;
	__u16 flr_linger;
	__u32 __flr_pad;
};

struct ip6_mtuinfo {
	struct sockaddr_in6 ip6m_addr;
	__u32 ip6m_mtu;
};

struct ipv6_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u8 first_segment;
	__u8 flags;
	__u16 tag;
	struct in6_addr segments[0];
};

struct nduseroptmsg {
	unsigned char nduseropt_family;
	unsigned char nduseropt_pad1;
	short unsigned int nduseropt_opts_len;
	int nduseropt_ifindex;
	__u8 nduseropt_icmp_type;
	__u8 nduseropt_icmp_code;
	short unsigned int nduseropt_pad2;
	unsigned int nduseropt_pad3;
};

enum {
	NDUSEROPT_UNSPEC = 0,
	NDUSEROPT_SRCADDR = 1,
	__NDUSEROPT_MAX = 2,
};

struct nd_msg {
	struct icmp6hdr icmph;
	struct in6_addr target;
	__u8 opt[0];
};

struct rs_msg {
	struct icmp6hdr icmph;
	__u8 opt[0];
};

struct ra_msg {
	struct icmp6hdr icmph;
	__be32 reachable_time;
	__be32 retrans_timer;
};

struct icmp6_filter {
	__u32 data[8];
};

struct raw6_sock {
	struct inet_sock inet;
	__u32 checksum;
	__u32 offset;
	struct icmp6_filter filter;
	__u32 ip6mr_table;
	struct ipv6_pinfo inet6;
};

struct raw6_frag_vec {
	struct msghdr *msg;
	int hlen;
	char c[4];
};

typedef void ip6_icmp_send_t(struct sk_buff *, u8, u8, __u32, const struct in6_addr *, const struct inet6_skb_parm *);

struct icmpv6_msg {
	struct sk_buff *skb;
	int offset;
	uint8_t type;
};

struct icmp6_err {
	int err;
	int fatal;
};

struct mld_msg {
	struct icmp6hdr mld_hdr;
	struct in6_addr mld_mca;
};

struct mld2_grec {
	__u8 grec_type;
	__u8 grec_auxwords;
	__be16 grec_nsrcs;
	struct in6_addr grec_mca;
	struct in6_addr grec_src[0];
};

struct mld2_report {
	struct icmp6hdr mld2r_hdr;
	struct mld2_grec mld2r_grec[0];
};

struct mld2_query {
	struct icmp6hdr mld2q_hdr;
	struct in6_addr mld2q_mca;
	__u8 mld2q_qrv: 3;
	__u8 mld2q_suppress: 1;
	__u8 mld2q_resv2: 4;
	__u8 mld2q_qqic;
	__be16 mld2q_nsrcs;
	struct in6_addr mld2q_srcs[0];
};

struct igmp6_mc_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
};

struct igmp6_mcf_iter_state {
	struct seq_net_private p;
	struct net_device *dev;
	struct inet6_dev *idev;
	struct ifmcaddr6 *im;
};

enum ip6_defrag_users {
	IP6_DEFRAG_LOCAL_DELIVER = 0,
	IP6_DEFRAG_CONNTRACK_IN = 1,
	__IP6_DEFRAG_CONNTRACK_IN = 65536,
	IP6_DEFRAG_CONNTRACK_OUT = 65537,
	__IP6_DEFRAG_CONNTRACK_OUT = 131072,
	IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 131073,
	__IP6_DEFRAG_CONNTRACK_BRIDGE_IN = 196608,
};

struct frag_queue {
	struct inet_frag_queue q;
	int iif;
	__u16 nhoffset;
	u8 ecn;
};

struct rt0_hdr {
	struct ipv6_rt_hdr rt_hdr;
	__u32 reserved;
	struct in6_addr addr[0];
};

struct ipv6_rpl_sr_hdr {
	__u8 nexthdr;
	__u8 hdrlen;
	__u8 type;
	__u8 segments_left;
	__u32 cmpre: 4;
	__u32 cmpri: 4;
	__u32 reserved: 4;
	__u32 pad: 4;
	__u32 reserved1: 16;
	union {
		struct in6_addr addr[0];
		__u8 data[0];
	} segments;
};

struct ioam6_hdr {
	__u8 opt_type;
	__u8 opt_len;
	char: 8;
	__u8 type;
};

struct ioam6_trace_hdr {
	__be16 namespace_id;
	char: 2;
	__u8 overflow: 1;
	__u8 nodelen: 5;
	__u8 remlen: 7;
	union {
		__be32 type_be32;
		struct {
			__u32 bit7: 1;
			__u32 bit6: 1;
			__u32 bit5: 1;
			__u32 bit4: 1;
			__u32 bit3: 1;
			__u32 bit2: 1;
			__u32 bit1: 1;
			__u32 bit0: 1;
			__u32 bit15: 1;
			__u32 bit14: 1;
			__u32 bit13: 1;
			__u32 bit12: 1;
			__u32 bit11: 1;
			__u32 bit10: 1;
			__u32 bit9: 1;
			__u32 bit8: 1;
			__u32 bit23: 1;
			__u32 bit22: 1;
			__u32 bit21: 1;
			__u32 bit20: 1;
			__u32 bit19: 1;
			__u32 bit18: 1;
			__u32 bit17: 1;
			__u32 bit16: 1;
		} type;
	};
	__u8 data[0];
};

struct ioam6_schema;

struct ioam6_namespace {
	struct rhash_head head;
	struct callback_head rcu;
	struct ioam6_schema *schema;
	__be16 id;
	__be32 data;
	__be64 data_wide;
};

struct ioam6_schema {
	struct rhash_head head;
	struct callback_head rcu;
	struct ioam6_namespace *ns;
	u32 id;
	int len;
	__be32 hdr;
	u8 data[0];
};

struct ip6fl_iter_state {
	struct seq_net_private p;
	struct pid_namespace *pid_ns;
	int bucket;
};

struct sr6_tlv {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

enum {
	SEG6_ATTR_UNSPEC = 0,
	SEG6_ATTR_DST = 1,
	SEG6_ATTR_DSTLEN = 2,
	SEG6_ATTR_HMACKEYID = 3,
	SEG6_ATTR_SECRET = 4,
	SEG6_ATTR_SECRETLEN = 5,
	SEG6_ATTR_ALGID = 6,
	SEG6_ATTR_HMACINFO = 7,
	__SEG6_ATTR_MAX = 8,
};

enum {
	SEG6_CMD_UNSPEC = 0,
	SEG6_CMD_SETHMAC = 1,
	SEG6_CMD_DUMPHMAC = 2,
	SEG6_CMD_SET_TUNSRC = 3,
	SEG6_CMD_GET_TUNSRC = 4,
	__SEG6_CMD_MAX = 5,
};

enum {
	IOAM6_ATTR_UNSPEC = 0,
	IOAM6_ATTR_NS_ID = 1,
	IOAM6_ATTR_NS_DATA = 2,
	IOAM6_ATTR_NS_DATA_WIDE = 3,
	IOAM6_ATTR_SC_ID = 4,
	IOAM6_ATTR_SC_DATA = 5,
	IOAM6_ATTR_SC_NONE = 6,
	IOAM6_ATTR_PAD = 7,
	__IOAM6_ATTR_MAX = 8,
};

enum {
	IOAM6_CMD_UNSPEC = 0,
	IOAM6_CMD_ADD_NAMESPACE = 1,
	IOAM6_CMD_DEL_NAMESPACE = 2,
	IOAM6_CMD_DUMP_NAMESPACES = 3,
	IOAM6_CMD_ADD_SCHEMA = 4,
	IOAM6_CMD_DEL_SCHEMA = 5,
	IOAM6_CMD_DUMP_SCHEMAS = 6,
	IOAM6_CMD_NS_SET_SCHEMA = 7,
	__IOAM6_CMD_MAX = 8,
};

struct br_input_skb_cb {
	struct net_device *brdev;
	u16 frag_max_size;
	u8 igmp;
	u8 mrouters_only: 1;
	u8 proxyarp_replied: 1;
	u8 src_port_isolated: 1;
	u8 vlan_filtered: 1;
	u8 br_netfilter_broute: 1;
	u8 tx_fwd_offload: 1;
	int src_hwdom;
	long unsigned int fwd_hwdoms;
};

struct nf_bridge_frag_data;

struct ip_tunnel_prl {
	__be32 addr;
	__u16 flags;
	__u16 __reserved;
	__u32 datalen;
	__u32 __reserved2;
};

struct sit_net {
	struct ip_tunnel *tunnels_r_l[16];
	struct ip_tunnel *tunnels_r[16];
	struct ip_tunnel *tunnels_l[16];
	struct ip_tunnel *tunnels_wc[1];
	struct ip_tunnel **tunnels[4];
	struct net_device *fb_tunnel_dev;
};

enum {
	IP6_FH_F_FRAG = 1,
	IP6_FH_F_AUTH = 2,
	IP6_FH_F_SKIP_RH = 4,
};

struct mbox_request {
	__u64 addr;
	__u32 len;
	__u32 is_set;
	__u32 cmd;
	__u32 pid;
};

struct mbox_reply {
	__u32 status;
};

struct sockaddr_pkt {
	short unsigned int spkt_family;
	unsigned char spkt_device[14];
	__be16 spkt_protocol;
};

struct sockaddr_ll {
	short unsigned int sll_family;
	__be16 sll_protocol;
	int sll_ifindex;
	short unsigned int sll_hatype;
	unsigned char sll_pkttype;
	unsigned char sll_halen;
	unsigned char sll_addr[8];
};

struct tpacket_stats {
	unsigned int tp_packets;
	unsigned int tp_drops;
};

struct tpacket_stats_v3 {
	unsigned int tp_packets;
	unsigned int tp_drops;
	unsigned int tp_freeze_q_cnt;
};

struct tpacket_rollover_stats {
	__u64 tp_all;
	__u64 tp_huge;
	__u64 tp_failed;
};

union tpacket_stats_u {
	struct tpacket_stats stats1;
	struct tpacket_stats_v3 stats3;
};

struct tpacket_auxdata {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
};

struct tpacket_hdr {
	long unsigned int tp_status;
	unsigned int tp_len;
	unsigned int tp_snaplen;
	short unsigned int tp_mac;
	short unsigned int tp_net;
	unsigned int tp_sec;
	unsigned int tp_usec;
};

struct tpacket2_hdr {
	__u32 tp_status;
	__u32 tp_len;
	__u32 tp_snaplen;
	__u16 tp_mac;
	__u16 tp_net;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u16 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u8 tp_padding[4];
};

struct tpacket_hdr_variant1 {
	__u32 tp_rxhash;
	__u32 tp_vlan_tci;
	__u16 tp_vlan_tpid;
	__u16 tp_padding;
};

struct tpacket3_hdr {
	__u32 tp_next_offset;
	__u32 tp_sec;
	__u32 tp_nsec;
	__u32 tp_snaplen;
	__u32 tp_len;
	__u32 tp_status;
	__u16 tp_mac;
	__u16 tp_net;
	union {
		struct tpacket_hdr_variant1 hv1;
	};
	__u8 tp_padding[8];
};

struct tpacket_bd_ts {
	unsigned int ts_sec;
	union {
		unsigned int ts_usec;
		unsigned int ts_nsec;
	};
};

struct tpacket_hdr_v1 {
	__u32 block_status;
	__u32 num_pkts;
	__u32 offset_to_first_pkt;
	__u32 blk_len;
	__u64 seq_num;
	struct tpacket_bd_ts ts_first_pkt;
	struct tpacket_bd_ts ts_last_pkt;
};

union tpacket_bd_header_u {
	struct tpacket_hdr_v1 bh1;
};

struct tpacket_block_desc {
	__u32 version;
	__u32 offset_to_priv;
	union tpacket_bd_header_u hdr;
};

enum tpacket_versions {
	TPACKET_V1 = 0,
	TPACKET_V2 = 1,
	TPACKET_V3 = 2,
};

struct tpacket_req {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
};

struct tpacket_req3 {
	unsigned int tp_block_size;
	unsigned int tp_block_nr;
	unsigned int tp_frame_size;
	unsigned int tp_frame_nr;
	unsigned int tp_retire_blk_tov;
	unsigned int tp_sizeof_priv;
	unsigned int tp_feature_req_word;
};

union tpacket_req_u {
	struct tpacket_req req;
	struct tpacket_req3 req3;
};

struct fanout_args {
	__u16 id;
	__u16 type_flags;
	__u32 max_num_members;
};

struct packet_mclist {
	struct packet_mclist *next;
	int ifindex;
	int count;
	short unsigned int type;
	short unsigned int alen;
	unsigned char addr[32];
};

struct pgv;

struct tpacket_kbdq_core {
	struct pgv *pkbdq;
	unsigned int feature_req_word;
	unsigned int hdrlen;
	unsigned char reset_pending_on_curr_blk;
	unsigned char delete_blk_timer;
	short unsigned int kactive_blk_num;
	short unsigned int blk_sizeof_priv;
	short unsigned int last_kactive_blk_num;
	char *pkblk_start;
	char *pkblk_end;
	int kblk_size;
	unsigned int max_frame_len;
	unsigned int knum_blocks;
	uint64_t knxt_seq_num;
	char *prev;
	char *nxt_offset;
	struct sk_buff *skb;
	rwlock_t blk_fill_in_prog_lock;
	short unsigned int retire_blk_tov;
	short unsigned int version;
	long unsigned int tov_in_jiffies;
	struct timer_list retire_blk_timer;
	int: 32;
};

struct pgv {
	char *buffer;
};

struct packet_ring_buffer {
	struct pgv *pg_vec;
	unsigned int head;
	unsigned int frames_per_block;
	unsigned int frame_size;
	unsigned int frame_max;
	unsigned int pg_vec_order;
	unsigned int pg_vec_pages;
	unsigned int pg_vec_len;
	unsigned int *pending_refcnt;
	int: 32;
	union {
		long unsigned int *rx_owner_map;
		struct tpacket_kbdq_core prb_bdqc;
	};
};

struct packet_fanout {
	possible_net_t net;
	unsigned int num_members;
	u32 max_num_members;
	u16 id;
	u8 type;
	u8 flags;
	union {
		atomic_t rr_cur;
		struct bpf_prog *bpf_prog;
	};
	struct list_head list;
	spinlock_t lock;
	refcount_t sk_ref;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct packet_type prot_hook;
	struct sock *arr[0];
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct packet_rollover {
	int sock;
	atomic_long_t num;
	atomic_long_t num_huge;
	atomic_long_t num_failed;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	u32 history[16];
};

struct packet_sock {
	struct sock sk;
	struct packet_fanout *fanout;
	union tpacket_stats_u stats;
	struct packet_ring_buffer rx_ring;
	struct packet_ring_buffer tx_ring;
	int copy_thresh;
	spinlock_t bind_lock;
	struct mutex pg_vec_lock;
	unsigned int running;
	unsigned int auxdata: 1;
	unsigned int origdev: 1;
	unsigned int has_vnet_hdr: 1;
	unsigned int tp_loss: 1;
	unsigned int tp_tx_has_off: 1;
	int pressure;
	int ifindex;
	__be16 num;
	struct packet_rollover *rollover;
	struct packet_mclist *mclist;
	atomic_t mapped;
	enum tpacket_versions tp_version;
	unsigned int tp_hdrlen;
	unsigned int tp_reserve;
	unsigned int tp_tstamp;
	struct completion skb_completion;
	struct net_device *cached_dev;
	int (*xmit)(struct sk_buff *);
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	struct packet_type prot_hook;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	atomic_t tp_drops;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
	int: 32;
};

struct packet_mreq_max {
	int mr_ifindex;
	short unsigned int mr_type;
	short unsigned int mr_alen;
	unsigned char mr_address[32];
};

union tpacket_uhdr {
	struct tpacket_hdr *h1;
	struct tpacket2_hdr *h2;
	struct tpacket3_hdr *h3;
	void *raw;
};

struct packet_skb_cb {
	union {
		struct sockaddr_pkt pkt;
		union {
			unsigned int origlen;
			struct sockaddr_ll ll;
		};
	} sa;
};

struct can_pkg_stats {
	long unsigned int jiffies_init;
	long unsigned int rx_frames;
	long unsigned int tx_frames;
	long unsigned int matches;
	long unsigned int total_rx_rate;
	long unsigned int total_tx_rate;
	long unsigned int total_rx_match_ratio;
	long unsigned int current_rx_rate;
	long unsigned int current_tx_rate;
	long unsigned int current_rx_match_ratio;
	long unsigned int max_rx_rate;
	long unsigned int max_tx_rate;
	long unsigned int max_rx_match_ratio;
	long unsigned int rx_frames_delta;
	long unsigned int tx_frames_delta;
	long unsigned int matches_delta;
};

struct can_rcv_lists_stats {
	long unsigned int stats_reset;
	long unsigned int user_reset;
	long unsigned int rcv_entries;
	long unsigned int rcv_entries_max;
};

struct can_proto {
	int type;
	int protocol;
	const struct proto_ops *ops;
	struct proto *prot;
};

struct receiver {
	struct hlist_node list;
	canid_t can_id;
	canid_t mask;
	long unsigned int matches;
	void (*func)(struct sk_buff *, void *);
	void *data;
	char *ident;
	struct sock *sk;
	struct callback_head rcu;
};

typedef __u32 can_err_mask_t;

struct sockaddr_can {
	__kernel_sa_family_t can_family;
	int can_ifindex;
	union {
		struct {
			canid_t rx_id;
			canid_t tx_id;
		} tp;
		struct {
			__u64 name;
			__u32 pgn;
			__u8 addr;
		} j1939;
	} can_addr;
};

struct can_filter {
	canid_t can_id;
	canid_t can_mask;
};

enum {
	SCM_CAN_RAW_ERRQUEUE = 1,
};

enum {
	CAN_RAW_FILTER = 1,
	CAN_RAW_ERR_FILTER = 2,
	CAN_RAW_LOOPBACK = 3,
	CAN_RAW_RECV_OWN_MSGS = 4,
	CAN_RAW_FD_FRAMES = 5,
	CAN_RAW_JOIN_FILTERS = 6,
	CAN_RAW_XL_FRAMES = 7,
};

struct uniqframe {
	int skbcnt;
	const struct sk_buff *skb;
	unsigned int join_rx_count;
};

struct raw_sock___2 {
	struct sock sk;
	int bound;
	int ifindex;
	struct list_head notifier;
	int loopback;
	int recv_own_msgs;
	int fd_frames;
	int xl_frames;
	int join_filters;
	int count;
	struct can_filter dfilter;
	struct can_filter *filter;
	can_err_mask_t err_mask;
	struct uniqframe *uniq;
	int: 32;
};

struct bcm_timeval {
	long int tv_sec;
	long int tv_usec;
};

struct bcm_msg_head {
	__u32 opcode;
	__u32 flags;
	__u32 count;
	struct bcm_timeval ival1;
	struct bcm_timeval ival2;
	canid_t can_id;
	__u32 nframes;
	int: 32;
	struct can_frame frames[0];
};

enum {
	TX_SETUP = 1,
	TX_DELETE = 2,
	TX_READ = 3,
	TX_SEND = 4,
	RX_SETUP = 5,
	RX_DELETE = 6,
	RX_READ = 7,
	TX_STATUS = 8,
	TX_EXPIRED = 9,
	RX_STATUS = 10,
	RX_TIMEOUT = 11,
	RX_CHANGED = 12,
};

struct bcm_op {
	struct list_head list;
	struct callback_head rcu;
	int ifindex;
	canid_t can_id;
	u32 flags;
	long unsigned int frames_abs;
	long unsigned int frames_filtered;
	struct bcm_timeval ival1;
	struct bcm_timeval ival2;
	int: 32;
	struct hrtimer timer;
	struct hrtimer thrtimer;
	ktime_t rx_stamp;
	ktime_t kt_ival1;
	ktime_t kt_ival2;
	ktime_t kt_lastmsg;
	int rx_ifindex;
	int cfsiz;
	u32 count;
	u32 nframes;
	u32 currframe;
	void *frames;
	void *last_frames;
	int: 32;
	struct canfd_frame sframe;
	struct canfd_frame last_sframe;
	struct sock *sk;
	struct net_device *rx_reg_dev;
};

struct bcm_sock {
	struct sock sk;
	int bound;
	int ifindex;
	struct list_head notifier;
	struct list_head rx_ops;
	struct list_head tx_ops;
	long unsigned int dropped_usr_msgs;
	struct proc_dir_entry *bcm_proc_read;
	char procname[32];
};

struct rtcanmsg {
	__u8 can_family;
	__u8 gwtype;
	__u16 flags;
};

enum {
	CGW_TYPE_UNSPEC = 0,
	CGW_TYPE_CAN_CAN = 1,
	__CGW_TYPE_MAX = 2,
};

enum {
	CGW_UNSPEC = 0,
	CGW_MOD_AND = 1,
	CGW_MOD_OR = 2,
	CGW_MOD_XOR = 3,
	CGW_MOD_SET = 4,
	CGW_CS_XOR = 5,
	CGW_CS_CRC8 = 6,
	CGW_HANDLED = 7,
	CGW_DROPPED = 8,
	CGW_SRC_IF = 9,
	CGW_DST_IF = 10,
	CGW_FILTER = 11,
	CGW_DELETED = 12,
	CGW_LIM_HOPS = 13,
	CGW_MOD_UID = 14,
	CGW_FDMOD_AND = 15,
	CGW_FDMOD_OR = 16,
	CGW_FDMOD_XOR = 17,
	CGW_FDMOD_SET = 18,
	__CGW_MAX = 19,
};

struct cgw_frame_mod {
	struct can_frame cf;
	__u8 modtype;
} __attribute__((packed));

struct cgw_fdframe_mod {
	struct canfd_frame cf;
	__u8 modtype;
} __attribute__((packed));

struct cgw_csum_xor {
	__s8 from_idx;
	__s8 to_idx;
	__s8 result_idx;
	__u8 init_xor_val;
};

struct cgw_csum_crc8 {
	__s8 from_idx;
	__s8 to_idx;
	__s8 result_idx;
	__u8 init_crc_val;
	__u8 final_xor_val;
	__u8 crctab[256];
	__u8 profile;
	__u8 profile_data[20];
};

enum {
	CGW_CRC8PRF_UNSPEC = 0,
	CGW_CRC8PRF_1U8 = 1,
	CGW_CRC8PRF_16U8 = 2,
	CGW_CRC8PRF_SFFID_XOR = 3,
	__CGW_CRC8PRF_MAX = 4,
};

struct cf_mod {
	struct {
		struct canfd_frame and;
		struct canfd_frame or;
		struct canfd_frame xor;
		struct canfd_frame set;
	} modframe;
	struct {
		u8 and;
		u8 or;
		u8 xor;
		u8 set;
	} modtype;
	void (*modfunc[16])(struct canfd_frame *, struct cf_mod *);
	struct {
		struct cgw_csum_xor xor;
		struct cgw_csum_crc8 crc8;
	} csum;
	struct {
		void (*xor)(struct canfd_frame *, struct cgw_csum_xor *);
		void (*crc8)(struct canfd_frame *, struct cgw_csum_crc8 *);
	} csumfunc;
	u32 uid;
};

struct can_can_gw {
	struct can_filter filter;
	int src_idx;
	int dst_idx;
};

struct cgw_job {
	struct hlist_node list;
	struct callback_head rcu;
	u32 handled_frames;
	u32 dropped_frames;
	u32 deleted_frames;
	int: 32;
	struct cf_mod mod;
	union {
		struct net_device *dev;
	} src;
	union {
		struct net_device *dev;
	} dst;
	union {
		struct can_can_gw ccgw;
	};
	u8 gwtype;
	u8 limit_hops;
	u16 flags;
	int: 32;
};

enum {
	BT_CONNECTED = 1,
	BT_OPEN = 2,
	BT_BOUND = 3,
	BT_LISTEN = 4,
	BT_CONNECT = 5,
	BT_CONNECT2 = 6,
	BT_CONFIG = 7,
	BT_DISCONN = 8,
	BT_CLOSED = 9,
};

struct bt_sock {
	struct sock sk;
	struct list_head accept_q;
	struct sock *parent;
	long unsigned int flags;
	void (*skb_msg_name)(struct sk_buff *, void *, int *);
	void (*skb_put_cmsg)(struct sk_buff *, struct msghdr *, struct sock *);
};

enum {
	BT_SK_DEFER_SETUP = 0,
	BT_SK_SUSPEND = 1,
};

struct bt_sock_list {
	struct hlist_head head;
	rwlock_t lock;
	int (*custom_seq_show)(struct seq_file *, void *);
};

enum rfkill_type {
	RFKILL_TYPE_ALL = 0,
	RFKILL_TYPE_WLAN = 1,
	RFKILL_TYPE_BLUETOOTH = 2,
	RFKILL_TYPE_UWB = 3,
	RFKILL_TYPE_WIMAX = 4,
	RFKILL_TYPE_WWAN = 5,
	RFKILL_TYPE_GPS = 6,
	RFKILL_TYPE_FM = 7,
	RFKILL_TYPE_NFC = 8,
	NUM_RFKILL_TYPES = 9,
};

struct rfkill_ops {
	void (*poll)(struct rfkill *, void *);
	void (*query)(struct rfkill *, void *);
	int (*set_block)(void *, bool);
};

struct l2cap_seq_list {
	__u16 head;
	__u16 tail;
	__u16 mask;
	__u16 *list;
};

struct l2cap_conn;

struct hci_chan;

struct l2cap_ops;

struct l2cap_chan {
	struct l2cap_conn *conn;
	struct hci_conn *hs_hcon;
	struct hci_chan *hs_hchan;
	struct kref kref;
	atomic_t nesting;
	__u8 state;
	bdaddr_t dst;
	__u8 dst_type;
	bdaddr_t src;
	__u8 src_type;
	__le16 psm;
	__le16 sport;
	__u16 dcid;
	__u16 scid;
	__u16 imtu;
	__u16 omtu;
	__u16 flush_to;
	__u8 mode;
	__u8 chan_type;
	__u8 chan_policy;
	__u8 sec_level;
	__u8 ident;
	__u8 conf_req[64];
	__u8 conf_len;
	__u8 num_conf_req;
	__u8 num_conf_rsp;
	__u8 fcs;
	__u16 tx_win;
	__u16 tx_win_max;
	__u16 ack_win;
	__u8 max_tx;
	__u16 retrans_timeout;
	__u16 monitor_timeout;
	__u16 mps;
	__u16 tx_credits;
	__u16 rx_credits;
	__u8 tx_state;
	__u8 rx_state;
	long unsigned int conf_state;
	long unsigned int conn_state;
	long unsigned int flags;
	__u8 remote_amp_id;
	__u8 local_amp_id;
	__u8 move_id;
	__u8 move_state;
	__u8 move_role;
	__u16 next_tx_seq;
	__u16 expected_ack_seq;
	__u16 expected_tx_seq;
	__u16 buffer_seq;
	__u16 srej_save_reqseq;
	__u16 last_acked_seq;
	__u16 frames_sent;
	__u16 unacked_frames;
	__u8 retry_count;
	__u16 sdu_len;
	struct sk_buff *sdu;
	struct sk_buff *sdu_last_frag;
	__u16 remote_tx_win;
	__u8 remote_max_tx;
	__u16 remote_mps;
	__u8 local_id;
	__u8 local_stype;
	__u16 local_msdu;
	__u32 local_sdu_itime;
	__u32 local_acc_lat;
	__u32 local_flush_to;
	__u8 remote_id;
	__u8 remote_stype;
	__u16 remote_msdu;
	__u32 remote_sdu_itime;
	__u32 remote_acc_lat;
	__u32 remote_flush_to;
	struct delayed_work chan_timer;
	struct delayed_work retrans_timer;
	struct delayed_work monitor_timer;
	struct delayed_work ack_timer;
	struct sk_buff *tx_send_head;
	struct sk_buff_head tx_q;
	struct sk_buff_head srej_q;
	struct l2cap_seq_list srej_list;
	struct l2cap_seq_list retrans_list;
	struct list_head list;
	struct list_head global_l;
	void *data;
	const struct l2cap_ops *ops;
	struct mutex lock;
};

struct hci_cp_inquiry {
	__u8 lap[3];
	__u8 length;
	__u8 num_rsp;
};

struct inquiry_info {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 pscan_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
};

struct hci_ev_le_meta {
	__u8 subevent;
};

struct hci_iso_hdr {
	__le16 handle;
	__le16 dlen;
	__u8 data[0];
};

struct hci_dev_info {
	__u16 dev_id;
	char name[8];
	bdaddr_t bdaddr;
	__u32 flags;
	__u8 type;
	__u8 features[8];
	__u32 pkt_type;
	__u32 link_policy;
	__u32 link_mode;
	__u16 acl_mtu;
	__u16 acl_pkts;
	__u16 sco_mtu;
	__u16 sco_pkts;
	struct hci_dev_stats stat;
};

struct hci_dev_req {
	__u16 dev_id;
	__u32 dev_opt;
};

struct hci_dev_list_req {
	__u16 dev_num;
	struct hci_dev_req dev_req[0];
};

struct hci_inquiry_req {
	__u16 dev_id;
	__u16 flags;
	__u8 lap[3];
	__u8 length;
	__u8 num_rsp;
};

struct inquiry_data {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 pscan_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
	__s8 rssi;
	__u8 ssp_mode;
};

struct inquiry_entry {
	struct list_head all;
	struct list_head list;
	enum {
		NAME_NOT_KNOWN = 0,
		NAME_NEEDED = 1,
		NAME_PENDING = 2,
		NAME_KNOWN = 3,
	} name_state;
	__u32 timestamp;
	struct inquiry_data data;
};

struct bdaddr_list {
	struct list_head list;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
};

struct bdaddr_list_with_irk {
	struct list_head list;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	u8 peer_irk[16];
	u8 local_irk[16];
};

enum hci_conn_flags {
	HCI_CONN_FLAG_REMOTE_WAKEUP = 1,
	HCI_CONN_FLAG_DEVICE_PRIVACY = 2,
};

struct bdaddr_list_with_flags {
	struct list_head list;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	hci_conn_flags_t flags;
};

struct bt_uuid {
	struct list_head list;
	u8 uuid[16];
	u8 size;
	u8 svc_hint;
};

struct blocked_key {
	struct list_head list;
	struct callback_head rcu;
	u8 type;
	u8 val[16];
};

struct smp_ltk {
	struct list_head list;
	struct callback_head rcu;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	u8 authenticated;
	u8 type;
	u8 enc_size;
	__le16 ediv;
	int: 32;
	__le64 rand;
	u8 val[16];
};

struct smp_irk {
	struct list_head list;
	struct callback_head rcu;
	bdaddr_t rpa;
	bdaddr_t bdaddr;
	u8 addr_type;
	u8 val[16];
};

struct link_key {
	struct list_head list;
	struct callback_head rcu;
	bdaddr_t bdaddr;
	u8 type;
	u8 val[16];
	u8 pin_len;
};

struct oob_data {
	struct list_head list;
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	u8 present;
	u8 hash192[16];
	u8 rand192[16];
	u8 hash256[16];
	u8 rand256[16];
};

struct adv_info {
	struct list_head list;
	bool enabled;
	bool pending;
	bool periodic;
	__u8 mesh;
	__u8 instance;
	__u32 flags;
	__u16 timeout;
	__u16 remaining_time;
	__u16 duration;
	__u16 adv_data_len;
	__u8 adv_data[251];
	bool adv_data_changed;
	__u16 scan_rsp_len;
	__u8 scan_rsp_data[251];
	bool scan_rsp_changed;
	__u16 per_adv_data_len;
	__u8 per_adv_data[252];
	__s8 tx_power;
	__u32 min_interval;
	__u32 max_interval;
	bdaddr_t random_addr;
	bool rpa_expired;
	struct delayed_work rpa_expired_cb;
};

struct adv_pattern {
	struct list_head list;
	__u8 ad_type;
	__u8 offset;
	__u8 length;
	__u8 value[31];
};

struct adv_rssi_thresholds {
	__s8 low_threshold;
	__s8 high_threshold;
	__u16 low_threshold_timeout;
	__u16 high_threshold_timeout;
	__u8 sampling_period;
};

struct adv_monitor {
	struct list_head patterns;
	struct adv_rssi_thresholds rssi;
	__u16 handle;
	enum {
		ADV_MONITOR_STATE_NOT_REGISTERED = 0,
		ADV_MONITOR_STATE_REGISTERED = 1,
		ADV_MONITOR_STATE_OFFLOADED = 2,
	} state;
};

struct hci_chan {
	struct list_head list;
	__u16 handle;
	struct hci_conn *conn;
	struct sk_buff_head data_q;
	unsigned int sent;
	__u8 state;
	bool amp;
};

struct hci_conn_params {
	struct list_head list;
	struct list_head action;
	bdaddr_t addr;
	u8 addr_type;
	u16 conn_min_interval;
	u16 conn_max_interval;
	u16 conn_latency;
	u16 supervision_timeout;
	enum {
		HCI_AUTO_CONN_DISABLED = 0,
		HCI_AUTO_CONN_REPORT = 1,
		HCI_AUTO_CONN_DIRECT = 2,
		HCI_AUTO_CONN_ALWAYS = 3,
		HCI_AUTO_CONN_LINK_LOSS = 4,
		HCI_AUTO_CONN_EXPLICIT = 5,
	} auto_connect;
	struct hci_conn *conn;
	bool explicit_connect;
	hci_conn_flags_t flags;
	u8 privacy_mode;
};

struct hci_cb {
	struct list_head list;
	char *name;
	void (*connect_cfm)(struct hci_conn *, __u8);
	void (*disconn_cfm)(struct hci_conn *, __u8);
	void (*security_cfm)(struct hci_conn *, __u8, __u8);
	void (*key_change_cfm)(struct hci_conn *, __u8);
	void (*role_switch_cfm)(struct hci_conn *, __u8, __u8);
};

struct l2cap_conn {
	struct hci_conn *hcon;
	struct hci_chan *hchan;
	unsigned int mtu;
	__u32 feat_mask;
	__u8 remote_fixed_chan;
	__u8 local_fixed_chan;
	__u8 info_state;
	__u8 info_ident;
	struct delayed_work info_timer;
	struct sk_buff *rx_skb;
	__u32 rx_len;
	__u8 tx_ident;
	struct mutex ident_lock;
	struct sk_buff_head pending_rx;
	struct work_struct pending_rx_work;
	struct work_struct id_addr_update_work;
	__u8 disc_reason;
	struct l2cap_chan *smp;
	struct list_head chan_l;
	struct mutex chan_lock;
	struct kref ref;
	struct list_head users;
};

struct l2cap_ops {
	char *name;
	struct l2cap_chan * (*new_connection)(struct l2cap_chan *);
	int (*recv)(struct l2cap_chan *, struct sk_buff *);
	void (*teardown)(struct l2cap_chan *, int);
	void (*close)(struct l2cap_chan *);
	void (*state_change)(struct l2cap_chan *, int, int);
	void (*ready)(struct l2cap_chan *);
	void (*defer)(struct l2cap_chan *);
	void (*resume)(struct l2cap_chan *);
	void (*suspend)(struct l2cap_chan *);
	void (*set_shutdown)(struct l2cap_chan *);
	long int (*get_sndtimeo)(struct l2cap_chan *);
	struct pid * (*get_peer_pid)(struct l2cap_chan *);
	struct sk_buff * (*alloc_skb)(struct l2cap_chan *, long unsigned int, long unsigned int, int);
	int (*filter)(struct l2cap_chan *, struct sk_buff *);
};

struct hci_request {
	struct hci_dev *hdev;
	struct sk_buff_head cmd_q;
	int err;
};

enum {
	SMP_STK = 0,
	SMP_LTK = 1,
	SMP_LTK_RESPONDER = 2,
	SMP_LTK_P256 = 3,
	SMP_LTK_P256_DEBUG = 4,
};

struct hci_cp_create_conn {
	bdaddr_t bdaddr;
	__le16 pkt_type;
	__u8 pscan_rep_mode;
	__u8 pscan_mode;
	__le16 clock_offset;
	__u8 role_switch;
} __attribute__((packed));

struct hci_cp_disconnect {
	__le16 handle;
	__u8 reason;
} __attribute__((packed));

struct hci_cp_add_sco {
	__le16 handle;
	__le16 pkt_type;
};

struct hci_cp_reject_conn_req {
	bdaddr_t bdaddr;
	__u8 reason;
};

struct hci_cp_auth_requested {
	__le16 handle;
};

struct hci_cp_set_conn_encrypt {
	__le16 handle;
	__u8 encrypt;
} __attribute__((packed));

struct hci_cp_read_clock_offset {
	__le16 handle;
};

struct hci_cp_setup_sync_conn {
	__le16 handle;
	__le32 tx_bandwidth;
	__le32 rx_bandwidth;
	__le16 max_latency;
	__le16 voice_setting;
	__u8 retrans_effort;
	__le16 pkt_type;
} __attribute__((packed));

struct hci_cp_reject_sync_conn_req {
	bdaddr_t bdaddr;
	__u8 reason;
};

struct hci_cp_disconn_phy_link {
	__u8 phy_handle;
	__u8 reason;
};

struct hci_coding_format {
	__u8 id;
	__le16 cid;
	__le16 vid;
} __attribute__((packed));

struct hci_cp_enhanced_setup_sync_conn {
	__le16 handle;
	__le32 tx_bandwidth;
	__le32 rx_bandwidth;
	struct hci_coding_format tx_coding_format;
	struct hci_coding_format rx_coding_format;
	__le16 tx_codec_frame_size;
	__le16 rx_codec_frame_size;
	__le32 in_bandwidth;
	__le32 out_bandwidth;
	struct hci_coding_format in_coding_format;
	struct hci_coding_format out_coding_format;
	__le16 in_coded_data_size;
	__le16 out_coded_data_size;
	__u8 in_pcm_data_format;
	__u8 out_pcm_data_format;
	__u8 in_pcm_sample_payload_msb_pos;
	__u8 out_pcm_sample_payload_msb_pos;
	__u8 in_data_path;
	__u8 out_data_path;
	__u8 in_transport_unit_size;
	__u8 out_transport_unit_size;
	__le16 max_latency;
	__le16 pkt_type;
	__u8 retrans_effort;
} __attribute__((packed));

struct hci_cp_sniff_mode {
	__le16 handle;
	__le16 max_interval;
	__le16 min_interval;
	__le16 attempt;
	__le16 timeout;
};

struct hci_cp_exit_sniff_mode {
	__le16 handle;
};

struct hci_cp_switch_role {
	bdaddr_t bdaddr;
	__u8 role;
};

struct hci_cp_sniff_subrate {
	__le16 handle;
	__le16 max_latency;
	__le16 min_remote_timeout;
	__le16 min_local_timeout;
};

struct hci_op_configure_data_path {
	__u8 direction;
	__u8 data_path_id;
	__u8 vnd_len;
	__u8 vnd_data[0];
};

struct hci_cp_le_conn_update {
	__le16 handle;
	__le16 conn_interval_min;
	__le16 conn_interval_max;
	__le16 conn_latency;
	__le16 supervision_timeout;
	__le16 min_ce_len;
	__le16 max_ce_len;
};

struct hci_cp_le_start_enc {
	__le16 handle;
	__le64 rand;
	__le16 ediv;
	__u8 ltk[16];
} __attribute__((packed));

struct hci_cp_le_pa_create_sync {
	__u8 options;
	__u8 sid;
	__u8 addr_type;
	bdaddr_t addr;
	__le16 skip;
	__le16 sync_timeout;
	__u8 sync_cte_type;
} __attribute__((packed));

struct hci_cp_le_set_ext_adv_enable {
	__u8 enable;
	__u8 num_of_sets;
	__u8 data[0];
};

struct hci_cis_params {
	__u8 cis_id;
	__le16 c_sdu;
	__le16 p_sdu;
	__u8 c_phy;
	__u8 p_phy;
	__u8 c_rtn;
	__u8 p_rtn;
} __attribute__((packed));

struct hci_cp_le_set_cig_params {
	__u8 cig_id;
	__u8 c_interval[3];
	__u8 p_interval[3];
	__u8 sca;
	__u8 packing;
	__u8 framing;
	__le16 c_latency;
	__le16 p_latency;
	__u8 num_cis;
	struct hci_cis_params cis[0];
} __attribute__((packed));

struct hci_cis {
	__le16 cis_handle;
	__le16 acl_handle;
};

struct hci_cp_le_create_cis {
	__u8 num_cis;
	struct hci_cis cis[0];
} __attribute__((packed));

struct hci_bis {
	__u8 sdu_interval[3];
	__le16 sdu;
	__le16 latency;
	__u8 rtn;
	__u8 phy;
	__u8 packing;
	__u8 framing;
	__u8 encryption;
	__u8 bcode[16];
} __attribute__((packed));

struct hci_cp_le_create_big {
	__u8 handle;
	__u8 adv_handle;
	__u8 num_bis;
	struct hci_bis bis;
} __attribute__((packed));

struct hci_cp_le_big_create_sync {
	__u8 handle;
	__le16 sync_handle;
	__u8 encryption;
	__u8 bcode[16];
	__u8 mse;
	__le16 timeout;
	__u8 num_bis;
	__u8 bis[0];
} __attribute__((packed));

struct hci_cp_le_setup_iso_path {
	__le16 handle;
	__u8 direction;
	__u8 path;
	__u8 codec;
	__le16 codec_cid;
	__le16 codec_vid;
	__u8 delay[3];
	__u8 codec_cfg_len;
	__u8 codec_cfg[0];
} __attribute__((packed));

struct hci_conn_info {
	__u16 handle;
	bdaddr_t bdaddr;
	__u8 type;
	__u8 out;
	__u16 state;
	__u32 link_mode;
};

struct hci_conn_list_req {
	__u16 dev_id;
	__u16 conn_num;
	struct hci_conn_info conn_info[0];
};

struct hci_conn_info_req {
	bdaddr_t bdaddr;
	__u8 type;
	struct hci_conn_info conn_info[0];
};

struct hci_auth_info_req {
	bdaddr_t bdaddr;
	__u8 type;
};

struct amp_mgr {
	struct list_head list;
	struct l2cap_conn *l2cap_conn;
	struct l2cap_chan *a2mp_chan;
	struct l2cap_chan *bredr_chan;
	struct kref kref;
	__u8 ident;
	__u8 handle;
	long unsigned int state;
	long unsigned int flags;
	struct list_head amp_ctrls;
	struct mutex amp_ctrls_lock;
};

enum {
	HCI_CONN_AUTH_PEND = 0,
	HCI_CONN_REAUTH_PEND = 1,
	HCI_CONN_ENCRYPT_PEND = 2,
	HCI_CONN_RSWITCH_PEND = 3,
	HCI_CONN_MODE_CHANGE_PEND = 4,
	HCI_CONN_SCO_SETUP_PEND = 5,
	HCI_CONN_MGMT_CONNECTED = 6,
	HCI_CONN_SSP_ENABLED = 7,
	HCI_CONN_SC_ENABLED = 8,
	HCI_CONN_AES_CCM = 9,
	HCI_CONN_POWER_SAVE = 10,
	HCI_CONN_FLUSH_KEY = 11,
	HCI_CONN_ENCRYPT = 12,
	HCI_CONN_AUTH = 13,
	HCI_CONN_SECURE = 14,
	HCI_CONN_FIPS = 15,
	HCI_CONN_STK_ENCRYPT = 16,
	HCI_CONN_AUTH_INITIATOR = 17,
	HCI_CONN_DROP = 18,
	HCI_CONN_PARAM_REMOVAL_PEND = 19,
	HCI_CONN_NEW_LINK_KEY = 20,
	HCI_CONN_SCANNING = 21,
	HCI_CONN_AUTH_FAILURE = 22,
	HCI_CONN_PER_ADV = 23,
};

typedef void (*hci_conn_func_t)(struct hci_conn *, void *);

struct sco_param {
	u16 pkt_type;
	u16 max_latency;
	u8 retrans_effort;
};

struct conn_handle_t {
	struct hci_conn *conn;
	__u16 handle;
};

struct iso_list_data {
	union {
		u8 cig;
		u8 big;
	};
	union {
		u8 cis;
		u8 bis;
		u16 sync_handle;
	};
	int count;
	struct {
		struct hci_cp_le_set_cig_params cp;
		struct hci_cis_params cis[17];
	} __attribute__((packed)) pdu;
};

struct _packed {
	struct hci_cp_le_big_create_sync cp;
	__u8 bis[17];
} __attribute__((packed));

struct hci_cp_accept_conn_req {
	bdaddr_t bdaddr;
	__u8 role;
};

struct hci_cp_link_key_reply {
	bdaddr_t bdaddr;
	__u8 link_key[16];
};

struct hci_cp_pin_code_reply {
	bdaddr_t bdaddr;
	__u8 pin_len;
	__u8 pin_code[16];
};

struct hci_rp_pin_code_reply {
	__u8 status;
	bdaddr_t bdaddr;
};

struct hci_rp_pin_code_neg_reply {
	__u8 status;
	bdaddr_t bdaddr;
};

struct hci_cp_change_conn_ptype {
	__le16 handle;
	__le16 pkt_type;
};

struct hci_cp_remote_name_req {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_mode;
	__le16 clock_offset;
};

struct hci_cp_read_remote_features {
	__le16 handle;
};

struct hci_cp_read_remote_ext_features {
	__le16 handle;
	__u8 page;
} __attribute__((packed));

struct hci_cp_accept_sync_conn_req {
	bdaddr_t bdaddr;
	__le32 tx_bandwidth;
	__le32 rx_bandwidth;
	__le16 max_latency;
	__le16 content_format;
	__u8 retrans_effort;
	__le16 pkt_type;
} __attribute__((packed));

struct hci_cp_io_capability_reply {
	bdaddr_t bdaddr;
	__u8 capability;
	__u8 oob_data;
	__u8 authentication;
};

struct hci_rp_user_confirm_reply {
	__u8 status;
	bdaddr_t bdaddr;
};

struct hci_cp_remote_oob_data_reply {
	bdaddr_t bdaddr;
	__u8 hash[16];
	__u8 rand[16];
};

struct hci_cp_remote_oob_data_neg_reply {
	bdaddr_t bdaddr;
};

struct hci_cp_io_capability_neg_reply {
	bdaddr_t bdaddr;
	__u8 reason;
};

struct hci_cp_remote_oob_ext_data_reply {
	bdaddr_t bdaddr;
	__u8 hash192[16];
	__u8 rand192[16];
	__u8 hash256[16];
	__u8 rand256[16];
};

struct hci_rp_role_discovery {
	__u8 status;
	__le16 handle;
	__u8 role;
} __attribute__((packed));

struct hci_rp_read_link_policy {
	__u8 status;
	__le16 handle;
	__le16 policy;
} __attribute__((packed));

struct hci_rp_write_link_policy {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_rp_read_def_link_policy {
	__u8 status;
	__le16 policy;
} __attribute__((packed));

struct hci_cp_set_event_filter {
	__u8 flt_type;
	__u8 cond_type;
	struct {
		bdaddr_t bdaddr;
		__u8 auto_accept;
	} addr_conn_flt;
};

struct hci_cp_read_stored_link_key {
	bdaddr_t bdaddr;
	__u8 read_all;
};

struct hci_rp_read_stored_link_key {
	__u8 status;
	__le16 max_keys;
	__le16 num_keys;
} __attribute__((packed));

struct hci_rp_delete_stored_link_key {
	__u8 status;
	__le16 num_keys;
} __attribute__((packed));

struct hci_rp_read_local_name {
	__u8 status;
	__u8 name[248];
};

struct hci_rp_read_class_of_dev {
	__u8 status;
	__u8 dev_class[3];
};

struct hci_rp_read_voice_setting {
	__u8 status;
	__le16 voice_setting;
} __attribute__((packed));

struct hci_rp_read_num_supported_iac {
	__u8 status;
	__u8 num_iac;
};

struct hci_cp_write_ssp_mode {
	__u8 mode;
};

struct hci_rp_read_local_oob_data {
	__u8 status;
	__u8 hash[16];
	__u8 rand[16];
};

struct hci_rp_read_inq_rsp_tx_power {
	__u8 status;
	__s8 tx_power;
};

struct hci_rp_read_def_err_data_reporting {
	__u8 status;
	__u8 err_data_reporting;
};

struct hci_cp_write_def_err_data_reporting {
	__u8 err_data_reporting;
};

struct hci_rp_read_flow_control_mode {
	__u8 status;
	__u8 mode;
};

struct hci_cp_write_le_host_supported {
	__u8 le;
	__u8 simul;
};

struct hci_cp_write_sc_support {
	__u8 support;
};

struct hci_rp_read_auth_payload_to {
	__u8 status;
	__le16 handle;
	__le16 timeout;
} __attribute__((packed));

struct hci_cp_write_auth_payload_to {
	__le16 handle;
	__le16 timeout;
};

struct hci_rp_write_auth_payload_to {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_rp_read_local_oob_ext_data {
	__u8 status;
	__u8 hash192[16];
	__u8 rand192[16];
	__u8 hash256[16];
	__u8 rand256[16];
};

struct hci_rp_read_local_commands {
	__u8 status;
	__u8 commands[64];
};

struct hci_rp_read_local_features {
	__u8 status;
	__u8 features[8];
};

struct hci_rp_read_local_ext_features {
	__u8 status;
	__u8 page;
	__u8 max_page;
	__u8 features[8];
};

struct hci_rp_read_buffer_size {
	__u8 status;
	__le16 acl_mtu;
	__u8 sco_mtu;
	__le16 acl_max_pkt;
	__le16 sco_max_pkt;
} __attribute__((packed));

struct hci_rp_read_data_block_size {
	__u8 status;
	__le16 max_acl_len;
	__le16 block_len;
	__le16 num_blocks;
} __attribute__((packed));

struct hci_rp_read_local_pairing_opts {
	__u8 status;
	__u8 pairing_opts;
	__u8 max_key_size;
};

struct hci_rp_read_page_scan_activity {
	__u8 status;
	__le16 interval;
	__le16 window;
} __attribute__((packed));

struct hci_cp_write_page_scan_activity {
	__le16 interval;
	__le16 window;
};

struct hci_cp_read_tx_power {
	__le16 handle;
	__u8 type;
} __attribute__((packed));

struct hci_rp_read_tx_power {
	__u8 status;
	__le16 handle;
	__s8 tx_power;
} __attribute__((packed));

struct hci_rp_read_page_scan_type {
	__u8 status;
	__u8 type;
};

struct hci_rp_read_rssi {
	__u8 status;
	__le16 handle;
	__s8 rssi;
} __attribute__((packed));

struct hci_cp_read_clock {
	__le16 handle;
	__u8 which;
} __attribute__((packed));

struct hci_rp_read_clock {
	__u8 status;
	__le16 handle;
	__le32 clock;
	__le16 accuracy;
} __attribute__((packed));

struct hci_cp_read_enc_key_size {
	__le16 handle;
};

struct hci_rp_read_enc_key_size {
	__u8 status;
	__le16 handle;
	__u8 key_size;
} __attribute__((packed));

struct hci_rp_read_local_amp_info {
	__u8 status;
	__u8 amp_status;
	__le32 total_bw;
	__le32 max_bw;
	__le32 min_latency;
	__le32 max_pdu;
	__u8 amp_type;
	__le16 pal_cap;
	__le16 max_assoc_size;
	__le32 max_flush_to;
	__le32 be_flush_to;
} __attribute__((packed));

struct hci_rp_le_read_buffer_size {
	__u8 status;
	__le16 le_mtu;
	__u8 le_max_pkt;
} __attribute__((packed));

struct hci_rp_le_read_local_features {
	__u8 status;
	__u8 features[8];
};

struct hci_cp_le_set_adv_param {
	__le16 min_interval;
	__le16 max_interval;
	__u8 type;
	__u8 own_address_type;
	__u8 direct_addr_type;
	bdaddr_t direct_addr;
	__u8 channel_map;
	__u8 filter_policy;
} __attribute__((packed));

struct hci_rp_le_read_adv_tx_power {
	__u8 status;
	__s8 tx_power;
};

struct hci_cp_le_set_scan_param {
	__u8 type;
	__le16 interval;
	__le16 window;
	__u8 own_address_type;
	__u8 filter_policy;
} __attribute__((packed));

struct hci_cp_le_set_scan_enable {
	__u8 enable;
	__u8 filter_dup;
};

struct hci_cp_le_create_conn {
	__le16 scan_interval;
	__le16 scan_window;
	__u8 filter_policy;
	__u8 peer_addr_type;
	bdaddr_t peer_addr;
	__u8 own_address_type;
	__le16 conn_interval_min;
	__le16 conn_interval_max;
	__le16 conn_latency;
	__le16 supervision_timeout;
	__le16 min_ce_len;
	__le16 max_ce_len;
} __attribute__((packed));

struct hci_rp_le_read_accept_list_size {
	__u8 status;
	__u8 size;
};

struct hci_cp_le_add_to_accept_list {
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
};

struct hci_cp_le_del_from_accept_list {
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
};

struct hci_cp_le_read_remote_features {
	__le16 handle;
};

struct hci_cp_le_ltk_reply {
	__le16 handle;
	__u8 ltk[16];
};

struct hci_cp_le_ltk_neg_reply {
	__le16 handle;
};

struct hci_rp_le_read_supported_states {
	__u8 status;
	__u8 le_states[8];
};

struct hci_cp_le_conn_param_req_reply {
	__le16 handle;
	__le16 interval_min;
	__le16 interval_max;
	__le16 latency;
	__le16 timeout;
	__le16 min_ce_len;
	__le16 max_ce_len;
};

struct hci_cp_le_conn_param_req_neg_reply {
	__le16 handle;
	__u8 reason;
} __attribute__((packed));

struct hci_rp_le_read_def_data_len {
	__u8 status;
	__le16 tx_len;
	__le16 tx_time;
} __attribute__((packed));

struct hci_cp_le_write_def_data_len {
	__le16 tx_len;
	__le16 tx_time;
};

struct hci_cp_le_add_to_resolv_list {
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 peer_irk[16];
	__u8 local_irk[16];
};

struct hci_cp_le_del_from_resolv_list {
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
};

struct hci_rp_le_read_resolv_list_size {
	__u8 status;
	__u8 size;
};

struct hci_rp_le_read_max_data_len {
	__u8 status;
	__le16 tx_len;
	__le16 tx_time;
	__le16 rx_len;
	__le16 rx_time;
} __attribute__((packed));

struct hci_cp_le_set_default_phy {
	__u8 all_phys;
	__u8 tx_phys;
	__u8 rx_phys;
};

struct hci_cp_le_set_ext_scan_params {
	__u8 own_addr_type;
	__u8 filter_policy;
	__u8 scanning_phys;
	__u8 data[0];
};

struct hci_cp_le_scan_phy_params {
	__u8 type;
	__le16 interval;
	__le16 window;
} __attribute__((packed));

struct hci_cp_le_set_ext_scan_enable {
	__u8 enable;
	__u8 filter_dup;
	__le16 duration;
	__le16 period;
};

struct hci_cp_le_ext_create_conn {
	__u8 filter_policy;
	__u8 own_addr_type;
	__u8 peer_addr_type;
	bdaddr_t peer_addr;
	__u8 phys;
	__u8 data[0];
};

struct hci_cp_le_pa_term_sync {
	__le16 handle;
};

struct hci_rp_le_read_num_supported_adv_sets {
	__u8 status;
	__u8 num_of_sets;
};

struct hci_cp_le_set_ext_adv_params {
	__u8 handle;
	__le16 evt_properties;
	__u8 min_interval[3];
	__u8 max_interval[3];
	__u8 channel_map;
	__u8 own_addr_type;
	__u8 peer_addr_type;
	bdaddr_t peer_addr;
	__u8 filter_policy;
	__u8 tx_power;
	__u8 primary_phy;
	__u8 secondary_max_skip;
	__u8 secondary_phy;
	__u8 sid;
	__u8 notif_enable;
} __attribute__((packed));

struct hci_rp_le_set_ext_adv_params {
	__u8 status;
	__u8 tx_power;
};

struct hci_cp_ext_adv_set {
	__u8 handle;
	__le16 duration;
	__u8 max_events;
} __attribute__((packed));

struct hci_cp_le_set_per_adv_params {
	__u8 handle;
	__le16 min_interval;
	__le16 max_interval;
	__le16 periodic_properties;
} __attribute__((packed));

struct hci_cp_le_set_adv_set_rand_addr {
	__u8 handle;
	bdaddr_t bdaddr;
};

struct hci_rp_le_read_transmit_power {
	__u8 status;
	__s8 min_le_tx_power;
	__s8 max_le_tx_power;
};

struct hci_cp_le_set_privacy_mode {
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 mode;
};

struct hci_rp_le_read_buffer_size_v2 {
	__u8 status;
	__le16 acl_mtu;
	__u8 acl_max_pkt;
	__le16 iso_mtu;
	__u8 iso_max_pkt;
} __attribute__((packed));

struct hci_rp_le_set_cig_params {
	__u8 status;
	__u8 cig_id;
	__u8 num_handles;
	__le16 handle[0];
} __attribute__((packed));

struct hci_cp_le_accept_cis {
	__le16 handle;
};

struct hci_cp_le_reject_cis {
	__le16 handle;
	__u8 reason;
} __attribute__((packed));

struct hci_rp_le_setup_iso_path {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_ev_status {
	__u8 status;
};

struct hci_ev_inquiry_result {
	__u8 num;
	struct inquiry_info info[0];
} __attribute__((packed));

struct hci_ev_conn_complete {
	__u8 status;
	__le16 handle;
	bdaddr_t bdaddr;
	__u8 link_type;
	__u8 encr_mode;
} __attribute__((packed));

struct hci_ev_conn_request {
	bdaddr_t bdaddr;
	__u8 dev_class[3];
	__u8 link_type;
};

struct hci_ev_disconn_complete {
	__u8 status;
	__le16 handle;
	__u8 reason;
} __attribute__((packed));

struct hci_ev_auth_complete {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_ev_remote_name {
	__u8 status;
	bdaddr_t bdaddr;
	__u8 name[248];
};

struct hci_ev_encrypt_change {
	__u8 status;
	__le16 handle;
	__u8 encrypt;
} __attribute__((packed));

struct hci_ev_change_link_key_complete {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_ev_remote_features {
	__u8 status;
	__le16 handle;
	__u8 features[8];
} __attribute__((packed));

struct hci_ev_cmd_status {
	__u8 status;
	__u8 ncmd;
	__le16 opcode;
};

struct hci_ev_hardware_error {
	__u8 code;
};

struct hci_ev_role_change {
	__u8 status;
	bdaddr_t bdaddr;
	__u8 role;
};

struct hci_comp_pkts_info {
	__le16 handle;
	__le16 count;
};

struct hci_ev_num_comp_pkts {
	__u8 num;
	struct hci_comp_pkts_info handles[0];
} __attribute__((packed));

struct hci_ev_mode_change {
	__u8 status;
	__le16 handle;
	__u8 mode;
	__le16 interval;
} __attribute__((packed));

struct hci_ev_pin_code_req {
	bdaddr_t bdaddr;
};

struct hci_ev_link_key_req {
	bdaddr_t bdaddr;
};

struct hci_ev_link_key_notify {
	bdaddr_t bdaddr;
	__u8 link_key[16];
	__u8 key_type;
};

struct hci_ev_clock_offset {
	__u8 status;
	__le16 handle;
	__le16 clock_offset;
} __attribute__((packed));

struct hci_ev_pkt_type_change {
	__u8 status;
	__le16 handle;
	__le16 pkt_type;
} __attribute__((packed));

struct hci_ev_pscan_rep_mode {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
};

struct inquiry_info_rssi {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
	__s8 rssi;
} __attribute__((packed));

struct inquiry_info_rssi_pscan {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 pscan_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
	__s8 rssi;
} __attribute__((packed));

struct hci_ev_inquiry_result_rssi {
	__u8 num;
	__u8 data[0];
};

struct hci_ev_remote_ext_features {
	__u8 status;
	__le16 handle;
	__u8 page;
	__u8 max_page;
	__u8 features[8];
} __attribute__((packed));

struct hci_ev_sync_conn_complete {
	__u8 status;
	__le16 handle;
	bdaddr_t bdaddr;
	__u8 link_type;
	__u8 tx_interval;
	__u8 retrans_window;
	__le16 rx_pkt_len;
	__le16 tx_pkt_len;
	__u8 air_mode;
} __attribute__((packed));

struct extended_inquiry_info {
	bdaddr_t bdaddr;
	__u8 pscan_rep_mode;
	__u8 pscan_period_mode;
	__u8 dev_class[3];
	__le16 clock_offset;
	__s8 rssi;
	__u8 data[240];
} __attribute__((packed));

struct hci_ev_ext_inquiry_result {
	__u8 num;
	struct extended_inquiry_info info[0];
} __attribute__((packed));

struct hci_ev_key_refresh_complete {
	__u8 status;
	__le16 handle;
} __attribute__((packed));

struct hci_ev_io_capa_request {
	bdaddr_t bdaddr;
};

struct hci_ev_io_capa_reply {
	bdaddr_t bdaddr;
	__u8 capability;
	__u8 oob_data;
	__u8 authentication;
};

struct hci_ev_user_confirm_req {
	bdaddr_t bdaddr;
	__le32 passkey;
} __attribute__((packed));

struct hci_ev_user_passkey_req {
	bdaddr_t bdaddr;
};

struct hci_ev_remote_oob_data_request {
	bdaddr_t bdaddr;
};

struct hci_ev_simple_pair_complete {
	__u8 status;
	bdaddr_t bdaddr;
};

struct hci_ev_user_passkey_notify {
	bdaddr_t bdaddr;
	__le32 passkey;
} __attribute__((packed));

struct hci_ev_keypress_notify {
	bdaddr_t bdaddr;
	__u8 type;
};

struct hci_ev_remote_host_features {
	bdaddr_t bdaddr;
	__u8 features[8];
};

struct hci_comp_blocks_info {
	__le16 handle;
	__le16 pkts;
	__le16 blocks;
};

struct hci_ev_num_comp_blocks {
	__le16 num_blocks;
	__u8 num_hndl;
	struct hci_comp_blocks_info handles[0];
} __attribute__((packed));

struct hci_ev_le_conn_complete {
	__u8 status;
	__le16 handle;
	__u8 role;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__le16 interval;
	__le16 latency;
	__le16 supervision_timeout;
	__u8 clk_accurancy;
} __attribute__((packed));

struct hci_ev_le_advertising_info {
	__u8 type;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 length;
	__u8 data[0];
};

struct hci_ev_le_advertising_report {
	__u8 num;
	struct hci_ev_le_advertising_info info[0];
};

struct hci_ev_le_conn_update_complete {
	__u8 status;
	__le16 handle;
	__le16 interval;
	__le16 latency;
	__le16 supervision_timeout;
} __attribute__((packed));

struct hci_ev_le_remote_feat_complete {
	__u8 status;
	__le16 handle;
	__u8 features[8];
} __attribute__((packed));

struct hci_ev_le_ltk_req {
	__le16 handle;
	__le64 rand;
	__le16 ediv;
} __attribute__((packed));

struct hci_ev_le_remote_conn_param_req {
	__le16 handle;
	__le16 interval_min;
	__le16 interval_max;
	__le16 latency;
	__le16 timeout;
};

struct hci_ev_le_direct_adv_info {
	__u8 type;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 direct_addr_type;
	bdaddr_t direct_addr;
	__s8 rssi;
};

struct hci_ev_le_direct_adv_report {
	__u8 num;
	struct hci_ev_le_direct_adv_info info[0];
};

struct hci_ev_le_phy_update_complete {
	__u8 status;
	__le16 handle;
	__u8 tx_phy;
	__u8 rx_phy;
} __attribute__((packed));

struct hci_ev_le_ext_adv_info {
	__le16 type;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 primary_phy;
	__u8 secondary_phy;
	__u8 sid;
	__u8 tx_power;
	__s8 rssi;
	__le16 interval;
	__u8 direct_addr_type;
	bdaddr_t direct_addr;
	__u8 length;
	__u8 data[0];
};

struct hci_ev_le_ext_adv_report {
	__u8 num;
	struct hci_ev_le_ext_adv_info info[0];
} __attribute__((packed));

struct hci_ev_le_pa_sync_established {
	__u8 status;
	__le16 handle;
	__u8 sid;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	__u8 phy;
	__le16 interval;
	__u8 clock_accuracy;
} __attribute__((packed));

struct hci_ev_le_enh_conn_complete {
	__u8 status;
	__le16 handle;
	__u8 role;
	__u8 bdaddr_type;
	bdaddr_t bdaddr;
	bdaddr_t local_rpa;
	bdaddr_t peer_rpa;
	__le16 interval;
	__le16 latency;
	__le16 supervision_timeout;
	__u8 clk_accurancy;
} __attribute__((packed));

struct hci_evt_le_ext_adv_set_term {
	__u8 status;
	__u8 handle;
	__le16 conn_handle;
	__u8 num_evts;
} __attribute__((packed));

struct hci_evt_le_cis_established {
	__u8 status;
	__le16 handle;
	__u8 cig_sync_delay[3];
	__u8 cis_sync_delay[3];
	__u8 c_latency[3];
	__u8 p_latency[3];
	__u8 c_phy;
	__u8 p_phy;
	__u8 nse;
	__u8 c_bn;
	__u8 p_bn;
	__u8 c_ft;
	__u8 p_ft;
	__le16 c_mtu;
	__le16 p_mtu;
	__le16 interval;
} __attribute__((packed));

struct hci_evt_le_cis_req {
	__le16 acl_handle;
	__le16 cis_handle;
	__u8 cig_id;
	__u8 cis_id;
};

struct hci_evt_le_create_big_complete {
	__u8 status;
	__u8 handle;
	__u8 sync_delay[3];
	__u8 transport_delay[3];
	__u8 phy;
	__u8 nse;
	__u8 bn;
	__u8 pto;
	__u8 irc;
	__le16 max_pdu;
	__le16 interval;
	__u8 num_bis;
	__le16 bis_handle[0];
} __attribute__((packed));

struct hci_evt_le_big_sync_estabilished {
	__u8 status;
	__u8 handle;
	__u8 latency[3];
	__u8 nse;
	__u8 bn;
	__u8 pto;
	__u8 irc;
	__le16 max_pdu;
	__le16 interval;
	__u8 num_bis;
	__le16 bis[0];
} __attribute__((packed));

struct hci_evt_le_big_info_adv_report {
	__le16 sync_handle;
	__u8 num_bis;
	__u8 nse;
	__le16 iso_interval;
	__u8 bn;
	__u8 pto;
	__u8 irc;
	__le16 max_pdu;
	__u8 sdu_interval[3];
	__le16 max_sdu;
	__u8 phy;
	__u8 framing;
	__u8 encryption;
} __attribute__((packed));

struct hci_cc {
	u16 op;
	u8 (*func)(struct hci_dev *, void *, struct sk_buff *);
	u16 min_len;
	u16 max_len;
};

struct hci_cs {
	u16 op;
	void (*func)(struct hci_dev *, __u8);
};

struct hci_le_ev {
	void (*func)(struct hci_dev *, void *, struct sk_buff *);
	u16 min_len;
	u16 max_len;
};

struct hci_ev {
	bool req;
	union {
		void (*func)(struct hci_dev *, void *, struct sk_buff *);
		void (*func_req)(struct hci_dev *, void *, struct sk_buff *, u16 *, u8 *, hci_req_complete_t *, hci_req_complete_skb_t *);
	};
	u16 min_len;
	u16 max_len;
};

enum {
	HCI_SOCK_TRUSTED = 0,
	HCI_MGMT_INDEX_EVENTS = 1,
	HCI_MGMT_UNCONF_INDEX_EVENTS = 2,
	HCI_MGMT_EXT_INDEX_EVENTS = 3,
	HCI_MGMT_EXT_INFO_EVENTS = 4,
	HCI_MGMT_OPTION_EVENTS = 5,
	HCI_MGMT_SETTING_EVENTS = 6,
	HCI_MGMT_DEV_CLASS_EVENTS = 7,
	HCI_MGMT_LOCAL_NAME_EVENTS = 8,
	HCI_MGMT_OOB_DATA_EVENTS = 9,
	HCI_MGMT_EXP_FEATURE_EVENTS = 10,
};

struct hci_cp_user_passkey_reply {
	bdaddr_t bdaddr;
	__le32 passkey;
} __attribute__((packed));

struct smp_csrk {
	bdaddr_t bdaddr;
	u8 bdaddr_type;
	u8 type;
	u8 val[16];
};

struct monitored_device {
	struct list_head list;
	bdaddr_t bdaddr;
	__u8 addr_type;
	__u16 handle;
	bool notified;
};

struct hci_mgmt_handler {
	int (*func)(struct sock *, struct hci_dev *, void *, u16);
	size_t data_len;
	long unsigned int flags;
};

struct hci_mgmt_chan {
	struct list_head list;
	short unsigned int channel;
	size_t handler_count;
	const struct hci_mgmt_handler *handlers;
	void (*hdev_init)(struct sock *, struct hci_dev *);
};

struct mgmt_addr_info {
	bdaddr_t bdaddr;
	__u8 type;
};

struct mgmt_rp_read_version {
	__u8 version;
	__le16 revision;
} __attribute__((packed));

struct mgmt_rp_read_commands {
	__le16 num_commands;
	__le16 num_events;
	__le16 opcodes[0];
};

struct mgmt_rp_read_index_list {
	__le16 num_controllers;
	__le16 index[0];
};

struct mgmt_rp_read_info {
	bdaddr_t bdaddr;
	__u8 version;
	__le16 manufacturer;
	__le32 supported_settings;
	__le32 current_settings;
	__u8 dev_class[3];
	__u8 name[249];
	__u8 short_name[11];
} __attribute__((packed));

struct mgmt_mode {
	__u8 val;
};

struct mgmt_cp_set_discoverable {
	__u8 val;
	__le16 timeout;
} __attribute__((packed));

struct mgmt_cp_set_dev_class {
	__u8 major;
	__u8 minor;
};

struct mgmt_cp_set_local_name {
	__u8 name[249];
	__u8 short_name[11];
};

struct mgmt_cp_add_uuid {
	__u8 uuid[16];
	__u8 svc_hint;
};

struct mgmt_cp_remove_uuid {
	__u8 uuid[16];
};

struct mgmt_link_key_info {
	struct mgmt_addr_info addr;
	__u8 type;
	__u8 val[16];
	__u8 pin_len;
};

struct mgmt_cp_load_link_keys {
	__u8 debug_keys;
	__le16 key_count;
	struct mgmt_link_key_info keys[0];
} __attribute__((packed));

struct mgmt_ltk_info {
	struct mgmt_addr_info addr;
	__u8 type;
	__u8 initiator;
	__u8 enc_size;
	__le16 ediv;
	__le64 rand;
	__u8 val[16];
};

struct mgmt_cp_load_long_term_keys {
	__le16 key_count;
	struct mgmt_ltk_info keys[0];
} __attribute__((packed));

struct mgmt_cp_disconnect {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_disconnect {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_get_connections {
	__le16 conn_count;
	struct mgmt_addr_info addr[0];
};

struct mgmt_cp_pin_code_reply {
	struct mgmt_addr_info addr;
	__u8 pin_len;
	__u8 pin_code[16];
};

struct mgmt_cp_pin_code_neg_reply {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_set_io_capability {
	__u8 io_capability;
};

struct mgmt_cp_pair_device {
	struct mgmt_addr_info addr;
	__u8 io_cap;
};

struct mgmt_rp_pair_device {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_unpair_device {
	struct mgmt_addr_info addr;
	__u8 disconnect;
};

struct mgmt_rp_unpair_device {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_user_confirm_reply {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_user_confirm_neg_reply {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_user_passkey_reply {
	struct mgmt_addr_info addr;
	__le32 passkey;
} __attribute__((packed));

struct mgmt_cp_user_passkey_neg_reply {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_read_local_oob_data {
	__u8 hash192[16];
	__u8 rand192[16];
	__u8 hash256[16];
	__u8 rand256[16];
};

struct mgmt_cp_add_remote_oob_data {
	struct mgmt_addr_info addr;
	__u8 hash[16];
	__u8 rand[16];
};

struct mgmt_cp_add_remote_oob_ext_data {
	struct mgmt_addr_info addr;
	__u8 hash192[16];
	__u8 rand192[16];
	__u8 hash256[16];
	__u8 rand256[16];
};

struct mgmt_cp_remove_remote_oob_data {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_start_discovery {
	__u8 type;
};

struct mgmt_cp_stop_discovery {
	__u8 type;
};

struct mgmt_cp_confirm_name {
	struct mgmt_addr_info addr;
	__u8 name_known;
};

struct mgmt_cp_block_device {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_unblock_device {
	struct mgmt_addr_info addr;
};

struct mgmt_cp_set_device_id {
	__le16 source;
	__le16 vendor;
	__le16 product;
	__le16 version;
};

struct mgmt_cp_set_static_address {
	bdaddr_t bdaddr;
};

struct mgmt_cp_set_scan_params {
	__le16 interval;
	__le16 window;
};

struct mgmt_cp_set_privacy {
	__u8 privacy;
	__u8 irk[16];
};

struct mgmt_irk_info {
	struct mgmt_addr_info addr;
	__u8 val[16];
};

struct mgmt_cp_load_irks {
	__le16 irk_count;
	struct mgmt_irk_info irks[0];
};

struct mgmt_cp_get_conn_info {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_get_conn_info {
	struct mgmt_addr_info addr;
	__s8 rssi;
	__s8 tx_power;
	__s8 max_tx_power;
};

struct mgmt_cp_get_clock_info {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_get_clock_info {
	struct mgmt_addr_info addr;
	__le32 local_clock;
	__le32 piconet_clock;
	__le16 accuracy;
} __attribute__((packed));

struct mgmt_cp_add_device {
	struct mgmt_addr_info addr;
	__u8 action;
};

struct mgmt_cp_remove_device {
	struct mgmt_addr_info addr;
};

struct mgmt_conn_param {
	struct mgmt_addr_info addr;
	__le16 min_interval;
	__le16 max_interval;
	__le16 latency;
	__le16 timeout;
} __attribute__((packed));

struct mgmt_cp_load_conn_param {
	__le16 param_count;
	struct mgmt_conn_param params[0];
};

struct mgmt_rp_read_unconf_index_list {
	__le16 num_controllers;
	__le16 index[0];
};

struct mgmt_rp_read_config_info {
	__le16 manufacturer;
	__le32 supported_options;
	__le32 missing_options;
} __attribute__((packed));

struct mgmt_cp_set_external_config {
	__u8 config;
};

struct mgmt_cp_set_public_address {
	bdaddr_t bdaddr;
};

struct mgmt_cp_start_service_discovery {
	__u8 type;
	__s8 rssi;
	__le16 uuid_count;
	__u8 uuids[0];
};

struct mgmt_cp_read_local_oob_ext_data {
	__u8 type;
};

struct mgmt_rp_read_local_oob_ext_data {
	__u8 type;
	__le16 eir_len;
	__u8 eir[0];
} __attribute__((packed));

struct mgmt_rp_read_ext_index_list {
	__le16 num_controllers;
	struct {
		__le16 index;
		__u8 type;
		__u8 bus;
	} entry[0];
};

struct mgmt_rp_read_adv_features {
	__le32 supported_flags;
	__u8 max_adv_data_len;
	__u8 max_scan_rsp_len;
	__u8 max_instances;
	__u8 num_instances;
	__u8 instance[0];
};

struct mgmt_cp_add_advertising {
	__u8 instance;
	__le32 flags;
	__le16 duration;
	__le16 timeout;
	__u8 adv_data_len;
	__u8 scan_rsp_len;
	__u8 data[0];
} __attribute__((packed));

struct mgmt_rp_add_advertising {
	__u8 instance;
};

struct mgmt_cp_remove_advertising {
	__u8 instance;
};

struct mgmt_rp_remove_advertising {
	__u8 instance;
};

struct mgmt_cp_get_adv_size_info {
	__u8 instance;
	__le32 flags;
} __attribute__((packed));

struct mgmt_rp_get_adv_size_info {
	__u8 instance;
	__le32 flags;
	__u8 max_adv_data_len;
	__u8 max_scan_rsp_len;
} __attribute__((packed));

struct mgmt_rp_read_ext_info {
	bdaddr_t bdaddr;
	__u8 version;
	__le16 manufacturer;
	__le32 supported_settings;
	__le32 current_settings;
	__le16 eir_len;
	__u8 eir[0];
} __attribute__((packed));

struct mgmt_cp_set_appearance {
	__le16 appearance;
};

struct mgmt_rp_get_phy_configuration {
	__le32 supported_phys;
	__le32 configurable_phys;
	__le32 selected_phys;
};

struct mgmt_cp_set_phy_configuration {
	__le32 selected_phys;
};

struct mgmt_blocked_key_info {
	__u8 type;
	__u8 val[16];
};

struct mgmt_cp_set_blocked_keys {
	__le16 key_count;
	struct mgmt_blocked_key_info keys[0];
};

struct mgmt_rp_read_controller_cap {
	__le16 cap_len;
	__u8 cap[0];
};

struct mgmt_rp_read_exp_features_info {
	__le16 feature_count;
	struct {
		__u8 uuid[16];
		__le32 flags;
	} features[0];
} __attribute__((packed));

struct mgmt_cp_set_exp_feature {
	__u8 uuid[16];
	__u8 param[0];
};

struct mgmt_rp_set_exp_feature {
	__u8 uuid[16];
	__le32 flags;
};

struct mgmt_cp_get_device_flags {
	struct mgmt_addr_info addr;
};

struct mgmt_rp_get_device_flags {
	struct mgmt_addr_info addr;
	__le32 supported_flags;
	__le32 current_flags;
} __attribute__((packed));

struct mgmt_cp_set_device_flags {
	struct mgmt_addr_info addr;
	__le32 current_flags;
} __attribute__((packed));

struct mgmt_rp_read_adv_monitor_features {
	__le32 supported_features;
	__le32 enabled_features;
	__le16 max_num_handles;
	__u8 max_num_patterns;
	__le16 num_handles;
	__le16 handles[0];
} __attribute__((packed));

struct mgmt_adv_pattern {
	__u8 ad_type;
	__u8 offset;
	__u8 length;
	__u8 value[31];
};

struct mgmt_cp_add_adv_patterns_monitor {
	__u8 pattern_count;
	struct mgmt_adv_pattern patterns[0];
};

struct mgmt_rp_add_adv_patterns_monitor {
	__le16 monitor_handle;
};

struct mgmt_cp_remove_adv_monitor {
	__le16 monitor_handle;
};

struct mgmt_rp_remove_adv_monitor {
	__le16 monitor_handle;
};

struct mgmt_cp_add_ext_adv_params {
	__u8 instance;
	__le32 flags;
	__le16 duration;
	__le16 timeout;
	__le32 min_interval;
	__le32 max_interval;
	__s8 tx_power;
} __attribute__((packed));

struct mgmt_rp_add_ext_adv_params {
	__u8 instance;
	__s8 tx_power;
	__u8 max_adv_data_len;
	__u8 max_scan_rsp_len;
};

struct mgmt_cp_add_ext_adv_data {
	__u8 instance;
	__u8 adv_data_len;
	__u8 scan_rsp_len;
	__u8 data[0];
};

struct mgmt_rp_add_ext_adv_data {
	__u8 instance;
};

struct mgmt_adv_rssi_thresholds {
	__s8 high_threshold;
	__le16 high_threshold_timeout;
	__s8 low_threshold;
	__le16 low_threshold_timeout;
	__u8 sampling_period;
} __attribute__((packed));

struct mgmt_cp_add_adv_patterns_monitor_rssi {
	struct mgmt_adv_rssi_thresholds rssi;
	__u8 pattern_count;
	struct mgmt_adv_pattern patterns[0];
};

struct mgmt_cp_set_mesh {
	__u8 enable;
	__le16 window;
	__le16 period;
	__u8 num_ad_types;
	__u8 ad_types[0];
} __attribute__((packed));

struct mgmt_rp_mesh_read_features {
	__le16 index;
	__u8 max_handles;
	__u8 used_handles;
	__u8 handles[3];
} __attribute__((packed));

struct mgmt_cp_mesh_send {
	struct mgmt_addr_info addr;
	__le64 instant;
	__le16 delay;
	__u8 cnt;
	__u8 adv_data_len;
	__u8 adv_data[0];
} __attribute__((packed));

struct mgmt_cp_mesh_send_cancel {
	__u8 handle;
};

struct mgmt_ev_new_link_key {
	__u8 store_hint;
	struct mgmt_link_key_info key;
};

struct mgmt_ev_new_long_term_key {
	__u8 store_hint;
	struct mgmt_ltk_info key;
} __attribute__((packed));

struct mgmt_ev_device_connected {
	struct mgmt_addr_info addr;
	__le32 flags;
	__le16 eir_len;
	__u8 eir[0];
} __attribute__((packed));

struct mgmt_ev_device_disconnected {
	struct mgmt_addr_info addr;
	__u8 reason;
};

struct mgmt_ev_connect_failed {
	struct mgmt_addr_info addr;
	__u8 status;
};

struct mgmt_ev_pin_code_request {
	struct mgmt_addr_info addr;
	__u8 secure;
};

struct mgmt_ev_user_confirm_request {
	struct mgmt_addr_info addr;
	__u8 confirm_hint;
	__le32 value;
};

struct mgmt_ev_user_passkey_request {
	struct mgmt_addr_info addr;
};

struct mgmt_ev_auth_failed {
	struct mgmt_addr_info addr;
	__u8 status;
};

struct mgmt_ev_device_found {
	struct mgmt_addr_info addr;
	__s8 rssi;
	__le32 flags;
	__le16 eir_len;
	__u8 eir[0];
} __attribute__((packed));

struct mgmt_ev_discovering {
	__u8 type;
	__u8 discovering;
};

struct mgmt_ev_device_unpaired {
	struct mgmt_addr_info addr;
};

struct mgmt_ev_passkey_notify {
	struct mgmt_addr_info addr;
	__le32 passkey;
	__u8 entered;
} __attribute__((packed));

struct mgmt_ev_new_irk {
	__u8 store_hint;
	bdaddr_t rpa;
	struct mgmt_irk_info irk;
};

struct mgmt_csrk_info {
	struct mgmt_addr_info addr;
	__u8 type;
	__u8 val[16];
};

struct mgmt_ev_new_csrk {
	__u8 store_hint;
	struct mgmt_csrk_info key;
};

struct mgmt_ev_device_added {
	struct mgmt_addr_info addr;
	__u8 action;
};

struct mgmt_ev_device_removed {
	struct mgmt_addr_info addr;
};

struct mgmt_ev_new_conn_param {
	struct mgmt_addr_info addr;
	__u8 store_hint;
	__le16 min_interval;
	__le16 max_interval;
	__le16 latency;
	__le16 timeout;
};

struct mgmt_ev_ext_index {
	__u8 type;
	__u8 bus;
};

struct mgmt_ev_advertising_added {
	__u8 instance;
};

struct mgmt_ev_advertising_removed {
	__u8 instance;
};

struct mgmt_ev_ext_info_changed {
	__le16 eir_len;
	__u8 eir[0];
};

struct mgmt_ev_phy_configuration_changed {
	__le32 selected_phys;
};

struct mgmt_ev_exp_feature_changed {
	__u8 uuid[16];
	__le32 flags;
};

struct mgmt_ev_device_flags_changed {
	struct mgmt_addr_info addr;
	__le32 supported_flags;
	__le32 current_flags;
} __attribute__((packed));

struct mgmt_ev_adv_monitor_added {
	__le16 monitor_handle;
};

struct mgmt_ev_adv_monitor_removed {
	__le16 monitor_handle;
};

struct mgmt_ev_controller_suspend {
	__u8 suspend_state;
};

struct mgmt_ev_controller_resume {
	__u8 wake_reason;
	struct mgmt_addr_info addr;
};

struct mgmt_ev_adv_monitor_device_lost {
	__le16 monitor_handle;
	struct mgmt_addr_info addr;
} __attribute__((packed));

struct mgmt_ev_mesh_device_found {
	struct mgmt_addr_info addr;
	__s8 rssi;
	__le64 instant;
	__le32 flags;
	__le16 eir_len;
	__u8 eir[0];
} __attribute__((packed));

struct mgmt_mesh_tx {
	struct list_head list;
	int index;
	size_t param_len;
	struct sock *sk;
	u8 handle;
	u8 instance;
	u8 param[48];
};

struct mgmt_pending_cmd {
	struct list_head list;
	u16 opcode;
	int index;
	void *param;
	size_t param_len;
	struct sock *sk;
	struct sk_buff *skb;
	void *user_data;
	int (*cmd_complete)(struct mgmt_pending_cmd *, u8);
};

struct cmd_lookup {
	struct sock *sk;
	struct hci_dev *hdev;
	u8 mgmt_status;
};

struct mgmt_exp_feature {
	const u8 *uuid;
	int (*set_func)(struct sock *, struct hci_dev *, struct mgmt_cp_set_exp_feature *, u16);
};

struct hci_ev_stack_internal {
	__u16 type;
	__u8 data[0];
};

struct hci_ev_si_device {
	__u16 event;
	__u16 dev_id;
};

struct sockaddr_hci {
	sa_family_t hci_family;
	short unsigned int hci_dev;
	short unsigned int hci_channel;
};

struct hci_filter {
	long unsigned int type_mask;
	long unsigned int event_mask[2];
	__le16 opcode;
};

struct hci_ufilter {
	__u32 type_mask;
	__u32 event_mask[2];
	__le16 opcode;
};

struct hci_mon_hdr {
	__le16 opcode;
	__le16 index;
	__le16 len;
};

struct hci_mon_new_index {
	__u8 type;
	__u8 bus;
	bdaddr_t bdaddr;
	char name[8];
};

struct hci_mon_index_info {
	bdaddr_t bdaddr;
	__le16 manufacturer;
};

struct mgmt_hdr {
	__le16 opcode;
	__le16 index;
	__le16 len;
};

struct hci_pinfo {
	struct bt_sock bt;
	struct hci_dev *hdev;
	struct hci_filter filter;
	__u8 cmsg_mask;
	short unsigned int channel;
	long unsigned int flags;
	__u32 cookie;
	char comm[16];
	__u16 mtu;
	int: 16;
	int: 32;
};

struct hci_sec_filter {
	__u32 type_mask;
	__u32 event_mask[2];
	__u32 ocf_mask[24];
};

struct l2cap_hdr {
	__le16 len;
	__le16 cid;
};

struct l2cap_cmd_hdr {
	__u8 code;
	__u8 ident;
	__le16 len;
};

struct l2cap_cmd_rej_unk {
	__le16 reason;
};

struct l2cap_cmd_rej_cid {
	__le16 reason;
	__le16 scid;
	__le16 dcid;
};

struct l2cap_conn_req {
	__le16 psm;
	__le16 scid;
};

struct l2cap_conn_rsp {
	__le16 dcid;
	__le16 scid;
	__le16 result;
	__le16 status;
};

struct l2cap_conf_req {
	__le16 dcid;
	__le16 flags;
	__u8 data[0];
};

struct l2cap_conf_rsp {
	__le16 scid;
	__le16 flags;
	__le16 result;
	__u8 data[0];
};

struct l2cap_conf_opt {
	__u8 type;
	__u8 len;
	__u8 val[0];
};

struct l2cap_conf_rfc {
	__u8 mode;
	__u8 txwin_size;
	__u8 max_transmit;
	__le16 retrans_timeout;
	__le16 monitor_timeout;
	__le16 max_pdu_size;
} __attribute__((packed));

struct l2cap_conf_efs {
	__u8 id;
	__u8 stype;
	__le16 msdu;
	__le32 sdu_itime;
	__le32 acc_lat;
	__le32 flush_to;
};

struct l2cap_disconn_req {
	__le16 dcid;
	__le16 scid;
};

struct l2cap_disconn_rsp {
	__le16 dcid;
	__le16 scid;
};

struct l2cap_info_req {
	__le16 type;
};

struct l2cap_info_rsp {
	__le16 type;
	__le16 result;
	__u8 data[0];
};

struct l2cap_create_chan_req {
	__le16 psm;
	__le16 scid;
	__u8 amp_id;
} __attribute__((packed));

struct l2cap_create_chan_rsp {
	__le16 dcid;
	__le16 scid;
	__le16 result;
	__le16 status;
};

struct l2cap_move_chan_req {
	__le16 icid;
	__u8 dest_amp_id;
} __attribute__((packed));

struct l2cap_move_chan_rsp {
	__le16 icid;
	__le16 result;
};

struct l2cap_move_chan_cfm {
	__le16 icid;
	__le16 result;
};

struct l2cap_move_chan_cfm_rsp {
	__le16 icid;
};

struct l2cap_conn_param_update_req {
	__le16 min;
	__le16 max;
	__le16 latency;
	__le16 to_multiplier;
};

struct l2cap_conn_param_update_rsp {
	__le16 result;
};

struct l2cap_le_conn_req {
	__le16 psm;
	__le16 scid;
	__le16 mtu;
	__le16 mps;
	__le16 credits;
};

struct l2cap_le_conn_rsp {
	__le16 dcid;
	__le16 mtu;
	__le16 mps;
	__le16 credits;
	__le16 result;
};

struct l2cap_le_credits {
	__le16 cid;
	__le16 credits;
};

struct l2cap_ecred_conn_req {
	__le16 psm;
	__le16 mtu;
	__le16 mps;
	__le16 credits;
	__le16 scid[0];
};

struct l2cap_ecred_conn_rsp {
	__le16 mtu;
	__le16 mps;
	__le16 credits;
	__le16 result;
	__le16 dcid[0];
};

struct l2cap_ecred_reconf_req {
	__le16 mtu;
	__le16 mps;
	__le16 scid[0];
};

struct l2cap_ecred_reconf_rsp {
	__le16 result;
};

struct l2cap_user {
	struct list_head list;
	int (*probe)(struct l2cap_conn *, struct l2cap_user *);
	void (*remove)(struct l2cap_conn *, struct l2cap_user *);
};

enum {
	CONF_REQ_SENT = 0,
	CONF_INPUT_DONE = 1,
	CONF_OUTPUT_DONE = 2,
	CONF_MTU_DONE = 3,
	CONF_MODE_DONE = 4,
	CONF_CONNECT_PEND = 5,
	CONF_RECV_NO_FCS = 6,
	CONF_STATE2_DEVICE = 7,
	CONF_EWS_RECV = 8,
	CONF_LOC_CONF_PEND = 9,
	CONF_REM_CONF_PEND = 10,
	CONF_NOT_COMPLETE = 11,
};

enum {
	CONN_SREJ_SENT = 0,
	CONN_WAIT_F = 1,
	CONN_SREJ_ACT = 2,
	CONN_SEND_PBIT = 3,
	CONN_REMOTE_BUSY = 4,
	CONN_LOCAL_BUSY = 5,
	CONN_REJ_ACT = 6,
	CONN_SEND_FBIT = 7,
	CONN_RNR_SENT = 8,
};

enum {
	FLAG_ROLE_SWITCH = 0,
	FLAG_FORCE_ACTIVE = 1,
	FLAG_FORCE_RELIABLE = 2,
	FLAG_FLUSHABLE = 3,
	FLAG_EXT_CTRL = 4,
	FLAG_EFS_ENABLE = 5,
	FLAG_DEFER_SETUP = 6,
	FLAG_LE_CONN_REQ_SENT = 7,
	FLAG_ECRED_CONN_REQ_SENT = 8,
	FLAG_PENDING_SECURITY = 9,
	FLAG_HOLD_HCI_CONN = 10,
};

enum {
	L2CAP_NESTING_SMP = 0,
	L2CAP_NESTING_NORMAL = 1,
	L2CAP_NESTING_PARENT = 2,
};

enum {
	L2CAP_TX_STATE_XMIT = 0,
	L2CAP_TX_STATE_WAIT_F = 1,
};

enum {
	L2CAP_RX_STATE_RECV = 0,
	L2CAP_RX_STATE_SREJ_SENT = 1,
	L2CAP_RX_STATE_MOVE = 2,
	L2CAP_RX_STATE_WAIT_P = 3,
	L2CAP_RX_STATE_WAIT_F = 4,
};

enum {
	L2CAP_TXSEQ_EXPECTED = 0,
	L2CAP_TXSEQ_EXPECTED_SREJ = 1,
	L2CAP_TXSEQ_UNEXPECTED = 2,
	L2CAP_TXSEQ_UNEXPECTED_SREJ = 3,
	L2CAP_TXSEQ_DUPLICATE = 4,
	L2CAP_TXSEQ_DUPLICATE_SREJ = 5,
	L2CAP_TXSEQ_INVALID = 6,
	L2CAP_TXSEQ_INVALID_IGNORE = 7,
};

enum {
	L2CAP_EV_DATA_REQUEST = 0,
	L2CAP_EV_LOCAL_BUSY_DETECTED = 1,
	L2CAP_EV_LOCAL_BUSY_CLEAR = 2,
	L2CAP_EV_RECV_REQSEQ_AND_FBIT = 3,
	L2CAP_EV_RECV_FBIT = 4,
	L2CAP_EV_RETRANS_TO = 5,
	L2CAP_EV_MONITOR_TO = 6,
	L2CAP_EV_EXPLICIT_POLL = 7,
	L2CAP_EV_RECV_IFRAME = 8,
	L2CAP_EV_RECV_RR = 9,
	L2CAP_EV_RECV_REJ = 10,
	L2CAP_EV_RECV_RNR = 11,
	L2CAP_EV_RECV_SREJ = 12,
	L2CAP_EV_RECV_FRAME = 13,
};

enum {
	L2CAP_MOVE_ROLE_NONE = 0,
	L2CAP_MOVE_ROLE_INITIATOR = 1,
	L2CAP_MOVE_ROLE_RESPONDER = 2,
};

enum {
	L2CAP_MOVE_STABLE = 0,
	L2CAP_MOVE_WAIT_REQ = 1,
	L2CAP_MOVE_WAIT_RSP = 2,
	L2CAP_MOVE_WAIT_RSP_SUCCESS = 3,
	L2CAP_MOVE_WAIT_CONFIRM = 4,
	L2CAP_MOVE_WAIT_CONFIRM_RSP = 5,
	L2CAP_MOVE_WAIT_LOGICAL_COMP = 6,
	L2CAP_MOVE_WAIT_LOGICAL_CFM = 7,
	L2CAP_MOVE_WAIT_LOCAL_BUSY = 8,
	L2CAP_MOVE_WAIT_PREPARE = 9,
};

typedef void (*l2cap_chan_func_t)(struct l2cap_chan *, void *);

enum smp_key_pref {
	SMP_ALLOW_STK = 0,
	SMP_USE_LTK = 1,
};

struct l2cap_ecred_conn_data {
	struct {
		struct l2cap_ecred_conn_req req;
		__le16 scid[5];
	} pdu;
	struct l2cap_chan *chan;
	struct pid *pid;
	int count;
};

struct l2cap_chan_data {
	struct l2cap_chan *chan;
	struct pid *pid;
	int count;
};

struct bt_security {
	__u8 level;
	__u8 key_size;
};

struct bt_power {
	__u8 force_active;
};

struct sockaddr_l2 {
	sa_family_t l2_family;
	__le16 l2_psm;
	bdaddr_t l2_bdaddr;
	__le16 l2_cid;
	__u8 l2_bdaddr_type;
};

struct l2cap_options {
	__u16 omtu;
	__u16 imtu;
	__u16 flush_to;
	__u8 mode;
	__u8 fcs;
	__u8 max_tx;
	__u16 txwin_size;
};

struct l2cap_conninfo {
	__u16 hci_handle;
	__u8 dev_class[3];
};

struct l2cap_pinfo {
	struct bt_sock bt;
	struct l2cap_chan *chan;
	struct sk_buff *rx_busy_skb;
};

struct smp_cmd_pairing {
	__u8 io_capability;
	__u8 oob_flag;
	__u8 auth_req;
	__u8 max_key_size;
	__u8 init_key_dist;
	__u8 resp_key_dist;
};

struct smp_cmd_pairing_confirm {
	__u8 confirm_val[16];
};

struct smp_cmd_encrypt_info {
	__u8 ltk[16];
};

struct smp_cmd_initiator_ident {
	__le16 ediv;
	__le64 rand;
} __attribute__((packed));

struct smp_cmd_ident_info {
	__u8 irk[16];
};

struct smp_cmd_ident_addr_info {
	__u8 addr_type;
	bdaddr_t bdaddr;
};

struct smp_cmd_sign_info {
	__u8 csrk[16];
};

struct smp_cmd_security_req {
	__u8 auth_req;
};

struct smp_cmd_public_key {
	__u8 x[32];
	__u8 y[32];
};

struct smp_cmd_dhkey_check {
	__u8 e[16];
};

struct smp_cmd_keypress_notify {
	__u8 value;
};

enum {
	SMP_FLAG_TK_VALID = 0,
	SMP_FLAG_CFM_PENDING = 1,
	SMP_FLAG_MITM_AUTH = 2,
	SMP_FLAG_COMPLETE = 3,
	SMP_FLAG_INITIATOR = 4,
	SMP_FLAG_SC = 5,
	SMP_FLAG_REMOTE_PK = 6,
	SMP_FLAG_DEBUG_KEY = 7,
	SMP_FLAG_WAIT_USER = 8,
	SMP_FLAG_DHKEY_PENDING = 9,
	SMP_FLAG_REMOTE_OOB = 10,
	SMP_FLAG_LOCAL_OOB = 11,
	SMP_FLAG_CT2 = 12,
};

struct smp_dev {
	bool local_oob;
	u8 local_pk[64];
	u8 local_rand[16];
	bool debug_key;
	struct crypto_shash *tfm_cmac;
	struct crypto_kpp *tfm_ecdh;
};

struct smp_chan {
	struct l2cap_conn *conn;
	struct delayed_work security_timer;
	long unsigned int allow_cmd;
	u8 preq[7];
	u8 prsp[7];
	u8 prnd[16];
	u8 rrnd[16];
	u8 pcnf[16];
	u8 tk[16];
	u8 rr[16];
	u8 lr[16];
	u8 enc_key_size;
	u8 remote_key_dist;
	bdaddr_t id_addr;
	u8 id_addr_type;
	u8 irk[16];
	struct smp_csrk *csrk;
	struct smp_csrk *responder_csrk;
	struct smp_ltk *ltk;
	struct smp_ltk *responder_ltk;
	struct smp_irk *remote_irk;
	u8 *link_key;
	long unsigned int flags;
	u8 method;
	u8 passkey_round;
	u8 local_pk[64];
	u8 remote_pk[64];
	u8 dhkey[32];
	u8 mackey[16];
	struct crypto_shash *tfm_cmac;
	struct crypto_kpp *tfm_ecdh;
};

struct ecdh_completion {
	struct completion completion;
	int err;
};

struct mgmt_ev_cmd_complete {
	__le16 opcode;
	__u8 status;
	__u8 data[0];
} __attribute__((packed));

struct mgmt_ev_cmd_status {
	__le16 opcode;
	__u8 status;
} __attribute__((packed));

struct mgmt_tlv {
	__le16 type;
	__u8 length;
	__u8 value[0];
} __attribute__((packed));

struct mgmt_rp_read_def_system_config {
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_page_scan_type;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_page_scan_int;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_page_scan_window;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_inq_scan_type;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_inq_scan_int;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_inq_scan_window;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_br_lsto;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_page_timeout;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) sniff_min_interval;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) sniff_max_interval;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_adv_min_interval;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_adv_max_interval;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_multi_adv_rotation_duration;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_interval;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_window;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_int_suspend;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_window_suspend;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_int_discovery;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_window_discovery;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_int_adv_monitor;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_window_adv_monitor;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_int_connect;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_scan_window_connect;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_conn_min_interval;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_conn_max_interval;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_conn_latency;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) le_supv_timeout;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) def_le_autoconnect_timeout;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) advmon_allowlist_duration;
	struct {
		struct mgmt_tlv entry;
		__le16 value;
	} __attribute__((packed)) advmon_no_filter_duration;
	struct {
		struct mgmt_tlv entry;
		__u8 value;
	} enable_advmon_interleave_scan;
} __attribute__((packed));

struct hci_std_codecs {
	__u8 num;
	__u8 codec[0];
};

struct hci_vnd_codec {
	__le16 cid;
	__le16 vid;
};

struct hci_vnd_codecs {
	__u8 num;
	struct hci_vnd_codec codec[0];
} __attribute__((packed));

struct hci_rp_read_local_supported_codecs {
	__u8 status;
	struct hci_std_codecs std_codecs;
	struct hci_vnd_codecs vnd_codecs;
} __attribute__((packed));

struct hci_std_codec_v2 {
	__u8 id;
	__u8 transport;
};

struct hci_std_codecs_v2 {
	__u8 num;
	struct hci_std_codec_v2 codec[0];
};

struct hci_vnd_codec_v2 {
	__le16 cid;
	__le16 vid;
	__u8 transport;
} __attribute__((packed));

struct hci_vnd_codecs_v2 {
	__u8 num;
	struct hci_vnd_codec_v2 codec[0];
} __attribute__((packed));

struct hci_rp_read_local_supported_codecs_v2 {
	__u8 status;
	struct hci_std_codecs_v2 std_codecs;
	struct hci_vnd_codecs_v2 vendor_codecs;
} __attribute__((packed));

struct hci_op_read_local_codec_caps {
	__u8 id;
	__le16 cid;
	__le16 vid;
	__u8 transport;
	__u8 direction;
} __attribute__((packed));

struct hci_codec_caps {
	__u8 len;
	__u8 data[0];
};

struct hci_rp_read_local_codec_caps {
	__u8 status;
	__u8 num_caps;
};

struct codec_list {
	struct list_head list;
	u8 id;
	__u16 cid;
	__u16 vid;
	u8 transport;
	u8 num_caps;
	u32 len;
	struct hci_codec_caps caps[0];
};

struct hci_cp_remote_name_req_cancel {
	bdaddr_t bdaddr;
};

struct hci_cp_write_def_link_policy {
	__le16 policy;
};

struct hci_cp_delete_stored_link_key {
	bdaddr_t bdaddr;
	__u8 delete_all;
};

struct hci_cp_write_local_name {
	__u8 name[248];
};

struct hci_cp_write_current_iac_lap {
	__u8 num_iac;
	__u8 iac_lap[6];
};

struct hci_cp_write_eir {
	__u8 fec;
	__u8 data[240];
};

struct hci_cp_read_local_ext_features {
	__u8 page;
};

struct hci_cp_read_rssi {
	__le16 handle;
};

struct hci_cp_le_set_adv_data {
	__u8 length;
	__u8 data[31];
};

struct hci_cp_le_set_scan_rsp_data {
	__u8 length;
	__u8 data[31];
};

struct hci_cp_le_ext_conn_param {
	__le16 scan_interval;
	__le16 scan_window;
	__le16 conn_interval_min;
	__le16 conn_interval_max;
	__le16 conn_latency;
	__le16 supervision_timeout;
	__le16 min_ce_len;
	__le16 max_ce_len;
};

struct hci_cp_le_set_ext_adv_data {
	__u8 handle;
	__u8 operation;
	__u8 frag_pref;
	__u8 length;
	__u8 data[0];
};

struct hci_cp_le_set_ext_scan_rsp_data {
	__u8 handle;
	__u8 operation;
	__u8 frag_pref;
	__u8 length;
	__u8 data[0];
};

struct hci_cp_le_set_per_adv_data {
	__u8 handle;
	__u8 operation;
	__u8 length;
	__u8 data[0];
};

struct hci_cp_le_set_per_adv_enable {
	__u8 enable;
	__u8 handle;
};

struct hci_cp_le_remove_cig {
	__u8 cig_id;
};

struct hci_cp_le_term_big {
	__u8 handle;
	__u8 reason;
};

struct hci_cp_le_big_term_sync {
	__u8 handle;
};

struct hci_cp_le_set_host_feature {
	__u8 bit_number;
	__u8 bit_value;
};

typedef int (*hci_cmd_sync_work_func_t)(struct hci_dev *, void *);

typedef void (*hci_cmd_sync_work_destroy_t)(struct hci_dev *, void *, int);

struct hci_cmd_sync_work_entry {
	struct list_head list;
	hci_cmd_sync_work_func_t func;
	void *data;
	hci_cmd_sync_work_destroy_t destroy;
};

struct hci_init_stage {
	int (*func)(struct hci_dev *);
};

struct bt_voice {
	__u16 setting;
};

struct bt_codecs {
	__u8 num_codecs;
	struct bt_codec codecs[0];
} __attribute__((packed));

struct sockaddr_sco {
	sa_family_t sco_family;
	bdaddr_t sco_bdaddr;
};

struct sco_options {
	__u16 mtu;
};

struct sco_conninfo {
	__u16 hci_handle;
	__u8 dev_class[3];
};

struct sco_conn {
	struct hci_conn *hcon;
	spinlock_t lock;
	struct sock *sk;
	struct delayed_work timeout_work;
	unsigned int mtu;
};

struct sco_pinfo {
	struct bt_sock bt;
	bdaddr_t src;
	bdaddr_t dst;
	__u32 flags;
	__u16 setting;
	__u8 cmsg_mask;
	struct bt_codec codec;
	short: 16;
	struct sco_conn *conn;
} __attribute__((packed));

struct hci_iso_data_hdr {
	__le16 sn;
	__le16 slen;
};

struct sockaddr_iso_bc {
	bdaddr_t bc_bdaddr;
	__u8 bc_bdaddr_type;
	__u8 bc_sid;
	__u8 bc_num_bis;
	__u8 bc_bis[31];
};

struct sockaddr_iso {
	sa_family_t iso_family;
	bdaddr_t iso_bdaddr;
	__u8 iso_bdaddr_type;
	struct sockaddr_iso_bc iso_bc[0];
};

struct iso_conn {
	struct hci_conn *hcon;
	spinlock_t lock;
	struct sock *sk;
	struct delayed_work timeout_work;
	struct sk_buff *rx_skb;
	__u32 rx_len;
	__u16 tx_sn;
};

struct iso_pinfo {
	struct bt_sock bt;
	bdaddr_t src;
	__u8 src_type;
	bdaddr_t dst;
	__u8 dst_type;
	__u8 bc_sid;
	__u8 bc_num_bis;
	__u8 bc_bis[31];
	__u16 sync_handle;
	__u32 flags;
	struct bt_iso_qos qos;
	__u8 base_len;
	__u8 base[248];
	struct iso_conn *conn;
};

typedef bool (*iso_sock_match_t)(struct sock *, void *);

struct hci_ev_le_big_sync_estabilished;

struct rfcomm_hdr {
	u8 addr;
	u8 ctrl;
	u8 len;
};

struct rfcomm_cmd {
	u8 addr;
	u8 ctrl;
	u8 len;
	u8 fcs;
};

struct rfcomm_mcc {
	u8 type;
	u8 len;
};

struct rfcomm_pn {
	u8 dlci;
	u8 flow_ctrl;
	u8 priority;
	u8 ack_timer;
	__le16 mtu;
	u8 max_retrans;
	u8 credits;
};

struct rfcomm_rpn {
	u8 dlci;
	u8 bit_rate;
	u8 line_settings;
	u8 flow_ctrl;
	u8 xon_char;
	u8 xoff_char;
	__le16 param_mask;
};

struct rfcomm_rls {
	u8 dlci;
	u8 status;
};

struct rfcomm_msc {
	u8 dlci;
	u8 v24_sig;
};

struct rfcomm_session {
	struct list_head list;
	struct socket *sock;
	struct timer_list timer;
	long unsigned int state;
	long unsigned int flags;
	int initiator;
	int cfc;
	uint mtu;
	struct list_head dlcs;
};

struct rfcomm_dlc {
	struct list_head list;
	struct rfcomm_session *session;
	struct sk_buff_head tx_queue;
	struct timer_list timer;
	struct mutex lock;
	long unsigned int state;
	long unsigned int flags;
	refcount_t refcnt;
	u8 dlci;
	u8 addr;
	u8 priority;
	u8 v24_sig;
	u8 remote_v24_sig;
	u8 mscex;
	u8 out;
	u8 sec_level;
	u8 role_switch;
	u32 defer_setup;
	uint mtu;
	uint cfc;
	uint rx_credits;
	uint tx_credits;
	void *owner;
	void (*data_ready)(struct rfcomm_dlc *, struct sk_buff *);
	void (*state_change)(struct rfcomm_dlc *, int);
	void (*modem_status)(struct rfcomm_dlc *, u8);
};

struct sockaddr_rc {
	sa_family_t rc_family;
	bdaddr_t rc_bdaddr;
	u8 rc_channel;
};

struct rfcomm_conninfo {
	__u16 hci_handle;
	__u8 dev_class[3];
};

struct rfcomm_pinfo {
	struct bt_sock bt;
	bdaddr_t src;
	bdaddr_t dst;
	struct rfcomm_dlc *dlc;
	u8 channel;
	u8 sec_level;
	u8 role_switch;
	int: 8;
	int: 32;
};

struct rfcomm_dev_req {
	s16 dev_id;
	u32 flags;
	bdaddr_t src;
	bdaddr_t dst;
	u8 channel;
};

struct rfcomm_dev_info {
	s16 id;
	u32 flags;
	u16 state;
	bdaddr_t src;
	bdaddr_t dst;
	u8 channel;
};

struct rfcomm_dev_list_req {
	u16 dev_num;
	struct rfcomm_dev_info dev_info[0];
};

struct rfcomm_dev {
	struct tty_port port;
	struct list_head list;
	char name[12];
	int id;
	long unsigned int flags;
	int err;
	long unsigned int status;
	bdaddr_t src;
	bdaddr_t dst;
	u8 channel;
	uint modem_status;
	struct rfcomm_dlc *dlc;
	struct device *tty_dev;
	atomic_t wmem_alloc;
	struct sk_buff_head pending;
};

struct bnep_control_rsp {
	__u8 type;
	__u8 ctrl;
	__be16 resp;
};

struct bnep_ext_hdr {
	__u8 type;
	__u8 len;
	__u8 data[0];
};

struct bnep_connadd_req {
	int sock;
	__u32 flags;
	__u16 role;
	char device[16];
};

struct bnep_conndel_req {
	__u32 flags;
	__u8 dst[6];
};

struct bnep_conninfo {
	__u32 flags;
	__u16 role;
	__u16 state;
	__u8 dst[6];
	char device[16];
};

struct bnep_connlist_req {
	__u32 cnum;
	struct bnep_conninfo *ci;
};

struct bnep_proto_filter {
	__u16 start;
	__u16 end;
};

struct bnep_session {
	struct list_head list;
	unsigned int role;
	long unsigned int state;
	long unsigned int flags;
	atomic_t terminate;
	struct task_struct *task;
	struct ethhdr eh;
	int: 16;
	int: 32;
	struct msghdr msg;
	struct bnep_proto_filter proto_filter[5];
	int: 32;
	long long unsigned int mc_filter;
	struct socket *sock;
	struct net_device *dev;
};

struct bnep_set_filter_req {
	__u8 type;
	__u8 ctrl;
	__be16 len;
	__u8 list[0];
};

struct hidp_connadd_req {
	int ctrl_sock;
	int intr_sock;
	__u16 parser;
	__u16 rd_size;
	__u8 *rd_data;
	__u8 country;
	__u8 subclass;
	__u16 vendor;
	__u16 product;
	__u16 version;
	__u32 flags;
	__u32 idle_to;
	char name[128];
};

struct hidp_conndel_req {
	bdaddr_t bdaddr;
	__u32 flags;
};

struct hidp_conninfo {
	bdaddr_t bdaddr;
	__u32 flags;
	__u16 state;
	__u16 vendor;
	__u16 product;
	__u16 version;
	char name[128];
};

struct hidp_connlist_req {
	__u32 cnum;
	struct hidp_conninfo *ci;
};

enum hidp_session_state {
	HIDP_SESSION_IDLING = 0,
	HIDP_SESSION_PREPARING = 1,
	HIDP_SESSION_RUNNING = 2,
};

struct hidp_session {
	struct list_head list;
	struct kref ref;
	atomic_t state;
	wait_queue_head_t state_queue;
	atomic_t terminate;
	struct task_struct *task;
	long unsigned int flags;
	bdaddr_t bdaddr;
	struct l2cap_conn *conn;
	struct l2cap_user user;
	struct socket *ctrl_sock;
	struct socket *intr_sock;
	struct sk_buff_head ctrl_transmit;
	struct sk_buff_head intr_transmit;
	uint ctrl_mtu;
	uint intr_mtu;
	long unsigned int idle_to;
	struct work_struct dev_init;
	struct input_dev *input;
	struct hid_device *hid;
	struct timer_list timer;
	__u8 *rd_data;
	uint rd_size;
	unsigned char keys[8];
	unsigned char leds;
	int waiting_report_type;
	int waiting_report_number;
	struct mutex report_mutex;
	struct sk_buff *report_return;
	wait_queue_head_t report_queue;
	int output_report_success;
	u8 input_buf[16384];
};

enum rpc_msg_type {
	RPC_CALL = 0,
	RPC_REPLY = 1,
};

enum rpc_reply_stat {
	RPC_MSG_ACCEPTED = 0,
	RPC_MSG_DENIED = 1,
};

enum rpc_reject_stat {
	RPC_MISMATCH = 0,
	RPC_AUTH_ERROR = 1,
};

struct rpc_sysfs_xprt {
	struct kobject kobject;
	struct rpc_xprt *xprt;
	struct rpc_xprt_switch *xprt_switch;
};

enum {
	SUNRPC_PIPEFS_NFS_PRIO = 0,
	SUNRPC_PIPEFS_RPC_PRIO = 1,
};

enum {
	RPC_PIPEFS_MOUNT = 0,
	RPC_PIPEFS_UMOUNT = 1,
};

struct rpc_sysfs_xprt_switch {
	struct kobject kobject;
	struct net *net;
	struct rpc_xprt_switch *xprt_switch;
	struct rpc_xprt *xprt;
};

struct rpc_sysfs_client {
	struct kobject kobject;
	struct net *net;
	struct rpc_clnt *clnt;
	struct rpc_xprt_switch *xprt_switch;
};

struct sunrpc_net {
	struct proc_dir_entry *proc_net_rpc;
	struct cache_detail *ip_map_cache;
	struct cache_detail *unix_gid_cache;
	struct cache_detail *rsc_cache;
	struct cache_detail *rsi_cache;
	struct super_block *pipefs_sb;
	struct rpc_pipe *gssd_dummy;
	struct mutex pipefs_sb_lock;
	struct list_head all_clients;
	spinlock_t rpc_client_lock;
	struct rpc_clnt *rpcb_local_clnt;
	struct rpc_clnt *rpcb_local_clnt4;
	spinlock_t rpcb_clnt_lock;
	unsigned int rpcb_users;
	unsigned int rpcb_is_af_local: 1;
	struct mutex gssp_lock;
	struct rpc_clnt *gssp_clnt;
	int use_gss_proxy;
	int pipe_version;
	atomic_t pipe_users;
	struct proc_dir_entry *use_gssp_proc;
};

struct rpc_cb_add_xprt_calldata {
	struct rpc_xprt_switch *xps;
	struct rpc_xprt *xprt;
};

struct connect_timeout_data {
	long unsigned int connect_timeout;
	long unsigned int reconnect_timeout;
};

enum xprt_xid_rb_cmp {
	XID_RB_EQUAL = 0,
	XID_RB_LEFT = 1,
	XID_RB_RIGHT = 2,
};

typedef __be32 rpc_fraghdr;

struct xdr_skb_reader {
	struct sk_buff *skb;
	unsigned int offset;
	size_t count;
	__wsum csum;
};

typedef size_t (*xdr_skb_read_actor)(struct xdr_skb_reader *, void *, size_t);

struct svc_sock {
	struct svc_xprt sk_xprt;
	struct socket *sk_sock;
	struct sock *sk_sk;
	void (*sk_ostate)(struct sock *);
	void (*sk_odata)(struct sock *);
	void (*sk_owspace)(struct sock *);
	__be32 sk_marker;
	u32 sk_tcplen;
	u32 sk_datalen;
	atomic_t sk_sendqlen;
	struct page *sk_pages[259];
};

struct sock_xprt {
	struct rpc_xprt xprt;
	struct socket *sock;
	struct sock *inet;
	struct file *file;
	struct {
		struct {
			__be32 fraghdr;
			__be32 xid;
			__be32 calldir;
		};
		u32 offset;
		u32 len;
		long unsigned int copied;
	} recv;
	struct {
		u32 offset;
	} xmit;
	long unsigned int sock_state;
	struct delayed_work connect_worker;
	struct work_struct error_worker;
	struct work_struct recv_worker;
	struct mutex recv_mutex;
	struct __kernel_sockaddr_storage srcaddr;
	short unsigned int srcport;
	int xprt_err;
	size_t rcvsize;
	size_t sndsize;
	struct rpc_timeout tcp_timeout;
	void (*old_data_ready)(struct sock *);
	void (*old_state_change)(struct sock *);
	void (*old_write_space)(struct sock *);
	void (*old_error_report)(struct sock *);
};

struct rpc_buffer {
	size_t len;
	char data[0];
};

typedef void (*rpc_action)(struct rpc_task *);

struct trace_event_raw_rpc_xdr_buf_class {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_class {
	struct trace_entry ent;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new {
	struct trace_entry ent;
	unsigned int client_id;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_new_err {
	struct trace_entry ent;
	int error;
	u32 __data_loc_program;
	u32 __data_loc_server;
	char __data[0];
};

struct trace_event_raw_rpc_clnt_clone_err {
	struct trace_entry ent;
	unsigned int client_id;
	int error;
	char __data[0];
};

struct trace_event_raw_rpc_task_status {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_request {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	bool async;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_rpc_task_running {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	const void *action;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	char __data[0];
};

struct trace_event_raw_rpc_task_queued {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	long unsigned int timeout;
	long unsigned int runstate;
	int status;
	short unsigned int flags;
	u32 __data_loc_q_name;
	char __data[0];
};

struct trace_event_raw_rpc_failure {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpc_reply_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 __data_loc_progname;
	u32 version;
	u32 __data_loc_procname;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpc_buf_alloc {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	size_t callsize;
	size_t recvsize;
	int status;
	char __data[0];
};

struct trace_event_raw_rpc_call_rpcerror {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int tk_status;
	int rpc_status;
	char __data[0];
};

struct trace_event_raw_rpc_stats_latency {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int version;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	long unsigned int backlog;
	long unsigned int rtt;
	long unsigned int execute;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_overflow {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t requested;
	const void *end;
	const void *p;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_rpc_xdr_alignment {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int version;
	size_t offset;
	unsigned int copied;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int len;
	u32 __data_loc_progname;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_xs_socket_event {
	struct trace_entry ent;
	unsigned int socket_state;
	unsigned int sock_state;
	long long unsigned int ino;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_xs_socket_event_done {
	struct trace_entry ent;
	int error;
	unsigned int socket_state;
	unsigned int sock_state;
	int: 32;
	long long unsigned int ino;
	__u8 saddr[28];
	__u8 daddr[28];
	char __data[0];
};

struct trace_event_raw_rpc_socket_nospace {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int total;
	unsigned int remaining;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_lifetime_class {
	struct trace_entry ent;
	long unsigned int state;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_rpc_xprt_event {
	struct trace_entry ent;
	u32 xid;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_transmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	int status;
	char __data[0];
};

struct trace_event_raw_xprt_retransmit {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	int ntrans;
	int version;
	long unsigned int timeout;
	u32 __data_loc_progname;
	u32 __data_loc_procname;
	char __data[0];
};

struct trace_event_raw_xprt_ping {
	struct trace_entry ent;
	int status;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xprt_writelock_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	char __data[0];
};

struct trace_event_raw_xprt_cong_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int snd_task_id;
	long unsigned int cong;
	long unsigned int cwnd;
	bool wait;
	char __data[0];
};

struct trace_event_raw_xprt_reserve {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	char __data[0];
};

struct trace_event_raw_xs_data_ready {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_data {
	struct trace_entry ent;
	ssize_t err;
	size_t total;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	char __data[0];
};

struct trace_event_raw_xs_stream_read_request {
	struct trace_entry ent;
	u32 __data_loc_addr;
	u32 __data_loc_port;
	u32 xid;
	long unsigned int copied;
	unsigned int reclen;
	unsigned int offset;
	char __data[0];
};

struct trace_event_raw_rpcb_getport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int bind_version;
	u32 __data_loc_servername;
	char __data[0];
};

struct trace_event_raw_rpcb_setport {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	int status;
	short unsigned int port;
	char __data[0];
};

struct trace_event_raw_pmap_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	int protocol;
	unsigned int port;
	char __data[0];
};

struct trace_event_raw_rpcb_register {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_addr;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_rpcb_unregister {
	struct trace_entry ent;
	unsigned int program;
	unsigned int version;
	u32 __data_loc_netid;
	char __data[0];
};

struct trace_event_raw_svc_xdr_msg_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_xdr_buf_class {
	struct trace_entry ent;
	u32 xid;
	const void *head_base;
	size_t head_len;
	const void *tail_base;
	size_t tail_len;
	unsigned int page_base;
	unsigned int page_len;
	unsigned int msg_len;
	char __data[0];
};

struct trace_event_raw_svc_authenticate {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	long unsigned int svc_status;
	long unsigned int auth_stat;
	char __data[0];
};

struct trace_event_raw_svc_process {
	struct trace_entry ent;
	u32 xid;
	u32 vers;
	u32 proc;
	u32 __data_loc_service;
	u32 __data_loc_procedure;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_rqst_event {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_svc_rqst_status {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	int status;
	long unsigned int flags;
	char __data[0];
};

struct trace_event_raw_svc_stats_latency {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	unsigned int netns_ino;
	u32 xid;
	long unsigned int execute;
	u32 __data_loc_procedure;
	char __data[0];
};

struct trace_event_raw_svc_xprt_create_err {
	struct trace_entry ent;
	long int error;
	u32 __data_loc_program;
	u32 __data_loc_protocol;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svc_xprt_enqueue {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	int pid;
	char __data[0];
};

struct trace_event_raw_svc_xprt_dequeue {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	long unsigned int wakeup;
	char __data[0];
};

struct trace_event_raw_svc_xprt_event {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_svc_xprt_accept {
	struct trace_entry ent;
	u32 __data_loc_server;
	u32 __data_loc_client;
	long unsigned int flags;
	unsigned int netns_ino;
	u32 __data_loc_protocol;
	u32 __data_loc_service;
	char __data[0];
};

struct trace_event_raw_svc_wake_up {
	struct trace_entry ent;
	int pid;
	char __data[0];
};

struct trace_event_raw_svc_alloc_arg_err {
	struct trace_entry ent;
	unsigned int requested;
	unsigned int allocated;
	char __data[0];
};

struct trace_event_raw_svc_deferred_event {
	struct trace_entry ent;
	const void *dr;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_new_socket {
	struct trace_entry ent;
	long unsigned int type;
	long unsigned int family;
	bool listener;
	char __data[0];
};

struct trace_event_raw_svcsock_marker {
	struct trace_entry ent;
	unsigned int length;
	bool last;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_class {
	struct trace_entry ent;
	ssize_t result;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_recv_short {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_tcp_state {
	struct trace_entry ent;
	long unsigned int socket_state;
	long unsigned int sock_state;
	long unsigned int flags;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_svcsock_accept_class {
	struct trace_entry ent;
	long int status;
	u32 __data_loc_service;
	unsigned int netns_ino;
	char __data[0];
};

struct trace_event_raw_cache_event {
	struct trace_entry ent;
	const struct cache_head *h;
	u32 __data_loc_name;
	char __data[0];
};

struct trace_event_raw_register_class {
	struct trace_entry ent;
	u32 version;
	long unsigned int family;
	short unsigned int protocol;
	short unsigned int port;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_raw_svc_unregister {
	struct trace_entry ent;
	u32 version;
	int error;
	u32 __data_loc_program;
	char __data[0];
};

struct trace_event_data_offsets_rpc_xdr_buf_class {};

struct trace_event_data_offsets_rpc_clnt_class {};

struct trace_event_data_offsets_rpc_clnt_new {
	u32 addr;
	u32 port;
	u32 program;
	u32 server;
};

struct trace_event_data_offsets_rpc_clnt_new_err {
	u32 program;
	u32 server;
};

struct trace_event_data_offsets_rpc_clnt_clone_err {};

struct trace_event_data_offsets_rpc_task_status {};

struct trace_event_data_offsets_rpc_request {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_task_running {};

struct trace_event_data_offsets_rpc_task_queued {
	u32 q_name;
};

struct trace_event_data_offsets_rpc_failure {};

struct trace_event_data_offsets_rpc_reply_event {
	u32 progname;
	u32 procname;
	u32 servername;
};

struct trace_event_data_offsets_rpc_buf_alloc {};

struct trace_event_data_offsets_rpc_call_rpcerror {};

struct trace_event_data_offsets_rpc_stats_latency {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_rpc_xdr_overflow {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_rpc_xdr_alignment {
	u32 progname;
	u32 procedure;
};

struct trace_event_data_offsets_xs_socket_event {};

struct trace_event_data_offsets_xs_socket_event_done {};

struct trace_event_data_offsets_rpc_socket_nospace {};

struct trace_event_data_offsets_rpc_xprt_lifetime_class {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpc_xprt_event {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xprt_transmit {};

struct trace_event_data_offsets_xprt_retransmit {
	u32 progname;
	u32 procname;
};

struct trace_event_data_offsets_xprt_ping {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xprt_writelock_event {};

struct trace_event_data_offsets_xprt_cong_event {};

struct trace_event_data_offsets_xprt_reserve {};

struct trace_event_data_offsets_xs_data_ready {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xs_stream_read_data {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_xs_stream_read_request {
	u32 addr;
	u32 port;
};

struct trace_event_data_offsets_rpcb_getport {
	u32 servername;
};

struct trace_event_data_offsets_rpcb_setport {};

struct trace_event_data_offsets_pmap_register {};

struct trace_event_data_offsets_rpcb_register {
	u32 addr;
	u32 netid;
};

struct trace_event_data_offsets_rpcb_unregister {
	u32 netid;
};

struct trace_event_data_offsets_svc_xdr_msg_class {};

struct trace_event_data_offsets_svc_xdr_buf_class {};

struct trace_event_data_offsets_svc_authenticate {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_process {
	u32 service;
	u32 procedure;
	u32 addr;
};

struct trace_event_data_offsets_svc_rqst_event {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_rqst_status {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_stats_latency {
	u32 server;
	u32 client;
	u32 procedure;
};

struct trace_event_data_offsets_svc_xprt_create_err {
	u32 program;
	u32 protocol;
	u32 addr;
};

struct trace_event_data_offsets_svc_xprt_enqueue {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_xprt_dequeue {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_xprt_event {
	u32 server;
	u32 client;
};

struct trace_event_data_offsets_svc_xprt_accept {
	u32 server;
	u32 client;
	u32 protocol;
	u32 service;
};

struct trace_event_data_offsets_svc_wake_up {};

struct trace_event_data_offsets_svc_alloc_arg_err {};

struct trace_event_data_offsets_svc_deferred_event {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_new_socket {};

struct trace_event_data_offsets_svcsock_marker {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_class {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_recv_short {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_tcp_state {
	u32 addr;
};

struct trace_event_data_offsets_svcsock_accept_class {
	u32 service;
};

struct trace_event_data_offsets_cache_event {
	u32 name;
};

struct trace_event_data_offsets_register_class {
	u32 program;
};

struct trace_event_data_offsets_svc_unregister {
	u32 program;
};

typedef void (*btf_trace_rpc_xdr_sendto)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_recvfrom)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_xdr_reply_pages)(void *, const struct rpc_task *, const struct xdr_buf *);

typedef void (*btf_trace_rpc_clnt_free)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_killall)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_shutdown)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_release)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_replace_xprt_err)(void *, const struct rpc_clnt *);

typedef void (*btf_trace_rpc_clnt_new)(void *, const struct rpc_clnt *, const struct rpc_xprt *, const char *, const char *);

typedef void (*btf_trace_rpc_clnt_new_err)(void *, const char *, const char *, int);

typedef void (*btf_trace_rpc_clnt_clone_err)(void *, const struct rpc_clnt *, int);

typedef void (*btf_trace_rpc_call_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_connect_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_timeout_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_retry_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_refresh_status)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_request)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_task_begin)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_run_action)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_sleep)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sync_wake)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_complete)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_timeout)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_signalled)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_end)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_call_done)(void *, const struct rpc_task *, const void *);

typedef void (*btf_trace_rpc_task_sleep)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_task_wakeup)(void *, const struct rpc_task *, const struct rpc_wait_queue *);

typedef void (*btf_trace_rpc_bad_callhdr)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_bad_verifier)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__prog_mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__proc_unavail)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__garbage_args)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__unparsable)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__mismatch)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__stale_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__bad_creds)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc__auth_tooweak)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_prog_unavail_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_timeout_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_bind_version_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unreachable_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcb_unrecognized_err)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpc_buf_alloc)(void *, const struct rpc_task *, int);

typedef void (*btf_trace_rpc_call_rpcerror)(void *, const struct rpc_task *, int, int);

typedef void (*btf_trace_rpc_stats_latency)(void *, const struct rpc_task *, ktime_t, ktime_t, ktime_t);

typedef void (*btf_trace_rpc_xdr_overflow)(void *, const struct xdr_stream *, size_t);

typedef void (*btf_trace_rpc_xdr_alignment)(void *, const struct xdr_stream *, size_t, unsigned int);

typedef void (*btf_trace_rpc_socket_state_change)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_connect)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_error)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_reset_connection)(void *, struct rpc_xprt *, struct socket *, int);

typedef void (*btf_trace_rpc_socket_close)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_shutdown)(void *, struct rpc_xprt *, struct socket *);

typedef void (*btf_trace_rpc_socket_nospace)(void *, const struct rpc_rqst *, const struct sock_xprt *);

typedef void (*btf_trace_xprt_create)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_connect)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_auto)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_done)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_disconnect_force)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_destroy)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xprt_timer)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_lookup_rqst)(void *, const struct rpc_xprt *, __be32, int);

typedef void (*btf_trace_xprt_transmit)(void *, const struct rpc_rqst *, int);

typedef void (*btf_trace_xprt_retransmit)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xprt_ping)(void *, const struct rpc_xprt *, int);

typedef void (*btf_trace_xprt_reserve_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_xprt)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_release_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_get_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_put_cong)(void *, const struct rpc_xprt *, const struct rpc_task *);

typedef void (*btf_trace_xprt_reserve)(void *, const struct rpc_rqst *);

typedef void (*btf_trace_xs_data_ready)(void *, const struct rpc_xprt *);

typedef void (*btf_trace_xs_stream_read_data)(void *, struct rpc_xprt *, ssize_t, size_t);

typedef void (*btf_trace_xs_stream_read_request)(void *, struct sock_xprt *);

typedef void (*btf_trace_rpcb_getport)(void *, const struct rpc_clnt *, const struct rpc_task *, unsigned int);

typedef void (*btf_trace_rpcb_setport)(void *, const struct rpc_task *, int, short unsigned int);

typedef void (*btf_trace_pmap_register)(void *, u32, u32, int, short unsigned int);

typedef void (*btf_trace_rpcb_register)(void *, u32, u32, const char *, const char *);

typedef void (*btf_trace_rpcb_unregister)(void *, u32, u32, const char *);

typedef void (*btf_trace_svc_xdr_recvfrom)(void *, const struct xdr_buf *);

typedef void (*btf_trace_svc_xdr_sendto)(void *, __be32, const struct xdr_buf *);

typedef void (*btf_trace_svc_authenticate)(void *, const struct svc_rqst *, int);

typedef void (*btf_trace_svc_process)(void *, const struct svc_rqst *, const char *);

typedef void (*btf_trace_svc_defer)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_drop)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_send)(void *, const struct svc_rqst *, int);

typedef void (*btf_trace_svc_stats_latency)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_create_err)(void *, const char *, const char *, struct sockaddr *, size_t, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_enqueue)(void *, const struct svc_xprt *, const struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_dequeue)(void *, const struct svc_rqst *);

typedef void (*btf_trace_svc_xprt_no_write_space)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_close)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_detach)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_free)(void *, const struct svc_xprt *);

typedef void (*btf_trace_svc_xprt_accept)(void *, const struct svc_xprt *, const char *);

typedef void (*btf_trace_svc_wake_up)(void *, int);

typedef void (*btf_trace_svc_alloc_arg_err)(void *, unsigned int, unsigned int);

typedef void (*btf_trace_svc_defer_drop)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_queue)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svc_defer_recv)(void *, const struct svc_deferred_req *);

typedef void (*btf_trace_svcsock_new_socket)(void *, const struct socket *);

typedef void (*btf_trace_svcsock_marker)(void *, const struct svc_xprt *, __be32);

typedef void (*btf_trace_svcsock_udp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_udp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_send)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_eagain)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_err)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_data_ready)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_write_space)(void *, const struct svc_xprt *, ssize_t);

typedef void (*btf_trace_svcsock_tcp_recv_short)(void *, const struct svc_xprt *, u32, u32);

typedef void (*btf_trace_svcsock_tcp_state)(void *, const struct svc_xprt *, const struct socket *);

typedef void (*btf_trace_svcsock_accept_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_svcsock_getpeername_err)(void *, const struct svc_xprt *, const char *, long int);

typedef void (*btf_trace_cache_entry_expired)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_upcall)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_update)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_make_negative)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_cache_entry_no_listener)(void *, const struct cache_detail *, const struct cache_head *);

typedef void (*btf_trace_svc_register)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_noregister)(void *, const char *, const u32, const int, const short unsigned int, const short unsigned int, int);

typedef void (*btf_trace_svc_unregister)(void *, const char *, const u32, int);

struct rpc_cred_cache {
	struct hlist_head *hashtable;
	unsigned int hashbits;
	spinlock_t lock;
};

enum {
	SVC_POOL_AUTO = 4294967295,
	SVC_POOL_GLOBAL = 0,
	SVC_POOL_PERCPU = 1,
	SVC_POOL_PERNODE = 2,
};

struct svc_pool_map {
	int count;
	int mode;
	unsigned int npools;
	unsigned int *pool_to;
	unsigned int *to_pool;
};

struct unix_domain {
	struct auth_domain h;
};

struct ip_map {
	struct cache_head h;
	char m_class[8];
	struct in6_addr m_addr;
	struct unix_domain *m_client;
	struct callback_head m_rcu;
	int: 32;
};

struct unix_gid {
	struct cache_head h;
	kuid_t uid;
	struct group_info *gi;
	struct callback_head rcu;
};

enum {
	RPCBPROC_NULL = 0,
	RPCBPROC_SET = 1,
	RPCBPROC_UNSET = 2,
	RPCBPROC_GETPORT = 3,
	RPCBPROC_GETADDR = 3,
	RPCBPROC_DUMP = 4,
	RPCBPROC_CALLIT = 5,
	RPCBPROC_BCAST = 5,
	RPCBPROC_GETTIME = 6,
	RPCBPROC_UADDR2TADDR = 7,
	RPCBPROC_TADDR2UADDR = 8,
	RPCBPROC_GETVERSADDR = 9,
	RPCBPROC_INDIRECT = 10,
	RPCBPROC_GETADDRLIST = 11,
	RPCBPROC_GETSTAT = 12,
};

struct rpcbind_args {
	struct rpc_xprt *r_xprt;
	u32 r_prog;
	u32 r_vers;
	u32 r_prot;
	short unsigned int r_port;
	const char *r_netid;
	const char *r_addr;
	const char *r_owner;
	int r_status;
};

struct rpcb_info {
	u32 rpc_vers;
	const struct rpc_procinfo *rpc_proc;
};

struct thread_deferred_req {
	struct cache_deferred_req handle;
	struct completion completion;
};

struct cache_queue {
	struct list_head list;
	int reader;
};

struct cache_request {
	struct cache_queue q;
	struct cache_head *item;
	char *buf;
	int len;
	int readers;
};

struct cache_reader {
	struct cache_queue q;
	int offset;
};

struct rpc_filelist {
	const char *name;
	const struct file_operations *i_fop;
	umode_t mode;
};

enum {
	RPCAUTH_info = 0,
	RPCAUTH_EOF = 1,
};

enum {
	RPCAUTH_lockd = 0,
	RPCAUTH_mount = 1,
	RPCAUTH_nfs = 2,
	RPCAUTH_portmap = 3,
	RPCAUTH_statd = 4,
	RPCAUTH_nfsd4_cb = 5,
	RPCAUTH_cache = 6,
	RPCAUTH_nfsd = 7,
	RPCAUTH_gssd = 8,
	RPCAUTH_RootEOF = 9,
};

struct xprt_addr {
	const char *addr;
	struct callback_head rcu;
};

struct svc_xpt_user {
	struct list_head list;
	void (*callback)(struct svc_xpt_user *);
};

typedef struct rpc_xprt * (*xprt_switch_find_xprt_t)(struct rpc_xprt_switch *, const struct rpc_xprt *);

enum rpc_gss_proc {
	RPC_GSS_PROC_DATA = 0,
	RPC_GSS_PROC_INIT = 1,
	RPC_GSS_PROC_CONTINUE_INIT = 2,
	RPC_GSS_PROC_DESTROY = 3,
};

enum rpc_gss_svc {
	RPC_GSS_SVC_NONE = 1,
	RPC_GSS_SVC_INTEGRITY = 2,
	RPC_GSS_SVC_PRIVACY = 3,
};

struct gss_cl_ctx {
	refcount_t count;
	enum rpc_gss_proc gc_proc;
	u32 gc_seq;
	u32 gc_seq_xmit;
	spinlock_t gc_seq_lock;
	struct gss_ctx *gc_gss_ctx;
	struct xdr_netobj gc_wire_ctx;
	struct xdr_netobj gc_acceptor;
	u32 gc_win;
	long unsigned int gc_expiry;
	struct callback_head gc_rcu;
};

struct gss_upcall_msg;

struct gss_cred {
	struct rpc_cred gc_base;
	enum rpc_gss_svc gc_service;
	struct gss_cl_ctx *gc_ctx;
	struct gss_upcall_msg *gc_upcall;
	const char *gc_principal;
	long unsigned int gc_upcall_timestamp;
};

struct gss_auth;

struct gss_upcall_msg {
	refcount_t count;
	kuid_t uid;
	const char *service_name;
	struct rpc_pipe_msg msg;
	struct list_head list;
	struct gss_auth *auth;
	struct rpc_pipe *pipe;
	struct rpc_wait_queue rpc_waitqueue;
	wait_queue_head_t waitqueue;
	struct gss_cl_ctx *ctx;
	char databuf[256];
};

typedef unsigned int OM_uint32;

struct gss_pipe {
	struct rpc_pipe_dir_object pdo;
	struct rpc_pipe *pipe;
	struct rpc_clnt *clnt;
	const char *name;
	struct kref kref;
};

struct gss_auth {
	struct kref kref;
	struct hlist_node hash;
	struct rpc_auth rpc_auth;
	struct gss_api_mech *mech;
	enum rpc_gss_svc service;
	struct rpc_clnt *client;
	struct net *net;
	netns_tracker ns_tracker;
	struct gss_pipe *gss_pipe[2];
	const char *target_name;
};

struct gss_alloc_pdo {
	struct rpc_clnt *clnt;
	const char *name;
	const struct rpc_pipe_ops *upcall_ops;
};

struct rpc_gss_wire_cred {
	u32 gc_v;
	u32 gc_proc;
	u32 gc_seq;
	u32 gc_svc;
	struct xdr_netobj gc_ctx;
};

struct gssp_in_token {
	struct page **pages;
	unsigned int page_base;
	unsigned int page_len;
};

struct gssp_upcall_data {
	struct xdr_netobj in_handle;
	struct gssp_in_token in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	struct rpcsec_gss_oid mech_oid;
	struct svc_cred creds;
	int found_creds;
	int major_status;
	int minor_status;
};

struct rsi {
	struct cache_head h;
	struct xdr_netobj in_handle;
	struct xdr_netobj in_token;
	struct xdr_netobj out_handle;
	struct xdr_netobj out_token;
	int major_status;
	int minor_status;
	struct callback_head callback_head;
};

struct gss_svc_seq_data {
	u32 sd_max;
	long unsigned int sd_win[4];
	spinlock_t sd_lock;
};

struct rsc {
	struct cache_head h;
	struct xdr_netobj handle;
	struct svc_cred cred;
	struct gss_svc_seq_data seqdata;
	struct gss_ctx *mechctx;
	struct callback_head callback_head;
	int: 32;
};

struct gss_domain {
	struct auth_domain h;
	u32 pseudoflavor;
};

struct gss_svc_data {
	struct rpc_gss_wire_cred clcred;
	__be32 *verf_start;
	struct rsc *rsci;
};

typedef struct xdr_netobj gssx_buffer;

typedef struct xdr_netobj utf8string;

typedef struct xdr_netobj gssx_OID;

struct gssx_option {
	gssx_buffer option;
	gssx_buffer value;
};

struct gssx_option_array {
	u32 count;
	struct gssx_option *data;
};

struct gssx_status {
	u64 major_status;
	gssx_OID mech;
	u64 minor_status;
	utf8string major_status_string;
	utf8string minor_status_string;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_call_ctx {
	utf8string locale;
	gssx_buffer server_ctx;
	struct gssx_option_array options;
};

struct gssx_name {
	gssx_buffer display_name;
};

typedef struct gssx_name gssx_name;

struct gssx_cred_element {
	gssx_name MN;
	gssx_OID mech;
	u32 cred_usage;
	int: 32;
	u64 initiator_time_rec;
	u64 acceptor_time_rec;
	struct gssx_option_array options;
};

struct gssx_cred_element_array {
	u32 count;
	struct gssx_cred_element *data;
};

struct gssx_cred {
	gssx_name desired_name;
	struct gssx_cred_element_array elements;
	gssx_buffer cred_handle_reference;
	u32 needs_release;
};

struct gssx_ctx {
	gssx_buffer exported_context_token;
	gssx_buffer state;
	u32 need_release;
	gssx_OID mech;
	gssx_name src_name;
	gssx_name targ_name;
	int: 32;
	u64 lifetime;
	u64 ctx_flags;
	u32 locally_initiated;
	u32 open;
	struct gssx_option_array options;
};

struct gssx_cb {
	u64 initiator_addrtype;
	gssx_buffer initiator_address;
	u64 acceptor_addrtype;
	gssx_buffer acceptor_address;
	gssx_buffer application_data;
};

struct gssx_arg_accept_sec_context {
	struct gssx_call_ctx call_ctx;
	struct gssx_ctx *context_handle;
	struct gssx_cred *cred_handle;
	struct gssp_in_token input_token;
	struct gssx_cb *input_cb;
	u32 ret_deleg_cred;
	struct gssx_option_array options;
	struct page **pages;
	unsigned int npages;
};

struct gssx_res_accept_sec_context {
	struct gssx_status status;
	struct gssx_ctx *context_handle;
	gssx_buffer *output_token;
	struct gssx_option_array options;
};

enum {
	GSSX_NULL = 0,
	GSSX_INDICATE_MECHS = 1,
	GSSX_GET_CALL_CONTEXT = 2,
	GSSX_IMPORT_AND_CANON_NAME = 3,
	GSSX_EXPORT_CRED = 4,
	GSSX_IMPORT_CRED = 5,
	GSSX_ACQUIRE_CRED = 6,
	GSSX_STORE_CRED = 7,
	GSSX_INIT_SEC_CONTEXT = 8,
	GSSX_ACCEPT_SEC_CONTEXT = 9,
	GSSX_RELEASE_HANDLE = 10,
	GSSX_GET_MIC = 11,
	GSSX_VERIFY = 12,
	GSSX_WRAP = 13,
	GSSX_UNWRAP = 14,
	GSSX_WRAP_SIZE_LIMIT = 15,
};

struct gssx_name_attr {
	gssx_buffer attr;
	gssx_buffer value;
	struct gssx_option_array extensions;
};

struct gssx_name_attr_array {
	u32 count;
	struct gssx_name_attr *data;
};

struct trace_event_raw_rpcgss_gssapi_event {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 maj_stat;
	char __data[0];
};

struct trace_event_raw_rpcgss_import_ctx {
	struct trace_entry ent;
	int status;
	char __data[0];
};

struct trace_event_raw_rpcgss_ctx_class {
	struct trace_entry ent;
	const void *cred;
	long unsigned int service;
	u32 __data_loc_principal;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_gssapi_class {
	struct trace_entry ent;
	u32 xid;
	u32 maj_stat;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_unwrap_failed {
	struct trace_entry ent;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_bad {
	struct trace_entry ent;
	u32 expected;
	u32 received;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_accept_upcall {
	struct trace_entry ent;
	u32 minor_status;
	long unsigned int major_status;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_authenticate {
	struct trace_entry ent;
	u32 seqno;
	u32 xid;
	u32 __data_loc_addr;
	char __data[0];
};

struct trace_event_raw_rpcgss_unwrap_failed {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	char __data[0];
};

struct trace_event_raw_rpcgss_bad_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 expected;
	u32 received;
	char __data[0];
};

struct trace_event_raw_rpcgss_seqno {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_need_reencode {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	u32 seq_xmit;
	u32 seqno;
	bool ret;
	char __data[0];
};

struct trace_event_raw_rpcgss_update_slack {
	struct trace_entry ent;
	unsigned int task_id;
	unsigned int client_id;
	u32 xid;
	const void *auth;
	unsigned int rslack;
	unsigned int ralign;
	unsigned int verfsize;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_class {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	char __data[0];
};

struct trace_event_raw_rpcgss_svc_seqno_low {
	struct trace_entry ent;
	u32 xid;
	u32 seqno;
	u32 min;
	u32 max;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_msg {
	struct trace_entry ent;
	u32 __data_loc_msg;
	char __data[0];
};

struct trace_event_raw_rpcgss_upcall_result {
	struct trace_entry ent;
	u32 uid;
	int result;
	char __data[0];
};

struct trace_event_raw_rpcgss_context {
	struct trace_entry ent;
	long unsigned int expiry;
	long unsigned int now;
	unsigned int timeout;
	u32 window_size;
	int len;
	u32 __data_loc_acceptor;
	char __data[0];
};

struct trace_event_raw_rpcgss_createauth {
	struct trace_entry ent;
	unsigned int flavor;
	int error;
	char __data[0];
};

struct trace_event_raw_rpcgss_oid_to_mech {
	struct trace_entry ent;
	u32 __data_loc_oid;
	char __data[0];
};

struct trace_event_data_offsets_rpcgss_gssapi_event {};

struct trace_event_data_offsets_rpcgss_import_ctx {};

struct trace_event_data_offsets_rpcgss_ctx_class {
	u32 principal;
};

struct trace_event_data_offsets_rpcgss_svc_gssapi_class {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_unwrap_failed {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_seqno_bad {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_accept_upcall {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_svc_authenticate {
	u32 addr;
};

struct trace_event_data_offsets_rpcgss_unwrap_failed {};

struct trace_event_data_offsets_rpcgss_bad_seqno {};

struct trace_event_data_offsets_rpcgss_seqno {};

struct trace_event_data_offsets_rpcgss_need_reencode {};

struct trace_event_data_offsets_rpcgss_update_slack {};

struct trace_event_data_offsets_rpcgss_svc_seqno_class {};

struct trace_event_data_offsets_rpcgss_svc_seqno_low {};

struct trace_event_data_offsets_rpcgss_upcall_msg {
	u32 msg;
};

struct trace_event_data_offsets_rpcgss_upcall_result {};

struct trace_event_data_offsets_rpcgss_context {
	u32 acceptor;
};

struct trace_event_data_offsets_rpcgss_createauth {};

struct trace_event_data_offsets_rpcgss_oid_to_mech {
	u32 oid;
};

typedef void (*btf_trace_rpcgss_import_ctx)(void *, int);

typedef void (*btf_trace_rpcgss_get_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_verify_mic)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_wrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_unwrap)(void *, const struct rpc_task *, u32);

typedef void (*btf_trace_rpcgss_ctx_init)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_ctx_destroy)(void *, const struct gss_cred *);

typedef void (*btf_trace_rpcgss_svc_unwrap)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_mic)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_unwrap_failed)(void *, const struct svc_rqst *);

typedef void (*btf_trace_rpcgss_svc_seqno_bad)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_accept_upcall)(void *, const struct svc_rqst *, u32, u32);

typedef void (*btf_trace_rpcgss_svc_authenticate)(void *, const struct svc_rqst *, const struct rpc_gss_wire_cred *);

typedef void (*btf_trace_rpcgss_unwrap_failed)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_bad_seqno)(void *, const struct rpc_task *, u32, u32);

typedef void (*btf_trace_rpcgss_seqno)(void *, const struct rpc_task *);

typedef void (*btf_trace_rpcgss_need_reencode)(void *, const struct rpc_task *, u32, bool);

typedef void (*btf_trace_rpcgss_update_slack)(void *, const struct rpc_task *, const struct rpc_auth *);

typedef void (*btf_trace_rpcgss_svc_seqno_large)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_seen)(void *, const struct svc_rqst *, u32);

typedef void (*btf_trace_rpcgss_svc_seqno_low)(void *, const struct svc_rqst *, u32, u32, u32);

typedef void (*btf_trace_rpcgss_upcall_msg)(void *, const char *);

typedef void (*btf_trace_rpcgss_upcall_result)(void *, u32, int);

typedef void (*btf_trace_rpcgss_context)(void *, u32, long unsigned int, long unsigned int, unsigned int, unsigned int, const u8 *);

typedef void (*btf_trace_rpcgss_createauth)(void *, unsigned int, int);

typedef void (*btf_trace_rpcgss_oid_to_mech)(void *, const char *);

struct vlan_group {
	unsigned int nr_vlan_devs;
	struct hlist_node hlist;
	struct net_device **vlan_devices_arrays[16];
};

struct vlan_info {
	struct net_device *real_dev;
	struct vlan_group grp;
	struct list_head vid_list;
	unsigned int nr_vids;
	struct callback_head rcu;
};

enum vlan_flags {
	VLAN_FLAG_REORDER_HDR = 1,
	VLAN_FLAG_GVRP = 2,
	VLAN_FLAG_LOOSE_BINDING = 4,
	VLAN_FLAG_MVRP = 8,
	VLAN_FLAG_BRIDGE_BINDING = 16,
};

struct vlan_pcpu_stats {
	u64_stats_t rx_packets;
	u64_stats_t rx_bytes;
	u64_stats_t rx_multicast;
	u64_stats_t tx_packets;
	u64_stats_t tx_bytes;
	struct u64_stats_sync syncp;
	u32 rx_errors;
	u32 tx_dropped;
	int: 32;
};

struct vlan_priority_tci_mapping {
	u32 priority;
	u16 vlan_qos;
	struct vlan_priority_tci_mapping *next;
};

struct vlan_dev_priv {
	unsigned int nr_ingress_mappings;
	u32 ingress_priority_map[8];
	unsigned int nr_egress_mappings;
	struct vlan_priority_tci_mapping *egress_priority_map[16];
	__be16 vlan_proto;
	u16 vlan_id;
	u16 flags;
	struct net_device *real_dev;
	netdevice_tracker dev_tracker;
	unsigned char real_dev_addr[6];
	struct proc_dir_entry *dent;
	struct vlan_pcpu_stats *vlan_pcpu_stats;
};

enum vlan_protos {
	VLAN_PROTO_8021Q = 0,
	VLAN_PROTO_8021AD = 1,
	VLAN_PROTO_NUM = 2,
};

struct vlan_vid_info {
	struct list_head list;
	__be16 proto;
	u16 vid;
	int refcount;
};

struct lib80211_crypto_alg {
	struct list_head list;
	struct lib80211_crypto_ops *ops;
};

struct lib80211_wep_data {
	u32 iv;
	u8 key[14];
	u8 key_len;
	u8 key_idx;
	struct arc4_ctx tx_ctx;
	struct arc4_ctx rx_ctx;
};

struct lib80211_ccmp_data {
	u8 key[16];
	int key_set;
	u8 tx_pn[6];
	u8 rx_pn[6];
	u32 dot11RSNAStatsCCMPFormatErrors;
	u32 dot11RSNAStatsCCMPReplays;
	u32 dot11RSNAStatsCCMPDecryptErrors;
	int key_idx;
	struct crypto_aead *tfm;
	u8 tx_aad[32];
	u8 rx_aad[32];
};

struct iw_michaelmicfailure {
	__u32 flags;
	struct sockaddr src_addr;
	__u8 tsc[8];
};

enum {
	IEEE80211_CRYPTO_TKIP_COUNTERMEASURES = 1,
};

struct lib80211_tkip_data {
	u8 key[32];
	int key_set;
	u32 tx_iv32;
	u16 tx_iv16;
	u16 tx_ttak[5];
	int tx_phase1_done;
	u32 rx_iv32;
	u16 rx_iv16;
	u16 rx_ttak[5];
	int rx_phase1_done;
	u32 rx_iv32_new;
	u16 rx_iv16_new;
	u32 dot11RSNAStatsTKIPReplays;
	u32 dot11RSNAStatsTKIPICVErrors;
	u32 dot11RSNAStatsTKIPLocalMICFailures;
	int key_idx;
	struct arc4_ctx rx_ctx_arc4;
	struct arc4_ctx tx_ctx_arc4;
	struct crypto_shash *rx_tfm_michael;
	struct crypto_shash *tx_tfm_michael;
	u8 rx_hdr[16];
	u8 tx_hdr[16];
	long unsigned int flags;
};

enum nl80211_iftype {
	NL80211_IFTYPE_UNSPECIFIED = 0,
	NL80211_IFTYPE_ADHOC = 1,
	NL80211_IFTYPE_STATION = 2,
	NL80211_IFTYPE_AP = 3,
	NL80211_IFTYPE_AP_VLAN = 4,
	NL80211_IFTYPE_WDS = 5,
	NL80211_IFTYPE_MONITOR = 6,
	NL80211_IFTYPE_MESH_POINT = 7,
	NL80211_IFTYPE_P2P_CLIENT = 8,
	NL80211_IFTYPE_P2P_GO = 9,
	NL80211_IFTYPE_P2P_DEVICE = 10,
	NL80211_IFTYPE_OCB = 11,
	NL80211_IFTYPE_NAN = 12,
	NUM_NL80211_IFTYPES = 13,
	NL80211_IFTYPE_MAX = 12,
};

enum nl80211_mntr_flags {
	__NL80211_MNTR_FLAG_INVALID = 0,
	NL80211_MNTR_FLAG_FCSFAIL = 1,
	NL80211_MNTR_FLAG_PLCPFAIL = 2,
	NL80211_MNTR_FLAG_CONTROL = 3,
	NL80211_MNTR_FLAG_OTHER_BSS = 4,
	NL80211_MNTR_FLAG_COOK_FRAMES = 5,
	NL80211_MNTR_FLAG_ACTIVE = 6,
	__NL80211_MNTR_FLAG_AFTER_LAST = 7,
	NL80211_MNTR_FLAG_MAX = 6,
};

enum nl80211_band {
	NL80211_BAND_2GHZ = 0,
	NL80211_BAND_5GHZ = 1,
	NL80211_BAND_60GHZ = 2,
	NL80211_BAND_6GHZ = 3,
	NL80211_BAND_S1GHZ = 4,
	NL80211_BAND_LC = 5,
	NUM_NL80211_BANDS = 6,
};

enum nl80211_ext_feature_index {
	NL80211_EXT_FEATURE_VHT_IBSS = 0,
	NL80211_EXT_FEATURE_RRM = 1,
	NL80211_EXT_FEATURE_MU_MIMO_AIR_SNIFFER = 2,
	NL80211_EXT_FEATURE_SCAN_START_TIME = 3,
	NL80211_EXT_FEATURE_BSS_PARENT_TSF = 4,
	NL80211_EXT_FEATURE_SET_SCAN_DWELL = 5,
	NL80211_EXT_FEATURE_BEACON_RATE_LEGACY = 6,
	NL80211_EXT_FEATURE_BEACON_RATE_HT = 7,
	NL80211_EXT_FEATURE_BEACON_RATE_VHT = 8,
	NL80211_EXT_FEATURE_FILS_STA = 9,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA = 10,
	NL80211_EXT_FEATURE_MGMT_TX_RANDOM_TA_CONNECTED = 11,
	NL80211_EXT_FEATURE_SCHED_SCAN_RELATIVE_RSSI = 12,
	NL80211_EXT_FEATURE_CQM_RSSI_LIST = 13,
	NL80211_EXT_FEATURE_FILS_SK_OFFLOAD = 14,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_PSK = 15,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_STA_1X = 16,
	NL80211_EXT_FEATURE_FILS_MAX_CHANNEL_TIME = 17,
	NL80211_EXT_FEATURE_ACCEPT_BCAST_PROBE_RESP = 18,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_HIGH_TX_RATE = 19,
	NL80211_EXT_FEATURE_OCE_PROBE_REQ_DEFERRAL_SUPPRESSION = 20,
	NL80211_EXT_FEATURE_MFP_OPTIONAL = 21,
	NL80211_EXT_FEATURE_LOW_SPAN_SCAN = 22,
	NL80211_EXT_FEATURE_LOW_POWER_SCAN = 23,
	NL80211_EXT_FEATURE_HIGH_ACCURACY_SCAN = 24,
	NL80211_EXT_FEATURE_DFS_OFFLOAD = 25,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211 = 26,
	NL80211_EXT_FEATURE_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_DATA_ACK_SIGNAL_SUPPORT = 27,
	NL80211_EXT_FEATURE_TXQS = 28,
	NL80211_EXT_FEATURE_SCAN_RANDOM_SN = 29,
	NL80211_EXT_FEATURE_SCAN_MIN_PREQ_CONTENT = 30,
	NL80211_EXT_FEATURE_CAN_REPLACE_PTK0 = 31,
	NL80211_EXT_FEATURE_ENABLE_FTM_RESPONDER = 32,
	NL80211_EXT_FEATURE_AIRTIME_FAIRNESS = 33,
	NL80211_EXT_FEATURE_AP_PMKSA_CACHING = 34,
	NL80211_EXT_FEATURE_SCHED_SCAN_BAND_SPECIFIC_RSSI_THOLD = 35,
	NL80211_EXT_FEATURE_EXT_KEY_ID = 36,
	NL80211_EXT_FEATURE_STA_TX_PWR = 37,
	NL80211_EXT_FEATURE_SAE_OFFLOAD = 38,
	NL80211_EXT_FEATURE_VLAN_OFFLOAD = 39,
	NL80211_EXT_FEATURE_AQL = 40,
	NL80211_EXT_FEATURE_BEACON_PROTECTION = 41,
	NL80211_EXT_FEATURE_CONTROL_PORT_NO_PREAUTH = 42,
	NL80211_EXT_FEATURE_PROTECTED_TWT = 43,
	NL80211_EXT_FEATURE_DEL_IBSS_STA = 44,
	NL80211_EXT_FEATURE_MULTICAST_REGISTRATIONS = 45,
	NL80211_EXT_FEATURE_BEACON_PROTECTION_CLIENT = 46,
	NL80211_EXT_FEATURE_SCAN_FREQ_KHZ = 47,
	NL80211_EXT_FEATURE_CONTROL_PORT_OVER_NL80211_TX_STATUS = 48,
	NL80211_EXT_FEATURE_OPERATING_CHANNEL_VALIDATION = 49,
	NL80211_EXT_FEATURE_4WAY_HANDSHAKE_AP_PSK = 50,
	NL80211_EXT_FEATURE_SAE_OFFLOAD_AP = 51,
	NL80211_EXT_FEATURE_FILS_DISCOVERY = 52,
	NL80211_EXT_FEATURE_UNSOL_BCAST_PROBE_RESP = 53,
	NL80211_EXT_FEATURE_BEACON_RATE_HE = 54,
	NL80211_EXT_FEATURE_SECURE_LTF = 55,
	NL80211_EXT_FEATURE_SECURE_RTT = 56,
	NL80211_EXT_FEATURE_PROT_RANGE_NEGO_AND_MEASURE = 57,
	NL80211_EXT_FEATURE_BSS_COLOR = 58,
	NL80211_EXT_FEATURE_FILS_CRYPTO_OFFLOAD = 59,
	NL80211_EXT_FEATURE_RADAR_BACKGROUND = 60,
	NL80211_EXT_FEATURE_POWERED_ADDR_CHANGE = 61,
	NUM_NL80211_EXT_FEATURES = 62,
	MAX_NL80211_EXT_FEATURES = 61,
};

struct iw_ioctl_description {
	__u8 header_type;
	__u8 token_type;
	__u16 token_size;
	__u16 min_tokens;
	__u16 max_tokens;
	__u32 flags;
};

typedef int (*wext_ioctl_func)(struct net_device *, struct iwreq *, unsigned int, struct iw_request_info *, iw_handler);

struct iw_thrspy {
	struct sockaddr addr;
	struct iw_quality qual;
	struct iw_quality low;
	struct iw_quality high;
};

enum dns_payload_content_type {
	DNS_PAYLOAD_IS_SERVER_LIST = 0,
};

struct dns_payload_header {
	__u8 zero;
	__u8 content;
	__u8 version;
};

enum {
	dns_key_data = 0,
	dns_key_error = 1,
};

enum switchdev_attr_id {
	SWITCHDEV_ATTR_ID_UNDEFINED = 0,
	SWITCHDEV_ATTR_ID_PORT_STP_STATE = 1,
	SWITCHDEV_ATTR_ID_PORT_MST_STATE = 2,
	SWITCHDEV_ATTR_ID_PORT_BRIDGE_FLAGS = 3,
	SWITCHDEV_ATTR_ID_PORT_PRE_BRIDGE_FLAGS = 4,
	SWITCHDEV_ATTR_ID_PORT_MROUTER = 5,
	SWITCHDEV_ATTR_ID_BRIDGE_AGEING_TIME = 6,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_FILTERING = 7,
	SWITCHDEV_ATTR_ID_BRIDGE_VLAN_PROTOCOL = 8,
	SWITCHDEV_ATTR_ID_BRIDGE_MC_DISABLED = 9,
	SWITCHDEV_ATTR_ID_BRIDGE_MROUTER = 10,
	SWITCHDEV_ATTR_ID_BRIDGE_MST = 11,
	SWITCHDEV_ATTR_ID_MRP_PORT_ROLE = 12,
	SWITCHDEV_ATTR_ID_VLAN_MSTI = 13,
};

struct switchdev_attr {
	struct net_device *orig_dev;
	enum switchdev_attr_id id;
	u32 flags;
	void *complete_priv;
	void (*complete)(struct net_device *, int, void *);
	union {
		u8 stp_state;
		struct switchdev_mst_state mst_state;
		struct switchdev_brport_flags brport_flags;
		bool mrouter;
		clock_t ageing_time;
		bool vlan_filtering;
		u16 vlan_protocol;
		bool mst;
		bool mc_disabled;
		u8 mrp_port_role;
		struct switchdev_vlan_msti vlan_msti;
	} u;
};

struct switchdev_brport {
	struct net_device *dev;
	const void *ctx;
	struct notifier_block *atomic_nb;
	struct notifier_block *blocking_nb;
	bool tx_fwd_offload;
};

enum switchdev_notifier_type {
	SWITCHDEV_FDB_ADD_TO_BRIDGE = 1,
	SWITCHDEV_FDB_DEL_TO_BRIDGE = 2,
	SWITCHDEV_FDB_ADD_TO_DEVICE = 3,
	SWITCHDEV_FDB_DEL_TO_DEVICE = 4,
	SWITCHDEV_FDB_OFFLOADED = 5,
	SWITCHDEV_FDB_FLUSH_TO_BRIDGE = 6,
	SWITCHDEV_PORT_OBJ_ADD = 7,
	SWITCHDEV_PORT_OBJ_DEL = 8,
	SWITCHDEV_PORT_ATTR_SET = 9,
	SWITCHDEV_VXLAN_FDB_ADD_TO_BRIDGE = 10,
	SWITCHDEV_VXLAN_FDB_DEL_TO_BRIDGE = 11,
	SWITCHDEV_VXLAN_FDB_ADD_TO_DEVICE = 12,
	SWITCHDEV_VXLAN_FDB_DEL_TO_DEVICE = 13,
	SWITCHDEV_VXLAN_FDB_OFFLOADED = 14,
	SWITCHDEV_BRPORT_OFFLOADED = 15,
	SWITCHDEV_BRPORT_UNOFFLOADED = 16,
};

struct switchdev_notifier_info {
	struct net_device *dev;
	struct netlink_ext_ack *extack;
	const void *ctx;
};

struct switchdev_notifier_fdb_info {
	struct switchdev_notifier_info info;
	const unsigned char *addr;
	u16 vid;
	u8 added_by_user: 1;
	u8 is_local: 1;
	u8 offloaded: 1;
};

struct switchdev_notifier_port_obj_info {
	struct switchdev_notifier_info info;
	const struct switchdev_obj *obj;
	bool handled;
};

struct switchdev_notifier_port_attr_info {
	struct switchdev_notifier_info info;
	const struct switchdev_attr *attr;
	bool handled;
};

struct switchdev_notifier_brport_info {
	struct switchdev_notifier_info info;
	const struct switchdev_brport brport;
};

typedef void switchdev_deferred_func_t(struct net_device *, const void *);

struct switchdev_deferred_item {
	struct list_head list;
	struct net_device *dev;
	netdevice_tracker dev_tracker;
	switchdev_deferred_func_t *func;
	long unsigned int data[0];
};

struct switchdev_nested_priv {
	bool (*check_cb)(const struct net_device *);
	bool (*foreign_dev_check_cb)(const struct net_device *, const struct net_device *);
	const struct net_device *dev;
	struct net_device *lower_dev;
};

typedef struct elf64_hdr Elf64_Ehdr;

typedef struct elf32_phdr Elf32_Phdr;

typedef struct elf64_phdr Elf64_Phdr;

typedef struct elf32_note Elf32_Nhdr;

struct compress_format {
	unsigned char magic[2];
	const char *name;
	decompress_fn decompressor;
};

struct group_data {
	int limit[21];
	int base[20];
	int permute[258];
	int minLen;
	int maxLen;
};

struct bunzip_data {
	int writeCopies;
	int writePos;
	int writeRunCountdown;
	int writeCount;
	int writeCurrent;
	long int (*fill)(void *, long unsigned int);
	long int inbufCount;
	long int inbufPos;
	unsigned char *inbuf;
	unsigned int inbufBitCount;
	unsigned int inbufBits;
	unsigned int crc32Table[256];
	unsigned int headerCRC;
	unsigned int totalCRC;
	unsigned int writeCRC;
	unsigned int *dbuf;
	unsigned int dbufSize;
	unsigned char selectors[32768];
	struct group_data groups[6];
	int io_error;
	int byteCount[256];
	unsigned char symToByte[256];
	unsigned char mtfSymbol[256];
};

struct rc {
	long int (*fill)(void *, long unsigned int);
	uint8_t *ptr;
	uint8_t *buffer;
	uint8_t *buffer_end;
	long int buffer_size;
	uint32_t code;
	uint32_t range;
	uint32_t bound;
	void (*error)(char *);
};

struct lzma_header {
	uint8_t pos;
	uint32_t dict_size;
	uint64_t dst_size;
} __attribute__((packed));

struct writer {
	uint8_t *buffer;
	uint8_t previous_byte;
	size_t buffer_pos;
	int bufsize;
	size_t global_pos;
	long int (*flush)(void *, long unsigned int);
	struct lzma_header *header;
};

struct cstate {
	int state;
	uint32_t rep0;
	uint32_t rep1;
	uint32_t rep2;
	uint32_t rep3;
};

struct xz_dec;

struct cpio_data {
	void *data;
	size_t size;
	char name[18];
};

enum cpio_fields {
	C_MAGIC = 0,
	C_INO = 1,
	C_MODE = 2,
	C_UID = 3,
	C_GID = 4,
	C_NLINK = 5,
	C_MTIME = 6,
	C_FILESIZE = 7,
	C_MAJ = 8,
	C_MIN = 9,
	C_RMAJ = 10,
	C_RMIN = 11,
	C_NAMESIZE = 12,
	C_CHKSUM = 13,
	C_NFIELDS = 14,
};

enum {
	ASSUME_PERFECT = 255,
	ASSUME_VALID_DTB = 1,
	ASSUME_VALID_INPUT = 2,
	ASSUME_LATEST = 4,
	ASSUME_NO_ROLLBACK = 8,
	ASSUME_LIBFDT_ORDER = 16,
	ASSUME_LIBFDT_FLAWLESS = 32,
};

typedef __be64 fdt64_t;

struct fdt_reserve_entry {
	fdt64_t address;
	fdt64_t size;
};

struct fdt_node_header {
	fdt32_t tag;
	char name[0];
};

struct fdt_errtabent {
	const char *str;
};

struct fprop_local_single {
	long unsigned int events;
	unsigned int period;
	raw_spinlock_t lock;
};

struct ida_bitmap {
	long unsigned int bitmap[32];
};

struct klist_waiter {
	struct list_head list;
	struct klist_node *node;
	struct task_struct *process;
	int woken;
};

struct uevent_sock {
	struct list_head list;
	struct sock *sk;
};

struct maple_metadata {
	unsigned char end;
	unsigned char gap;
};

struct maple_pnode;

struct maple_range_64 {
	struct maple_pnode *parent;
	long unsigned int pivot[31];
	union {
		void *slot[32];
		struct {
			void *pad[31];
			struct maple_metadata meta;
		};
	};
};

struct maple_arange_64 {
	struct maple_pnode *parent;
	long unsigned int pivot[20];
	void *slot[21];
	long unsigned int gap[21];
	struct maple_metadata meta;
};

struct maple_topiary {
	struct maple_pnode *parent;
	struct maple_enode *next;
};

enum maple_type {
	maple_dense = 0,
	maple_leaf_64 = 1,
	maple_range_64 = 2,
	maple_arange_64 = 3,
};

struct maple_node {
	union {
		struct {
			struct maple_pnode *parent;
			void *slot[63];
		};
		struct {
			void *pad;
			struct callback_head rcu;
			struct maple_enode *piv_parent;
			unsigned char parent_slot;
			enum maple_type type;
			unsigned char slot_len;
			unsigned int ma_flags;
		};
		struct maple_range_64 mr64;
		struct maple_arange_64 ma64;
		struct maple_alloc alloc;
	};
};

struct ma_topiary {
	struct maple_enode *head;
	struct maple_enode *tail;
	struct maple_tree *mtree;
};

struct ma_wr_state {
	struct ma_state *mas;
	struct maple_node *node;
	long unsigned int r_min;
	long unsigned int r_max;
	enum maple_type type;
	unsigned char offset_end;
	unsigned char node_end;
	long unsigned int *pivots;
	long unsigned int end_piv;
	void **slots;
	void *entry;
	void *content;
};

struct trace_event_raw_ma_op {
	struct trace_entry ent;
	const char *fn;
	long unsigned int min;
	long unsigned int max;
	long unsigned int index;
	long unsigned int last;
	void *node;
	char __data[0];
};

struct trace_event_raw_ma_read {
	struct trace_entry ent;
	const char *fn;
	long unsigned int min;
	long unsigned int max;
	long unsigned int index;
	long unsigned int last;
	void *node;
	char __data[0];
};

struct trace_event_raw_ma_write {
	struct trace_entry ent;
	const char *fn;
	long unsigned int min;
	long unsigned int max;
	long unsigned int index;
	long unsigned int last;
	long unsigned int piv;
	void *val;
	void *node;
	char __data[0];
};

struct trace_event_data_offsets_ma_op {};

struct trace_event_data_offsets_ma_read {};

struct trace_event_data_offsets_ma_write {};

typedef void (*btf_trace_ma_op)(void *, const char *, struct ma_state *);

typedef void (*btf_trace_ma_read)(void *, const char *, struct ma_state *);

typedef void (*btf_trace_ma_write)(void *, const char *, struct ma_state *, long unsigned int, void *);

struct maple_big_node {
	struct maple_pnode *parent;
	long unsigned int pivot[65];
	union {
		struct maple_enode *slot[66];
		struct {
			long unsigned int padding[43];
			long unsigned int gap[43];
		};
	};
	unsigned char b_end;
	enum maple_type type;
};

struct maple_subtree_state {
	struct ma_state *orig_l;
	struct ma_state *orig_r;
	struct ma_state *l;
	struct ma_state *m;
	struct ma_state *r;
	struct ma_topiary *free;
	struct ma_topiary *destroy;
	struct maple_big_node *bn;
};

typedef struct {
	long unsigned int key[2];
} hsiphash_key_t;

enum format_type {
	FORMAT_TYPE_NONE = 0,
	FORMAT_TYPE_WIDTH = 1,
	FORMAT_TYPE_PRECISION = 2,
	FORMAT_TYPE_CHAR = 3,
	FORMAT_TYPE_STR = 4,
	FORMAT_TYPE_PTR = 5,
	FORMAT_TYPE_PERCENT_CHAR = 6,
	FORMAT_TYPE_INVALID = 7,
	FORMAT_TYPE_LONG_LONG = 8,
	FORMAT_TYPE_ULONG = 9,
	FORMAT_TYPE_LONG = 10,
	FORMAT_TYPE_UBYTE = 11,
	FORMAT_TYPE_BYTE = 12,
	FORMAT_TYPE_USHORT = 13,
	FORMAT_TYPE_SHORT = 14,
	FORMAT_TYPE_UINT = 15,
	FORMAT_TYPE_INT = 16,
	FORMAT_TYPE_SIZE_T = 17,
	FORMAT_TYPE_PTRDIFF = 18,
};

struct printf_spec {
	unsigned int type: 8;
	int field_width: 24;
	unsigned int flags: 8;
	unsigned int base: 8;
	int precision: 16;
};

struct page_flags_fields {
	int width;
	int shift;
	int mask;
	const struct printf_spec *spec;
	const char *name;
};

#ifndef BPF_NO_PRESERVE_ACCESS_INDEX
#pragma clang attribute pop
#endif

#endif /* __VMLINUX_H__ */
